(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod3) => function __require() {
    return mod3 || (0, cb[__getOwnPropNames(cb)[0]])((mod3 = { exports: {} }).exports, mod3), mod3.exports;
  };
  var __copyProps = (to2, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to2, key) && key !== except)
          __defProp(to2, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to2;
  };
  var __toESM = (mod3, isNodeMode, target) => (target = mod3 != null ? __create(__getProtoOf(mod3)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod3 || !mod3.__esModule ? __defProp(target, "default", { value: mod3, enumerable: true }) : target,
    mod3
  ));

  // node_modules/typed-function/lib/umd/typed-function.js
  var require_typed_function = __commonJS({
    "node_modules/typed-function/lib/umd/typed-function.js"(exports, module) {
      (function(global, factory2) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory2() : typeof define === "function" && define.amd ? define(factory2) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, global["'typed'"] = factory2());
      })(exports, function() {
        "use strict";
        function ok() {
          return true;
        }
        function notOk() {
          return false;
        }
        function undef() {
          return void 0;
        }
        const NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
        function create() {
          function isPlainObject2(x) {
            return typeof x === "object" && x !== null && x.constructor === Object;
          }
          const _types = [{
            name: "number",
            test: function(x) {
              return typeof x === "number";
            }
          }, {
            name: "string",
            test: function(x) {
              return typeof x === "string";
            }
          }, {
            name: "boolean",
            test: function(x) {
              return typeof x === "boolean";
            }
          }, {
            name: "Function",
            test: function(x) {
              return typeof x === "function";
            }
          }, {
            name: "Array",
            test: Array.isArray
          }, {
            name: "Date",
            test: function(x) {
              return x instanceof Date;
            }
          }, {
            name: "RegExp",
            test: function(x) {
              return x instanceof RegExp;
            }
          }, {
            name: "Object",
            test: isPlainObject2
          }, {
            name: "null",
            test: function(x) {
              return x === null;
            }
          }, {
            name: "undefined",
            test: function(x) {
              return x === void 0;
            }
          }];
          const anyType = {
            name: "any",
            test: ok,
            isAny: true
          };
          let typeMap;
          let typeList;
          let nConversions = 0;
          let typed3 = {
            createCount: 0
          };
          function findType(typeName) {
            const type = typeMap.get(typeName);
            if (type) {
              return type;
            }
            let message = 'Unknown type "' + typeName + '"';
            const name310 = typeName.toLowerCase();
            let otherName;
            for (otherName of typeList) {
              if (otherName.toLowerCase() === name310) {
                message += '. Did you mean "' + otherName + '" ?';
                break;
              }
            }
            throw new TypeError(message);
          }
          function addTypes(types) {
            let beforeSpec = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
            const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
            const newTypes = [];
            for (let i3 = 0; i3 < types.length; ++i3) {
              if (!types[i3] || typeof types[i3].name !== "string" || typeof types[i3].test !== "function") {
                throw new TypeError("Object with properties {name: string, test: function} expected");
              }
              const typeName = types[i3].name;
              if (typeMap.has(typeName)) {
                throw new TypeError('Duplicate type name "' + typeName + '"');
              }
              newTypes.push(typeName);
              typeMap.set(typeName, {
                name: typeName,
                test: types[i3].test,
                isAny: types[i3].isAny,
                index: beforeIndex + i3,
                conversionsTo: []
                // Newly added type can't have any conversions to it
              });
            }
            const affectedTypes = typeList.slice(beforeIndex);
            typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
            for (let i3 = beforeIndex + newTypes.length; i3 < typeList.length; ++i3) {
              typeMap.get(typeList[i3]).index = i3;
            }
          }
          function clear() {
            typeMap = /* @__PURE__ */ new Map();
            typeList = [];
            nConversions = 0;
            addTypes([anyType], false);
          }
          clear();
          addTypes(_types);
          function clearConversions() {
            let typeName;
            for (typeName of typeList) {
              typeMap.get(typeName).conversionsTo = [];
            }
            nConversions = 0;
          }
          function findTypeNames(value) {
            const matches = typeList.filter((name310) => {
              const type = typeMap.get(name310);
              return !type.isAny && type.test(value);
            });
            if (matches.length) {
              return matches;
            }
            return ["any"];
          }
          function isTypedFunction(entity) {
            return entity && typeof entity === "function" && "_typedFunctionData" in entity;
          }
          function findSignature(fn, signature, options) {
            if (!isTypedFunction(fn)) {
              throw new TypeError(NOT_TYPED_FUNCTION);
            }
            const exact = options && options.exact;
            const stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
            const params = parseSignature(stringSignature);
            const canonicalSignature = stringifyParams(params);
            if (!exact || canonicalSignature in fn.signatures) {
              const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
              if (match) {
                return match;
              }
            }
            const nParams = params.length;
            let remainingSignatures;
            if (exact) {
              remainingSignatures = [];
              let name310;
              for (name310 in fn.signatures) {
                remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name310));
              }
            } else {
              remainingSignatures = fn._typedFunctionData.signatures;
            }
            for (let i3 = 0; i3 < nParams; ++i3) {
              const want = params[i3];
              const filteredSignatures = [];
              let possibility;
              for (possibility of remainingSignatures) {
                const have = getParamAtIndex(possibility.params, i3);
                if (!have || want.restParam && !have.restParam) {
                  continue;
                }
                if (!have.hasAny) {
                  const haveTypes = paramTypeSet(have);
                  if (want.types.some((wtype) => !haveTypes.has(wtype.name))) {
                    continue;
                  }
                }
                filteredSignatures.push(possibility);
              }
              remainingSignatures = filteredSignatures;
              if (remainingSignatures.length === 0)
                break;
            }
            let candidate;
            for (candidate of remainingSignatures) {
              if (candidate.params.length <= nParams) {
                return candidate;
              }
            }
            throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
          }
          function find(fn, signature, options) {
            return findSignature(fn, signature, options).implementation;
          }
          function convert(value, typeName) {
            const type = findType(typeName);
            if (type.test(value)) {
              return value;
            }
            const conversions = type.conversionsTo;
            if (conversions.length === 0) {
              throw new Error("There are no conversions to " + typeName + " defined.");
            }
            for (let i3 = 0; i3 < conversions.length; i3++) {
              const fromType = findType(conversions[i3].from);
              if (fromType.test(value)) {
                return conversions[i3].convert(value);
              }
            }
            throw new Error("Cannot convert " + value + " to " + typeName);
          }
          function stringifyParams(params) {
            let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
            return params.map((p) => p.name).join(separator);
          }
          function parseParam(param) {
            const restParam = param.indexOf("...") === 0;
            const types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
            const typeDefs = types.split("|").map((s) => findType(s.trim()));
            let hasAny = false;
            let paramName = restParam ? "..." : "";
            const exactTypes = typeDefs.map(function(type) {
              hasAny = type.isAny || hasAny;
              paramName += type.name + "|";
              return {
                name: type.name,
                typeIndex: type.index,
                test: type.test,
                isAny: type.isAny,
                conversion: null,
                conversionIndex: -1
              };
            });
            return {
              types: exactTypes,
              name: paramName.slice(0, -1),
              // remove trailing '|' from above
              hasAny,
              hasConversion: false,
              restParam
            };
          }
          function expandParam(param) {
            const typeNames = param.types.map((t) => t.name);
            const matchingConversions = availableConversions(typeNames);
            let hasAny = param.hasAny;
            let newName = param.name;
            const convertibleTypes = matchingConversions.map(function(conversion) {
              const type = findType(conversion.from);
              hasAny = type.isAny || hasAny;
              newName += "|" + conversion.from;
              return {
                name: conversion.from,
                typeIndex: type.index,
                test: type.test,
                isAny: type.isAny,
                conversion,
                conversionIndex: conversion.index
              };
            });
            return {
              types: param.types.concat(convertibleTypes),
              name: newName,
              hasAny,
              hasConversion: convertibleTypes.length > 0,
              restParam: param.restParam
            };
          }
          function paramTypeSet(param) {
            if (!param.typeSet) {
              param.typeSet = /* @__PURE__ */ new Set();
              param.types.forEach((type) => param.typeSet.add(type.name));
            }
            return param.typeSet;
          }
          function parseSignature(rawSignature) {
            const params = [];
            if (typeof rawSignature !== "string") {
              throw new TypeError("Signatures must be strings");
            }
            const signature = rawSignature.trim();
            if (signature === "") {
              return params;
            }
            const rawParams = signature.split(",");
            for (let i3 = 0; i3 < rawParams.length; ++i3) {
              const parsedParam = parseParam(rawParams[i3].trim());
              if (parsedParam.restParam && i3 !== rawParams.length - 1) {
                throw new SyntaxError('Unexpected rest parameter "' + rawParams[i3] + '": only allowed for the last parameter');
              }
              if (parsedParam.types.length === 0) {
                return null;
              }
              params.push(parsedParam);
            }
            return params;
          }
          function hasRestParam(params) {
            const param = last(params);
            return param ? param.restParam : false;
          }
          function compileTest(param) {
            if (!param || param.types.length === 0) {
              return ok;
            } else if (param.types.length === 1) {
              return findType(param.types[0].name).test;
            } else if (param.types.length === 2) {
              const test0 = findType(param.types[0].name).test;
              const test1 = findType(param.types[1].name).test;
              return function or2(x) {
                return test0(x) || test1(x);
              };
            } else {
              const tests = param.types.map(function(type) {
                return findType(type.name).test;
              });
              return function or2(x) {
                for (let i3 = 0; i3 < tests.length; i3++) {
                  if (tests[i3](x)) {
                    return true;
                  }
                }
                return false;
              };
            }
          }
          function compileTests(params) {
            let tests, test0, test1;
            if (hasRestParam(params)) {
              tests = initial(params).map(compileTest);
              const varIndex = tests.length;
              const lastTest = compileTest(last(params));
              const testRestParam = function(args) {
                for (let i3 = varIndex; i3 < args.length; i3++) {
                  if (!lastTest(args[i3])) {
                    return false;
                  }
                }
                return true;
              };
              return function testArgs(args) {
                for (let i3 = 0; i3 < tests.length; i3++) {
                  if (!tests[i3](args[i3])) {
                    return false;
                  }
                }
                return testRestParam(args) && args.length >= varIndex + 1;
              };
            } else {
              if (params.length === 0) {
                return function testArgs(args) {
                  return args.length === 0;
                };
              } else if (params.length === 1) {
                test0 = compileTest(params[0]);
                return function testArgs(args) {
                  return test0(args[0]) && args.length === 1;
                };
              } else if (params.length === 2) {
                test0 = compileTest(params[0]);
                test1 = compileTest(params[1]);
                return function testArgs(args) {
                  return test0(args[0]) && test1(args[1]) && args.length === 2;
                };
              } else {
                tests = params.map(compileTest);
                return function testArgs(args) {
                  for (let i3 = 0; i3 < tests.length; i3++) {
                    if (!tests[i3](args[i3])) {
                      return false;
                    }
                  }
                  return args.length === tests.length;
                };
              }
            }
          }
          function getParamAtIndex(params, index2) {
            return index2 < params.length ? params[index2] : hasRestParam(params) ? last(params) : null;
          }
          function getTypeSetAtIndex(params, index2) {
            const param = getParamAtIndex(params, index2);
            if (!param) {
              return /* @__PURE__ */ new Set();
            }
            return paramTypeSet(param);
          }
          function isExactType(type) {
            return type.conversion === null || type.conversion === void 0;
          }
          function mergeExpectedParams(signatures, index2) {
            const typeSet = /* @__PURE__ */ new Set();
            signatures.forEach((signature) => {
              const paramSet = getTypeSetAtIndex(signature.params, index2);
              let name310;
              for (name310 of paramSet) {
                typeSet.add(name310);
              }
            });
            return typeSet.has("any") ? ["any"] : Array.from(typeSet);
          }
          function createError(name310, args, signatures) {
            let err, expected;
            const _name = name310 || "unnamed";
            let matchingSignatures = signatures;
            let index2;
            for (index2 = 0; index2 < args.length; index2++) {
              const nextMatchingDefs = [];
              matchingSignatures.forEach((signature) => {
                const param = getParamAtIndex(signature.params, index2);
                const test = compileTest(param);
                if ((index2 < signature.params.length || hasRestParam(signature.params)) && test(args[index2])) {
                  nextMatchingDefs.push(signature);
                }
              });
              if (nextMatchingDefs.length === 0) {
                expected = mergeExpectedParams(matchingSignatures, index2);
                if (expected.length > 0) {
                  const actualTypes = findTypeNames(args[index2]);
                  err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index2 + ")");
                  err.data = {
                    category: "wrongType",
                    fn: _name,
                    index: index2,
                    actual: actualTypes,
                    expected
                  };
                  return err;
                }
              } else {
                matchingSignatures = nextMatchingDefs;
              }
            }
            const lengths = matchingSignatures.map(function(signature) {
              return hasRestParam(signature.params) ? Infinity : signature.params.length;
            });
            if (args.length < Math.min.apply(null, lengths)) {
              expected = mergeExpectedParams(matchingSignatures, index2);
              err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
              err.data = {
                category: "tooFewArgs",
                fn: _name,
                index: args.length,
                expected
              };
              return err;
            }
            const maxLength = Math.max.apply(null, lengths);
            if (args.length > maxLength) {
              err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
              err.data = {
                category: "tooManyArgs",
                fn: _name,
                index: args.length,
                expectedLength: maxLength
              };
              return err;
            }
            const argTypes = [];
            for (let i3 = 0; i3 < args.length; ++i3) {
              argTypes.push(findTypeNames(args[i3]).join("|"));
            }
            err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
            err.data = {
              category: "mismatch",
              actual: argTypes
            };
            return err;
          }
          function getLowestTypeIndex(param) {
            let min3 = typeList.length + 1;
            for (let i3 = 0; i3 < param.types.length; i3++) {
              if (isExactType(param.types[i3])) {
                min3 = Math.min(min3, param.types[i3].typeIndex);
              }
            }
            return min3;
          }
          function getLowestConversionIndex(param) {
            let min3 = nConversions + 1;
            for (let i3 = 0; i3 < param.types.length; i3++) {
              if (!isExactType(param.types[i3])) {
                min3 = Math.min(min3, param.types[i3].conversionIndex);
              }
            }
            return min3;
          }
          function compareParams(param1, param2) {
            if (param1.hasAny) {
              if (!param2.hasAny) {
                return 1;
              }
            } else if (param2.hasAny) {
              return -1;
            }
            if (param1.restParam) {
              if (!param2.restParam) {
                return 1;
              }
            } else if (param2.restParam) {
              return -1;
            }
            if (param1.hasConversion) {
              if (!param2.hasConversion) {
                return 1;
              }
            } else if (param2.hasConversion) {
              return -1;
            }
            const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
            if (typeDiff < 0) {
              return -1;
            }
            if (typeDiff > 0) {
              return 1;
            }
            const convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
            if (convDiff < 0) {
              return -1;
            }
            if (convDiff > 0) {
              return 1;
            }
            return 0;
          }
          function compareSignatures(signature1, signature2) {
            const pars1 = signature1.params;
            const pars2 = signature2.params;
            const last1 = last(pars1);
            const last2 = last(pars2);
            const hasRest1 = hasRestParam(pars1);
            const hasRest2 = hasRestParam(pars2);
            if (hasRest1 && last1.hasAny) {
              if (!hasRest2 || !last2.hasAny) {
                return 1;
              }
            } else if (hasRest2 && last2.hasAny) {
              return -1;
            }
            let any1 = 0;
            let conv1 = 0;
            let par;
            for (par of pars1) {
              if (par.hasAny)
                ++any1;
              if (par.hasConversion)
                ++conv1;
            }
            let any2 = 0;
            let conv2 = 0;
            for (par of pars2) {
              if (par.hasAny)
                ++any2;
              if (par.hasConversion)
                ++conv2;
            }
            if (any1 !== any2) {
              return any1 - any2;
            }
            if (hasRest1 && last1.hasConversion) {
              if (!hasRest2 || !last2.hasConversion) {
                return 1;
              }
            } else if (hasRest2 && last2.hasConversion) {
              return -1;
            }
            if (conv1 !== conv2) {
              return conv1 - conv2;
            }
            if (hasRest1) {
              if (!hasRest2) {
                return 1;
              }
            } else if (hasRest2) {
              return -1;
            }
            const lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);
            if (lengthCriterion !== 0) {
              return lengthCriterion;
            }
            const comparisons = [];
            let tc = 0;
            for (let i3 = 0; i3 < pars1.length; ++i3) {
              const thisComparison = compareParams(pars1[i3], pars2[i3]);
              comparisons.push(thisComparison);
              tc += thisComparison;
            }
            if (tc !== 0) {
              return tc;
            }
            let c;
            for (c of comparisons) {
              if (c !== 0) {
                return c;
              }
            }
            return 0;
          }
          function availableConversions(typeNames) {
            if (typeNames.length === 0) {
              return [];
            }
            const types = typeNames.map(findType);
            if (typeNames.length > 1) {
              types.sort((t1, t2) => t1.index - t2.index);
            }
            let matches = types[0].conversionsTo;
            if (typeNames.length === 1) {
              return matches;
            }
            matches = matches.concat([]);
            const knownTypes = new Set(typeNames);
            for (let i3 = 1; i3 < types.length; ++i3) {
              let newMatch;
              for (newMatch of types[i3].conversionsTo) {
                if (!knownTypes.has(newMatch.from)) {
                  matches.push(newMatch);
                  knownTypes.add(newMatch.from);
                }
              }
            }
            return matches;
          }
          function compileArgsPreprocessing(params, fn) {
            let fnConvert = fn;
            if (params.some((p) => p.hasConversion)) {
              const restParam = hasRestParam(params);
              const compiledConversions = params.map(compileArgConversion);
              fnConvert = function convertArgs() {
                const args = [];
                const last2 = restParam ? arguments.length - 1 : arguments.length;
                for (let i3 = 0; i3 < last2; i3++) {
                  args[i3] = compiledConversions[i3](arguments[i3]);
                }
                if (restParam) {
                  args[last2] = arguments[last2].map(compiledConversions[last2]);
                }
                return fn.apply(this, args);
              };
            }
            let fnPreprocess = fnConvert;
            if (hasRestParam(params)) {
              const offset = params.length - 1;
              fnPreprocess = function preprocessRestParams() {
                return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
              };
            }
            return fnPreprocess;
          }
          function compileArgConversion(param) {
            let test0, test1, conversion0, conversion1;
            const tests = [];
            const conversions = [];
            param.types.forEach(function(type) {
              if (type.conversion) {
                tests.push(findType(type.conversion.from).test);
                conversions.push(type.conversion.convert);
              }
            });
            switch (conversions.length) {
              case 0:
                return function convertArg(arg2) {
                  return arg2;
                };
              case 1:
                test0 = tests[0];
                conversion0 = conversions[0];
                return function convertArg(arg2) {
                  if (test0(arg2)) {
                    return conversion0(arg2);
                  }
                  return arg2;
                };
              case 2:
                test0 = tests[0];
                test1 = tests[1];
                conversion0 = conversions[0];
                conversion1 = conversions[1];
                return function convertArg(arg2) {
                  if (test0(arg2)) {
                    return conversion0(arg2);
                  }
                  if (test1(arg2)) {
                    return conversion1(arg2);
                  }
                  return arg2;
                };
              default:
                return function convertArg(arg2) {
                  for (let i3 = 0; i3 < conversions.length; i3++) {
                    if (tests[i3](arg2)) {
                      return conversions[i3](arg2);
                    }
                  }
                  return arg2;
                };
            }
          }
          function splitParams(params) {
            function _splitParams(params2, index2, paramsSoFar) {
              if (index2 < params2.length) {
                const param = params2[index2];
                let resultingParams = [];
                if (param.restParam) {
                  const exactTypes = param.types.filter(isExactType);
                  if (exactTypes.length < param.types.length) {
                    resultingParams.push({
                      types: exactTypes,
                      name: "..." + exactTypes.map((t) => t.name).join("|"),
                      hasAny: exactTypes.some((t) => t.isAny),
                      hasConversion: false,
                      restParam: true
                    });
                  }
                  resultingParams.push(param);
                } else {
                  resultingParams = param.types.map(function(type) {
                    return {
                      types: [type],
                      name: type.name,
                      hasAny: type.isAny,
                      hasConversion: type.conversion,
                      restParam: false
                    };
                  });
                }
                return flatMap(resultingParams, function(nextParam) {
                  return _splitParams(params2, index2 + 1, paramsSoFar.concat([nextParam]));
                });
              } else {
                return [paramsSoFar];
              }
            }
            return _splitParams(params, 0, []);
          }
          function conflicting(params1, params2) {
            const ii = Math.max(params1.length, params2.length);
            for (let i3 = 0; i3 < ii; i3++) {
              const typeSet1 = getTypeSetAtIndex(params1, i3);
              const typeSet2 = getTypeSetAtIndex(params2, i3);
              let overlap = false;
              let name310;
              for (name310 of typeSet2) {
                if (typeSet1.has(name310)) {
                  overlap = true;
                  break;
                }
              }
              if (!overlap) {
                return false;
              }
            }
            const len1 = params1.length;
            const len2 = params2.length;
            const restParam1 = hasRestParam(params1);
            const restParam2 = hasRestParam(params2);
            return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
          }
          function clearResolutions(functionList) {
            return functionList.map((fn) => {
              if (isReferToSelf(fn)) {
                return referToSelf(fn.referToSelf.callback);
              }
              if (isReferTo(fn)) {
                return makeReferTo(fn.referTo.references, fn.referTo.callback);
              }
              return fn;
            });
          }
          function collectResolutions(references, functionList, signatureMap) {
            const resolvedReferences = [];
            let reference;
            for (reference of references) {
              let resolution = signatureMap[reference];
              if (typeof resolution !== "number") {
                throw new TypeError('No definition for referenced signature "' + reference + '"');
              }
              resolution = functionList[resolution];
              if (typeof resolution !== "function") {
                return false;
              }
              resolvedReferences.push(resolution);
            }
            return resolvedReferences;
          }
          function resolveReferences(functionList, signatureMap, self2) {
            const resolvedFunctions = clearResolutions(functionList);
            const isResolved = new Array(resolvedFunctions.length).fill(false);
            let leftUnresolved = true;
            while (leftUnresolved) {
              leftUnresolved = false;
              let nothingResolved = true;
              for (let i3 = 0; i3 < resolvedFunctions.length; ++i3) {
                if (isResolved[i3])
                  continue;
                const fn = resolvedFunctions[i3];
                if (isReferToSelf(fn)) {
                  resolvedFunctions[i3] = fn.referToSelf.callback(self2);
                  resolvedFunctions[i3].referToSelf = fn.referToSelf;
                  isResolved[i3] = true;
                  nothingResolved = false;
                } else if (isReferTo(fn)) {
                  const resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);
                  if (resolvedReferences) {
                    resolvedFunctions[i3] = fn.referTo.callback.apply(this, resolvedReferences);
                    resolvedFunctions[i3].referTo = fn.referTo;
                    isResolved[i3] = true;
                    nothingResolved = false;
                  } else {
                    leftUnresolved = true;
                  }
                }
              }
              if (nothingResolved && leftUnresolved) {
                throw new SyntaxError("Circular reference detected in resolving typed.referTo");
              }
            }
            return resolvedFunctions;
          }
          function validateDeprecatedThis(signaturesMap) {
            const deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
            Object.keys(signaturesMap).forEach((signature) => {
              const fn = signaturesMap[signature];
              if (deprecatedThisRegex.test(fn.toString())) {
                throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
              }
            });
          }
          function createTypedFunction(name310, rawSignaturesMap) {
            typed3.createCount++;
            if (Object.keys(rawSignaturesMap).length === 0) {
              throw new SyntaxError("No signatures provided");
            }
            if (typed3.warnAgainstDeprecatedThis) {
              validateDeprecatedThis(rawSignaturesMap);
            }
            const parsedParams = [];
            const originalFunctions = [];
            const signaturesMap = {};
            const preliminarySignatures = [];
            let signature;
            for (signature in rawSignaturesMap) {
              if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
                continue;
              }
              const params = parseSignature(signature);
              if (!params)
                continue;
              parsedParams.forEach(function(pp) {
                if (conflicting(pp, params)) {
                  throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
                }
              });
              parsedParams.push(params);
              const functionIndex = originalFunctions.length;
              originalFunctions.push(rawSignaturesMap[signature]);
              const conversionParams = params.map(expandParam);
              let sp;
              for (sp of splitParams(conversionParams)) {
                const spName = stringifyParams(sp);
                preliminarySignatures.push({
                  params: sp,
                  name: spName,
                  fn: functionIndex
                });
                if (sp.every((p) => !p.hasConversion)) {
                  signaturesMap[spName] = functionIndex;
                }
              }
            }
            preliminarySignatures.sort(compareSignatures);
            const resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);
            let s;
            for (s in signaturesMap) {
              if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {
                signaturesMap[s] = resolvedFunctions[signaturesMap[s]];
              }
            }
            const signatures = [];
            const internalSignatureMap = /* @__PURE__ */ new Map();
            for (s of preliminarySignatures) {
              if (!internalSignatureMap.has(s.name)) {
                s.fn = resolvedFunctions[s.fn];
                signatures.push(s);
                internalSignatureMap.set(s.name, s);
              }
            }
            const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
            const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
            const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
            const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
            const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
            const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
            const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
            for (let i3 = 0; i3 < signatures.length; ++i3) {
              signatures[i3].test = compileTests(signatures[i3].params);
            }
            const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
            const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
            const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
            const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
            const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
            const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
            const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
            const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
            const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
            const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
            const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
            const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
            for (let i3 = 0; i3 < signatures.length; ++i3) {
              signatures[i3].implementation = compileArgsPreprocessing(signatures[i3].params, signatures[i3].fn);
            }
            const fn0 = ok0 ? signatures[0].implementation : undef;
            const fn1 = ok1 ? signatures[1].implementation : undef;
            const fn2 = ok2 ? signatures[2].implementation : undef;
            const fn3 = ok3 ? signatures[3].implementation : undef;
            const fn4 = ok4 ? signatures[4].implementation : undef;
            const fn5 = ok5 ? signatures[5].implementation : undef;
            const len0 = ok0 ? signatures[0].params.length : -1;
            const len1 = ok1 ? signatures[1].params.length : -1;
            const len2 = ok2 ? signatures[2].params.length : -1;
            const len3 = ok3 ? signatures[3].params.length : -1;
            const len4 = ok4 ? signatures[4].params.length : -1;
            const len5 = ok5 ? signatures[5].params.length : -1;
            const iStart = allOk ? 6 : 0;
            const iEnd = signatures.length;
            const tests = signatures.map((s2) => s2.test);
            const fns = signatures.map((s2) => s2.implementation);
            const generic = function generic2() {
              for (let i3 = iStart; i3 < iEnd; i3++) {
                if (tests[i3](arguments)) {
                  return fns[i3].apply(this, arguments);
                }
              }
              return typed3.onMismatch(name310, arguments, signatures);
            };
            function theTypedFn(arg0, arg1) {
              if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
                return fn0.apply(this, arguments);
              }
              if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
                return fn1.apply(this, arguments);
              }
              if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
                return fn2.apply(this, arguments);
              }
              if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
                return fn3.apply(this, arguments);
              }
              if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
                return fn4.apply(this, arguments);
              }
              if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
                return fn5.apply(this, arguments);
              }
              return generic.apply(this, arguments);
            }
            try {
              Object.defineProperty(theTypedFn, "name", {
                value: name310
              });
            } catch (err) {
            }
            theTypedFn.signatures = signaturesMap;
            theTypedFn._typedFunctionData = {
              signatures,
              signatureMap: internalSignatureMap
            };
            return theTypedFn;
          }
          function _onMismatch(name310, args, signatures) {
            throw createError(name310, args, signatures);
          }
          function initial(arr) {
            return slice(arr, 0, arr.length - 1);
          }
          function last(arr) {
            return arr[arr.length - 1];
          }
          function slice(arr, start, end) {
            return Array.prototype.slice.call(arr, start, end);
          }
          function findInArray(arr, test) {
            for (let i3 = 0; i3 < arr.length; i3++) {
              if (test(arr[i3])) {
                return arr[i3];
              }
            }
            return void 0;
          }
          function flatMap(arr, callback) {
            return Array.prototype.concat.apply([], arr.map(callback));
          }
          function referTo() {
            const references = initial(arguments).map((s) => stringifyParams(parseSignature(s)));
            const callback = last(arguments);
            if (typeof callback !== "function") {
              throw new TypeError("Callback function expected as last argument");
            }
            return makeReferTo(references, callback);
          }
          function makeReferTo(references, callback) {
            return {
              referTo: {
                references,
                callback
              }
            };
          }
          function referToSelf(callback) {
            if (typeof callback !== "function") {
              throw new TypeError("Callback function expected as first argument");
            }
            return {
              referToSelf: {
                callback
              }
            };
          }
          function isReferTo(objectOrFn) {
            return objectOrFn && typeof objectOrFn.referTo === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
          }
          function isReferToSelf(objectOrFn) {
            return objectOrFn && typeof objectOrFn.referToSelf === "object" && typeof objectOrFn.referToSelf.callback === "function";
          }
          function checkName(nameSoFar, newName) {
            if (!nameSoFar) {
              return newName;
            }
            if (newName && newName !== nameSoFar) {
              const err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
              err.data = {
                actual: newName,
                expected: nameSoFar
              };
              throw err;
            }
            return nameSoFar;
          }
          function getObjectName(obj) {
            let name310;
            for (const key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
                name310 = checkName(name310, obj[key].name);
              }
            }
            return name310;
          }
          function mergeSignatures(dest, source) {
            let key;
            for (key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                if (key in dest) {
                  if (source[key] !== dest[key]) {
                    const err = new Error('Signature "' + key + '" is defined twice');
                    err.data = {
                      signature: key,
                      sourceFunction: source[key],
                      destFunction: dest[key]
                    };
                    throw err;
                  }
                }
                dest[key] = source[key];
              }
            }
          }
          const saveTyped = typed3;
          typed3 = function(maybeName) {
            const named = typeof maybeName === "string";
            const start = named ? 1 : 0;
            let name310 = named ? maybeName : "";
            const allSignatures = {};
            for (let i3 = start; i3 < arguments.length; ++i3) {
              const item = arguments[i3];
              let theseSignatures = {};
              let thisName;
              if (typeof item === "function") {
                thisName = item.name;
                if (typeof item.signature === "string") {
                  theseSignatures[item.signature] = item;
                } else if (isTypedFunction(item)) {
                  theseSignatures = item.signatures;
                }
              } else if (isPlainObject2(item)) {
                theseSignatures = item;
                if (!named) {
                  thisName = getObjectName(item);
                }
              }
              if (Object.keys(theseSignatures).length === 0) {
                const err = new TypeError("Argument to 'typed' at index " + i3 + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
                err.data = {
                  index: i3,
                  argument: item
                };
                throw err;
              }
              if (!named) {
                name310 = checkName(name310, thisName);
              }
              mergeSignatures(allSignatures, theseSignatures);
            }
            return createTypedFunction(name310 || "", allSignatures);
          };
          typed3.create = create;
          typed3.createCount = saveTyped.createCount;
          typed3.onMismatch = _onMismatch;
          typed3.throwMismatchError = _onMismatch;
          typed3.createError = createError;
          typed3.clear = clear;
          typed3.clearConversions = clearConversions;
          typed3.addTypes = addTypes;
          typed3._findType = findType;
          typed3.referTo = referTo;
          typed3.referToSelf = referToSelf;
          typed3.convert = convert;
          typed3.findSignature = findSignature;
          typed3.find = find;
          typed3.isTypedFunction = isTypedFunction;
          typed3.warnAgainstDeprecatedThis = true;
          typed3.addType = function(type, beforeObjectTest) {
            let before = "any";
            if (beforeObjectTest !== false && typeMap.has("Object")) {
              before = "Object";
            }
            typed3.addTypes([type], before);
          };
          function _validateConversion(conversion) {
            if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
              throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
            }
            if (conversion.to === conversion.from) {
              throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
            }
          }
          typed3.addConversion = function(conversion) {
            _validateConversion(conversion);
            const to2 = findType(conversion.to);
            if (to2.conversionsTo.every(function(other) {
              return other.from !== conversion.from;
            })) {
              to2.conversionsTo.push({
                from: conversion.from,
                convert: conversion.convert,
                index: nConversions++
              });
            } else {
              throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to2.name + '"');
            }
          };
          typed3.addConversions = function(conversions) {
            conversions.forEach(typed3.addConversion);
          };
          typed3.removeConversion = function(conversion) {
            _validateConversion(conversion);
            const to2 = findType(conversion.to);
            const existingConversion = findInArray(to2.conversionsTo, (c) => c.from === conversion.from);
            if (!existingConversion) {
              throw new Error("Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to);
            }
            if (existingConversion.convert !== conversion.convert) {
              throw new Error("Conversion to remove does not match existing conversion");
            }
            const index2 = to2.conversionsTo.indexOf(existingConversion);
            to2.conversionsTo.splice(index2, 1);
          };
          typed3.resolve = function(tf, argList) {
            if (!isTypedFunction(tf)) {
              throw new TypeError(NOT_TYPED_FUNCTION);
            }
            const sigs = tf._typedFunctionData.signatures;
            for (let i3 = 0; i3 < sigs.length; ++i3) {
              if (sigs[i3].test(argList)) {
                return sigs[i3];
              }
            }
            return null;
          };
          return typed3;
        }
        var typedFunction2 = create();
        return typedFunction2;
      });
    }
  });

  // node_modules/complex.js/complex.js
  var require_complex = __commonJS({
    "node_modules/complex.js/complex.js"(exports, module) {
      (function(root) {
        "use strict";
        var cosh4 = Math.cosh || function(x) {
          return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
        };
        var sinh4 = Math.sinh || function(x) {
          return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
        };
        var cosm1 = function(x) {
          var b = Math.PI / 4;
          if (-b > x || x > b) {
            return Math.cos(x) - 1;
          }
          var xx = x * x;
          return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
        };
        var hypot3 = function(x, y2) {
          var a = Math.abs(x);
          var b = Math.abs(y2);
          if (a < 3e3 && b < 3e3) {
            return Math.sqrt(a * a + b * b);
          }
          if (a < b) {
            a = b;
            b = x / y2;
          } else {
            b = y2 / x;
          }
          return a * Math.sqrt(1 + b * b);
        };
        var parser_exit = function() {
          throw SyntaxError("Invalid Param");
        };
        function logHypot(a, b) {
          var _a = Math.abs(a);
          var _b = Math.abs(b);
          if (a === 0) {
            return Math.log(_b);
          }
          if (b === 0) {
            return Math.log(_a);
          }
          if (_a < 3e3 && _b < 3e3) {
            return Math.log(a * a + b * b) * 0.5;
          }
          a = a / 2;
          b = b / 2;
          return 0.5 * Math.log(a * a + b * b) + Math.LN2;
        }
        var parse2 = function(a, b) {
          var z = { "re": 0, "im": 0 };
          if (a === void 0 || a === null) {
            z["re"] = z["im"] = 0;
          } else if (b !== void 0) {
            z["re"] = a;
            z["im"] = b;
          } else
            switch (typeof a) {
              case "object":
                if ("im" in a && "re" in a) {
                  z["re"] = a["re"];
                  z["im"] = a["im"];
                } else if ("abs" in a && "arg" in a) {
                  if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                    return Complex3["INFINITY"];
                  }
                  z["re"] = a["abs"] * Math.cos(a["arg"]);
                  z["im"] = a["abs"] * Math.sin(a["arg"]);
                } else if ("r" in a && "phi" in a) {
                  if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                    return Complex3["INFINITY"];
                  }
                  z["re"] = a["r"] * Math.cos(a["phi"]);
                  z["im"] = a["r"] * Math.sin(a["phi"]);
                } else if (a.length === 2) {
                  z["re"] = a[0];
                  z["im"] = a[1];
                } else {
                  parser_exit();
                }
                break;
              case "string":
                z["im"] = /* void */
                z["re"] = 0;
                var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
                var plus = 1;
                var minus = 0;
                if (tokens === null) {
                  parser_exit();
                }
                for (var i3 = 0; i3 < tokens.length; i3++) {
                  var c = tokens[i3];
                  if (c === " " || c === "	" || c === "\n") {
                  } else if (c === "+") {
                    plus++;
                  } else if (c === "-") {
                    minus++;
                  } else if (c === "i" || c === "I") {
                    if (plus + minus === 0) {
                      parser_exit();
                    }
                    if (tokens[i3 + 1] !== " " && !isNaN(tokens[i3 + 1])) {
                      z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i3 + 1]);
                      i3++;
                    } else {
                      z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                    }
                    plus = minus = 0;
                  } else {
                    if (plus + minus === 0 || isNaN(c)) {
                      parser_exit();
                    }
                    if (tokens[i3 + 1] === "i" || tokens[i3 + 1] === "I") {
                      z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                      i3++;
                    } else {
                      z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                    }
                    plus = minus = 0;
                  }
                }
                if (plus + minus > 0) {
                  parser_exit();
                }
                break;
              case "number":
                z["im"] = 0;
                z["re"] = a;
                break;
              default:
                parser_exit();
            }
          if (isNaN(z["re"]) || isNaN(z["im"])) {
          }
          return z;
        };
        function Complex3(a, b) {
          if (!(this instanceof Complex3)) {
            return new Complex3(a, b);
          }
          var z = parse2(a, b);
          this["re"] = z["re"];
          this["im"] = z["im"];
        }
        Complex3.prototype = {
          "re": 0,
          "im": 0,
          /**
           * Calculates the sign of a complex number, which is a normalized complex
           *
           * @returns {Complex}
           */
          "sign": function() {
            var abs3 = this["abs"]();
            return new Complex3(
              this["re"] / abs3,
              this["im"] / abs3
            );
          },
          /**
           * Adds two complex numbers
           *
           * @returns {Complex}
           */
          "add": function(a, b) {
            var z = new Complex3(a, b);
            if (this["isInfinite"]() && z["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z["isInfinite"]()) {
              return Complex3["INFINITY"];
            }
            return new Complex3(
              this["re"] + z["re"],
              this["im"] + z["im"]
            );
          },
          /**
           * Subtracts two complex numbers
           *
           * @returns {Complex}
           */
          "sub": function(a, b) {
            var z = new Complex3(a, b);
            if (this["isInfinite"]() && z["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z["isInfinite"]()) {
              return Complex3["INFINITY"];
            }
            return new Complex3(
              this["re"] - z["re"],
              this["im"] - z["im"]
            );
          },
          /**
           * Multiplies two complex numbers
           *
           * @returns {Complex}
           */
          "mul": function(a, b) {
            var z = new Complex3(a, b);
            if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z["isInfinite"]()) {
              return Complex3["INFINITY"];
            }
            if (z["im"] === 0 && this["im"] === 0) {
              return new Complex3(this["re"] * z["re"], 0);
            }
            return new Complex3(
              this["re"] * z["re"] - this["im"] * z["im"],
              this["re"] * z["im"] + this["im"] * z["re"]
            );
          },
          /**
           * Divides two complex numbers
           *
           * @returns {Complex}
           */
          "div": function(a, b) {
            var z = new Complex3(a, b);
            if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
              return Complex3["NAN"];
            }
            if (this["isInfinite"]() || z["isZero"]()) {
              return Complex3["INFINITY"];
            }
            if (this["isZero"]() || z["isInfinite"]()) {
              return Complex3["ZERO"];
            }
            a = this["re"];
            b = this["im"];
            var c = z["re"];
            var d = z["im"];
            var t, x;
            if (0 === d) {
              return new Complex3(a / c, b / c);
            }
            if (Math.abs(c) < Math.abs(d)) {
              x = c / d;
              t = c * x + d;
              return new Complex3(
                (a * x + b) / t,
                (b * x - a) / t
              );
            } else {
              x = d / c;
              t = d * x + c;
              return new Complex3(
                (a + b * x) / t,
                (b - a * x) / t
              );
            }
          },
          /**
           * Calculate the power of two complex numbers
           *
           * @returns {Complex}
           */
          "pow": function(a, b) {
            var z = new Complex3(a, b);
            a = this["re"];
            b = this["im"];
            if (z["isZero"]()) {
              return Complex3["ONE"];
            }
            if (z["im"] === 0) {
              if (b === 0 && a > 0) {
                return new Complex3(Math.pow(a, z["re"]), 0);
              } else if (a === 0) {
                switch ((z["re"] % 4 + 4) % 4) {
                  case 0:
                    return new Complex3(Math.pow(b, z["re"]), 0);
                  case 1:
                    return new Complex3(0, Math.pow(b, z["re"]));
                  case 2:
                    return new Complex3(-Math.pow(b, z["re"]), 0);
                  case 3:
                    return new Complex3(0, -Math.pow(b, z["re"]));
                }
              }
            }
            if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
              return Complex3["ZERO"];
            }
            var arg2 = Math.atan2(b, a);
            var loh = logHypot(a, b);
            a = Math.exp(z["re"] * loh - z["im"] * arg2);
            b = z["im"] * loh + z["re"] * arg2;
            return new Complex3(
              a * Math.cos(b),
              a * Math.sin(b)
            );
          },
          /**
           * Calculate the complex square root
           *
           * @returns {Complex}
           */
          "sqrt": function() {
            var a = this["re"];
            var b = this["im"];
            var r = this["abs"]();
            var re2, im2;
            if (a >= 0) {
              if (b === 0) {
                return new Complex3(Math.sqrt(a), 0);
              }
              re2 = 0.5 * Math.sqrt(2 * (r + a));
            } else {
              re2 = Math.abs(b) / Math.sqrt(2 * (r - a));
            }
            if (a <= 0) {
              im2 = 0.5 * Math.sqrt(2 * (r - a));
            } else {
              im2 = Math.abs(b) / Math.sqrt(2 * (r + a));
            }
            return new Complex3(re2, b < 0 ? -im2 : im2);
          },
          /**
           * Calculate the complex exponent
           *
           * @returns {Complex}
           */
          "exp": function() {
            var tmp = Math.exp(this["re"]);
            if (this["im"] === 0) {
            }
            return new Complex3(
              tmp * Math.cos(this["im"]),
              tmp * Math.sin(this["im"])
            );
          },
          /**
           * Calculate the complex exponent and subtracts one.
           *
           * This may be more accurate than `Complex(x).exp().sub(1)` if
           * `x` is small.
           *
           * @returns {Complex}
           */
          "expm1": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              Math.expm1(a) * Math.cos(b) + cosm1(b),
              Math.exp(a) * Math.sin(b)
            );
          },
          /**
           * Calculate the natural log
           *
           * @returns {Complex}
           */
          "log": function() {
            var a = this["re"];
            var b = this["im"];
            if (b === 0 && a > 0) {
            }
            return new Complex3(
              logHypot(a, b),
              Math.atan2(b, a)
            );
          },
          /**
           * Calculate the magnitude of the complex number
           *
           * @returns {number}
           */
          "abs": function() {
            return hypot3(this["re"], this["im"]);
          },
          /**
           * Calculate the angle of the complex number
           *
           * @returns {number}
           */
          "arg": function() {
            return Math.atan2(this["im"], this["re"]);
          },
          /**
           * Calculate the sine of the complex number
           *
           * @returns {Complex}
           */
          "sin": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              Math.sin(a) * cosh4(b),
              Math.cos(a) * sinh4(b)
            );
          },
          /**
           * Calculate the cosine
           *
           * @returns {Complex}
           */
          "cos": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              Math.cos(a) * cosh4(b),
              -Math.sin(a) * sinh4(b)
            );
          },
          /**
           * Calculate the tangent
           *
           * @returns {Complex}
           */
          "tan": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = Math.cos(a) + cosh4(b);
            return new Complex3(
              Math.sin(a) / d,
              sinh4(b) / d
            );
          },
          /**
           * Calculate the cotangent
           *
           * @returns {Complex}
           */
          "cot": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = Math.cos(a) - cosh4(b);
            return new Complex3(
              -Math.sin(a) / d,
              sinh4(b) / d
            );
          },
          /**
           * Calculate the secant
           *
           * @returns {Complex}
           */
          "sec": function() {
            var a = this["re"];
            var b = this["im"];
            var d = 0.5 * cosh4(2 * b) + 0.5 * Math.cos(2 * a);
            return new Complex3(
              Math.cos(a) * cosh4(b) / d,
              Math.sin(a) * sinh4(b) / d
            );
          },
          /**
           * Calculate the cosecans
           *
           * @returns {Complex}
           */
          "csc": function() {
            var a = this["re"];
            var b = this["im"];
            var d = 0.5 * cosh4(2 * b) - 0.5 * Math.cos(2 * a);
            return new Complex3(
              Math.sin(a) * cosh4(b) / d,
              -Math.cos(a) * sinh4(b) / d
            );
          },
          /**
           * Calculate the complex arcus sinus
           *
           * @returns {Complex}
           */
          "asin": function() {
            var a = this["re"];
            var b = this["im"];
            var t1 = new Complex3(
              b * b - a * a + 1,
              -2 * a * b
            )["sqrt"]();
            var t2 = new Complex3(
              t1["re"] - b,
              t1["im"] + a
            )["log"]();
            return new Complex3(t2["im"], -t2["re"]);
          },
          /**
           * Calculate the complex arcus cosinus
           *
           * @returns {Complex}
           */
          "acos": function() {
            var a = this["re"];
            var b = this["im"];
            var t1 = new Complex3(
              b * b - a * a + 1,
              -2 * a * b
            )["sqrt"]();
            var t2 = new Complex3(
              t1["re"] - b,
              t1["im"] + a
            )["log"]();
            return new Complex3(Math.PI / 2 - t2["im"], t2["re"]);
          },
          /**
           * Calculate the complex arcus tangent
           *
           * @returns {Complex}
           */
          "atan": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0) {
              if (b === 1) {
                return new Complex3(0, Infinity);
              }
              if (b === -1) {
                return new Complex3(0, -Infinity);
              }
            }
            var d = a * a + (1 - b) * (1 - b);
            var t1 = new Complex3(
              (1 - b * b - a * a) / d,
              -2 * a / d
            ).log();
            return new Complex3(-0.5 * t1["im"], 0.5 * t1["re"]);
          },
          /**
           * Calculate the complex arcus cotangent
           *
           * @returns {Complex}
           */
          "acot": function() {
            var a = this["re"];
            var b = this["im"];
            if (b === 0) {
              return new Complex3(Math.atan2(1, a), 0);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).atan() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).atan();
          },
          /**
           * Calculate the complex arcus secant
           *
           * @returns {Complex}
           */
          "asec": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0 && b === 0) {
              return new Complex3(0, Infinity);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).acos() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).acos();
          },
          /**
           * Calculate the complex arcus cosecans
           *
           * @returns {Complex}
           */
          "acsc": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0 && b === 0) {
              return new Complex3(Math.PI / 2, Infinity);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).asin() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).asin();
          },
          /**
           * Calculate the complex sinh
           *
           * @returns {Complex}
           */
          "sinh": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              sinh4(a) * Math.cos(b),
              cosh4(a) * Math.sin(b)
            );
          },
          /**
           * Calculate the complex cosh
           *
           * @returns {Complex}
           */
          "cosh": function() {
            var a = this["re"];
            var b = this["im"];
            return new Complex3(
              cosh4(a) * Math.cos(b),
              sinh4(a) * Math.sin(b)
            );
          },
          /**
           * Calculate the complex tanh
           *
           * @returns {Complex}
           */
          "tanh": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = cosh4(a) + Math.cos(b);
            return new Complex3(
              sinh4(a) / d,
              Math.sin(b) / d
            );
          },
          /**
           * Calculate the complex coth
           *
           * @returns {Complex}
           */
          "coth": function() {
            var a = 2 * this["re"];
            var b = 2 * this["im"];
            var d = cosh4(a) - Math.cos(b);
            return new Complex3(
              sinh4(a) / d,
              -Math.sin(b) / d
            );
          },
          /**
           * Calculate the complex coth
           *
           * @returns {Complex}
           */
          "csch": function() {
            var a = this["re"];
            var b = this["im"];
            var d = Math.cos(2 * b) - cosh4(2 * a);
            return new Complex3(
              -2 * sinh4(a) * Math.cos(b) / d,
              2 * cosh4(a) * Math.sin(b) / d
            );
          },
          /**
           * Calculate the complex sech
           *
           * @returns {Complex}
           */
          "sech": function() {
            var a = this["re"];
            var b = this["im"];
            var d = Math.cos(2 * b) + cosh4(2 * a);
            return new Complex3(
              2 * cosh4(a) * Math.cos(b) / d,
              -2 * sinh4(a) * Math.sin(b) / d
            );
          },
          /**
           * Calculate the complex asinh
           *
           * @returns {Complex}
           */
          "asinh": function() {
            var tmp = this["im"];
            this["im"] = -this["re"];
            this["re"] = tmp;
            var res = this["asin"]();
            this["re"] = -this["im"];
            this["im"] = tmp;
            tmp = res["re"];
            res["re"] = -res["im"];
            res["im"] = tmp;
            return res;
          },
          /**
           * Calculate the complex acosh
           *
           * @returns {Complex}
           */
          "acosh": function() {
            var res = this["acos"]();
            if (res["im"] <= 0) {
              var tmp = res["re"];
              res["re"] = -res["im"];
              res["im"] = tmp;
            } else {
              var tmp = res["im"];
              res["im"] = -res["re"];
              res["re"] = tmp;
            }
            return res;
          },
          /**
           * Calculate the complex atanh
           *
           * @returns {Complex}
           */
          "atanh": function() {
            var a = this["re"];
            var b = this["im"];
            var noIM = a > 1 && b === 0;
            var oneMinus = 1 - a;
            var onePlus = 1 + a;
            var d = oneMinus * oneMinus + b * b;
            var x = d !== 0 ? new Complex3(
              (onePlus * oneMinus - b * b) / d,
              (b * oneMinus + onePlus * b) / d
            ) : new Complex3(
              a !== -1 ? a / 0 : 0,
              b !== 0 ? b / 0 : 0
            );
            var temp = x["re"];
            x["re"] = logHypot(x["re"], x["im"]) / 2;
            x["im"] = Math.atan2(x["im"], temp) / 2;
            if (noIM) {
              x["im"] = -x["im"];
            }
            return x;
          },
          /**
           * Calculate the complex acoth
           *
           * @returns {Complex}
           */
          "acoth": function() {
            var a = this["re"];
            var b = this["im"];
            if (a === 0 && b === 0) {
              return new Complex3(0, Math.PI / 2);
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).atanh() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).atanh();
          },
          /**
           * Calculate the complex acsch
           *
           * @returns {Complex}
           */
          "acsch": function() {
            var a = this["re"];
            var b = this["im"];
            if (b === 0) {
              return new Complex3(
                a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
                0
              );
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).asinh() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).asinh();
          },
          /**
           * Calculate the complex asech
           *
           * @returns {Complex}
           */
          "asech": function() {
            var a = this["re"];
            var b = this["im"];
            if (this["isZero"]()) {
              return Complex3["INFINITY"];
            }
            var d = a * a + b * b;
            return d !== 0 ? new Complex3(
              a / d,
              -b / d
            ).acosh() : new Complex3(
              a !== 0 ? a / 0 : 0,
              b !== 0 ? -b / 0 : 0
            ).acosh();
          },
          /**
           * Calculate the complex inverse 1/z
           *
           * @returns {Complex}
           */
          "inverse": function() {
            if (this["isZero"]()) {
              return Complex3["INFINITY"];
            }
            if (this["isInfinite"]()) {
              return Complex3["ZERO"];
            }
            var a = this["re"];
            var b = this["im"];
            var d = a * a + b * b;
            return new Complex3(a / d, -b / d);
          },
          /**
           * Returns the complex conjugate
           *
           * @returns {Complex}
           */
          "conjugate": function() {
            return new Complex3(this["re"], -this["im"]);
          },
          /**
           * Gets the negated complex number
           *
           * @returns {Complex}
           */
          "neg": function() {
            return new Complex3(-this["re"], -this["im"]);
          },
          /**
           * Ceils the actual complex number
           *
           * @returns {Complex}
           */
          "ceil": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex3(
              Math.ceil(this["re"] * places) / places,
              Math.ceil(this["im"] * places) / places
            );
          },
          /**
           * Floors the actual complex number
           *
           * @returns {Complex}
           */
          "floor": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex3(
              Math.floor(this["re"] * places) / places,
              Math.floor(this["im"] * places) / places
            );
          },
          /**
           * Ceils the actual complex number
           *
           * @returns {Complex}
           */
          "round": function(places) {
            places = Math.pow(10, places || 0);
            return new Complex3(
              Math.round(this["re"] * places) / places,
              Math.round(this["im"] * places) / places
            );
          },
          /**
           * Compares two complex numbers
           *
           * **Note:** new Complex(Infinity).equals(Infinity) === false
           *
           * @returns {boolean}
           */
          "equals": function(a, b) {
            var z = new Complex3(a, b);
            return Math.abs(z["re"] - this["re"]) <= Complex3["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex3["EPSILON"];
          },
          /**
           * Clones the actual object
           *
           * @returns {Complex}
           */
          "clone": function() {
            return new Complex3(this["re"], this["im"]);
          },
          /**
           * Gets a string of the actual complex number
           *
           * @returns {string}
           */
          "toString": function() {
            var a = this["re"];
            var b = this["im"];
            var ret = "";
            if (this["isNaN"]()) {
              return "NaN";
            }
            if (this["isInfinite"]()) {
              return "Infinity";
            }
            if (Math.abs(a) < Complex3["EPSILON"]) {
              a = 0;
            }
            if (Math.abs(b) < Complex3["EPSILON"]) {
              b = 0;
            }
            if (b === 0) {
              return ret + a;
            }
            if (a !== 0) {
              ret += a;
              ret += " ";
              if (b < 0) {
                b = -b;
                ret += "-";
              } else {
                ret += "+";
              }
              ret += " ";
            } else if (b < 0) {
              b = -b;
              ret += "-";
            }
            if (1 !== b) {
              ret += b;
            }
            return ret + "i";
          },
          /**
           * Returns the actual number as a vector
           *
           * @returns {Array}
           */
          "toVector": function() {
            return [this["re"], this["im"]];
          },
          /**
           * Returns the actual real value of the current object
           *
           * @returns {number|null}
           */
          "valueOf": function() {
            if (this["im"] === 0) {
              return this["re"];
            }
            return null;
          },
          /**
           * Determines whether a complex number is not on the Riemann sphere.
           *
           * @returns {boolean}
           */
          "isNaN": function() {
            return isNaN(this["re"]) || isNaN(this["im"]);
          },
          /**
           * Determines whether or not a complex number is at the zero pole of the
           * Riemann sphere.
           *
           * @returns {boolean}
           */
          "isZero": function() {
            return this["im"] === 0 && this["re"] === 0;
          },
          /**
           * Determines whether a complex number is not at the infinity pole of the
           * Riemann sphere.
           *
           * @returns {boolean}
           */
          "isFinite": function() {
            return isFinite(this["re"]) && isFinite(this["im"]);
          },
          /**
           * Determines whether or not a complex number is at the infinity pole of the
           * Riemann sphere.
           *
           * @returns {boolean}
           */
          "isInfinite": function() {
            return !(this["isNaN"]() || this["isFinite"]());
          }
        };
        Complex3["ZERO"] = new Complex3(0, 0);
        Complex3["ONE"] = new Complex3(1, 0);
        Complex3["I"] = new Complex3(0, 1);
        Complex3["PI"] = new Complex3(Math.PI, 0);
        Complex3["E"] = new Complex3(Math.E, 0);
        Complex3["INFINITY"] = new Complex3(Infinity, Infinity);
        Complex3["NAN"] = new Complex3(NaN, NaN);
        Complex3["EPSILON"] = 1e-15;
        if (typeof define === "function" && define["amd"]) {
          define([], function() {
            return Complex3;
          });
        } else if (typeof exports === "object") {
          Object.defineProperty(Complex3, "__esModule", { "value": true });
          Complex3["default"] = Complex3;
          Complex3["Complex"] = Complex3;
          module["exports"] = Complex3;
        } else {
          root["Complex"] = Complex3;
        }
      })(exports);
    }
  });

  // node_modules/fraction.js/fraction.js
  var require_fraction = __commonJS({
    "node_modules/fraction.js/fraction.js"(exports, module) {
      (function(root) {
        "use strict";
        var MAX_CYCLE_LEN = 2e3;
        var P3 = {
          "s": 1,
          "n": 0,
          "d": 1
        };
        function assign2(n, s) {
          if (isNaN(n = parseInt(n, 10))) {
            throw InvalidParameter();
          }
          return n * s;
        }
        function newFraction(n, d) {
          if (d === 0) {
            throw DivisionByZero();
          }
          var f = Object.create(Fraction3.prototype);
          f["s"] = n < 0 ? -1 : 1;
          n = n < 0 ? -n : n;
          var a = gcd2(n, d);
          f["n"] = n / a;
          f["d"] = d / a;
          return f;
        }
        function factorize(num) {
          var factors = {};
          var n = num;
          var i3 = 2;
          var s = 4;
          while (s <= n) {
            while (n % i3 === 0) {
              n /= i3;
              factors[i3] = (factors[i3] || 0) + 1;
            }
            s += 1 + 2 * i3++;
          }
          if (n !== num) {
            if (n > 1)
              factors[n] = (factors[n] || 0) + 1;
          } else {
            factors[num] = (factors[num] || 0) + 1;
          }
          return factors;
        }
        var parse2 = function(p1, p2) {
          var n = 0, d = 1, s = 1;
          var v = 0, w2 = 0, x = 0, y2 = 1, z = 1;
          var A2 = 0, B2 = 1;
          var C2 = 1, D2 = 1;
          var N = 1e7;
          var M;
          if (p1 === void 0 || p1 === null) {
          } else if (p2 !== void 0) {
            n = p1;
            d = p2;
            s = n * d;
            if (n % 1 !== 0 || d % 1 !== 0) {
              throw NonIntegerParameter();
            }
          } else
            switch (typeof p1) {
              case "object": {
                if ("d" in p1 && "n" in p1) {
                  n = p1["n"];
                  d = p1["d"];
                  if ("s" in p1)
                    n *= p1["s"];
                } else if (0 in p1) {
                  n = p1[0];
                  if (1 in p1)
                    d = p1[1];
                } else {
                  throw InvalidParameter();
                }
                s = n * d;
                break;
              }
              case "number": {
                if (p1 < 0) {
                  s = p1;
                  p1 = -p1;
                }
                if (p1 % 1 === 0) {
                  n = p1;
                } else if (p1 > 0) {
                  if (p1 >= 1) {
                    z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                    p1 /= z;
                  }
                  while (B2 <= N && D2 <= N) {
                    M = (A2 + C2) / (B2 + D2);
                    if (p1 === M) {
                      if (B2 + D2 <= N) {
                        n = A2 + C2;
                        d = B2 + D2;
                      } else if (D2 > B2) {
                        n = C2;
                        d = D2;
                      } else {
                        n = A2;
                        d = B2;
                      }
                      break;
                    } else {
                      if (p1 > M) {
                        A2 += C2;
                        B2 += D2;
                      } else {
                        C2 += A2;
                        D2 += B2;
                      }
                      if (B2 > N) {
                        n = C2;
                        d = D2;
                      } else {
                        n = A2;
                        d = B2;
                      }
                    }
                  }
                  n *= z;
                } else if (isNaN(p1) || isNaN(p2)) {
                  d = n = NaN;
                }
                break;
              }
              case "string": {
                B2 = p1.match(/\d+|./g);
                if (B2 === null)
                  throw InvalidParameter();
                if (B2[A2] === "-") {
                  s = -1;
                  A2++;
                } else if (B2[A2] === "+") {
                  A2++;
                }
                if (B2.length === A2 + 1) {
                  w2 = assign2(B2[A2++], s);
                } else if (B2[A2 + 1] === "." || B2[A2] === ".") {
                  if (B2[A2] !== ".") {
                    v = assign2(B2[A2++], s);
                  }
                  A2++;
                  if (A2 + 1 === B2.length || B2[A2 + 1] === "(" && B2[A2 + 3] === ")" || B2[A2 + 1] === "'" && B2[A2 + 3] === "'") {
                    w2 = assign2(B2[A2], s);
                    y2 = Math.pow(10, B2[A2].length);
                    A2++;
                  }
                  if (B2[A2] === "(" && B2[A2 + 2] === ")" || B2[A2] === "'" && B2[A2 + 2] === "'") {
                    x = assign2(B2[A2 + 1], s);
                    z = Math.pow(10, B2[A2 + 1].length) - 1;
                    A2 += 3;
                  }
                } else if (B2[A2 + 1] === "/" || B2[A2 + 1] === ":") {
                  w2 = assign2(B2[A2], s);
                  y2 = assign2(B2[A2 + 2], 1);
                  A2 += 3;
                } else if (B2[A2 + 3] === "/" && B2[A2 + 1] === " ") {
                  v = assign2(B2[A2], s);
                  w2 = assign2(B2[A2 + 2], s);
                  y2 = assign2(B2[A2 + 4], 1);
                  A2 += 5;
                }
                if (B2.length <= A2) {
                  d = y2 * z;
                  s = /* void */
                  n = x + d * v + z * w2;
                  break;
                }
              }
              default:
                throw InvalidParameter();
            }
          if (d === 0) {
            throw DivisionByZero();
          }
          P3["s"] = s < 0 ? -1 : 1;
          P3["n"] = Math.abs(n);
          P3["d"] = Math.abs(d);
        };
        function modpow(b, e3, m) {
          var r = 1;
          for (; e3 > 0; b = b * b % m, e3 >>= 1) {
            if (e3 & 1) {
              r = r * b % m;
            }
          }
          return r;
        }
        function cycleLen(n, d) {
          for (; d % 2 === 0; d /= 2) {
          }
          for (; d % 5 === 0; d /= 5) {
          }
          if (d === 1)
            return 0;
          var rem = 10 % d;
          var t = 1;
          for (; rem !== 1; t++) {
            rem = rem * 10 % d;
            if (t > MAX_CYCLE_LEN)
              return 0;
          }
          return t;
        }
        function cycleStart(n, d, len) {
          var rem1 = 1;
          var rem2 = modpow(10, len, d);
          for (var t = 0; t < 300; t++) {
            if (rem1 === rem2)
              return t;
            rem1 = rem1 * 10 % d;
            rem2 = rem2 * 10 % d;
          }
          return 0;
        }
        function gcd2(a, b) {
          if (!a)
            return b;
          if (!b)
            return a;
          while (1) {
            a %= b;
            if (!a)
              return b;
            b %= a;
            if (!b)
              return a;
          }
        }
        ;
        function Fraction3(a, b) {
          parse2(a, b);
          if (this instanceof Fraction3) {
            a = gcd2(P3["d"], P3["n"]);
            this["s"] = P3["s"];
            this["n"] = P3["n"] / a;
            this["d"] = P3["d"] / a;
          } else {
            return newFraction(P3["s"] * P3["n"], P3["d"]);
          }
        }
        var DivisionByZero = function() {
          return new Error("Division by Zero");
        };
        var InvalidParameter = function() {
          return new Error("Invalid argument");
        };
        var NonIntegerParameter = function() {
          return new Error("Parameters must be integer");
        };
        Fraction3.prototype = {
          "s": 1,
          "n": 0,
          "d": 1,
          /**
           * Calculates the absolute value
           *
           * Ex: new Fraction(-4).abs() => 4
           **/
          "abs": function() {
            return newFraction(this["n"], this["d"]);
          },
          /**
           * Inverts the sign of the current fraction
           *
           * Ex: new Fraction(-4).neg() => 4
           **/
          "neg": function() {
            return newFraction(-this["s"] * this["n"], this["d"]);
          },
          /**
           * Adds two rational numbers
           *
           * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
           **/
          "add": function(a, b) {
            parse2(a, b);
            return newFraction(
              this["s"] * this["n"] * P3["d"] + P3["s"] * this["d"] * P3["n"],
              this["d"] * P3["d"]
            );
          },
          /**
           * Subtracts two rational numbers
           *
           * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
           **/
          "sub": function(a, b) {
            parse2(a, b);
            return newFraction(
              this["s"] * this["n"] * P3["d"] - P3["s"] * this["d"] * P3["n"],
              this["d"] * P3["d"]
            );
          },
          /**
           * Multiplies two rational numbers
           *
           * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
           **/
          "mul": function(a, b) {
            parse2(a, b);
            return newFraction(
              this["s"] * P3["s"] * this["n"] * P3["n"],
              this["d"] * P3["d"]
            );
          },
          /**
           * Divides two rational numbers
           *
           * Ex: new Fraction("-17.(345)").inverse().div(3)
           **/
          "div": function(a, b) {
            parse2(a, b);
            return newFraction(
              this["s"] * P3["s"] * this["n"] * P3["d"],
              this["d"] * P3["n"]
            );
          },
          /**
           * Clones the actual object
           *
           * Ex: new Fraction("-17.(345)").clone()
           **/
          "clone": function() {
            return newFraction(this["s"] * this["n"], this["d"]);
          },
          /**
           * Calculates the modulo of two rational numbers - a more precise fmod
           *
           * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
           **/
          "mod": function(a, b) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            if (a === void 0) {
              return newFraction(this["s"] * this["n"] % this["d"], 1);
            }
            parse2(a, b);
            if (0 === P3["n"] && 0 === this["d"]) {
              throw DivisionByZero();
            }
            return newFraction(
              this["s"] * (P3["d"] * this["n"]) % (P3["n"] * this["d"]),
              P3["d"] * this["d"]
            );
          },
          /**
           * Calculates the fractional gcd of two rational numbers
           *
           * Ex: new Fraction(5,8).gcd(3,7) => 1/56
           */
          "gcd": function(a, b) {
            parse2(a, b);
            return newFraction(gcd2(P3["n"], this["n"]) * gcd2(P3["d"], this["d"]), P3["d"] * this["d"]);
          },
          /**
           * Calculates the fractional lcm of two rational numbers
           *
           * Ex: new Fraction(5,8).lcm(3,7) => 15
           */
          "lcm": function(a, b) {
            parse2(a, b);
            if (P3["n"] === 0 && this["n"] === 0) {
              return newFraction(0, 1);
            }
            return newFraction(P3["n"] * this["n"], gcd2(P3["n"], this["n"]) * gcd2(P3["d"], this["d"]));
          },
          /**
           * Calculates the ceil of a rational number
           *
           * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
           **/
          "ceil": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Calculates the floor of a rational number
           *
           * Ex: new Fraction('4.(3)').floor() => (4 / 1)
           **/
          "floor": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Rounds a rational numbers
           *
           * Ex: new Fraction('4.(3)').round() => (4 / 1)
           **/
          "round": function(places) {
            places = Math.pow(10, places || 0);
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return new Fraction3(NaN);
            }
            return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
          },
          /**
           * Gets the inverse of the fraction, means numerator and denominator are exchanged
           *
           * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
           **/
          "inverse": function() {
            return newFraction(this["s"] * this["d"], this["n"]);
          },
          /**
           * Calculates the fraction to some rational exponent, if possible
           *
           * Ex: new Fraction(-1,2).pow(-3) => -8
           */
          "pow": function(a, b) {
            parse2(a, b);
            if (P3["d"] === 1) {
              if (P3["s"] < 0) {
                return newFraction(Math.pow(this["s"] * this["d"], P3["n"]), Math.pow(this["n"], P3["n"]));
              } else {
                return newFraction(Math.pow(this["s"] * this["n"], P3["n"]), Math.pow(this["d"], P3["n"]));
              }
            }
            if (this["s"] < 0)
              return null;
            var N = factorize(this["n"]);
            var D2 = factorize(this["d"]);
            var n = 1;
            var d = 1;
            for (var k in N) {
              if (k === "1")
                continue;
              if (k === "0") {
                n = 0;
                break;
              }
              N[k] *= P3["n"];
              if (N[k] % P3["d"] === 0) {
                N[k] /= P3["d"];
              } else
                return null;
              n *= Math.pow(k, N[k]);
            }
            for (var k in D2) {
              if (k === "1")
                continue;
              D2[k] *= P3["n"];
              if (D2[k] % P3["d"] === 0) {
                D2[k] /= P3["d"];
              } else
                return null;
              d *= Math.pow(k, D2[k]);
            }
            if (P3["s"] < 0) {
              return newFraction(d, n);
            }
            return newFraction(n, d);
          },
          /**
           * Check if two rational numbers are the same
           *
           * Ex: new Fraction(19.6).equals([98, 5]);
           **/
          "equals": function(a, b) {
            parse2(a, b);
            return this["s"] * this["n"] * P3["d"] === P3["s"] * P3["n"] * this["d"];
          },
          /**
           * Check if two rational numbers are the same
           *
           * Ex: new Fraction(19.6).equals([98, 5]);
           **/
          "compare": function(a, b) {
            parse2(a, b);
            var t = this["s"] * this["n"] * P3["d"] - P3["s"] * P3["n"] * this["d"];
            return (0 < t) - (t < 0);
          },
          "simplify": function(eps) {
            if (isNaN(this["n"]) || isNaN(this["d"])) {
              return this;
            }
            eps = eps || 1e-3;
            var thisABS = this["abs"]();
            var cont = thisABS["toContinued"]();
            for (var i3 = 1; i3 < cont.length; i3++) {
              var s = newFraction(cont[i3 - 1], 1);
              for (var k = i3 - 2; k >= 0; k--) {
                s = s["inverse"]()["add"](cont[k]);
              }
              if (Math.abs(s["sub"](thisABS).valueOf()) < eps) {
                return s["mul"](this["s"]);
              }
            }
            return this;
          },
          /**
           * Check if two rational numbers are divisible
           *
           * Ex: new Fraction(19.6).divisible(1.5);
           */
          "divisible": function(a, b) {
            parse2(a, b);
            return !(!(P3["n"] * this["d"]) || this["n"] * P3["d"] % (P3["n"] * this["d"]));
          },
          /**
           * Returns a decimal representation of the fraction
           *
           * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
           **/
          "valueOf": function() {
            return this["s"] * this["n"] / this["d"];
          },
          /**
           * Returns a string-fraction representation of a Fraction object
           *
           * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
           **/
          "toFraction": function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                str += " ";
                n %= d;
              }
              str += n;
              str += "/";
              str += d;
            }
            return str;
          },
          /**
           * Returns a latex representation of a Fraction object
           *
           * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
           **/
          "toLatex": function(excludeWhole) {
            var whole, str = "";
            var n = this["n"];
            var d = this["d"];
            if (this["s"] < 0) {
              str += "-";
            }
            if (d === 1) {
              str += n;
            } else {
              if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
                str += whole;
                n %= d;
              }
              str += "\\frac{";
              str += n;
              str += "}{";
              str += d;
              str += "}";
            }
            return str;
          },
          /**
           * Returns an array of continued fraction elements
           *
           * Ex: new Fraction("7/8").toContinued() => [0,1,7]
           */
          "toContinued": function() {
            var t;
            var a = this["n"];
            var b = this["d"];
            var res = [];
            if (isNaN(a) || isNaN(b)) {
              return res;
            }
            do {
              res.push(Math.floor(a / b));
              t = a % b;
              a = b;
              b = t;
            } while (a !== 1);
            return res;
          },
          /**
           * Creates a string representation of a fraction with all digits
           *
           * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
           **/
          "toString": function(dec) {
            var N = this["n"];
            var D2 = this["d"];
            if (isNaN(N) || isNaN(D2)) {
              return "NaN";
            }
            dec = dec || 15;
            var cycLen = cycleLen(N, D2);
            var cycOff = cycleStart(N, D2, cycLen);
            var str = this["s"] < 0 ? "-" : "";
            str += N / D2 | 0;
            N %= D2;
            N *= 10;
            if (N)
              str += ".";
            if (cycLen) {
              for (var i3 = cycOff; i3--; ) {
                str += N / D2 | 0;
                N %= D2;
                N *= 10;
              }
              str += "(";
              for (var i3 = cycLen; i3--; ) {
                str += N / D2 | 0;
                N %= D2;
                N *= 10;
              }
              str += ")";
            } else {
              for (var i3 = dec; N && i3--; ) {
                str += N / D2 | 0;
                N %= D2;
                N *= 10;
              }
            }
            return str;
          }
        };
        if (typeof exports === "object") {
          Object.defineProperty(Fraction3, "__esModule", { "value": true });
          Fraction3["default"] = Fraction3;
          Fraction3["Fraction"] = Fraction3;
          module["exports"] = Fraction3;
        } else {
          root["Fraction"] = Fraction3;
        }
      })(exports);
    }
  });

  // node_modules/javascript-natural-sort/naturalSort.js
  var require_naturalSort = __commonJS({
    "node_modules/javascript-natural-sort/naturalSort.js"(exports, module) {
      module.exports = function naturalSort2(a, b) {
        "use strict";
        var re2 = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i3 = function(s) {
          return naturalSort2.insensitive && ("" + s).toLowerCase() || "" + s;
        }, x = i3(a).replace(sre, "") || "", y2 = i3(b).replace(sre, "") || "", xN = x.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y2.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y2.match(hre), 16) || xD && y2.match(dre) && Date.parse(y2) || null, oFxNcL, oFyNcL;
        if (yD) {
          if (xD < yD) {
            return -1;
          } else if (xD > yD) {
            return 1;
          }
        }
        for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
          oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
          oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
          if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
            return isNaN(oFxNcL) ? 1 : -1;
          } else if (typeof oFxNcL !== typeof oFyNcL) {
            oFxNcL += "";
            oFyNcL += "";
          }
          if (oFxNcL < oFyNcL) {
            return -1;
          }
          if (oFxNcL > oFyNcL) {
            return 1;
          }
        }
        return 0;
      };
    }
  });

  // node_modules/escape-latex/dist/index.js
  var require_dist = __commonJS({
    "node_modules/escape-latex/dist/index.js"(exports, module) {
      "use strict";
      var _extends2 = Object.assign || function(target) {
        for (var i3 = 1; i3 < arguments.length; i3++) {
          var source = arguments[i3];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      };
      var defaultEscapes = {
        "{": "\\{",
        "}": "\\}",
        "\\": "\\textbackslash{}",
        "#": "\\#",
        $: "\\$",
        "%": "\\%",
        "&": "\\&",
        "^": "\\textasciicircum{}",
        _: "\\_",
        "~": "\\textasciitilde{}"
      };
      var formatEscapes = {
        "\u2013": "\\--",
        "\u2014": "\\---",
        " ": "~",
        "	": "\\qquad{}",
        "\r\n": "\\newline{}",
        "\n": "\\newline{}"
      };
      var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
        return _extends2({}, defaultEscapes2, formatEscapes2);
      };
      module.exports = function(str) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
        var runningStr = String(str);
        var result = "";
        var escapes = escapeMapFn(_extends2({}, defaultEscapes), preserveFormatting ? _extends2({}, formatEscapes) : {});
        var escapeKeys = Object.keys(escapes);
        var _loop = function _loop2() {
          var specialCharFound = false;
          escapeKeys.forEach(function(key, index2) {
            if (specialCharFound) {
              return;
            }
            if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
              result += escapes[escapeKeys[index2]];
              runningStr = runningStr.slice(key.length, runningStr.length);
              specialCharFound = true;
            }
          });
          if (!specialCharFound) {
            result += runningStr.slice(0, 1);
            runningStr = runningStr.slice(1, runningStr.length);
          }
        };
        while (runningStr) {
          _loop();
        }
        return result;
      };
    }
  });

  // node_modules/seedrandom/lib/alea.js
  var require_alea = __commonJS({
    "node_modules/seedrandom/lib/alea.js"(exports, module) {
      (function(global, module2, define2) {
        function Alea(seed) {
          var me = this, mash = Mash();
          me.next = function() {
            var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
            me.s0 = me.s1;
            me.s1 = me.s2;
            return me.s2 = t - (me.c = t | 0);
          };
          me.c = 1;
          me.s0 = mash(" ");
          me.s1 = mash(" ");
          me.s2 = mash(" ");
          me.s0 -= mash(seed);
          if (me.s0 < 0) {
            me.s0 += 1;
          }
          me.s1 -= mash(seed);
          if (me.s1 < 0) {
            me.s1 += 1;
          }
          me.s2 -= mash(seed);
          if (me.s2 < 0) {
            me.s2 += 1;
          }
          mash = null;
        }
        function copy(f, t) {
          t.c = f.c;
          t.s0 = f.s0;
          t.s1 = f.s1;
          t.s2 = f.s2;
          return t;
        }
        function impl(seed, opts) {
          var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
          prng.int32 = function() {
            return xg.next() * 4294967296 | 0;
          };
          prng.double = function() {
            return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
          };
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        function Mash() {
          var n = 4022871197;
          var mash = function(data) {
            data = String(data);
            for (var i3 = 0; i3 < data.length; i3++) {
              n += data.charCodeAt(i3);
              var h = 0.02519603282416938 * n;
              n = h >>> 0;
              h -= n;
              h *= n;
              n = h >>> 0;
              h -= n;
              n += h * 4294967296;
            }
            return (n >>> 0) * 23283064365386963e-26;
          };
          return mash;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.alea = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xor128.js
  var require_xor128 = __commonJS({
    "node_modules/seedrandom/lib/xor128.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.next = function() {
            var t = me.x ^ me.x << 11;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
          };
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor128 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xorwow.js
  var require_xorwow = __commonJS({
    "node_modules/seedrandom/lib/xorwow.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var t = me.x ^ me.x >>> 2;
            me.x = me.y;
            me.y = me.z;
            me.z = me.w;
            me.w = me.v;
            return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
          };
          me.x = 0;
          me.y = 0;
          me.z = 0;
          me.w = 0;
          me.v = 0;
          if (seed === (seed | 0)) {
            me.x = seed;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 64; k++) {
            me.x ^= strseed.charCodeAt(k) | 0;
            if (k == strseed.length) {
              me.d = me.x << 10 ^ me.x >>> 4;
            }
            me.next();
          }
        }
        function copy(f, t) {
          t.x = f.x;
          t.y = f.y;
          t.z = f.z;
          t.w = f.w;
          t.v = f.v;
          t.d = f.d;
          return t;
        }
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorwow = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xorshift7.js
  var require_xorshift7 = __commonJS({
    "node_modules/seedrandom/lib/xorshift7.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var X = me.x, i3 = me.i, t, v, w2;
            t = X[i3];
            t ^= t >>> 7;
            v = t ^ t << 24;
            t = X[i3 + 1 & 7];
            v ^= t ^ t >>> 10;
            t = X[i3 + 3 & 7];
            v ^= t ^ t >>> 3;
            t = X[i3 + 4 & 7];
            v ^= t ^ t << 7;
            t = X[i3 + 7 & 7];
            t = t ^ t << 13;
            v ^= t ^ t << 9;
            X[i3] = v;
            me.i = i3 + 1 & 7;
            return v;
          };
          function init(me2, seed2) {
            var j, w2, X = [];
            if (seed2 === (seed2 | 0)) {
              w2 = X[0] = seed2;
            } else {
              seed2 = "" + seed2;
              for (j = 0; j < seed2.length; ++j) {
                X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
              }
            }
            while (X.length < 8)
              X.push(0);
            for (j = 0; j < 8 && X[j] === 0; ++j)
              ;
            if (j == 8)
              w2 = X[7] = -1;
            else
              w2 = X[j];
            me2.x = X;
            me2.i = 0;
            for (j = 256; j > 0; --j) {
              me2.next();
            }
          }
          init(me, seed);
        }
        function copy(f, t) {
          t.x = f.x.slice();
          t.i = f.i;
          return t;
        }
        function impl(seed, opts) {
          if (seed == null)
            seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.x)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xorshift7 = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/xor4096.js
  var require_xor4096 = __commonJS({
    "node_modules/seedrandom/lib/xor4096.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this;
          me.next = function() {
            var w2 = me.w, X = me.X, i3 = me.i, t, v;
            me.w = w2 = w2 + 1640531527 | 0;
            v = X[i3 + 34 & 127];
            t = X[i3 = i3 + 1 & 127];
            v ^= v << 13;
            t ^= t << 17;
            v ^= v >>> 15;
            t ^= t >>> 12;
            v = X[i3] = v ^ t;
            me.i = i3;
            return v + (w2 ^ w2 >>> 16) | 0;
          };
          function init(me2, seed2) {
            var t, v, i3, j, w2, X = [], limit = 128;
            if (seed2 === (seed2 | 0)) {
              v = seed2;
              seed2 = null;
            } else {
              seed2 = seed2 + "\0";
              v = 0;
              limit = Math.max(limit, seed2.length);
            }
            for (i3 = 0, j = -32; j < limit; ++j) {
              if (seed2)
                v ^= seed2.charCodeAt((j + 32) % seed2.length);
              if (j === 0)
                w2 = v;
              v ^= v << 10;
              v ^= v >>> 15;
              v ^= v << 4;
              v ^= v >>> 13;
              if (j >= 0) {
                w2 = w2 + 1640531527 | 0;
                t = X[j & 127] ^= v + w2;
                i3 = 0 == t ? i3 + 1 : 0;
              }
            }
            if (i3 >= 128) {
              X[(seed2 && seed2.length || 0) & 127] = -1;
            }
            i3 = 127;
            for (j = 4 * 128; j > 0; --j) {
              v = X[i3 + 34 & 127];
              t = X[i3 = i3 + 1 & 127];
              v ^= v << 13;
              t ^= t << 17;
              v ^= v >>> 15;
              t ^= t >>> 12;
              X[i3] = v ^ t;
            }
            me2.w = w2;
            me2.X = X;
            me2.i = i3;
          }
          init(me, seed);
        }
        function copy(f, t) {
          t.i = f.i;
          t.w = f.w;
          t.X = f.X.slice();
          return t;
        }
        ;
        function impl(seed, opts) {
          if (seed == null)
            seed = +/* @__PURE__ */ new Date();
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (state.X)
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.xor4096 = impl;
        }
      })(
        exports,
        // window object or global
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // node_modules/seedrandom/lib/tychei.js
  var require_tychei = __commonJS({
    "node_modules/seedrandom/lib/tychei.js"(exports, module) {
      (function(global, module2, define2) {
        function XorGen(seed) {
          var me = this, strseed = "";
          me.next = function() {
            var b = me.b, c = me.c, d = me.d, a = me.a;
            b = b << 25 ^ b >>> 7 ^ c;
            c = c - d | 0;
            d = d << 24 ^ d >>> 8 ^ a;
            a = a - b | 0;
            me.b = b = b << 20 ^ b >>> 12 ^ c;
            me.c = c = c - d | 0;
            me.d = d << 16 ^ c >>> 16 ^ a;
            return me.a = a - b | 0;
          };
          me.a = 0;
          me.b = 0;
          me.c = 2654435769 | 0;
          me.d = 1367130551;
          if (seed === Math.floor(seed)) {
            me.a = seed / 4294967296 | 0;
            me.b = seed | 0;
          } else {
            strseed += seed;
          }
          for (var k = 0; k < strseed.length + 20; k++) {
            me.b ^= strseed.charCodeAt(k) | 0;
            me.next();
          }
        }
        function copy(f, t) {
          t.a = f.a;
          t.b = f.b;
          t.c = f.c;
          t.d = f.d;
          return t;
        }
        ;
        function impl(seed, opts) {
          var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
            return (xg.next() >>> 0) / 4294967296;
          };
          prng.double = function() {
            do {
              var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
            } while (result === 0);
            return result;
          };
          prng.int32 = xg.next;
          prng.quick = prng;
          if (state) {
            if (typeof state == "object")
              copy(state, xg);
            prng.state = function() {
              return copy(xg, {});
            };
          }
          return prng;
        }
        if (module2 && module2.exports) {
          module2.exports = impl;
        } else if (define2 && define2.amd) {
          define2(function() {
            return impl;
          });
        } else {
          this.tychei = impl;
        }
      })(
        exports,
        typeof module == "object" && module,
        // present in node.js
        typeof define == "function" && define
        // present with an AMD loader
      );
    }
  });

  // (disabled):crypto
  var require_crypto = __commonJS({
    "(disabled):crypto"() {
    }
  });

  // node_modules/seedrandom/seedrandom.js
  var require_seedrandom = __commonJS({
    "node_modules/seedrandom/seedrandom.js"(exports, module) {
      (function(global, pool, math2) {
        var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
        function seedrandom2(seed, options, callback) {
          var key = [];
          options = options == true ? { entropy: true } : options || {};
          var shortseed = mixkey(flatten3(
            options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
            3
          ), key);
          var arc4 = new ARC4(key);
          var prng = function() {
            var n = arc4.g(chunks), d = startdenom, x = 0;
            while (n < significance) {
              n = (n + x) * width;
              d *= width;
              x = arc4.g(1);
            }
            while (n >= overflow) {
              n /= 2;
              d /= 2;
              x >>>= 1;
            }
            return (n + x) / d;
          };
          prng.int32 = function() {
            return arc4.g(4) | 0;
          };
          prng.quick = function() {
            return arc4.g(4) / 4294967296;
          };
          prng.double = prng;
          mixkey(tostring(arc4.S), pool);
          return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
            if (state) {
              if (state.S) {
                copy(state, arc4);
              }
              prng2.state = function() {
                return copy(arc4, {});
              };
            }
            if (is_math_call) {
              math2[rngname] = prng2;
              return seed2;
            } else
              return prng2;
          })(
            prng,
            shortseed,
            "global" in options ? options.global : this == math2,
            options.state
          );
        }
        function ARC4(key) {
          var t, keylen = key.length, me = this, i3 = 0, j = me.i = me.j = 0, s = me.S = [];
          if (!keylen) {
            key = [keylen++];
          }
          while (i3 < width) {
            s[i3] = i3++;
          }
          for (i3 = 0; i3 < width; i3++) {
            s[i3] = s[j = mask & j + key[i3 % keylen] + (t = s[i3])];
            s[j] = t;
          }
          (me.g = function(count2) {
            var t2, r = 0, i4 = me.i, j2 = me.j, s2 = me.S;
            while (count2--) {
              t2 = s2[i4 = mask & i4 + 1];
              r = r * width + s2[mask & (s2[i4] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
            }
            me.i = i4;
            me.j = j2;
            return r;
          })(width);
        }
        function copy(f, t) {
          t.i = f.i;
          t.j = f.j;
          t.S = f.S.slice();
          return t;
        }
        ;
        function flatten3(obj, depth) {
          var result = [], typ = typeof obj, prop;
          if (depth && typ == "object") {
            for (prop in obj) {
              try {
                result.push(flatten3(obj[prop], depth - 1));
              } catch (e3) {
              }
            }
          }
          return result.length ? result : typ == "string" ? obj : obj + "\0";
        }
        function mixkey(seed, key) {
          var stringseed = seed + "", smear, j = 0;
          while (j < stringseed.length) {
            key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
          }
          return tostring(key);
        }
        function autoseed() {
          try {
            var out;
            if (nodecrypto && (out = nodecrypto.randomBytes)) {
              out = out(width);
            } else {
              out = new Uint8Array(width);
              (global.crypto || global.msCrypto).getRandomValues(out);
            }
            return tostring(out);
          } catch (e3) {
            var browser = global.navigator, plugins = browser && browser.plugins;
            return [+/* @__PURE__ */ new Date(), global, plugins, global.screen, tostring(pool)];
          }
        }
        function tostring(a) {
          return String.fromCharCode.apply(0, a);
        }
        mixkey(math2.random(), pool);
        if (typeof module == "object" && module.exports) {
          module.exports = seedrandom2;
          try {
            nodecrypto = require_crypto();
          } catch (ex) {
          }
        } else if (typeof define == "function" && define.amd) {
          define(function() {
            return seedrandom2;
          });
        } else {
          math2["seed" + rngname] = seedrandom2;
        }
      })(
        // global: `self` in browsers (including strict mode and web workers),
        // otherwise `this` in Node and other environments
        typeof self !== "undefined" ? self : exports,
        [],
        // pool: entropy pool starts empty
        Math
        // math: package containing random, pow, and seedrandom
      );
    }
  });

  // node_modules/seedrandom/index.js
  var require_seedrandom2 = __commonJS({
    "node_modules/seedrandom/index.js"(exports, module) {
      var alea = require_alea();
      var xor128 = require_xor128();
      var xorwow = require_xorwow();
      var xorshift7 = require_xorshift7();
      var xor4096 = require_xor4096();
      var tychei = require_tychei();
      var sr = require_seedrandom();
      sr.alea = alea;
      sr.xor128 = xor128;
      sr.xorwow = xorwow;
      sr.xorshift7 = xorshift7;
      sr.xor4096 = xor4096;
      sr.tychei = tychei;
      module.exports = sr;
    }
  });

  // node_modules/@viz-js/viz/lib/viz-standalone.mjs
  var A = function() {
    let A2 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
    var I2, g2 = A2;
    g2.ready = new Promise((A3, g3) => {
      I2 = A3;
    });
    var C2, Q3, B2, E2, D2, w2, i3, o2, G2, M = (A3) => console.log(A3);
    function R(A3) {
      throw A3;
    }
    function F() {
      var A3 = G2.buffer;
      Q3 = new Int8Array(A3), B2 = new Int16Array(A3), D2 = new Uint8Array(A3), E2 = new Int32Array(A3), w2 = new Uint32Array(A3), i3 = new Float32Array(A3), o2 = new Float64Array(A3);
    }
    g2.agerrMessages = [], g2.stderrMessages = [], C2 = (A3) => g2.stderrMessages.push(A3);
    var y2 = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0, K = (A3, I3, g3) => {
      for (var C3 = I3 + g3, Q4 = I3; A3[Q4] && !(Q4 >= C3); )
        ++Q4;
      if (Q4 - I3 > 16 && A3.buffer && y2)
        return y2.decode(A3.subarray(I3, Q4));
      for (var B3 = ""; I3 < Q4; ) {
        var E3 = A3[I3++];
        if (128 & E3) {
          var D3 = 63 & A3[I3++];
          if (192 != (224 & E3)) {
            var w3 = 63 & A3[I3++];
            if ((E3 = 224 == (240 & E3) ? (15 & E3) << 12 | D3 << 6 | w3 : (7 & E3) << 18 | D3 << 12 | w3 << 6 | 63 & A3[I3++]) < 65536)
              B3 += String.fromCharCode(E3);
            else {
              var i4 = E3 - 65536;
              B3 += String.fromCharCode(55296 | i4 >> 10, 56320 | 1023 & i4);
            }
          } else
            B3 += String.fromCharCode((31 & E3) << 6 | D3);
        } else
          B3 += String.fromCharCode(E3);
      }
      return B3;
    }, h = (A3, I3) => A3 ? K(D2, A3, I3) : "";
    function N(A3) {
      this.excPtr = A3, this.ptr = A3 - 24, this.set_type = function(A4) {
        w2[this.ptr + 4 >> 2] = A4;
      }, this.get_type = function() {
        return w2[this.ptr + 4 >> 2];
      }, this.set_destructor = function(A4) {
        w2[this.ptr + 8 >> 2] = A4;
      }, this.get_destructor = function() {
        return w2[this.ptr + 8 >> 2];
      }, this.set_caught = function(A4) {
        A4 = A4 ? 1 : 0, Q3[this.ptr + 12 >> 0] = A4;
      }, this.get_caught = function() {
        return 0 != Q3[this.ptr + 12 >> 0];
      }, this.set_rethrown = function(A4) {
        A4 = A4 ? 1 : 0, Q3[this.ptr + 13 >> 0] = A4;
      }, this.get_rethrown = function() {
        return 0 != Q3[this.ptr + 13 >> 0];
      }, this.init = function(A4, I3) {
        this.set_adjusted_ptr(0), this.set_type(A4), this.set_destructor(I3);
      }, this.set_adjusted_ptr = function(A4) {
        w2[this.ptr + 16 >> 2] = A4;
      }, this.get_adjusted_ptr = function() {
        return w2[this.ptr + 16 >> 2];
      }, this.get_exception_ptr = function() {
        if (l(this.get_type()))
          return w2[this.excPtr >> 2];
        var A4 = this.get_adjusted_ptr();
        return 0 !== A4 ? A4 : this.excPtr;
      };
    }
    var s = (A3) => {
      var I3 = (A3 - G2.buffer.byteLength + 65535) / 65536;
      try {
        return G2.grow(I3), F(), 1;
      } catch (A4) {
      }
    }, k = {}, L = () => {
      if (!L.strings) {
        var A3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: "./this.program" };
        for (var I3 in k)
          void 0 === k[I3] ? delete A3[I3] : A3[I3] = k[I3];
        var g3 = [];
        for (var I3 in A3)
          g3.push(`${I3}=${A3[I3]}`);
        L.strings = g3;
      }
      return L.strings;
    };
    var S = [null, [], []], U = (A3, I3) => {
      var g3 = S[A3];
      0 === I3 || 10 === I3 ? ((1 === A3 ? M : C2)(K(g3, 0)), g3.length = 0) : g3.push(I3);
    }, Y = (A3) => A3 % 4 == 0 && (A3 % 100 != 0 || A3 % 400 == 0), J = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], c = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], a = (A3) => {
      for (var I3 = 0, g3 = 0; g3 < A3.length; ++g3) {
        var C3 = A3.charCodeAt(g3);
        C3 <= 127 ? I3++ : C3 <= 2047 ? I3 += 2 : C3 >= 55296 && C3 <= 57343 ? (I3 += 4, ++g3) : I3 += 3;
      }
      return I3;
    }, H = (A3, I3, g3, C3) => {
      if (!(C3 > 0))
        return 0;
      for (var Q4 = g3, B3 = g3 + C3 - 1, E3 = 0; E3 < A3.length; ++E3) {
        var D3 = A3.charCodeAt(E3);
        if (D3 >= 55296 && D3 <= 57343)
          D3 = 65536 + ((1023 & D3) << 10) | 1023 & A3.charCodeAt(++E3);
        if (D3 <= 127) {
          if (g3 >= B3)
            break;
          I3[g3++] = D3;
        } else if (D3 <= 2047) {
          if (g3 + 1 >= B3)
            break;
          I3[g3++] = 192 | D3 >> 6, I3[g3++] = 128 | 63 & D3;
        } else if (D3 <= 65535) {
          if (g3 + 2 >= B3)
            break;
          I3[g3++] = 224 | D3 >> 12, I3[g3++] = 128 | D3 >> 6 & 63, I3[g3++] = 128 | 63 & D3;
        } else {
          if (g3 + 3 >= B3)
            break;
          I3[g3++] = 240 | D3 >> 18, I3[g3++] = 128 | D3 >> 12 & 63, I3[g3++] = 128 | D3 >> 6 & 63, I3[g3++] = 128 | 63 & D3;
        }
      }
      return I3[g3] = 0, g3 - Q4;
    };
    var Z = (A3, I3) => {
      Q3.set(A3, I3);
    }, q = (A3, I3, g3, C3) => {
      var Q4 = w2[C3 + 40 >> 2], B3 = { tm_sec: E2[C3 >> 2], tm_min: E2[C3 + 4 >> 2], tm_hour: E2[C3 + 8 >> 2], tm_mday: E2[C3 + 12 >> 2], tm_mon: E2[C3 + 16 >> 2], tm_year: E2[C3 + 20 >> 2], tm_wday: E2[C3 + 24 >> 2], tm_yday: E2[C3 + 28 >> 2], tm_isdst: E2[C3 + 32 >> 2], tm_gmtoff: E2[C3 + 36 >> 2], tm_zone: Q4 ? h(Q4) : "" }, D3 = h(g3), i4 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" };
      for (var o3 in i4)
        D3 = D3.replace(new RegExp(o3, "g"), i4[o3]);
      var G3 = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], M2 = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
      function R2(A4, I4, g4) {
        for (var C4 = "number" == typeof A4 ? A4.toString() : A4 || ""; C4.length < I4; )
          C4 = g4[0] + C4;
        return C4;
      }
      function F2(A4, I4) {
        return R2(A4, I4, "0");
      }
      function y3(A4, I4) {
        function g4(A5) {
          return A5 < 0 ? -1 : A5 > 0 ? 1 : 0;
        }
        var C4;
        return 0 === (C4 = g4(A4.getFullYear() - I4.getFullYear())) && 0 === (C4 = g4(A4.getMonth() - I4.getMonth())) && (C4 = g4(A4.getDate() - I4.getDate())), C4;
      }
      function K2(A4) {
        switch (A4.getDay()) {
          case 0:
            return new Date(A4.getFullYear() - 1, 11, 29);
          case 1:
            return A4;
          case 2:
            return new Date(A4.getFullYear(), 0, 3);
          case 3:
            return new Date(A4.getFullYear(), 0, 2);
          case 4:
            return new Date(A4.getFullYear(), 0, 1);
          case 5:
            return new Date(A4.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(A4.getFullYear() - 1, 11, 30);
        }
      }
      function N2(A4) {
        var I4 = ((A5, I5) => {
          for (var g5 = new Date(A5.getTime()); I5 > 0; ) {
            var C5 = Y(g5.getFullYear()), Q6 = g5.getMonth(), B5 = (C5 ? J : c)[Q6];
            if (!(I5 > B5 - g5.getDate()))
              return g5.setDate(g5.getDate() + I5), g5;
            I5 -= B5 - g5.getDate() + 1, g5.setDate(1), Q6 < 11 ? g5.setMonth(Q6 + 1) : (g5.setMonth(0), g5.setFullYear(g5.getFullYear() + 1));
          }
          return g5;
        })(new Date(A4.tm_year + 1900, 0, 1), A4.tm_yday), g4 = new Date(I4.getFullYear(), 0, 4), C4 = new Date(I4.getFullYear() + 1, 0, 4), Q5 = K2(g4), B4 = K2(C4);
        return y3(Q5, I4) <= 0 ? y3(B4, I4) <= 0 ? I4.getFullYear() + 1 : I4.getFullYear() : I4.getFullYear() - 1;
      }
      var s2 = { "%a": (A4) => G3[A4.tm_wday].substring(0, 3), "%A": (A4) => G3[A4.tm_wday], "%b": (A4) => M2[A4.tm_mon].substring(0, 3), "%B": (A4) => M2[A4.tm_mon], "%C": (A4) => F2((A4.tm_year + 1900) / 100 | 0, 2), "%d": (A4) => F2(A4.tm_mday, 2), "%e": (A4) => R2(A4.tm_mday, 2, " "), "%g": (A4) => N2(A4).toString().substring(2), "%G": (A4) => N2(A4), "%H": (A4) => F2(A4.tm_hour, 2), "%I": (A4) => {
        var I4 = A4.tm_hour;
        return 0 == I4 ? I4 = 12 : I4 > 12 && (I4 -= 12), F2(I4, 2);
      }, "%j": (A4) => F2(A4.tm_mday + ((A5, I4) => {
        for (var g4 = 0, C4 = 0; C4 <= I4; g4 += A5[C4++])
          ;
        return g4;
      })(Y(A4.tm_year + 1900) ? J : c, A4.tm_mon - 1), 3), "%m": (A4) => F2(A4.tm_mon + 1, 2), "%M": (A4) => F2(A4.tm_min, 2), "%n": () => "\n", "%p": (A4) => A4.tm_hour >= 0 && A4.tm_hour < 12 ? "AM" : "PM", "%S": (A4) => F2(A4.tm_sec, 2), "%t": () => "	", "%u": (A4) => A4.tm_wday || 7, "%U": (A4) => {
        var I4 = A4.tm_yday + 7 - A4.tm_wday;
        return F2(Math.floor(I4 / 7), 2);
      }, "%V": (A4) => {
        var I4 = Math.floor((A4.tm_yday + 7 - (A4.tm_wday + 6) % 7) / 7);
        if ((A4.tm_wday + 371 - A4.tm_yday - 2) % 7 <= 2 && I4++, I4) {
          if (53 == I4) {
            var g4 = (A4.tm_wday + 371 - A4.tm_yday) % 7;
            4 == g4 || 3 == g4 && Y(A4.tm_year) || (I4 = 1);
          }
        } else {
          I4 = 52;
          var C4 = (A4.tm_wday + 7 - A4.tm_yday - 1) % 7;
          (4 == C4 || 5 == C4 && Y(A4.tm_year % 400 - 1)) && I4++;
        }
        return F2(I4, 2);
      }, "%w": (A4) => A4.tm_wday, "%W": (A4) => {
        var I4 = A4.tm_yday + 7 - (A4.tm_wday + 6) % 7;
        return F2(Math.floor(I4 / 7), 2);
      }, "%y": (A4) => (A4.tm_year + 1900).toString().substring(2), "%Y": (A4) => A4.tm_year + 1900, "%z": (A4) => {
        var I4 = A4.tm_gmtoff, g4 = I4 >= 0;
        return I4 = (I4 = Math.abs(I4) / 60) / 60 * 100 + I4 % 60, (g4 ? "+" : "-") + String("0000" + I4).slice(-4);
      }, "%Z": (A4) => A4.tm_zone, "%%": () => "%" };
      for (var o3 in D3 = D3.replace(/%%/g, "\0\0"), s2)
        D3.includes(o3) && (D3 = D3.replace(new RegExp(o3, "g"), s2[o3](B3)));
      D3 = D3.replace(/\0\0/g, "%");
      var k2, L2, S2, U2, q2, d2, W2 = (k2 = D3, L2 = false, U2 = S2 > 0 ? S2 : a(k2) + 1, q2 = new Array(U2), d2 = H(k2, q2, 0, q2.length), L2 && (q2.length = d2), q2);
      return W2.length > I3 ? 0 : (Z(W2, A3), W2.length - 1);
    }, d = (A3, I3, g3) => H(A3, D2, I3, g3);
    var W = { a: (A3, I3, g3, C3) => {
      R(`Assertion failed: ${h(A3)}, at: ` + [I3 ? h(I3) : "unknown filename", g3, C3 ? h(C3) : "unknown function"]);
    }, c: (A3, I3, g3) => {
      throw new N(A3).init(I3, g3), A3;
    }, l: (A3, I3, g3, C3) => {
    }, j: function(A3, I3, g3) {
      return 0;
    }, w: (A3, I3) => {
    }, x: function(A3, I3, g3) {
      return 0;
    }, u: (A3, I3, g3, C3) => {
    }, e: function(A3, I3, g3, C3) {
    }, v: (A3, I3) => {
    }, r: (A3, I3, g3) => {
    }, k: () => true, m: function(A3, I3, g3, C3, Q4, B3, E3, D3) {
      return -52;
    }, n: function(A3, I3, g3, C3, Q4, B3, E3) {
    }, b: () => {
      R("");
    }, f: () => Date.now(), q: (A3) => {
      var I3 = D2.length, g3 = 2147483648;
      if ((A3 >>>= 0) > g3)
        return false;
      for (var C3, Q4, B3 = 1; B3 <= 4; B3 *= 2) {
        var E3 = I3 * (1 + 0.2 / B3);
        E3 = Math.min(E3, A3 + 100663296);
        var w3 = Math.min(g3, (C3 = Math.max(A3, E3)) + ((Q4 = 65536) - C3 % Q4) % Q4);
        if (s(w3))
          return true;
      }
      return false;
    }, s: (A3, I3) => {
      var g3 = 0;
      return L().forEach((C3, B3) => {
        var E3 = I3 + g3;
        w2[A3 + 4 * B3 >> 2] = E3, ((A4, I4) => {
          for (var g4 = 0; g4 < A4.length; ++g4)
            Q3[I4++ >> 0] = A4.charCodeAt(g4);
          Q3[I4 >> 0] = 0;
        })(C3, E3), g3 += C3.length + 1;
      }), 0;
    }, t: (A3, I3) => {
      var g3 = L();
      w2[A3 >> 2] = g3.length;
      var C3 = 0;
      return g3.forEach((A4) => C3 += A4.length + 1), w2[I3 >> 2] = C3, 0;
    }, g: (A3) => {
      throw `exit(${A3})`;
    }, d: (A3) => 52, h: (A3, I3, g3, C3) => 52, o: function(A3, I3, g3, C3, Q4) {
      return 70;
    }, i: (A3, I3, g3, C3) => {
      for (var Q4 = 0, B3 = 0; B3 < g3; B3++) {
        var E3 = w2[I3 >> 2], i4 = w2[I3 + 4 >> 2];
        I3 += 8;
        for (var o3 = 0; o3 < i4; o3++)
          U(A3, D2[E3 + o3]);
        Q4 += i4;
      }
      return w2[C3 >> 2] = Q4, 0;
    }, p: (A3, I3, g3, C3, Q4) => q(A3, I3, g3, C3), y: function(A3) {
      return g2.agerrMessages.push(h(A3)), 0;
    } };
    g2.ccall = (A3, I3, C3, Q4, B3) => {
      var E3 = { string: (A4) => {
        var I4 = 0;
        return null != A4 && 0 !== A4 && (I4 = ((A5) => {
          var I5 = a(A5) + 1, g3 = O(I5);
          return d(A5, g3, I5), g3;
        })(A4)), I4;
      }, array: (A4) => {
        var I4 = O(A4.length);
        return Z(A4, I4), I4;
      } };
      var D3 = ((A4) => g2["_" + A4])(A3), w3 = [], i4 = 0;
      if (Q4)
        for (var o3 = 0; o3 < Q4.length; o3++) {
          var G3 = E3[C3[o3]];
          G3 ? (0 === i4 && (i4 = b()), w3[o3] = G3(Q4[o3])) : w3[o3] = Q4[o3];
        }
      var M2 = D3.apply(null, w3);
      return M2 = function(A4) {
        return 0 !== i4 && x(i4), function(A5) {
          return "string" === I3 ? h(A5) : "boolean" === I3 ? Boolean(A5) : A5;
        }(A4);
      }(M2);
    }, g2.getValue = function(A3) {
      let I3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "i8";
      switch (I3.endsWith("*") && (I3 = "*"), I3) {
        case "i1":
        case "i8":
          return Q3[A3 >> 0];
        case "i16":
          return B2[A3 >> 1];
        case "i32":
          return E2[A3 >> 2];
        case "i64":
          R("to do getValue(i64) use WASM_BIGINT");
        case "float":
          return i3[A3 >> 2];
        case "double":
          return o2[A3 >> 3];
        case "*":
          return w2[A3 >> 2];
        default:
          R(`invalid type for getValue: ${I3}`);
      }
    }, g2.UTF8ToString = h, g2.stringToUTF8 = d, g2.lengthBytesUTF8 = a;
    var b, x, O, l, m = { a: W };
    return WebAssembly.instantiate(g2.wasm, m).then((A3) => {
      var C3 = A3.instance.exports;
      g2._viz_set_y_invert = C3.B, g2._viz_set_reduce = C3.C, g2._viz_get_graphviz_version = C3.D, g2._viz_get_plugin_list = C3.E, g2._viz_create_graph = C3.F, g2._viz_read_one_graph = C3.G, g2._viz_string_dup = C3.H, g2._viz_string_dup_html = C3.I, g2._viz_string_free = C3.J, g2._viz_add_node = C3.K, g2._viz_add_edge = C3.L, g2._viz_add_subgraph = C3.M, g2._viz_set_default_graph_attribute = C3.N, g2._viz_set_default_node_attribute = C3.O, g2._viz_set_default_edge_attribute = C3.P, g2._viz_set_attribute = C3.Q, g2._viz_free_graph = C3.R, g2._viz_render_graph = C3.S, g2._free = C3.U, g2._malloc = C3.V, b = C3.W, x = C3.X, O = C3.Y, l = C3.Z, C3.T, G2 = C3.z, F(), function(A4) {
        A4.A();
      }(C3), I2(g2);
    }), A2.ready;
  };
  var I = [[/^Error: (.*)/, "error"], [/^Warning: (.*)/, "warning"]];
  function g(A2) {
    return function(A3) {
      const I2 = [];
      let g2;
      for (let C2 = 0; C2 < A3.length; C2++)
        "Error" == A3[C2] && ": " == A3[C2 + 1] ? (g2 = "error", C2 += 1) : "Warning" == A3[C2] && ": " == A3[C2 + 1] ? (g2 = "warning", C2 += 1) : I2.push({ message: A3[C2].trimEnd(), level: g2 });
      return I2;
    }(A2.agerrMessages).concat(A2.stderrMessages.map((A3) => {
      for (let g2 = 0; g2 < I.length; g2++) {
        const [C2, Q3] = I[g2];
        let B2;
        if (null !== (B2 = C2.exec(A3)))
          return { message: B2[1].trimEnd(), level: Q3 };
      }
      return { message: A3.trimEnd() };
    }));
  }
  function C(A2, I2, g2, C2) {
    let Q3;
    if (Q3 = "object" == typeof g2 && "html" in g2 ? A2.ccall("viz_string_dup_html", "number", ["number", "string"], [I2, String(g2.html)]) : A2.ccall("viz_string_dup", "number", ["number", "string"], [I2, String(g2)]), 0 == Q3)
      throw new Error("couldn't dup string");
    C2(Q3), A2.ccall("viz_string_free", "number", ["number", "number"], [I2, Q3]);
  }
  function Q(A2, I2, g2) {
    if (g2.graphAttributes)
      for (const [Q3, B2] of Object.entries(g2.graphAttributes))
        C(A2, I2, B2, (g3) => {
          A2.ccall("viz_set_default_graph_attribute", "number", ["number", "string", "number"], [I2, Q3, g3]);
        });
    if (g2.nodeAttributes)
      for (const [Q3, B2] of Object.entries(g2.nodeAttributes))
        C(A2, I2, B2, (g3) => {
          A2.ccall("viz_set_default_node_attribute", "number", ["number", "string", "number"], [I2, Q3, g3]);
        });
    if (g2.edgeAttributes)
      for (const [Q3, B2] of Object.entries(g2.edgeAttributes))
        C(A2, I2, B2, (g3) => {
          A2.ccall("viz_set_default_edge_attribute", "number", ["number", "string", "number"], [I2, Q3, g3]);
        });
  }
  function B(A2, I2, g2, Q3) {
    for (const [B2, E2] of Object.entries(Q3))
      C(A2, I2, E2, (I3) => {
        A2.ccall("viz_set_attribute", "number", ["number", "string", "number"], [g2, B2, I3]);
      });
  }
  function E(A2, I2, g2) {
    Q(A2, I2, g2), g2.nodes && g2.nodes.forEach((g3) => {
      const C2 = A2.ccall("viz_add_node", "number", ["number", "string"], [I2, String(g3.name)]);
      g3.attributes && B(A2, I2, C2, g3.attributes);
    }), g2.edges && g2.edges.forEach((g3) => {
      const C2 = A2.ccall("viz_add_edge", "number", ["number", "string", "string"], [I2, String(g3.tail), String(g3.head)]);
      g3.attributes && B(A2, I2, C2, g3.attributes);
    }), g2.subgraphs && g2.subgraphs.forEach((g3) => {
      const C2 = A2.ccall("viz_add_subgraph", "number", ["number", "string"], [I2, String(g3.name)]);
      E(A2, C2, g3);
    });
  }
  function D(A2, I2, g2) {
    const C2 = A2.ccall("viz_create_graph", "number", ["string", "number", "number"], [I2.name, void 0 === I2.directed || I2.directed, void 0 !== I2.strict && I2.strict]);
    return E(A2, C2, I2), C2;
  }
  function w(A2, I2) {
    const g2 = A2.ccall("viz_get_plugin_list", "number", ["string"], [I2]);
    if (0 == g2)
      throw new Error(`couldn't get plugin list: ${I2}`);
    const C2 = [];
    let Q3, B2 = g2;
    for (; Q3 = A2.getValue(B2, "*"); )
      C2.push(A2.UTF8ToString(Q3)), A2.ccall("free", "number", ["number"], [Q3]), B2 += 4;
    return A2.ccall("free", "number", ["number"], [g2]), C2;
  }
  var i = class {
    constructor(A2) {
      this.module = A2;
    }
    get graphvizVersion() {
      return function(A2) {
        const I2 = A2.ccall("viz_get_graphviz_version", "number", [], []);
        return A2.UTF8ToString(I2);
      }(this.module);
    }
    get formats() {
      return w(this.module, "device");
    }
    get engines() {
      return w(this.module, "layout");
    }
    render(A2) {
      let I2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return function(A3, I3, C2) {
        let B2, E2;
        try {
          if (A3.agerrMessages = [], A3.stderrMessages = [], "string" == typeof I3)
            B2 = function(A4, I4, g2) {
              let C3;
              try {
                const g3 = A4.lengthBytesUTF8(I4);
                return C3 = A4.ccall("malloc", "number", ["number"], [g3 + 1]), A4.stringToUTF8(I4, C3, g3 + 1), A4.ccall("viz_read_one_graph", "number", ["number"], [C3]);
              } finally {
                C3 && A4.ccall("free", "number", ["number"], [C3]);
              }
            }(A3, I3);
          else {
            if ("object" != typeof I3)
              throw new Error("input must be a string or object");
            B2 = D(A3, I3);
          }
          return 0 === B2 ? { status: "failure", output: void 0, errors: g(A3) } : (Q(A3, B2, C2), A3.ccall("viz_set_y_invert", "number", ["number"], [C2.yInvert ? 1 : 0]), A3.ccall("viz_set_reduce", "number", ["number"], [C2.reduce ? 1 : 0]), E2 = A3.ccall("viz_render_graph", "number", ["number", "string", "string"], [B2, C2.format, C2.engine]), 0 === E2 ? { status: "failure", output: void 0, errors: g(A3) } : { status: "success", output: A3.UTF8ToString(E2), errors: g(A3) });
        } catch (I4) {
          if (/^exit\(\d+\)/.test(I4))
            return { status: "failure", output: void 0, errors: g(A3) };
          throw I4;
        } finally {
          B2 && A3.ccall("viz_free_graph", "number", ["number"], [B2]), E2 && A3.ccall("free", "number", ["number"], [E2]);
        }
      }(this.module, A2, { format: "dot", engine: "dot", ...I2 });
    }
    renderString(A2) {
      let I2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const g2 = this.render(A2, I2);
      if ("success" !== g2.status)
        throw new Error(g2.errors.find((A3) => "error" == A3.level)?.message || "render failed");
      return g2.output;
    }
    renderSVGElement(A2) {
      let I2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const g2 = this.renderString(A2, { ...I2, format: "svg" });
      return new DOMParser().parseFromString(g2, "image/svg+xml").documentElement;
    }
    renderJSON(A2) {
      let I2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      const g2 = this.renderString(A2, { ...I2, format: "json" });
      return JSON.parse(g2);
    }
  };
  var o = "AGFzbQEAAAAB/wZxYAJ/fwF/YAF/AGABfwF/YAN/f38Bf2ACf38AYAN/f38AYAR/f39/AX9gBX9/f39/AX9gBH9/f38AYAZ/f39/f38Bf2AFf39/f38AYAAAYAABf2AGf39/f39/AGAIf39/f39/f38Bf2AHf39/f39/fwF/YAd/f39/f39/AGACf38BfGABfAF8YAN/f38BfGABfwF8YAd/f39/fHx/AGAEfHx8fwF8YAJ8fAF8YAV/fn5+fgBgA39/fABgA39/fgF/YAJ/fABgCX9/f39/f39/fwBgA398fABgBH9/fX0Bf2AKf39/f39/f39/fwF/YAN/fn8BfmADfHx8AXxgA39/fgBgAAF8YAR/f39/AXxgAn98AX9gBH9/f38BfmAFf39/f34Bf2AEf35+fwBgBH9/f3wBf2ABfwF+YAR/f3x/AGACfX0BfWAIf39/f39/f38AYAV/f39/fAF/YAt/f39/f39/f39/fwF/YAV/f35/fwBgBH9/fH8Bf2ACf34AYAN/f3wBf2ACfH8BfGADfHx/AXxgA399fwBgAn9+AX9gAnx/AX9gA398fwBgBn98fHx8fAF8YAV/f3x/fwF/YAx/f39/f39/f39/f38Bf2ACf38BfmAGf39/fH9/AGAKf3x/f39/f39/fwBgBn9/f39+fwF/YA9/f39/f39/f39/f39/f38AYAp/f39/f39/f39/AGAGf3x/f39/AX9gB39/f39/fn4Bf2AGf39/f35+AX9gBH9/fHwBfGAFf398f38AYAl/f39/f39/f38Bf2AEf398fABgBn9/f3x/fwF/YAV/f39/fABgBH9/f30AYAJ/fQF/YAR+fn5+AX9gCH9/f398fHx/AGACfn8Bf2ABfAF/YAR/f398AGAGf31/f39/AGAEf399fwBgAn5+AX1gAn99AGAEf39/fgF+YAN8f38AYAZ8fHx/f38AYAR/fHx8AGACfn4BfGAFf39/fH8AYAZ/f398fH8AYAd/f398fH9/AGAIf39/f39/fH8AYAR/fH9/AGAEf3x/fwF/YAV/f3x8fABgBX9/f39/AXxgA3x8fAF/YAd/f39/fH9/AX9gBX9/fX9/AGADf39/AX1gA35+fgF/YAN/fn8Bf2AAAX5gAX8BfWADf35+AX9gBnx8f3x8fwBgBHx8fHwBfGAEf31/fwBgB398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jwNB8/sAQeUBQd4dEAAAC0GLxQFB8/sAQegBQd4dEAAAC8cKAgV/EX4jAEHgAGsiBSQAIARC////////P4MhDCACIASFQoCAgICAgICAgH+DIQogAkL///////8/gyINQiCIIQ4gBEIwiKdB//8BcSEHAkACQCACQjCIp0H//wFxIglB//8Ba0GCgH5PBEAgB0H//wFrQYGAfksNAQsgAVAgAkL///////////8AgyILQoCAgICAgMD//wBUIAtCgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhCgwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEKIAMhAQwCCyABIAtCgICAgICAwP//AIWEUARAIAIgA4RQBEBCgICAgICA4P//ACEKQgAhAQwDCyAKQoCAgICAgMD//wCEIQpCACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEAgASALhCEZQgAhASAZUARAQoCAgICAgOD//wAhCgwDCyAKQoCAgICAgMD//wCEIQoMAgsgASALhFAEQEIAIQEMAgsgAiADhFAEQEIAIQEMAgsgC0L///////8/WARAIAVB0ABqIAEgDSABIA0gDVAiBht5IAZBBnStfKciBkEPaxCrAUEQIAZrIQYgBSkDWCINQiCIIQ4gBSkDUCEBCyACQv///////z9WDQAgBUFAayADIAwgAyAMIAxQIggbeSAIQQZ0rXynIghBD2sQqwEgBiAIa0EQaiEGIAUpA0ghDCAFKQNAIQMLIANCD4YiC0KAgP7/D4MiAiABQiCIIgR+IhAgC0IgiCITIAFC/////w+DIgF+fCIPQiCGIhEgASACfnwiCyARVK0gAiANQv////8PgyINfiIVIAQgE358IhEgDEIPhiISIANCMYiEQv////8PgyIDIAF+fCIUIA8gEFStQiCGIA9CIIiEfCIPIAIgDkKAgASEIgx+IhYgDSATfnwiDiASQiCIQoCAgIAIhCICIAF+fCIQIAMgBH58IhJCIIZ8Ihd8IQEgByAJaiAGakH//wBrIQYCQCACIAR+IhggDCATfnwiBCAYVK0gBCAEIAMgDX58IgRWrXwgAiAMfnwgBCAEIBEgFVStIBEgFFatfHwiBFatfCADIAx+IgMgAiAN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AjAQuQINACAAKAIsEHINBCAAIAAoAiwQuQINACAAKAI0EHINBSAAIAAoAjQQuQINACAALQAYQSBxBEBBACECQeCLCyAANgIAIAAQ4AEiAQRAIAAgARD0DSAAIAEoAgAQ0wELAkAgAEEAEKkCIgFFDQBBASECIAAgASgCCBC5Ag0AIAAgASgCDBC5Ag0AIAAgASgCEBC5Ag0AIAAgASgCABDTAUEAIQILIAINAQsgABDvByAAQQAgACkDCBDzBwJAIAMEQCADIAAQuw0gABAZDAELA0AgACgCQCIBKAIoIgIEQCACKAIAIQMgACgCQCICKAIoIgFFDQECQCADIAEoAgBGBEAgAiABKAIINgIoDAELA0AgASICKAIIIgEoAgAgA0cNAAsgAiABKAIINgIIIAIhAQsgARAZDAELCyABKAIIIAEoAgAoAhQRAQAgACAAENAFELkCDQEgACgCQCEGIAAQGSAGEBkLCw8LQa2PA0H8twFB6wBBnpABEAAAC0HujgNB/LcBQe0AQZ6QARAAAAtBwo8DQfy3AUHwAEGekAEQAAALQYSPA0H8twFB8gBBnpABEAAAC0HXjgNB/LcBQfUAQZ6QARAAAAspACAAIAEQNyIAIAFFckUEQEHdwQNBDkEBQejeBigCABBGGhAvAAsgAAteAQF/IwBBIGsiAiQAIAIgACgCADYCCCACIAAoAgQ2AgwgAiAAKAIINgIQIABCADcCBCACIAArAxA5AxggACABEMgBIAEgAkEIaiIAEMgBIABBBHIQ5QEgAkEgaiQACzcBAX8gACgCBCIBBEAgASEAA0AgACIBKAIAIgANAAsgAQ8LA0AgACAAKAIIIgAoAgBHDQALIAALBABBAAsFABABAAt1AQF+IAAgASAEfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IAEgAn4gA0L/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwALigYBDn8CQAJAAkACQCABKAIIRQRAIANFDQQgAUHAADYCCCABQQY6AAQgAUGAAiABKAIQKAIAEQIAIgQ2AgAgBA0BIAFBADYCCEEADwsgACACENoHIg1BACABKAIIIglrcSEKIA0gCUEBayIEcSEFIARBAnYhCyAB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AC0AD0EBajoADyAAECVBEEkNAUGypANB8/sAQaECQfeuARAAAAsgACgCACACaiABOgAAIAAgACgCBEEBajYCBAsLEQAgACABIAAoAgAoAhwRAAALGAAgAC0AAEEgcUUEQCABIAIgABDIBxoLCyABAn8gABBAQQFqIgEQOCICRQRAQQAPCyACIAAgARAjCykBAX5BiJALQYiQCykDAEKt/tXk1IX9qNgAfkIBfCIANwMAIABCIYinCxAAIABBIEYgAEEJa0EFSXILqAMCBX8BfiAAvUL///////////8Ag0KBgICAgICA+P8AVCABvUL///////////8Ag0KAgICAgICA+P8AWHFFBEAgACABoA8LIAG9IgdCIIinIgJBgIDA/wNrIAenIgVyRQRAIAAQwgUPCyACQR52QQJxIgYgAL0iB0I/iKdyIQMCQCAHQiCIp0H/////B3EiBCAHp3JFBEACQAJAIANBAmsOAgABAwtEGC1EVPshCUAPC0QYLURU+yEJwA8LIAJB/////wdxIgIgBXJFBEBEGC1EVPsh+T8gAKYPCwJAIAJBgIDA/wdGBEAgBEGAgMD/B0cNASADQQN0QcC1BmorAwAPCyAEQYCAwP8HRyACQYCAgCBqIARPcUUEQEQYLURU+yH5PyAApg8LAnwgBgRARAAAAAAAAAAAIARBgICAIGogAkkNARoLIAAgAaOZEMIFCyEAAkACQAJAIAMOAwQAAQILIACaDwtEGC1EVPshCUAgAEQHXBQzJqahvKChDwsgAEQHXBQzJqahvKBEGC1EVPshCcCgDwsgA0EDdEHgtQZqKwMAIQALIAALFQAgAARAIABCADcCACAAQgA3AggLC+sPAwd8CH8CfkQAAAAAAADwPyEDAkACQAJAIAG9IhFCIIinIg9B/////wdxIgkgEaciDHJFDQAgAL0iEkIgiKchCiASpyIQRSAKQYCAwP8DRnENACAKQf////8HcSILQYCAwP8HSyALQYCAwP8HRiAQQQBHcXIgCUGAgMD/B0tyRSAMRSAJQYCAwP8HR3JxRQRAIAAgAaAPCwJAAkACQAJAAkACf0EAIBJCAFkNABpBAiAJQf///5kESw0AGkEAIAlBgIDA/wNJDQAaIAlBFHYhDSAJQYCAgIoESQ0BQQAgDEGzCCANayIOdiINIA50IAxHDQAaQQIgDUEB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ABA0IAEQNEcNAAJAAkACQCABKAIAQQNxDgIAAQILA0AgACABRiIDDQMgASgCOCIBDQALDAILAn8gACABKQMIIgIQ5gMiAUEBckUEQAJAIAAQNCIBIABGDQAgASACEOYDIgFFDQAgACABQQEQehogAQwCC0EAIAAoAkAiASgCCEEBIAIgASgCACgCCBEaAEUNARogACAAIAIgAEEBEPoHENUNIgEQ1A0gACABENMNCyABC0EARw8LIAAgAUEAELoCQQBHIQMLIAMLoQEBAn8CQCAAECZFIAIgAWtBBUhyDQAgASACEJ4FIAJBBGshBCAAEEMiAiAAECZqIQUCQANAAkAgAiwAACEAIAEgBE8NACAAQQBMIABB/wBOckUEQCABKAIAIAIsAABHDQMLIAFBBGohASACIAUgAmtBAUpqIQIMAQsLIABBAEwgAEH/AE5yDQEgAiwAACAEKAIAQQFrSw0BCyADQQQ2AgALC1cBAX8jAEEQayICJAAgABDBAQRAIAAgACgCACAAEN0CEKYFCyAAIAEoAgg2AgggACABKQIANwIAIAFBABDAASACQQA6AA8gASACQQ9qEL8BIAJBEGokAAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAvLCQIEfwZ+IwBB8ABrIgYkACAEQv///////////wCDIQkCQAJAIAFQIgUgAkL///////////8AgyIKQoCAgICAgMD//wB9QoCAgICAgMCAgH9UIApQG0UEQCADQgBSIAlCgICAgICAwP//AH0iC0KAgICAgIDAgIB/ViALQoCAgICAgMCAgH9RGw0BCyAFIApCgICAgICAwP//AFQgCkKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEEIAEhAwwCCyADUCAJQoCAgICAgMD//wBUIAlCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhBAwCCyABIApCgICAgICAwP//AIWEUARAQoCAgICAgOD//wAgAiABIAOFIAIgBIVCgICAgICAgICAf4WEUCIFGyEEQgAgASAFGyEDDAILIAMgCUKAgICAgIDA//8AhYRQDQEgASAKhFAEQCADIAmEQgBSDQIgASADgyEDIAIgBIMhBAwCCyADIAmEUEUNACABIQMgAiEEDAELIAMgASABIANUIAkgClYgCSAKURsiCBshCiAEIAIgCBsiC0L///////8/gyEJIAIgBCAIGyICQjCIp0H//wFxIQcgC0IwiKdB//8BcSIFRQRAIAZB4ABqIAogCSAKIAkgCVAiBRt5IAVBBnStfKciBUEPaxCrASAGKQNoIQkgBikDYCEKQRAgBWshBQsgASADIAgbIQMgAkL///////8/gyEEIAdFBEAgBkHQAGogAyAEIAMgBCAEUCIHG3kgB0EGdK18pyIHQQ9rEKsBQRAgB2shByAGKQNYIQQgBikDUCEDCyAEQgOGIANCPYiEQoCAgICAgIAEhCEBIAlCA4YgCkI9iIQhDiACIAuFIQ0CfiADQgOGIgIgBSAHRg0AGiAFIAdrIgdB/wBLBEBCACEBQgEMAQsgBkFAayACIAFBgAEgB2sQqwEgBkEwaiACIAEgBxCYAyAGKQM4IQEgBikDMCAGKQNAIAYpA0iEQgBSrYQLIQkgDkKAgICAgICABIQhDCAKQgOGIQoCQCANQgBTBEBCACEDQgAhBCAJIAqFIAEgDIWEUA0CIAogCX0hAiAMIAF9IAkgClatfSIEQv////////8DVg0BIAZBIGogAiAEIAIgBCAEUCIHG3kgB0EGdK18p0EMayIHEKsBIAUgB2shBSAGKQMoIQQgBikDICECDAELIAkgCnwiAiAJVK0gASAMfHwiBEKAgICAgICACINQDQAgCUIBgyAEQj+GIAJCAYiEhCECIAVBAWohBSAEQgGIIQQLIAtCgICAgICAgICAf4MhASAFQf//AU4EQCABQoCAgICAgMD//wCEIQRCACEDDAELQQAhBwJAIAVBAEoEQCAFIQcMAQsgBkEQaiACIAQgBUH/AGoQqwEgBiACIARBASAFaxCYAyAGKQMAIAYpAxAgBikDGIRCAFKthCECIAYpAwghBAsgAqdBB3EiBUEES60gBEI9hiACQgOIhCICfCIDIAJUrSAEQgOIQv///////z+DIAetQjCGhCABhHwhBAJAIAVBBEYEQCAEIANCAYMiASADfCIDIAFUrXwhBAwBCyAFRQ0BCwsgACADNwMAIAAgBDcDCCAGQfAAaiQAC28BAX8jAEGAAmsiBSQAIARBgMAEcSACIANMckUEQCAFIAFB/wFx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ADcCUCAHQgA3AmggB0IANwIIIAdBADoABCAHIAI2AhAgB0EANgIAIAdBADYCFCAHQQA2AmAgB0IANwJYIAcgAjYCZCAHQgA3AnAgB0EANgJ4IAcgAjYCfCAHQgA3AhwgB0EAOgAYIAdCADcCMCAHQQA6ACwgByACNgIkIAdCADcCRCAHQUBrQQA6AAAgByACNgI4IAdBADYCKCAHQQA2AjwgByACNgJMIAdCADcCjAEgB0EAOgCIASAHQgE3AoABIAcgAjYClAEgB0IANwKYASAHQQA6AKABIAdCADcCpAEgB0IANwKsASAHQgA3ArQBCyABQQA2AvQCIAEgBzYC4AIgAUEANgLsAiABQQA2AqwCIAFCADcCzAMgAUEhOgDUAyABQQA2AvQBIAFBADYCfCABQQA7AegBIAFCADcCnAMgAUEANgLkASABQgA3A4gDIAFCADcCtAMgAUIANwKkAyABQQA2AqwDIAFBADoAkAMgASACNgKwAyABQQA2AsQDIAFCADcCvAMgASACNgLIA0EAIQcgAUGSAzYClAIgAUGhAzYC/AEgAUEANgKQAiABQoCAgIAQNwKIAiAEBEADQCAEIAdqIR8gB0EBaiEHIB8tAAANAAsgByABKAIMEQIAIgIEQCACIAQgBxAjGgsgASACNgLkAQsgAUEANgLkAiABQZQBaiABQZABakEAENMHGiABQgA3AwAgAUE0akEAQcAAEDoaIAFCADcDgAEgAUEANgJ4IAFCADcDiAEgAUIANwKUAyABQgA3AiQgAUIANwOYAiABQgA3A6ACIAFBADYCqAIgASABKAIIIgI2AhwgASACNgIYIAEgATYCdCABQbgCakEAQSYQOhogAUEANgL8AiABQQA2AvACIAFBADYC6AIgAUEANgK0AiABQQE6ALACIAFBADYC+AEgAUEAOwHkAyABQgA3A9gDIAFCADcC7AEgAUHoA2pBAEEoEDoaQfLNARDkByECIAFCADcDkAQgAUKAgIAENwOIBCABQYCAoJYENgKEBCABIAI2AoAEIAFCADcDmAQgAUHLzQEQ5Ac2ApwEAkAgBEUNACABKALkAQ0AIAEQow0MAgsgAUGgjgY2AuABIAEMAwsgAUEANgLgAiABKAIsIAEoAhQRAQAgASgChAMgASgCFBEBAAwBC0EADAELIAEgASgCFBEBAEEACyIB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GCABIAApAxA3AxAgASAAKQMINwMIIAEgACkDADcDAAJAIAJFDQACQCABKAIEDQAgAigCBCIARQ0AIAEgADYCBAsCQCABKwMQRAAAAAAAAAAAY0UNACACKwMQIgREAAAAAAAAAABmRQ0AIAEgBDkDEAsCQCABKAIADQAgAigCACIARQ0AIAEgADYCAAsgAigCGEH/AHEiAEUNACABIAEoAhggAHI2AhgLIANByIYLKAIAKAKIASIAIAFBASAAKAIAEQMANgIAIANBxIYLKAIANgIEQcSGCyADNgIAIAFBIGokAAuWAQECfyAAEEIiAiABaiIBIAJBAXRBgAggAhsiAyABIANLGyEBIAAQJSEDAkACQAJAAkAgAC0AD0H+AWsOAgABAgsgACgCACACIAFBARCIASECDAILIAFBARAdIgIgACgCACADECMaDAELIAFBARAdIgIgACADECMaIAAgAzYCBAsgAEH+AToADyAAIAE2AgggACACNgIAC8MBAQJ/AkACQCABIAAoAhAiAigCsAEiA0cEQCAAIAEoAhAiACgCsAFHDQELQQBB4/sDQQAQHwwBCyADRQRAIAIgATYCsAEgAigCrAEiAyAAKAKsAUoEQCAAIAM2AqwBCwNAIAFFDQIgASgCECIAIAAvAagBIAIvAagBajsBqAEgACAALwGaASACLwGaAWo7AZoBIAAgACgCnAEgAigCnAFqNgKcASAAKAKwASEBDAALAAtBt8kBQey1AUGxAkGYDxAAAAsLcgECfyMAQSBrIgMkACADQgA3AxggA0IANwMIIANCgICAgICAgPi/fzcDECADIAJB/wBxNgIYIANCADcDACABBEAgA0GA/glBAyABQc/TARDIBAsgACgCiAEiACADQQEgACgCABEDACEEIANBIGokACAEC2kBAX9BhIILKAIAIQECQCAABEBBhIILIAFBAWo2AgAgAQ0BQYCCC0EAEMMHEGY2AgBBnNIBEMMHGg8LIAFBAEwNAEGEggsgAUEBayIANgIAIAANAEGAggsoAgAQwwcaQYCCCygCABAZCwutBAEKfAJAAkAgASsDACIFIAIrAwAiBmEEQCABKwMIIAIrAwhhDQELIAYgAysDACIIYgRAIAIrAwghBwwCCyACKwMIIgcgAysDCGINAQsgACACKQMANwMAIAAgAikDCDcDCCAAIAIp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QKMhBSAAEBshAQNAIAEEQCABKAIQKAKUASIDIAMrAwAgBKE5AwAgAyADKwMIIAWhOQMIIAAgARAcIQEMAQsLIAIgACgCECIBKQMYNwMIIAIgASkDEDcDACAAIAIQvQogAEEBEIYFIAJBEGokAAs8AQF/IAFBAWohASACIQMgACECA0AgAQRAIAIgAysDADkDACABQQFrIQEgAkEIaiECIANBCGohAwwBCwsLPwEBfyABQQFqIQEgAyEEIAAhAwNAIAEEQCADIAQrAwAgAqI5AwAgAUEBayEBIANBCGohAyAEQQhqIQQMAQsLCwwAIAAgASAAEMwCnwsTACAAEJQFKAIAIAAoAgBrQQJ1CwcAIABBEGoLDQAgACgCACABQQJ0agsZACAAEMEBBEAgACABEL4BDwsgACABEMABC2EBAX8jAEEQayICJAAgAiAANgIMAkAgACABRg0AA0AgAiABQQFrIgE2AgggACABTw0BIAIoAgwgAigCCBDpCyACIAIoAgxBAWoiADYCDCACKAIIIQEMAAsACyACQRBqJAALuAEBBH8jAEEQayIIJAACQCAARQ0AIAQoAgwhBiACIAFrIgdBAEoEQCAAIAEgB0ECdiIHEK8HIAdHDQELIAYgAyABa0ECdSIBa0EAIAEgBkgbIgFBAEoEQCAAIAhBBGogASAFEPMLIgUQQyABEK8HIQYgBRBxGiABIAZHDQELIAMgAmsiAUEASgRAIAAgAiABQQJ2IgEQrwcgAUcNAQsgBCgCDBogBEEANgIMIAAhCQsgCEEQaiQAIAkLDgAgACABKAIANgIAIAALqQEBBH8jAEEQayIFJAAgARBAIQIjAEEQayIDJAACQCACQe////8HTQRAAkAgAhClBQRAIAAgAhDAASAAIQQMAQsgA0EIaiAAIAIQ1wNBAWoQ1gMgAygCDBogACADKAIIIgQQ7QEgACADKAIMEOwBIAAgAhC+AQsgBCABIAIQnQIgA0EAOgAHIAIgBGogA0EHahC/ASADQRBqJAAMAQsQ6wEACyAFQRBqJAALCAAgAEH/AXELUAEBfgJAIANBwABxBEAgAiADQUBqrYghAUIAIQIMAQsgA0UNACACQcAAIANrrYYgASADrSIEiIQhASACIASIIQILIAAgATcDACAAIAI3AwgL2wECAX8CfkEBIQQCQCAAQgBSIAFC////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NwNAIAqnIQQLIAMgAykCSDcDOCADIAMpAlg3AzAgA0E4aiADQTBqENsERQ0AIARFIAdFckUEQCADIAMpA0A3AyggAyADKQNQNwMgIANBKGogA0EgahDbBEUNAQsgCARAIAIoAgwoAgghBSADIAY2AmQgAyAINgJgIAVFDQMgA0HoAGogBUEAENgBIAMgAykDYDcDGCADIAMpAmg3AxAgA0EYaiADQRBqENsERQ0BCyAERSABIAlGckUEQCAAIAkgBBC3A0UNAQsLIAIoAhBFBEBBAUHhlQRBABAfQQAgAigCEEUNARoLIAAoAghBAEoEQCACKAIEIQQgAyACKAIMKAIINgIIIAMgBDYCBCADIAFBAnRBsPAEaigCADYCAEHo3gYoAgBB4dcDIAMQIgsgAgsiBDYCUCADQfAAaiQAIAQPC0H6ygFBufoAQeQAQdQ6EAAAC3MBAX8gABAlIAAQQk8EQCAAQQEQtQELIAAQJSECAkAgABApBEAgACACaiABOgAAIAAgAC0AD0EBajoADyAAECVBEEkNAUGypANB8/sAQaECQfeuARAAAAsgACgCACACaiABOgAAIAAgACgCBEEBajYCBAsLKQEBfwNAIAAiASgCECgCsAEiAA0ACwNAIAEiACgCECgCeCIBDQALIAAL8QEBBn8jAEEQayIEJAAjAEEQayIDJAAgASIHQQRqIQUCQCABKAIEIgZFBEAgBSEBDAELIAIoAgAhCANAIAYiASgCECIGIAhLBEAgASEFIAEoAgAiBg0BDAILIAYgCE8NASABQQRqIQUgASgCBCIGDQALCyADIAE2AgwgBCAFKAIAIgEEf0EABUEUEHkhASADIAdBBGo2AgQgASACKAIANgIQIANBAToACCAHIAMoAgwgBSABEO4EIANBADYCACADEO0EQQELOgAMIAQgATYCCCADQRBqJAAgACAEKAIINgIAIAAgBC0ADDoABCAEQRBqJAALhwEBAn8gASAAIAMoAgARAAAhBSACIAEgAygCABEAACEEAn8CQCAFRQRAQQAgBEUNAhogASACEJQBQQEgASAAIAMoAgARAABFDQIaIAAgARCUAQwBCyAEBEAgACACEJQBQQEPCyAAIAEQlAFBASACIAEgAygCABEAAEUNARogASACEJQBC0ECCwsKACAAKAIEEIUEC0gBAn8gAEEAIABB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IQJBASEHA0BBkMMKKAIAIAdLBEBB1MMKKAIAIAdB4ABsaiIAQQhqIgZBwMQKENMCIhIgECAQIBJkIgobIRAgACAEIAobIQQgBkHgxAoQ0wIiEiATIBIgE2MiChshEyAAIAEgChshASAGQdDEChDTAiISIA8gDyASZCIKGyEPIAAgCCAKGyEIIAZB8MQKENMCIhIgESARIBJkIgYbIREgACACIAYbIQIgB0EBaiEHDAELC0EAIQAgBEEIakHAxAorAwBByMQKKwMAENECIAFBCGpB4MQKKwMAQejECisDABDRAiAIQQhqQdDECisDAEHYxAorAwAQ0QIgAkEIakHwxAorAwBB+MQKKwMAENECQYjFCi0AACEGQdTDCigCACEEQZDDCigCACEKA0AgACAKRwRAAkAgBkEBcUUEQCAEIABB4ABsaigCIEUNAQsgBCAAQeAAbGoiCCgCWCIHKAIAIQJEAAAAAAAAAAAhEEQAAAAAAAAAACEPRAAAAAAAAAAAIREDQCACKAIAIgEEQCABKwAIIhYgBysAECITIAIrABAiEqGiIAcrAAgiFyASIAErABAiFKGiIAIrAAgiGCAUIBOhoqCgmUQAAAAAAADgP6IiFSAUIBIgE6CgRAAAAAAAAAhAo6IgEaAhESAQIBWgIRAgFSAWIBggF6CgRAAAAAAAAAhAo6IgD6AhDyABIQIMAQsLIAggDyAQozkDCCAIIBEgEKM5AxALIABBAWohAAwBCwsgCUEBaiIJEIAHIgAEQCAMQQFqQQAgACAFThsiDARAIANB6MMKKwMAIg8gD0HwwworAwAiD6FEmpmZmZmZqT+iIhGgOQOoASADQfjDCisDACIQIBBBgMQKKwMAIhChRJqZmZmZmak/oiIToDkDoAEgAyAPIBGhOQN4IAMgECAToTkDcCADQfAAaiADQaABahDxCiALQQFqIQsLQYjFCkEBOgAAQQEQ7woQpQogACEFDAELC0GoggstAAAEQCADIAk2AjBB6N4GKAIAIgBBu6wEIANBMGoQIiADIAs2AiAgAEHWrAQgA0EgahAiC0GIxAooAgAQGUGIxApBADYCAEGYxApBKBCYBEGkxAooAgAQGUGkxApBADYCABC1ChC4CwtBACECQdTDCigCACEBQZDDCigCACEFQQEhCANAIAIgBUYNASABIAJB4ABsaiIAKAIAKAIQKAKUASIEIAArAwg5AwAgBCAAKwMQOQMIIAJBAWohAgwACwALEPMKQbzECigCABAZQbzECkEANgIAIAggDWohDQwEBSAEIAdB4ABsaiICKwMwIRQgAisDECESIAIrAzghFSACQUBrKwMAIRYgB0EBaiEHIBMgAisDCCIXIAIrAyigED8hEyARIBIgFqAQMyERIBAgFyAVoBAzIRAgDyASIBSgED8hDwwBCwALAAtBxokDQb2zAUHmAEHQERAAAAtBpo0DQb2zAUGJAUHq3QAQAAALIANBsAFqJAAgDQsZACABIAIQtQshASAAIAI2AgQgACABNgIACyQAIABBAk8EfyAAQQRqQXxxIgAgAEEBayIAIABBAkYbBUEBCwutAQEEfyMAQRBrIgUkACABEKQLIQIjAEEQayIDJAACQCACQe////8DTQRAAkAgAhCWBQRAIAAgAhDAASAAIQQMAQsgA0EIaiAAIAIQzANBAWoQywMgAygCDBogACADKAIIIgQQ7QEgACADKAIMEOwBIAAgAhC+AQsgBCABIAIQ3gIgA0EANgIEIAQgAkECdGogA0EEahDKASADQRBqJAAMAQsQ6wEACyAFQRBqJAALxwEBBn8jAEEQayIEJAAgABCZBCgCACEFAn8gAigCACAAKAIAayIDQf////8HSQRAIANBAXQMAQtBfwsiA0EEIAMbIQMgASgCACEGIAAoAgAhByAFQcQERgR/QQAFIAAoAgALIAMQNyIIBEAgBUHEBEcEQCAAEOADGgsgBEGRAzYCBCAAIARBCGogCCAEQQRqEHYiBRDeCyAFEHUgASAAKAIAIAYgB2tqNgIAIAIgACgCACADQXxxajYCACAEQRBqJAAPCxCXAQALEwAgACABQQAgACgCACgCNBEDAAsTACAAIAFBACAAKAIAKAIkEQMAC/ICAQJ/IwBBEGsiCiQAIAogADYCDAJAAkACQCADKAIAIAJHDQBBKyELIAAgCSgCYEcEQEEtIQsgCSgCZCAARw0BCyADIAJBAWo2AgAgAiALOgAADAELIAYQJkUgACAFR3JFBEBBACEAIAgoAgAiASAHa0GfAUoNAiAEKAIAIQAgCCABQQRqNgIAIAEgADYCAAwBC0F/IQAgCSAJQegAaiAKQQxqEKAHIAlrIgZB3ABKDQEgBkECdSEFAkACQAJAIAFBCGsOAwACAAELIAEgBUoNAQwDCyABQRBHIAZB2ABIcg0AIAMoAgAiASACRiABIAJrQQJKcg0CIAFBAWstAABBMEcNAkEAIQAgBEEANgIAIAMgAUEBajYCACABIAVBoJcHai0AADoAAAwCCyADIAMoAgAiAEEBajYCACAAIAVBoJcHai0AADoAACAEIAQoAgBBAWo2AgBBACEADAELQQAhACAEQQA2AgALIApBEGokACAACwsAIABBqKgLELgCC+4CAQN/IwBBEGsiCiQAIAogADoADwJAAkACQCADKAIAIAJHDQBBKyELIABB/wFxIgwgCS0AGEcEQEEtIQsgCS0AGSAMRw0BCyADIAJBAWo2AgAgAiALOgAADAELIAYQJkUgACAFR3JFBEBBACEAIAgoAgAiASAHa0GfAUoNAiAEKAIAIQAgCCABQQRqNgIAIAEgADYCAAwBC0F/IQAgCSAJQRpqIApBD2oQowcgCWsiBUEXSg0BAkACQAJAIAFBCGsOAwACAAELIAEgBUoNAQwDCyABQRBHIAVBFkhyDQAgAygCACIBIAJGIAEgAmtBAkpyDQIgAUEBay0AAEEwRw0CQQAhACAEQQA2AgAgAyABQQFqNgIAIAEgBUGglwdqLQAAOgAADAILIAMgAygCACIAQQFqNgIAIAAgBUGglwdqLQAAOgAAIAQgBCgCAEEBajYCAEEAIQAMAQtBACEAIARBADYCAAsgCkEQaiQAIAALCwAgAEGgqAsQuAILFAAgAEHfAHEgACAAQeEAa0EaSRsLGQAgAkEBEJEMIQEgACACNgIEIAAgATYCAAskACAAQQtPBH8gAEEQakFwcSIAIABBAWsiACAAQQtGGwVBCgsLJAECfyMAQRBrIgIkACAAIAEQkAwhAyACQRBqJAAgASAAIAMbC2QCAX8BfiMAQRBrIgIkACAAAn4gAUUEQEIADAELIAIgAa1CACABZyIBQdEAahCrASACKQMIQoCAgICAgMAAhUGegAEgAWutQjCGfCEDIAIpAwALNwMAIAAgAzcDCCACQRBqJAALUgECf0HcwQooAgAiASAAQQdqQXhxIgJqIQACQCACQQAgACABTRsNACAAPwBBEHRLBEAgABAQRQ0BC0HcwQogADYCACABDwtBsI4LQTA2AgBBfwsWACAARQRAQQAPC0GwjgsgADYCAEF/C4MBAgV/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ayIDJAAgA0EANgIIIANCADcDAAJAAkACQCAAQQAgAxCFBg0AIAMoAgAiBkECSA0AIAMoAggiBCgCAA0BCyABQQA2AgAMAQsgBkEDTwRAQQBBnP8DQQAQHwsgASAAEEBBAWpBARBFIgA2AgAgACAEKAIAEN4DIQACQCAEKAIMBEAgASAAEEAgAGpBAWoiADYCBCAAIAQoAgwQ3gMaDAELIAFBADYCBAsgAgJ9IAQtAAgEQCAEKgIEDAELQwAAAAAgBC0AFEUNABpDAACAPyAEKgIQkws4AgBBASEFCyADEM0EIANBEGokACAFCxAAIAAoAgQQGSAAKAIIEBkLrwEBAX8gACgCECIBRQRAQdv0AEHEtAFB+ABB1I4BEAAACyABKALUARAZIAEoAtABEBkgASgC2AEQGSABKALcARAZIAEoAuABEBkgASgC5AEQGSABKALoARAZIAEoAuwBEBkgASgC8AEQGSABKAL0ARAZIAEoAvgBEBkgASgC/AEQGSABKAKAAhAZIAEoApACEBkgASgCnAIQGSABKAKYAhAZIAAgASgCADYCECABEBkLngEBAn9BsAIQxAMiASAAKAIQIgI2AgAgACABNgIQIAIEQCABQRBqIAJBEGpBKBAjGiABQThqIAJBOGpBKBAjGiABIAIoApABNgKQASABIAIoApQBNgKUASABIAIrA5gBOQOYASABIAIoAogBNgKIASABQeAAaiACQeAAakEoECMaIAEPCyABQoCAgICAgID4PzcDmAEgAUIDNwOQASABC7wBAQN/IAAgAEEwaiICIAAoAgBBA3FBA0YbKAIoKAIQIgEoAuABIAEoAuQBIgFBAWogAUECahDGASEBIAAgAiAAKAIAQQNxQQNGGygCKCgCECABNgLgASAAIAIgACgCAEEDcUEDRhsoAigoAhAiAUHkAWogASgC5AEiA0EBajYCACABKALgASADQQJ0aiAANgIAIAAgAiAAKAIAQQNxQQNGGygCKCgCECIAKALgASAAKALkAUECdGpBADYCAAtlAQV/IAAoAgQhBAJAA0AgAiAERg0BIAJBAnQhBiACQQFqIQIgBiAAKAIAIgVqIgMoAgAgAUcNAAsgACAEQQFrIgE2AgQgAyAFIAFBAnQiAWooAgA2AgAgACgCACABakEANgIACwv7AwIBfAh/An8gACsDCCIDRAAA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IAEgAjYCAAsIACAAKAIARQuNAQEBfwJAIAAoAgQiASABKAIAQQxrKAIAaigCGEUNACAAKAIEIgEgASgCAEEMaygCAGoQrgxFDQAgACgCBCIBIAEoAgBBDGsoAgBqKAIEQYDAAHFFDQAgACgCBCIBIAEoAgBBDGsoAgBqKAIYEK0MQX9HDQAgACgCBCIAIAAoAgBBDGsoAgBqQQEQrQULC7MBAQF/IAAgATYCBCAAQQA6AAAgASABKAIAQQxrKAIAahCuDARAIAEgASgCAEEMaygCAGooAkgiAQRAIwBBEGsiAiQAIAEgASgCAEEMaygCAGooAhgEQCACQQhqIAEQrAUaAkAgAi0ACEUNACABIAEoAgBBDGsoAgBqKAIYEK0MQX9HDQAgASABKAIAQQxrKAIAakEBEK0FCyACQQhqEKsFCyACQRBqJAALIABBAToAAAsgAAsJACAAIAEQxwkLtgMCA38BfiMAQSBrIgMkAAJAIAFC////////////AIMiBUKAgICAgIDAwD99IAVCgICAgICAwL/AAH1UBEAgAUIZiKchBCAAUCABQv///w+DIgVCgICACFQgBUKAgIAIURtFBEAgBEGBgICABGohAgwCCyAEQYCAgIAEaiECIAAgBUKAgIAIhYRCAFINASACIARBAXFqIQIMAQsgAFAgBUKAgICAgIDA//8AVCAFQoCAgICAgMD//wBRG0UEQCABQhmIp0H///8BcUGAgID+B3IhAgwBC0GAgID8ByECIAVC////////v7/AAFYNAEEAIQIgBUIwiKciBEGR/gBJDQAgA0EQaiAAIAFC////////P4NCgICAgICAwACEIgUgBEGB/gBrEKsBIAMgACAFQYH/ACAEaxCYAyADKQMIIgBCGYinIQIgAykDACADKQMQIAMpAxiEQgBSrYQiBVAgAEL///8PgyIAQoCAgAhUIABCgICACFEbRQRAIAJBAWohAgwBCyAFIABCgICACIWEQgBSDQAgAkEBcSACaiECCyADQSBqJAAgAiABQiCIp0GAgICAeHFyvgvHAQIDfwJ+IwBBEGsiAyQAAn4gAbwiBEH/////B3EiAkGAgIAEa0H////3B00EQCACrUIZhkKAgICAgICAwD98DAELIAJBgICA/AdPBEAgBK1CGYZCgICAgICAwP//AIQMAQsgAkUEQEIADAEL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QQN2QRxxaigCACACdkEBcUUNASABLQABIQIgAUEBaiEBIAINAAsLIAEgAGsL2QEBAn8CQCABQf8BcSIDBEAgAEEDcQRAA0AgAC0AACICRSACIAFB/wFxRnINAyAAQQFqIgBBA3ENAAsLAkAgACgCACICQX9zIAJBgYKECGtxQYCBgoR4cQ0AIANBgYKECGwhAwNAIAIgA3MiAkF/cyACQYGChAhrcUGAgYKEeHENASAAKAIEIQIgAEEEaiEAIAJBgYKECGsgAkF/c3FBgIGChHhxRQ0ACwsDQCAAIgItAAAiAwRAIABBAWohACADIAFB/wFxRw0BCwsgAg8LIAAQQCAAag8LIAALpwICAn8BfCMAQRBrIgMkAAJAIAC9QiCIp0H/////B3EiBEH7w6T/A00EQCAEQZ3BmvIDTQRAIAEgADkDACACQoCAgICAgID4PzcDAAwCCyABIABEAAAAAAAAAABBABCcAzkDACACIABEAAAAAAAAAAAQnQM5AwAMAQsgBEGAgMD/B08EQCACIAAgAKEiADkDACABIAA5AwAMAQsgACADEMEFIQQgAysDACADKwMIQQEQnAMhACADKwMAIAMrAwgQnQMhBQJAAkACQAJAIARBA3FBAWsOAwECAwALIAEgADkDACACIAU5AwAMAwsgASAFOQMAIAIgAJo5AwAMAgsgASAAmjkDACACIAWaOQMADAELIAEgBZo5AwAgAiAAOQMACyADQRBqJAALDwBBiJALIABBAWutNwMAC0gBAn8CfyABQR9NBEAgACgCACECIABBBGoMAQsgAUEgayEBIAALKAIAIQMgACACIAF0NgIAIAAgAyABdCACQSAgAWt2cjYCBAuyAgEFfyMAQfABayIHJAAgByADKAIAIgg2AugBIAMoAgQhAyAHIAA2AgAgByADNgLsAUEBIQkCQAJAAkAgCEEBRyADckUEQCAAIQMMAQtBACABayELIAAhCANAIAggBiAEQQJ0aiIKKAIAayIDIAAgAhCbA0EATARAIAghAwwCCwJAIAUgBEECSHJFBEAgCkEIaygCACEFIAggC2oiCiADIAIQmwNBAE4NASAKIAVrIAMgAhCbA0EATg0BCyAHIAlBAnRqIAM2AgAgB0HoAWoiBSAFEM4MIgUQuwUgCUEBaiEJIAQgBWohBEEAIQUgAyEIIAcoAugBQQFHDQEgBygC7AENAQwDCwsgCCEDDAELIAUNAQsgASAHIAkQzQwgAyABIAIgBCAGEMYHCyAHQfABaiQAC0sBAn8gACgCBCECIAACfyABQR9NBEAgACgCACEDIAIMAQsgAUEgayEBIAIhA0EACyICIAF2NgIEIAAgAkEgIAFrdCADIAF2cjYCAAsOACAAQSByQeEAa0EaSQsbAQF/QQEhASAAELwFBH9BAQUgABDQAUEARwsLrwEBA38gAygCTBogASACbCEFIAMgAygCSCIEQQFrIARyNgJIIAMoAgQiBiADKAIIIgRGBH8gBQUgACAGIAQgBmsiBCAFIAQgBUkbIgQQIxogAyADKAIEIARqNgIEIAAgBGohACAFIARrCyIEBEADQAJAIAMQzQdFBEAgAyAAIAQgAygCIBEDACIGDQELIAUgBGsgAW4PCyAAIAZqIQAgBCAGayIEDQALCyACQQAgARsLLwAgACAAIAGXIAG8Qf////8HcUGAgID8B0sbIAEgALxB/////wdxQYCAgPwHTRsLQQECfyMAQRBrIgEkAEF/IQICQCAAEM0HDQAgACABQQ9qQQEgACgCIBEDAEEBRw0AIAEtAA8hAgsgAUEQaiQAIAILuxgDGX8EfAF+IwBBMGsiCCQAAkACQAJAIAC9Ih9CIIinIgNB/////wdxIgZB+tS9gARNBEAgA0H//z9xQfvDJEYNASAGQfyyi4AETQRAIB9CAFkEQCABIABEAABAVPsh+b+gIgBEMWNiGmG00L2gIhs5AwAgASAAIBuhRDFjYhphtNC9oDkDCEEBIQMMBQsgASAARAAAQFT7Ifk/oCIARDFjYhphtNA9oCIbOQMAIAEgACAboUQxY2IaYbTQPaA5AwhBfyEDDAQLIB9CAFkEQCABIABEAABAVPshCcCgIgBEMWNiGmG04L2gIhs5AwAgASAAIBuhRDFjYhphtOC9oDkDCEECIQMMBAsgASAARAAAQFT7IQlAoCIARDFjYhphtOA9oCIbOQMAIAEgACAboUQxY2IaYbTgPaA5AwhBfiEDDAMLIAZBu4zxgARNBEAgBkG8+9eABE0EQCAGQfyyy4AERg0CIB9CAFkEQCABIABEAAAwf3zZEsCgIgBEypSTp5EO6b2gIhs5AwAgASAAIBuhRMqUk6eRDum9oDkDCEEDIQMMBQsgASAARAAAMH982RJAoCIARMqUk6eRDuk9oCIbOQMAIAEgACAboUTKlJOnkQ7pPaA5AwhBfSEDDAQLIAZB+8PkgARGDQEgH0IAWQRAIAEgAEQAAEBU+yEZwKAiAEQxY2IaYbTwvaAiGzkDACABIAAgG6FEMWNiGmG08L2gOQMIQQQhAwwECyABIABEAABAVPshGUCgIgBEMWNiGmG08D2gIhs5AwAgASAAIBuhRDFjYhphtPA9oDkDCEF8IQMMAwsgBkH6w+SJBEsNAQsgACAARIPIyW0wX+Q/okQAAAAAAAA4Q6BEAAAAAAAAOMOgIhxEAABAVPsh+b+ioCIbIBxEMWNiGmG00D2iIh2hIh5EGC1EVPsh6b9jIQICfyAcmUQAAAAAAADgQWMEQCAcqgwBC0GAgICAeAshAwJAIAIEQCADQQFrIQMgHEQAAAAAAADwv6AiHEQxY2IaYbTQPaIhHSAAIBxEAABAVPsh+b+ioCEbDAELIB5EGC1EVPsh6T9kRQ0AIANBAWohAyAcRAAAAAAAAPA/oCIcRDFjYhphtNA9oiEdIAAgHEQAAEBU+yH5v6KgIRsLIAEgGyAdoSIAOQMAAkAgBkEUdiICIAC9QjSIp0H/D3FrQRFIDQAgASAbIBxEAABgGmG00D2iIgChIh4gHERzcAMuihmjO6IgGyAeoSAAoaEiHaEiADkDACACIAC9QjSIp0H/D3FrQTJIBEAgHiEbDAELIAEgHiAcRAAAAC6KGaM7oiIAoSIbIBxEwUkgJZqDezmiIB4gG6EgAKGhIh2hIgA5AwALIAEgGyAAoSAdoTkDCAwBCyAGQYCAwP8HTwRAIAEgACAAoSIAOQMAIAEgADkDCEEAIQMMAQsgH0L/////////B4NCgICAgICAgLDBAIS/IQBBACEDQQEhAgNAIAhBEGogA0EDdGoCfyAAmUQAAAAAAADgQWMEQCAAqgwBC0GAgICAeAu3Ihs5AwAgACAboUQAAAAAAABwQaIhAEEBIQMgAiEWQQAhAiAWDQALIAggADkDIEECIQMDQCADIgJBAWshAyAIQRBqIg4gAkEDdGorAwBEAAAAAAAAAABhDQALQQAhBCMAQbAEayIFJAAgBkEUdkGWCGsiA0EDa0EYbSIGQQAgBkEAShsiEEFobCADaiEGQYS2BigCACIJIAJBAWoiDEEBayIHakEATgRAIAkgDGohAyAQIAdrIQIDQCAFQcACaiAEQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBkLYGaigCALcLOQMAIAJBAWohAiAEQQFqIgQgA0cNAAsLIAZBGGshCkEAIQMgCUEAIAlBAEobIQQgDEEATCELA0ACQCALBEBEAAAAAAAAAAAhAAwBCyADIAdqIQ9BACECRAAAAAAAAAAAIQADQCAOIAJBA3RqKwMAIAVBwAJqIA8gAmtBA3RqKwMAoiAAoCEAIAJBAWoiAiAMRw0ACwsgBSADQQN0aiAAOQMAIAMgBEYhFyADQQFqIQMgF0UNAAtBLyAGayESQTAgBmshDyAGQRlrIRMgCSEDAkADQCAFIANBA3RqKwMAIQBBACECIAMhBCADQQBMIg1FBEADQCAFQeADaiACQQJ0agJ/An8gAEQAAAAAAABwPqIiG5lEAAAAAAAA4EFjBEAgG6oMAQtBgICAgHgLtyIbRAAAAAAAAHDBoiAAoCIAmUQAAAAAAADgQWMEQCAAqgwBC0GAgICAeAs2AgAgBSAEQQFrIgRBA3RqKwMAIBugIQAgAkEBaiICIANHDQALCwJ/IAAgChDiAiIAIABEAAAAAAAAwD+inEQAAAAAAAAgwKKgIgCZRAAAAAAAAOBBYwRAIACqDAELQYCAgIB4CyEHIAAgB7ehIQACQAJAAkACfyAKQQBMIhRFBEAgA0ECdCAFaiICIAIoAtwDIgIgAiAPdSICIA90ayIENgLcAyACIAdqIQcgBCASdQwBCyAKDQEgA0ECdCAFaigC3ANBF3ULIgtBAEwNAgwBC0ECIQsgAEQAAAAAAADgP2YNAEEAIQsMAQtBACECQQAhBCANRQRAA0AgBUHgA2ogAkECdGoiFSgCACENQf///wchEQJ/AkAgBA0AQYCAgAghESANDQBBAAwBCyAVIBEgDWs2AgBBAQshBCACQQFqIgIgA0cNAAsLAkAgFA0AQf///wMhAgJAAkAgEw4CAQACC0H///8BIQILIANBAnQgBWoiDSANKALcAyACcTYC3AMLIAdBAWohByALQQJHDQBEAAAAAAAA8D8gAKEhAEECIQsgBEUNACAARAAAAAAAAPA/IAoQ4gKhIQALIABEAAAAAAAAAABhBEBBACEEIAMhAgJAIAMgCUwNAANAIAVB4ANqIAJBAWsiAkECdGooAgAgBHIhBCACIAlKDQALIARFDQAgCiEGA0AgBkEYayEGIAVB4ANqIANBAWsiA0ECdGooAgBFDQALDAMLQQEhAgNAIAIiBEEBaiECIAVB4ANqIAkgBGtBAnRqKAIARQ0ACyADIARqIQQDQCAFQcACaiADIAxqIgdBA3RqIANBAWoiAyAQakECdEGQtgZqKAIAtzkDAEEAIQJEAAAAAAAAAAAhACAMQQBKBEADQCAOIAJBA3RqKwMAIAVBwAJqIAcgAmtBA3RqKwMAoiAAoCEAIAJBAWoiAiAMRw0ACwsgBSADQQN0aiAAOQMAIAMgBEgNAAsgBCEDDAELCwJAIABBGCAGaxDiAiIARAAAAAAAAHBBZgRAIAVB4ANqIANBAnRqAn8CfyAARAAAAAAAAHA+oiIbmUQAAAAAAADgQWMEQCAbqgwBC0GAgICAeAsiArdEAAAAAAAAcMGiIACgIgCZRAAAAAAAAOBBYwRAIACqDAELQYCAgIB4CzYCACADQQFqIQMMAQsCfyAAmUQAAAAAAADgQWMEQCAAqgwBC0GAgICAeAshAiAKIQYLIAVB4ANqIANBAnRqIAI2AgALRAAAAAAAAPA/IAYQ4gIhAAJAIANBAEgNACADIQIDQCAFIAIiBEEDdGogACAFQeADaiACQQJ0aigCALeiOQMAIAJBAWshAiAARAAAAAAAAHA+oiEAIAQNAAsgA0EASA0AIAMhBANARAAAAAAAAAAAIQBBACECIAkgAyAEayIGIAYgCUobIgpBAE4EQANAIAJBA3RB4MsGaisDACAFIAIgBGpBA3RqKwMAoiAAoCEAIAIgCkchGCACQQFqIQIgGA0ACwsgBUGgAWogBkEDdGogADkDACAEQQBKIRkgBEEBayEEIBkNAAsLRAAAAAAAAAAAIQAgA0EATgRAIAMhAgNAIAIiBEEBayECIAAgBUGgAWogBEEDdGorAwCgIQAgBA0ACwsgCCAAmiAAIAsbOQMAIAUrA6ABIAChIQBBASECIANBAEoEQANAIAAgBUGgAWogAkEDdGorAwCgIQAgAiADRyEaIAJBAWohAiAaDQALCyAIIACaIAAgCxs5AwggBUGwBGokACAHQQdxIQMgCCsDACEAIB9CAFMEQCABIACaOQMAIAEgCCsDCJo5AwhBACADayEDDAELIAEgADkDACABIAgrAwg5AwgLIAhBMGokACADC/4DAwN8A38BfiAAvSIHQiCIp0H/////B3EiBEGAgMCgBE8EQCAARBgtRFT7Ifk/IACmIAC9Qv///////////wCDQoCAgICAgID4/wBWGw8LAkACfyAEQf//7/4DTQRAQX8gBEGAgIDyA08NARoMAgsgAJkhACAEQf//y/8DTQRAIARB//+X/wNNBEAgACAAoEQAAAAAAADwv6AgAEQAAAAAAAAAQKCjIQBBAAwCCyAARAAAAAAAAPC/oCAARAAAAAAAAPA/oKMhAEEBDAELIARB//+NgARNBEAgAEQAAAAAAAD4v6AgAEQAAAAAAAD4P6JEAAAAAAAA8D+goyEAQQIMAQtEAAAAAAAA8L8gAKMhAEEDCyEGIAAgAKIiAiACoiIBIAEgASABIAFEL2xqLES0or+iRJr93lIt3q2/oKJEbZp0r/Kws7+gokRxFiP+xnG8v6CiRMTrmJmZmcm/oKIhAyACIAEgASABIAEgAUQR2iLjOq2QP6JE6w12JEt7qT+gokRRPdCgZg2xP6CiRG4gTMXNRbc/oKJE/4MAkiRJwj+gokQNVVVVVVXVP6CiIQEgBEH//+/+A00EQCAAIAAgAyABoKKhDwsgBkEDdCIEQYC1BmorAwAgACADIAGgoiAEQaC1BmorAwChIAChoSIAmiAAIAdCAFMbIQALIAALzwUBB39BfyEHAkAgAiABayIGQQJIDQAgAS0AASEEAkACQAJAAkACQAJAAn8gAS0AACIIRQRAIAAgBGotAEgMAQsgCMAgBMAQKgtB/wFxIgVBE2sOBgIFBQEFAQALAkAgBUEGaw4CBAMACyAFQR1HDQQgBEEDdkEccSAIQYCUBmotAABBBXRyQaCEBmooAgAgBHZBAXFFDQQLAkACQANAIAIgASIEQQJqIgFrIghBAkgNByAELQADIQYCQAJAAkACfyAELQACIgpFBEAgACAGai0ASAwBCyAKwCAGwBAqC0H/AXEiBUESaw4MBQkJCQMJAwMDAwkBAAsgBUEGaw4CAQMICyAGQQN2QRxxIApBgJYGai0AAEEFdHJBoIQGaigCACAGdkEBcQ0BDAcLC0F+IQcgCEEDTw0FDAYLQX4hByAIQQRPDQQMBQsgBEEEaiEBQQkhCQwDCyACIAFBAmoiBGtBAkgNAyABLQADIQUCfyABLQACIgZFBEAgBUH4AEYEQCACIAFBBGoiBGtBAkgNBiABLQAFIQUCfyABLQAEIgFFBEAgACAFai0ASAwBCyABwCAFwBAqC0H+AXFBGEcEQCAEIQEMBgsgBCEBA0AgAiABIgRBAmoiAWtBAkgNByAELQADIQUCfyAELQACIgZFBEAgACAFai0ASAwBCyAGwCAFwBAqC0H/AXEiBUEYa0ECSQ0ACyAFQRJHDQUgBEEEaiEBQQohCQwFCyAAIAVqLQBIDAELIAbAIAXAECoLQRlHBEAgBCEBDAMLIAQhAQNAIAIgASIEQQJqIgFrQQJIDQQgBC0AAyEFAn8gBC0AAiIGRQRAIAAgBWotAEgMAQsgBsAgBcAQKgtB/wFxIgVBGUYNAAsgBUESRw0CIARBBGohAUEKIQkMAgtBfiEHIAZBBE8NAQwCC0F+IQcgBkEDSQ0BCyADIAE2AgAgCSEHCyAHC88FAQd/QX8hBwJAIAIgAWsiBkECSA0AIAEtAAAhBAJAAkACQAJAAkACQAJ/IAEtAAEiCEUEQCAAIARqLQBIDAELIAjAIATAECoLQf8BcSIFQRNrDgYCBQUBBQEACwJAIAVBBmsOAgQDAAsgBUEdRw0EIARBA3ZBHHEgCEGAlAZqLQAAQQV0ckGghAZqKAIAIAR2QQFxRQ0ECwJAAkADQCACIAEiBEECaiIBayIIQQJIDQcgBC0AAiEGAkACQAJAAn8gBC0AAyIKRQRAIAAgBmotAEgMAQsgCsAgBsAQKgtB/wFxIgVBEmsODAUJCQkDCQMDAwMJAQALIAVBBmsOAgEDCAsgBkEDdkEccSAKQYCWBmotAABBBXRyQaCEBmooAgAgBnZBAXENAQwHCwtBfiEHIAhBA08NBQwGC0F+IQcgCEEETw0EDAULIARBBGohAUEJIQkMAwsgAiABQQJqIgRrQQJIDQMgAS0AAiEFAn8gAS0AAyIGRQRAIAVB+ABGBEAgAiABQQRqIgRrQQJIDQYgAS0ABCEFAn8gAS0ABSIBRQRAIAAgBWotAEgMAQsgAcAgBcAQKgtB/gFxQRhHBEAgBCEBDAYLIAQhAQNAIAIgASIEQQJqIgFrQQJIDQcgBC0AAiEFAn8gBC0AAyIGRQRAIAAgBWotAEgMAQsgBsAgBcAQKgtB/wFxIgVBGGtBAkkNAAsgBUESRw0FIARBBGohAUEKIQkMBQsgACAFai0ASAwBCyAGwCAFwBAqC0EZRwRAIAQhAQwDCyAEIQEDQCACIAEiBEECaiIBa0ECSA0EIAQtAAIhBQJ/IAQtAAMiBkUEQCAAIAVqLQBIDAELIAbAIAXAECoLQf8BcSIFQRlGDQALIAVBEkcNAiAEQQRqIQFBCiEJDAILQX4hByAGQQRPDQEMAgtBfiEHIAZBA0kNAQsgAyABNgIAIAkhBwsgBwuwBQEFf0EBIQdBfyEGAkAgAiABayIEQQBMDQACQAJAAkACQAJAAkACQAJAIAAgAS0AAGotAEgiBUEFaw4DAQIDAAsgBUETaw4GBAUFAwUDBQtBfiEGIARBAkkNBSAAIAEgACgC4AIRAAANBEECIQcgACABIAAoAtQCEQAADQIMBAtBfiEGIARBA0kNBCAAIAEgACgC5AIRAAANA0EDIQcgACABIAAoAtgCEQAADQEMAwtBfiEGIARBBEkNAyAAIAEgACgC6AIRAAANAkEEIQcgACABIAAoAtwCEQAARQ0CCyABIAdqIQECQANAIAIgAWsiBEEATA0FQQEhBgJAAkACQCAAIAEtAABqLQBIIgVBEmsOCgIGBgYBBgEBAQEACwJAAkACQCAFQQVrDgMAAQIICyAEQQJJDQUgACABIAAoAuACEQAADQdBAiEGIAAgASAAKALIAhEAAA0CDAcLIARBA0kNBCAAIAEgACgC5AIRAAANBkEDIQYgACABIAAoAswCEQAADQEMBgsgBEEESQ0DIAAgASAAKALoAhEAAA0FQQQhBiAAIAEgACgC0AIRAABFDQULIAEgBmohAQwBCwsgAUEBaiEBQQkhCAwCC0F+DwsgAiABQQFqIgVrQQBMDQEgBS0AACIEQfgARgRAIAIgAUECaiIBa0EATA0CIAAgAS0AAGotAEhB/gFxQRhHDQEDQCACIAEiBUEBaiIBa0EATA0DIAAgAS0AAGotAEgiBEEYa0ECSQ0ACyAEQRJHDQEgBUECaiEBQQohCAwBCyAAIARqLQBIQRlHBEAgBSEBDAELIAUhAQNAIAIgASIFQQFqIgFrQQBMDQIgACABLQAAai0ASCIEQRlGDQALIARBEkcNACAFQQJqIQFBCiEICyADIAE2AgAgCCEGCyAGDwtBfwuJBAEFf0F8IQYCQAJAIAMgBE8NACABKAJIIQcCQAJAIAQgA0EBakYEQEF/IQYgASwARSIJQQNrQQNJDQMgAy0AACIIQe8BayIKQRBLQQEgCnRBgYAGcUVyDQEgAkEBRw0DIAlFDQIMAwsCQAJAAkAgAy0AASIIIAMtAAAiCUEIdHIiBkGA+ABHBEAgBkG73wNGDQIgBkH+/wNGDQEgBkH//QNHDQMgAkEBRgRAIAEtAEVFDQYLIAUgA0ECajYCACAHIAAoAhA2AgBBDg8LAkAgAS0ARSIGQQRHBEAgAkEBRyAGQQNHcg0BDAYLIAJBAUYNBQsgByAAKAIUIgA2AgAMBgsgAkEBRgRAIAEtAEVFDQQLIAUgA0ECajYCACAHIAAoAhQ2AgBBDg8LAkAgAkEBRw0AIAEtAEUiBkEFSw0AQQEgBnRBOXENAwsgBCADQQJqRgRAQX8PCyADLQACQb8BRw0CIAUgA0EDajYCACAHIAAoAgg2AgBBDg8LIAlFBEAgAkEBRgRAIAEtAEVBBUYNAwsgByAAKAIQIgA2AgAMBAsgAkEBRiAIcg0BIAcgACgCFCIANgIAIAAgAyAEIAUgACgCABEGACEGDAILIAhFIAhBPEZyDQELIAcgACABLABFQQJ0aigCACIANgIADAELIAYPCyAAIAMgBCAFIAAgAkECdGooAgARBgALtAECAnwDfyAAKAIQKAKEAkUEQCAAEFsQrQIiAygCEEECOgCsASAAEFsQrQIiBCgCEEECOgCsAQJAIAAoAhAoAgxFDQAgABBbIABGDQAgABA0KAIQLQB0QQFxDQAgAyAEAn8gACgCECIFKwMwIgEgBSsDUCICIAEgAmQbIgGZRAAAAAAAAOBBYwRAIAGqDAELQYCAgIB4C7dBABCaARoLIAAoAhAiACAENgKIAiAAIAM2AoQCCwsqAQN/A0AgAiIDQQFqIQIgACIEKALYAyIADQALIAEEQCABIAM2AgALIAQLbgECfyMAQRBrIgQkACAEIAI2AgwCfwJAIAAoAgxFBEAgABBcRQ0BCyAAQQxqIQIDQCABIARBDGogAyACIAAoAgggASgCOBEHAEECTwRAIAAQXA0BDAILCyAAKAIQDAELQQALIQUgBEEQaiQAIAULjTEBEn8jAEEQayIMJAAgDCAFNgIMIAAoAuACIQoCfyABIAAoApABRgRAIABBnAJqIRUgAEGgAmoMAQsgACgCqAIiFUEEagshESAAQZwDaiEPIApBhAFqIRYgCkHQAGohEyAAQfwBaiEXAkACQAJAA0ACQCAVIAI2AgAgESAMKAIMIhA2AgACQCAEQQBKDQAgB0EAIAQbDQQgBEFxRgRAQQ8hBAwBC0EGIQtBBSEFAkACQAJAIARBBGoOBQECCAQAAgsgFSAQNgIAQQQhCwwHCyAAKAKQASABRwRAIAAoAqgCLQAURQ0GDAULIAAtAOQDDQRBAyELDAYLIAwgAzYCDEEAIARrIQQgAyEQCwJAIBcgBCACIBAgASAXKAIAEQcAIg5BAWtBAkkgDkE5RnINACAAIAQgAiAMKAIMQe0kIAkQoQINACAAEOcCQSshCwwFC0EBIQ1BACEFAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAOQQFqDj4iOgAIOQEYBAIHHB04FxkFGhs3HiAhHwoLDA0ODxAREhQUNgkVFRYWNSgpKSokMzEwMiYlListLDw7AyMnJ0ULIABBACACIAwoAgwQmw0iBQ1MDEoLIAAoAlQEfyAAIA8gASACIAwoAgwQggEiBDYCvAIgBEUNSSAAQQA2AsQCIAAgACgCqAM2AqwDQQAFQQELIQ0gAEEANgLAAgxCCyAAKAJUIgRFDUIgACgCBCAAKAK8AiAAKALAAiAAKALEAkEBIAQRCgAgAEEANgK8AiAPEKICDEkLIABBASACIAwoAgwQmw0iBUUNRwxJCyAAQQA6AOUDIAAgACAWQez0BUEkEJkBIgQ2ArgCIARFDUUgCkEBOgCBASAAKAJURQ0AIAEgAiAMKAIMIBUgASgCNBEGAEUNRCAPIAEgAiABKAJAIgRqIAwoAgwgBGsQggEiBEUNRSAEEN8HIAAgBDYCxAIgACAAKAKoAzYCrANBACENDAELIAEgAiAMKAIMIBUgASgCNBEGAEUNQwsgCi0AgAFFDT0gACgCuAJFDT0gEyABIAIgASgCQCIEaiAMKAIMIARrEIIBIgRFDUMgBBDfByAAKAK4AiAENgIYIAogCigCXDYCYCAOQQ5HDT0gACgCiAFFDT0MRQsgCEEBRwRAQQQhBQxGCyAAKAK8AiIEBEAgACgCBCAEIAAoAsACIAAoAsQCQQAgACgCVBEKACAPEKICQQAhDQsCQCAAKALAAkUEQCAALQDlA0UNAQsgCi0AgQEhBSAKQQE6AIEBAkAgACgC6ANFDQAgACgCcEUNACAAIBZB7PQFQSQQmQEiBEUNRCAALQDlAwRAIAQgACgC5AI2AhQLIApBADoAgwEgACgCdEEAIAQoAhQgBCgCECAEKAIYIAAoAnARBwBFBEBBFSEFDEgLIAotAIMBBEAgCi0AggENASAAKAJsIgRFDQEgACgCBCAEEQIADQEMQwsgACgCwAINACAKIAU6AIEBCyAAQQA6AOUDCyAAKAJYIgRFDTwgACgCBCAEEQEADEQLAkAgAC0A5QNFDQAgCi0AgQEhBCAKQQE6AIEBIAAoAugDRQ0AIAAoAnBFDQAgACAWQez0BUEkEJkBIgFFDT8gASAAKALkAjYCFCAKQQA6AIMBIAAoAnRBACABKAIUIAEoAhAgASgCGCAAKAJwEQcARQ0+IAotAIMBBEAgCi0AggENASAAKAJsIgFFDQEgACgCBCABEQIADQFBFiELDEoLIAogBDoAgQELIABBmQM2ApQCIAAgAiADIAYQ3gchCwxICyAAIAAgASACIAwoAgwQ3QciBDYC1AIgBEUNQAwJCyAAIAAgASACIAwoAgwQmg0iBDYC2AIgBEUNPyAAQQA2AsgCIABBADsB3AIMCAsgAEHu9AU2AsgCIABBAToA3AIMBwsgAEH09AU2AsgCIABBAToA3QIMBgsgAEH39AU2AsgCDAULIABB/fQFNgLIAgwECyAAQYT1BTYCyAIMAwsgAEGL9QU2AsgCDAILIABBlPUFNgLIAgwBCyAAQZz1BTYCyAILIAotAIABRQ0xIAAoAoQBRQ0xDDgLIAotAIABRQ0wIAAoAoQBRQ0wQb4IQe+aA0H6mgMgDkEgRhsgACgCyAIbIQUDQCAFLQAAIgsEQCAAKAKoAyIEIAAoAqQDRgRAIA8QXEUNNSAAKAKoAyEECyAAIARBAWo2AqgDIAQgCzoAACAFQQFqIQUMAQsLQQEhBSAAKAKsA0UNOCAPIAEgAiAMKAIMEMkFRQ04IAAgACgCrAM2AsgCDDcLIAotAIABRQRADC4LIAAoAtQCIAAoAtgCIAAtANwCIAAtAN0CQQAgABCYDUUNNCAAKAKEAUUNLSAAKALIAiIERQ0tAkAgBC0AACIFQShHBEAgBUHOAEcNASAELQABQc8ARw0BCyAAKAKoAyIEIAAoAqQDRgRAIA8QXEUNNiAAKAKoAyEEC0EBIQUgACAEQQFqNgKoAyAEQSk6AAAgACgCqAMiBCAAKAKkA0YEQCAPEFxFDTkgACgCqAMhBAsgACAEQQFqNgKoAyAEQQA6AAAgACAAKAKsAzYCyAIgACAAKAKoAzYCrAMLIBEgAjYCAEEAIQ0gACgCBCAAKALUAigCACAAKALYAigCACAAKALIAkEAIA5BJEYgACgChAERDQAMLQsgCi0AgAFFDS4gACABIAAtANwCIAIgASgCQCIEaiAMKAIMIARrIBNBAhCXDSIFDTYgCigCYCEEIAogCigCXDYCYEEBIQUgACgC1AIgACgC2AIgAC0A3AJBACAEIAAQmA1FDTYgACgChAFFDS4gACgCyAIiC0UNLgJAIAstAAAiEEEoRwRAIBBBzgBHDQEgCy0AAUHPAEcNAQsgACgCqAMiCyAAKAKkA0YEQCAPEFxFDTggACgCqAMhCwsgACALQQFqNgKoAyALQSk6AAAgACgCqAMiCyAAKAKkA0YEQCAPEFxFDTggACgCqAMhCwsgACALQQFqNgKoAyALQQA6AAAgACAAKAKsAzYCyAIgACAAKAKoAzYCrAMLIBEgAjYCACAAKAIEIAAoAtQCKAIAIAAoAtgCKAIAIAAoAsgCIAQgDkEmRiAAKAKEARENACAPEKICDDULIAotAIABRQ0tIAAgASACIAEoAkAiBGogDCgCDCAEa0ECEJYNIQUgCigCeCEEAn8CQCAAKAK4AiILBEAgCyAENgIEIAAoArgCIAooAnQgCigCeGs2AgggCiAKKAJ0NgJ4IAAoAogBRQ0BIBEgAjYCACAAKAIEIAAoArgCIgQoAgAgBC0AISAEKAIEIAQoAgggACgC5AJBAEEAQQAgACgCiAERHABBAAwCCyAKIAQ2AnQLQQELIQ0gBQ01DCwLIABBADoA5QNBASEFIApBAToAgQECfyAAKAJUBEAgACAPIAEgAiABKAJAIgRqIAwoAgwgBGsQggEiBDYCwAIgBEUNNiAAIAAoAqgDNgKsA0EADAELIABB7PQFNgLAAkEBCyENAkAgCi0AggENACAAKALoAw0AIAAoAmwiBEUNACAAKAIEIAQRAgBFDTALIAAoArgCDQAgACAAIBZB7PQFQSQQmQEiBDYCuAIgBEUNNCAEQQA2AhgLIAotAIABRQ0qIAAoArgCRQ0qIBMgASACIAEoAkAiBGogDCgCDCAEaxCCASEEIAAoArgCIAQ2AhAgACgCuAIiBCgCEEUNMCAEIAAoAuQCNgIUIAogCigCXDYCYCAOQQ1HDSogACgCiAFFDSoMMgsgCi0AgAFFDSogACgCuAJFDSogACgCiAFFDSogESACNgIAIAAoAgQgACgCuAIiAigCACACLQAhQQBBACACKAIUIAIoAhAgAigCGEEAIAAoAogBERwADDELIAotAIABRQ0pIAAoArgCRQ0pIBMgASACIAwoAgwQggEhBCAAKAK4AiAENgIcIAAoArgCKAIcRQ0uIAogCigCXDYCYCAAKAJcBEAgESACNgIAIAAoAgQgACgCuAIiAigCACACKAIUIAIoAhAgAigCGCACKAIcIAAoAlwRDQAMMQsgACgCiAFFDSkgESACNgIAIAAoAgQgACgCuAIiAigCAEEAQQBBACACKAIUIAIoAhAgAigCGCACKAIcIAAoAogBERwADDALIAEgAiAMKAIMIAEoAiwRAwAEQCAAQQA2ArgCDCkLIAotAIABRQ0XQQEhBSATIAEgAiAMKAIMEIIBIgRFDTAgACAAIAogBEEkEJkBIgs2ArgCIAtFDTAgBCALKAIARwRAIAogCigCYDYCXCAAQQA2ArgCDCkLIAogCigCXDYCYCAAKAK4AkEANgIYIAAoArgCQQA6ACFBASEEIAAoArgCIAAoAtgDBH9BAQUgACgCqAJBAEcLQQFzOgAiIAAoAogBRQ0oDC8LIAotAIABBEBBASEFIBMgASACIAwoAgwQggEiBEUNMCAAIAAgFiAEQSQQmQEiCzYCuAIgC0UNMCAEIAsoAgBHBEAgCiAKKAJgNgJcIABBADYCuAIMKQsgCiAKKAJcNgJgIAAoArgCQQA2AhggACgCuAJBAToAIUEBIQQgACgCuAIgACgC2AMEf0EBBSAAKAKoAkEARwtBAXM6ACIgACgCiAFFDSgMLwsgCiAKKAJgNgJcIABBADYCuAIMJwsgAEIANwLMAiAAKAJgRQ0mIAAgDyABIAIgDCgCDBCCASICNgLMAiACRQ0rIAAgACgCqAM2AqwDDC0LIAEgAiAMKAIMIBUgASgCNBEGAEUNKSAAKALMAkUNJSAPIAEgAiABKAJAIgRqIAwoAgwgBGsQggEiAkUNKiACEN8HIAAgAjYC0AIgACAAKAKoAzYCrAMMLAsgACgCzAJFDSIgACgCYEUNIiAPIAEgAiABKAJAIgRqIAwoAgwgBGsQggEiBEUNKSARIAI2AgAgACgCBCAAKALMAiAAKALkAiAEIAAoAtACIAAoAmARCgBBACENDCILIAAoAtACRQ0hIAAoAmBFDSEgESACNgIAQQAhDSAAKAIEIAAoAswCIAAoAuQCQQAgACgC0AIgACgCYBEKAAwhC0EKQRFBAiAEQQxGGyAEQRxGGyELDC4LIAAoAlAEQCAAIAEgAiAMKAIMEIMBCyAAIAEgDEEMaiADIAYgBxCVDSIFDSkgDCgCDA0oIABBmgM2ApQCQQAhCwwtCyAAKALQAyIEIAAoAoACSw0dIAQEQCAEQQBIDSZBASELIAAgBEEBdCIENgLQAyAAKALMAyAEIAAoAhARAAAiBEUEQCAAIAAoAtADQQF2NgLQAwwuCyAAIAQ2AswDIAooArgBIgRFDR5BASEFIAAoAtADIgtB/////wNLDSkgBCALQQJ0IAAoAhARAAAiBEUNKSAKIAQ2ArgBDB4LIABBIDYC0AMgAEEgIAAoAgwRAgAiBDYCzAMgBA0dIABBADYC0AMMIgsgACgCzAMgACgCgAJqIgQtAABB/ABGDRsgBEEsOgAAIAotAKABRQ0fIAAoAoABRQ0fDCYLIAAoAswDIgQgACgCgAIiBWotAAAiC0EsRg0aAkAgCw0AIAotAKABRQ0AIAooAqQBIAooArgBIAooArQBQQJ0akEEaygCAEEcbGoiCygCAEEDRg0AIAtBBTYCACAAKAKAAiEFIAAoAswDIQQgACgCgAFFIQ0LIAQgBWpB/AA6AAAMHQtBASEFIApBAToAgQEgACgC6ANFBEAgCiAKLQCCASIEOgCAAQwZCyATIAEgAiABKAJAIgRqIAwoAgwgBGsQggEiC0UNJSAAIBYgC0EAEJkBIQQgCiAKKAJgNgJcIAAoAowCRQ0WAkAgCi0AggEEQCAAKAKoAkUNAQwYCyAKLQCBAQ0XCyAERQRAQQshBQwmCyAELQAiDRdBGCEFDCULIAAoAoABRQ0cIAAgACABIAIgDCgCDBDdByICNgLUAiACRQ0hIApCADcCsAEgCkEBOgCgAQwjCyAKLQCgAUUNGyAAKAKAAQR/QRQgACgCDBECACIERQ0hIARCADcCBCAEQgA3AgwgBEECQQEgDkEpRhs2AgAgESACNgIAIAAoAgQgACgC1AIoAgAgBCAAKAKAAREFAEEABUEBCyENIApBADoAoAEMGgsgCi0AoAFFDRogCigCpAEgCigCuAEgCigCtAFBAnRqQQRrKAIAQRxsakEDNgIAIAAoAoABRQ0aDCELQQIhDQwBC0EDIQ0LIAotAKABRQ0XIAwoAgwgASgCQGsMAQsgCi0AoAFFDRZBACENIAwoAgwLIRBBASEFIAAQlA0iBEEASA0dIARBHGwiBCAKKAKkAWpBBDYCACAKKAKkASAEaiANNgIEIAAgASACIBAQ3QciC0UNHSAKKAKkASAEaiALKAIAIgs2AghBACEEA0AgBCALaiEaIARBAWohBCAaLQAADQALIAQgCigCqAEiC0F/c0sNHSAKIAQgC2o2AqgBIAAoAoABRQ0VDBwLQQEhBQwCC0ECIQUMAQtBAyEFCyAKLQCgAUUNESAAKAKAASEEIAogCigCtAFBAWsiCzYCtAEgCigCpAEgCigCuAEgC0ECdGooAgBBHGxqIAU2AgQgBEUhDSAKKAK0AQ0QIARFDQlBASEFIAAoAuACIhIoArABIgRBzJmz5gBLDRkgBEEUbCIEIBIoAqgBIgtBf3NLDRkgBCALaiAAKAIMEQIAIhhFDRkgEigCsAEhBCAYQQA2AgwgGEEUaiEQIBgiDiAEQRRsaiIZIQUDQAJAIA4gGUkEQCAOIA4oAgxBHGwiFCASKAKkAWooAgAiBDYCACAOIBIoAqQBIBRqKAIENgIEIARBBEYEQCAOIAU2AgggEigCpAEgFGooAgghBANAIAUgBC0AADoAACAFQQFqIQUgBC0AACEbIARBAWohBCAbDQALIA5CADcCDAwCC0EAIQQgDkEANgIIIBIoAqQBIBRqKAIUIQsgDiAQNgIQIA4gCzYCDCASKAKkASAUakEMaiEUA0AgBCALTw0CIBAgFCgCACILNgIMIARBAWohBCAQQRRqIRAgEigCpAEgC0EcbGpBGGohFCAOKAIMIQsMAAsACyARIAI2AgAgACgCBCAAKALUAigCACAYIAAoAoABEQUADAsLIA5BFGohDgwACwALIAogCigCYDYCXCAAQQA2ArgCDBALIAAoAoABRQ0PDBYLIAotAIABRQ0OIAAoAoQBRQ0ODBULIAAoAmBFDQ0MFAsgCi0AgAFFDQwgACgCiAFFDQwMEwsgACgCVEUNCwwSCyAEQQ5HDQoMEQsgACABIAIgDCgCDBDcB0UNDgwQCyAAIAEgAiAMKAIMENsHRQ0NDA8LIApBADYCqAEgCkEAOgCgAQwGCyAEDQAgCiAKLQCCAToAgAEgDkE8Rw0GIAAoAngiBEUNBiAAKAIEIAtBASAEEQUADA0LIAQtACAEQEEMIQUMDgsgBCgCBARAIAAgBCAOQTxGEJMNIgVFDQ0MDgsgACgCcARAQQAhDSAKQQA6AIMBIARBAToAICAAIARBvyoQrgQgACgCdEEAIAQoAhQgBCgCECAEKAIYIAAoAnARBwBFBEAgACAEQcMqEOYCIARBADoAIAwICyAAIARBxyoQ5gIgBEEAOgAgIAotAIIBIQQgCi0AgwENASAKIAQ6AIABDA0LIAogCi0AggE6AIABDAULIARB/wFxDQMgACgCbCIERQ0DIAAoAgQgBBECAEUNBwwDC0ECIQUMCwsgACgCzAMgACgCgAJqQQA6AAAgCi0AoAFFDQIgABCUDSIEQQBIDQcgCigCuAEiBQRAIAUgCigCtAFBAnRqIAQ2AgAgCiAKKAK0AUEBajYCtAEgCigCpAEgBEEcbGpBBjYCACAAKAKAAUUNAwwKC0HcyQFB3bgBQdopQZT9ABAAAAsgDxCiAgsgDUUNBwsgACgCUEUNBiAAIAEgAiAMKAIMEIMBDAYLQRUhCwwKC0EBIQsMCQtBFiEFDAQLQSAhBQwDC0EBIQUMAgsgACgCkAEhAQtBIyEFAkACQCAAKALcA0ECaw4CAgABCyAGIAwoAgw2AgBBACELDAULIAEgDCgCDCICIAMgDEEMaiABKAIAEQYAIQQMAQsLIAUhCwwCCyAXQXwgAyADIAEgFygCABEHAEF/Rw0AQR0hCwwBCyAGIAI2AgBBACELCyAMQRBqJAAgCwtWAQR/IAAoAgAhAQNAIAEEQCABKAIAIQMgASAAKAIUKAIIEQEAIAMhAQwBCwsgACgCBCEBA0AgAQRAIAEoAgAhBCABIAAoAhQoAggRAQAgBCEBDAELCwurBAEKfyAAKAIEIghFBEAgACABNgIEIAAgASgCGCIAQYsDIAAbNgIMIAEPCwJAIAFFDQAgACgCECgCACEJIAAoAggoAgAiBEGAIHEEQCAAQQAQ0gEgACgCCCgCACEECyAAIAE2AgQgACABKAIYIgJBiwMgAhs2AgwgBEHAAHENACAAEIcBIQQgACgCCCIFQQA2AhAgBUEANgIEIAUgBSgCACICQf9fcTYCAAJAIAJBAXFFDQAgBSgCCCIDIAUoAgxBAnRqIQIDQCACIANNDQEgA0EANgIAIANBBGohAwwACwALA0AgBEUNAQJ/IAEoAggiAkEASARAIAQoAggMAQsgBCACawsgASgCAGohAyAEKAIAIQsgBAJ/IAEoAgQiAkEASARAIAMoAgAhAwtBACEGAkACQAJAIAJBAEwEQCADIQIDQCACLQAAIgoEQCACQQJBASACLQABIgcbaiECIAcgCkEIdCAGampBs6aUCGwhBgwBCwsgAxBAQQBIDQIgAiADayECDAELIAIgA2pBAWshBwNAIAMgB0kEQCADLQABIAMtAABBCHQgBmpqQbOmlAhsIQYgA0ECaiEDDAELCyADIAdLDQAgAy0AAEEIdCAGakGzppQIbCEGCyACQQBIDQEgAiAGakGzppQIbAwCC0GexAFB7bcBQRpBw/gAEAAAC0GAjANB7bcBQSRBw/gAEAAACzYCBCAAIARBICAJEQMAGiALIQQMAAsACyAICzQBAX8jAEEQayICJAAgASAAIAJBDGoQvQc2AgAgAigCDCEBIAJBEGokACABQQAgACABRxsLNgAgAQJ/IAMEQCACEOUDDAELIAIQuQ0iA0UEQEF/DwsgAiADELoNCyAAKAJAKAIEKAIEEQAACx0AIAAQvQVBAEcgAEEta0H/AXFBAklyIABBAEhyCzoBAn8gAAR/IAAoAkBBDGoFQayNCwsiAigCACIBRQRAIAIgAEG4vQpBiL4KKAIAEIQCIgE2AgALIAELGwAgACgCQCIAKAIIIAEgAiAAKAIAKAIYEQUACwIACycBAX9B8IsLKAIAQRAQ1AEiAyACNgIIIAMgATYCBCADIAA2AgAgAwsNACAALQAYQQF2QQFxCyUAIAAgASgCABDSASAAIAJBASAAKAIAEQMAGiABIAAQ6QI2AgALOQAgACABKAIAENIBIAAgAkECIAAoAgARAwBFBEBBmxNBqrkBQaMBQcnvABAAAAsgASAAEOkCNgIAC4gBAQR/IAAQKyEEAkAgACgCACICIAEoAgBzQQNxDQADQCAEIAJBA3EgAxD0ASIDRQ0BIAEgAygCCBCBCCICRQ0BIAEgAiAAIAMQOSIFEGQgBRCkAgRAIAEgAhA5IgIEQCACQQxrIgIgAikDAEKAgICAgICAgIB/hDcDAAsLIAAoAgAhAgwACwALCyAAIAAQKxA0IAAoAgBBA3EQnwMiAEUEQEEADwsgABByCx8BAX8CQCABEOABIgIEQCACKAIIDQELIAAgARD1DQsLJAEBfyMAQRBrIgIkACACIAE2AgxBASAAIAEQggggAkEQaiQAC04BAX8CQCABKAIQKAKcAUUNACAAIAEgASgCAEEDcUEDR0EwbGooAigQ8g1FDQAgACABQVBBACABKAIAQQNxQQJHG2ooAigQ8g0hAgsgAguIAQIGfAF/IAErAwAhBSABKwMIIQcgAisDACEGIAArAwAhAyACKwMIIQggACsDCCEEAkAgACABIAIQxAFBA0cNACAGIAOhIgYgBSADoSIDoiAHIAShIgUgCCAEoSIEoqBEAAAAAAAAAABmRQ0AIAYgBqIgBCAEoqAgAyADoiAFIAWioGUhCQsgCQvCAwIEfAJ/IAQoAgQhCQNAAn8CQAJAAkACQAJAAkAgCSACQShsaiIEKAIAQQFrDgMCAQADCyAJIAJBKGxqKAIYDwsgACsDCCIFIAQrAxAiBkRIr7ya8td6PqAiB2QNAyAFIAZESK+8mvLXer6gIghjRQRAIAArAwAgBCsDCGQNBAsgBSAGoZlESK+8mvLXej5lRQ0CIAArAwAgBCsDCCIFoZlESK+8mvLXej5lRQ0CIAErAwgiBiAHZA0DIAYgCGMNAiABKwMAIAVkDQMMAgsCQAJAIAArAwgiBSADIAQoAgQiCkE4bGoiAisDCKGZREivvJry13o+ZQRAIAArAwAiBiACKwMAoZlESK+8mvLXej5lDQELIAUgAisDGKGZREivvJry13o+ZUUNASAAKwMAIgYgAisDEKGZREivvJry13o+ZUUNAQsgBSABKwMIoZlESK+8mvLXej5lBEAgASsDACAGY0UNBAwDCyAKIAMgARChA0UNAwwCCyAKIAMgABChA0UNAgwBC0HiyQNBI0EBQejeBigCABBGGkG1kANB87kBQcYCQegdEAAACyAEQSBqDAELIARBJGoLKAIAIQIMAAsACzsBAX8jAEEQayIDJAAgAyACNgIEIAAoAgQgAUEMbGooAggiACADQQRqQQEgACgCABEDABogA0EQaiQACygAIABBBU8EQEGtxgFByrYBQYgEQYY0EAAACyAAQQJ0QZDeBWooAgALngECAn8BfgJAIAEgAkGABCABKAIAEQMAIgVFBEAgACgCECAAKAIAIgVBKGxqIgYgBTYCICAAIAVBAWo2AgAgBiEAIANFDQEgAyAAKAIgQQV0aiIFIAIpAwA3AwggAikDCCEHIAUgADYCACAFIAc3AxAgACAEOgAkIAEgBUEBIAEoAgARAwAaCyAFKAIADwtBxytBtLgBQa4CQagbEAAAC2gBA38gACgCECIBKAIIIgIEf0EAIQEDfyACKAIAIQMgAigCBCABTAR/IAMQGSAAKAIQKAIIEBkgACgCEAUgAyABQTBsaigCABAZIAFBAWohASAAKAIQKAIIIQIMAQsLBSABC0EANgIIC9UBAQJ/IwBBEGsiBCQAQbiKC0G4igsoAgAiBUEBajYCACAEIAEQITYCBCAEIAU2AgAgAkGhMiAEENcBIAEQNCACELkOQQEQbyICQbolQcACQQEQMBogAigCEEEBOgCGASABIAJBARB6GiADIABBARB6GkH0gwsgAhArIAJB+e8AQdLnBEH0gwsoAgAQkgg2AgBBgIQLIAIQKyACQYaWAUHzLEGAhAsoAgAQkgg2AgBBuIMLIAIQKyACQemSAUHEEUG4gwsoAgAQkgg2AgAgBEEQaiQAIAILqgUCBX8BfCAAQbSDCygCAEQAAAAAAADoP0R7FK5H4XqEPxBTIQYgACgCECAGOQMgIABBsIMLKAIARAAAAAAAAOA/RHsUrkfhepQ/EFMhBiAAKAIQIAY5AyggAEG4gwsoAgBB5o8BEE0hAiMAQRBrIgQkACAAQYeXARAnEOQFBEBB8OoAIAIgAkGiggEQKBshAgsCQAJAIAJB8OoAEChFDQBBkIAKIQEDQCABKAIAIgNFDQEgAyACEChFDQIgAUEQaiEBDAALAAsgAhCfCCIBDQBB5IgLQeSICygCACIDQQFqIgE2AgAgAUECdCEBQeCICwJ/QeCICygCACIFBEAgBSABEJMBDAELIAEQeAs2AgBBEBBOIQFB4IgLKAIAIANBAnRqIAE2AgAgAUGYgAopAwA3AgggAUGQgAopAwA3AgAgASACEKEBIgU2AgBBASEDAkBBoIILKAIADQAgAkHw6gAQKEUNACAEIAU2AgRBACEDIARBkIAKKAIANgIAQQBB5eEDIAQQHwsgASADOgAMCyAEQRBqJAAgACgCECABNgIIIABB9IMLKAIAEDkhASAAQeSDCygCAEQAAAAAAAAsQEQAAAAAAADwPxBTIQYgAEHogwsoAgBBvugAEE0hAiAAQeyDCygCAEG89AAQTSEEIAEQpAIhAyAAIAEgABD0AkECRkECdCADQQBHQQF0ciAGIAIgBBD3AiEBIAAoAhAgATYCeAJAQfiDCygCACIBRQ0AIAAgARA5IgFFDQAgAS0AAEUNACAAIAEgARCkAkEAR0EBdCAGIAIgBBD3AiEBIAAoAhAgATYCfCAAECsoAhAiASABLQBxQRByOgBxCyAAQYSECygCAEEAQQAQTCEBIAAoAhAiAiABOgCgASAAIAIoAggoAgQoAgARAQAL/wMBB38jAEEgayIEJAACQCAARQ0AIAAtAABFDQBBrIILKAIAIgIEQEGQigstAAANASAEIAI2AhBBAEG03gQgBEEQahAfQZCKC0EBOgAADAELQQAhAkGYigsoAgAhAQJAQZSKCygCAEGkggsoAgBGBEAgASECDAELIAEQGUGUigtBpIILKAIAIgU2AgBBmIoLQQA2AgAgBUUNACAFLQAARQ0AQYjXASEDQQFBCBAdIQICQANAIANBidcBRgRAQQAhAyAFIQEDQCABQYjXARDdAyEHA0AgAUUNBCADQQJqIQYgA0EDdCACIANBAWoiAyAGQQgQiAEiAmogAa0gB61CIIaENwIAIAEgB2ohBkEAIQFBACEHIAYgBRBAIAVqRg0ACyAGQYjXARC1BSAGaiEBDAALAAsgAy0AACEHIANBAWoiAyEBA0AgAS0AACIGRQ0BIAFBAWohASAGIAdHDQALC0HyoQNBjfwAQTRBr/IAEAAAC0GYigsgAjYCAAsgAkUgAC0AAEEvRnJFBEADQCACKAIAIgFFBEBBACEBDAMLIAIoAgQhBSAEIAA2AgwgBEG9kAM2AgggBCABNgIEIAQgBTYCAEGoigtBxDEgBBDXASACQQhqIQJBnH9BqIoLELkOIgFBBEEAEAsQ4QINAAwCCwALIAAhAQsgBEEgaiQAIAELtAEBBH8CQCAAIAFGDQACQCAAKAIQIgIoAvABRQRAIAJBATYC7AEgAiAANgLwAQwBCyAAEJwBIQALAkAgASgCECICKALwAUUEQCACQQE2AuwBIAIgATYC8AEMAQsgARCcASEBCyAAIAFGDQAgACgCECICIAEoAhAiAyACKAKIASADKAKIAUoiBBsiBSABIAAgBBsiADYC8AEgAyACIAQbIgEgASgC7AEgBSgC7AFqNgLsAQsgAAurAQEEfyMAQRBrIgQkAAJAIAAoAgAiA0H/////AEkEQCAAKAIEIANBBHQiBUEQaiIGEDciA0UNASADIAVqIgVCADcAACAFQgA3AAggACADNgIEIAAgACgCACIAQQFqNgIAIAMgAEEEdGoiACACOQMIIAAgATkDACAEQRBqJAAPC0GoqQNBqfwAQc0AQdWvARAAAAsgBCAGNgIAQejeBigCAEHU0QMgBBAiEC8AC5wFAgV/BXwjAEHQAGsiBCQAAkAgACgCEC0AcEEGRg0AAkBB2IULKAIAIgMEQCAAIAMQOS0AAA0BC0HUhQsoAgAiA0UNASAAIAMQOS0AAEUNAQsgACgCEEHkAEHoACABG2ooAgAhBSAAEKYDIgJFBEBBACECDAELIAIoAgAhAwJ8AkAgAUUEQCADKAIIBEAgAysDGCEIIAMrAxAhCSADKAIAIgErAwghByABKwMADAMLIAMoAgAiASsDCCEIIAErAwAhCUEAIQIDQCACQQRGRQRAIAJBBHQiASAEQRBqaiIGIAMoAgAgAWoiASkDADcDACAGIAEpAwg3AwggAkEBaiECDAELCyAEIARBEGpEmpmZmZmZuT9BAEEAEJsBDAELIAMgAigCBEEBa0EwbGoiASgCDARAIAErAyAhCSABKwMoIQggASgCACABKAIEQQR0akEQayIBKwMIIQcgASsDAAwCCyABKAIAIAEoAgRBBHRqQRBrIgIrAwghCCACKwMAIQlBACECA0AgAkEERkUEQCAEQRBqIAJBBHRqIgMgASgCACACIAEoAgRqQQR0akFAaiIGKQMANwMAIAMgBikDCDcDCCACQQFqIQIMAQsLIAQgBEEQakTNzMzMzMzsP0EAQQAQmwELIAQrAwghByAEKwMACyEKIAcgCKEgCiAJoRCkASEHIABB2IULKAIARAAAAAAAADnARAAAAAAAgGbAEFMhCkEBIQIgAEHUhQsoAgBEAAAAAAAA8D9EAAAAAAAAAAAQUyELIAVBAToAUSAFQUBrIAtEAAAAAAAAJECiIgsgByAKRAAAAAAAgGZAo0QYLURU+yEJQKKgIgcQXaIgCKA5AwAgBSALIAcQSKIgCaA5AzgLIARB0ABqJAAgAgvQAQEHfyABKAIQKALIASECA0AgAigCACIBBEAgAUFQQQAgASgCAEEDcUECRxtqKAIoKAIQKAL4ASEFIAAoAhAoAsgBIQQgASgCECIGLgGaASEHA0AgBCgCACIBBEACQAJAIAUgAUFQQQAgASgCAEEDcUECRxtqKAIoKAIQKAL4ASIISARAIAEoAhAhAQwBCyAFIAhHDQEgASgCECIBKwM4IAYrAzhkRQ0BCyABLgGaASAHbCADaiEDCyAEQQRqIQQMAQsLIAJBBGohAgwBCwsgAwuLAQEBfwNAAkAgAkEIRgRAQX8hAgwBCyACQQJ0QcCCBWooAgAgAUYNACACQQFqIQIMAQsLQQAhAQNAAkAgAUEIRgRAQX8hAQwBCyABQQJ0QcCCBWooAgAgAEYNACABQQFqIQEMAQsLQQAhACABIAJyQQBOBH8gAUEFdCACQQJ0akHgggVqKAIABUEACwufDwIJfAh/IwBBMGsiEyQAIAEgAUEwayIPIAEoAgBBA3EiEUECRhsoAighECABKAIQIg4tAFcEQCATQQhqIhIgECABIBFBA0dBMGxqKAIoIA5BOGoiERDvBSARIBJBKBAjGgsgECgCECIRKAIIIg4EfyAOKAIEKAIQBUEACyEUIBErABghBSABKAIQIg5BQGsrAAAhBiAAIA4rADggESsAEKA5AyggACIOQTBqIhEgBiAFoDkDACAAAn8gBARAIAAgASAPIAEoAgBBA3FBAkYbKAIoEMYORBgtRFT7IQlAoCIFOQM4QQEgBUQYLURU+yEZQGMNARpB/cwBQcy1AUHcBEHd9wAQAAALQQAgASgCECIALQBVRQ0AGiAOIAArA0g5AzhBAQs6AEUgAyAOQShqIgQpAwg3AyggAyAEKQMANwMgAkACQAJAAkACQCACQQFrDgIAAQILQQQhACAQKAIQIg8tAKwBDQIgASgCEC0AWSISRQ0CIAMrAxAhBSADKwMAIQYCfCASQQRxBEAgA0EENgIwIA4rAzAhCCADIAY5AzggA0EBNgI0IAMgBTkDSCADIAMrAxg5A1AgA0FAayADKwMIIgUgCCAFIAhjGzkDAEQAAAAAAADwPwwBCyASQQFxBEAgA0EBNgIwIA8rAxggDysDUEQAAAAAAADgv6KgIQoCfCAEKwMAIA8rAxBjBEAgDisDMCEIIBAQKyECIAZEAAAAAAAA8L+gIgYhCSAQKAIQIgArAxAgACsDWKEMAQsgDisDMCEIIBAQKyECIBAoAhAiACsDECAAKwNgoEQAAAAAAAAAAKAhCSAFRAAAAAAAAPA/oCIFCyEHIAArAxghCyACKAIQKAKAAiECIAArA1AhDCADIAc5A2ggAyAIOQNgIAMgCTkDWCADIAg5A1AgAyAFOQNIIAMgBjkDOCADQQI2AjQgAyALIAxEAAAAAAAA4D+ioDkDcCADQUBrIAogAkECbbehOQMARAAAAAAAAPC/DAELIAQhEQJ8IBJBCHEEQCADQQg2AjAgDysDGCEFIA8rA1AhCCAOKwMwIQcgAyAEKwMAOQNIIAMgBzkDQCADIAY5AzggA0EBNgI0IAMgBSAIRAAAAAAAAOA/oqA5A1BEAAAAAAAA8L8MAQsgA0ECNgIwIA8rAxghBiAPKwNQIQggBCsDACEHIA4rAzAhCSADIAU5A0ggAyAJOQNAIAMgBzkDOCADQQE2AjQgAyAGIAhEAAAAAAAA4D+ioDkDUEQAAAAAAADwPwsLIQUgESARKwMAIAWgOQMAA0AgASIAKAIQIgIoAngiAQRAIAItAHANAQsLIAJB1gBBLiAQIABBUEEAIAAoAgBBA3FBAkcbaigCKEYbakEAOgAAIAMgEjYCMAwDCyABKAIQLQBZIg9FDQAgAysDGCEGIAMrAxAhCCADKwMIIQUgAysDACEJIAMCfyAPQQRxBEAgDisDMCEHIAMgCTkDOCAFIAcgBSAHYxshBUQAAAAAAADwPyEHQQEMAQsgD0EBcQRAIAMoAjBBBEYEQCAQKAIQIgArA1AhBSAAKwMYIQYgBCsDACEIIBAQKyEVIBAoAhAiACsDGCEKIBUoAhAoAoACIQIgACsDWCELIAArAxAhDCAAKwNQIQ0gAyAGIAVEAAAAAAAA4D+ioSIGOQNgRAAAAAAAAPC/IQcgAyAJRAAAAAAAAPC/oCIFOQNYIAMgBTkDOCADIAogDUQAAAAAAADgP6KgOQNwIAMgDCALoUQAAAAAAAAAwKA5A2ggBiACQQJtt6EhBUECDAILIA4rAwghByADIAk5AzggBiAHIAYgB2QbIQZEAAAAAAAA8L8hB0EBDAELIBAoAhAiACsDGCIGIAArA1BEAAAAAAAA4D+iIgehIQUgBiAHoCEGRAAAAAAAAPC/IQcgDisDMCIKRAAAAAAAAPC/oCELIAMoAjAhACAEKwMAIQwCQCAPQQhxBEAgAyAJOQM4IAYgCkQAAAAAAADwP6AgAEEERiIAGyEGIAsgBSAAGyEFIAxEAAAAAAAA8D+gIQgMAQsgAyAMRAAAAAAAAPC/oDkDOCALIAUgAEEERiIAGyEFIAYgCiAAGyEGRAAAAAAAAPA/IQcLIAQhEUEBCzYCNCADIAY5A1AgAyAIOQNIIANBQGsgBTkDACARIBErAwAgB6A5AwADQCABIgAoAhAiAigCeCIBBEAgAi0AcA0BCwsgAkHWAEEuIBAgAEFQQQAgACgCAEEDcUECRxtqKAIoRhtqQQA6AAAgAyAPNgIwDAILIAMoAjAhAAsCQCAURQ0AIBAgASgCEEE4aiAAIANBOGogA0E0aiAUEQcAIgBFDQAgAyAANgIwDAELIANBATYCNCADIAMpAwA3AzggAyADKQMYNwNQIAMgAykDEDcDSCADQUBrIgAgAykDCDcDAAJAAkACQCACQQFrDgICAQALIAJBCEcNAkG1kANBzLUBQf0FQd33ABAAAAsgDisDMCEFIAMoAjBBBEYEQCADQUBrIAU5AwAMAgsgAyAFOQNQDAELIA4rAzAhBSADQQQ2AjAgACAFOQMAIA4gBUQAAAAAAADwP6A5AzALIBNBMGokAAuzDwIHfwh8IwBBMGsiCiQAIAEgAUEwaiIIIAEoAgBBA3EiBUEDRhsoAighBiABKAIQIgctAC8EQCAKQQhqIgkgBiABQVBBACAFQQJHG2ooAiggB0EQaiIFEO8FIAUgCUEoECMaCyAGKAIQIgUoAggiBwR/IAcoAgQoAhAFQQALIQcgBSsAGCEMIAEoAhAiCSsAGCENIAAgCSsAECAFKwAQoDkDACAAIA0gDKA5AwgCfyAAAnwgBARAIAEgCCABKAIAQQNxQQNGGygCKBDGDgwBC0EAIAEoAhAiBC0ALUUNARogBCsDIAs5AxBBAQshBCAAIgVBCGohACAFIAE2AlggBUEANgJQIAUgBDoAHSADIAUpAwA3AyAgAyAFKQMINwMoAkACQAJAAkACQCACQQFrDgIAAQILQQEhBCAGKAIQIgAtAKwBDQIgASgCEC0AMSIIRQ0CIAMrAxAhDCADKwMAIQ0CQCAIQQRxBEAgA0EENgIwIAArAxggACsDUEQAAAAAAADgP6KgIRECfCAFKwMAIAArAxBjBEAgBSsDCCEPIAYQKyECIA1EAAAAAAAA8L+gIg0hECAGKAIQIgArAxAgACsDWKEMAQsgBSsDCCEPIAYQKyECIAYoAhAiACsDECAAKwNgoEQAAAAAAAAAAKAhECAMRAAAAAAAAPA/oCIMCyEOIAArAxghEiACKAIQKAKAAiECIAArA1AhEyADIA85A3AgAyAOOQNoIAMgEDkDWCADIAw5A0ggA0FAayAPOQMAIAMgDTkDOCADIBIgE0QAAAAAAADgv6KgOQNgIAMgESACQQJtt6A5A1AgBSAFKwMIRAAAAAAAAPA/oDkDCCADQQI2AjQMAQsgCEEBcQRAIAMrAxghDyADKwMIIRAgA0EBNgIwIAUrAwghDiADIAw5A0ggA0FAayAQOQMAIAMgDTkDOCADQQE2AjQgAyAPIA4gDiAPYxs5A1AgBSAFKwMIRAAAAAAAAPC/oDkDCAwBCyAIQQhxBEAgA0EINgIwIAArAxghDCAAKwNQIQ8gBSsDACEOIAMgBSsDCDkDUCADIA45A0ggAyANOQM4IANBATYCNCADIAwgD0QAAAAAAADgv6KgOQNAIAUgBSsDAEQAAAAAAADwv6A5AwAMAQsgA0ECNgIwIAArAxghDSAAKwNQIQ8gBSsDACEOIAMgBSsDCDkDUCADIAw5A0ggAyAOOQM4IANBATYCNCADIA0gD0QAAAAAAADgv6KgOQNAIAUgBSsDAEQAAAAAAADwP6A5AwALA0AgASIAKAIQIgIoAngiAQRAIAItAHANAQsLIAAgACgCAEEDcUEDR0EwbGooAiggBkYEQCACQQA6AC4MBAsgAkEAOgBWDAMLIAEoAhAtADEiBEUNACADKwMYIQ0gAysDECEPIAMrAwghDCADKwMAIQ4gAwJ/IARBBHEEQCAFKwMIIRAgAyAOOQM4IAwgECAMIBBjGyEMRAAAAAAAAPA/IQ5BAQwBCyAEQQFxBEAgAygCMEEERgRAIAYoAhAiAisDGCEMIAUrAwAhDiACKwNQIQ0gBhArIQsgBigCECICKwMYIRAgCygCECgCgAIhBSACKwNgIREgAisDECESIAIrA1AhEyADIA9EAAAAAAAA8D+gIg85A2ggAyAMIA1EAAAAAAAA4D+ioSINOQNgIAMgDjkDOCADIBAgE0QAAAAAAADgP6KgOQNwIAMgEiARoEQAAAAAAAAAAKA5A1ggDSAFQQJtt6EhDEQAAAAAAADwvyEOQQIMAgsgBSsDCCEQIAMgDjkDOCANIBAgDSAQZBshDUQAAAAAAADwvyEOQQEMAQsgBSsDACEQAnwgBEEIcQRAIAYoAhAiACsDGCENIAUrAwghDyAAKwNQIQwgAyAOOQM4IA9EAAAAAAAA8L+gIA0gDEQAAAAAAADgP6IiEaEgAygCMEEERiIAGyEMIA0gEaAgD0QAAAAAAADwP6AgABshDSAQRAAAAAAAAPA/oCEPRAAAAAAAAPC/DAELIAYoAhAiACsDGCENIAUrAwghESAAKwNQIQwgAyAQOQM4IBEgDSAMRAAAAAAAAOA/oiIQoSADKAIwQQRGIgAbIQwgDSAQoCARRAAAAAAAAPA/oCAAGyENRAAAAAAAAPA/CyEOIAUhAEEBCzYCNCADIA05A1AgAyAPOQNIIANBQGsgDDkDACAAIAArAwAgDqA5AwADQCABIgAoAhAiAigCeCIBBEAgAi0AcA0BCwsgAkEuQdYAIAYgACAAKAIAQQNxQQNHQTBsaigCKEYbakEAOgAAIAMgBDYCMAwCCyADKAIwIQQLAkAgB0UNACAGIAEoAhBBEGogBCADQThqIANBNGogBxEHACIARQ0AIAMgADYCMAwBCyADQQE2AjQgAyADKQMANwM4IAMgAykDGDcDUCADIAMpAxA3A0ggA0FAayADKQMINwMAAkACQAJAIAJBAWsOAgIBAAsgAkEIRw0CQbWQA0HMtQFBtwRByfcAEAAACyAFKwMIIQwgAygCMEEERgRAIANBQGsgDDkDAAwCCyADIAw5A1AMAQsgBSsDCCEMIANBATYCMCADIAw5A1AgBSAMRAAAAAAAAPC/oDkDCAsgCkEwaiQAC8wBAQd/IAEoAhAoAsABIQIDQCACKAIAIgEEQCABIAEoAgBBA3FBA0dBMGxqKAIoKAIQKAL4ASEFIAAoAhAoAsABIQQgASgCECIGLgGaASEHA0AgBCgCACIBBEACQAJAIAUgASABKAIAQQNxQQNHQTBsaigCKCgCECgC+AEiCEgEQCABKAIQIQEMAQsgBSAIRw0BIAEoAhAiASsDECAGKwMQZEUNAQsgAS4BmgEgB2wgA2ohAwsgBEEEaiEEDAELCyACQQRqIQIMAQsLIAMLiQQDB38DfAF+IwBBwAFrIgQkACAEAn8gAwRAIARBIGohBiAEQShqIQcgBEGAAWohCCACDAELIARBKGohBiAEQSBqIQcgBEGAAWohCSACQTBqCyIDKQMINwM4IAQgAykDADcDMCAEQgA3AyggBEKAgICAgICA+D83AyBEAAAAAAAA8D8hCyAEKwMwIQwDQCAEKwM4IQ0gBEEQaiACIAtEAAAAAAAA4D+iIgsgCSAIEJsBIAQgBCkDGCIONwM4IAQgDjcDCCAEIAQpAxAiDjcDMCAEIA43AwACQCAAIAQgAREAAARAIAcgCzkDAEEAIQMDQCADQQRGBEBBASEFDAMFIANBBHQiBSAEQUBraiIKIARBgAFqIAVqIgUpAwg3AwggCiAFKQMANwMAIANBAWohAwwBCwALAAsgBiALOQMACwJAIAwgBCsDMCIMoZlEAAAAAAAA4D9kRQRAIA0gBCsDOKGZRAAAAAAAAOA/ZEUNAQsgBCsDICAEKwMooCELDAELC0EAIQMCQCAFBEADQCADQQRGDQIgAiADQQR0IgBqIgEgBEFAayAAaiIAKQMINwMIIAEgACkDADcDACADQQFqIQMMAAsACwNAIANBBEYNASACIANBBHQiAGoiASAEQYABaiAAaiIAKQMINwMIIAEgACkDADcDACADQQFqIQMMAAsACyAEQcABaiQACyUAIAAgAUG8gwsoAgBB0ucEEE0iAEG89AAgAC0AABsiABBEIAAL3QQCB38IfCMAQUBqIgQkACABECsoAjwoAhAoAnQhBSAEIAEoAhAiBikDGDcDKCAEIAYpAxA3AyAgBEE4aiAEQSBqIAVBA3EiBRDPDiAEIAIoAhAiAikDGDcDGCAEIAIpAxA3AxAgBEEwaiAEQRBqIAUQzw4CQCADLQAhIgdFIAdBD0ZyRQRAAnwgAygCGCICBEAgAisDGCENIAIrAxAhDiACKwMAIQ8gAisDCAwBCyABECshAiABKAIQIgUrA1giCyAFKwNQRAAAAAAAAOA/oiIMIAIoAhAtAHRBAXEiAhshDSAMIAsgAhshDiAMmiIMIAuaIgsgAhshDyALIAwgAhsLIRAgBCgCPCAEKAI0ayEJIAQoAjggBCgCMGshCiAPIA6gRAAAAAAAAOA/oiERIBAgDaBEAAAAAAAA4D+iIRJBACECQQAhBQNAIAJBBEZFBEACQCAHIAJ2QQFxRQ0AIBEhCyAQIQwCQAJ8AkACQAJAAkAgAg4EBQMAAQILIA0hDAwECyAPDAILIARBrCE2AgQgBEGxtQE2AgBB6N4GKAIAQc2rASAEECIQAQALIA4LIQsgEiEMCyAIQQACfyALmUQAAAAAAADgQWMEQCALqgwBC0GAgICAeAsgCmoiBiAGbAJ/IAyZRAAAAAAAAOBBYwRAIAyqDAELQYCAgIB4CyAJaiIGIAZsaiIGIAVOGw0AIAJBAnRBsIIFaigCACEIIAYhBQsgAkEBaiECDAELCyADLQAhIQcMAQsLIAAgAygCJDYCJCABIAMoAhggACAIIAdBABC+BBogBEFAayQACxoBAX8QwwQhAEG7iAstAABBsIgLKAIAIAAbC4QDAQV/IwBBEGsiBCQAAkACQBDwBRDdDk8EQBDdDiIDQQFqIgEgA0EBdEGACCADGyICIAEgAksbIQEQ8AUhBQJAAkACQAJAQbuICy0AAEH+AWsOAgABAgsgA0F/Rg0EQayICygCACECIAFFBEAgAhAZQQAhAgwDCyACIAEQNyICRQ0FIAEgA00NAiACIANqQQAgASADaxA6GgwCCyABQQEQHSICQayICygCACAFECMaDAELIAFBARAdIgJBrIgLIAUQIxpBsIgLIAU2AgALQbuIC0H+AToAAEG0iAsgATYCAEGsiAsgAjYCAAsQ8AUhAQJAEMMEBEAgAUGsiAtqIAA6AABBu4gLQbuICy0AAEEBajoAABDwBUEQSQ0BQbKkA0Hz+wBBoQJB964BEAAAC0GsiAsoAgAgAWogADoAAEGwiAtBsIgLKAIAQQFqNgIACyAEQRBqJAAPC0GoqQNBqfwAQc0AQdWvARAAAAsgBCABNgIAQejeBigCAEHU0QMgBBAiEC8AC4NEAxd/CHwBfiMAQdAGayICJABBkIgLIAAoAhAoAnQiC0EBcSIDOgAAQYyICyALQQNxNgIAAkAgAwRAIAAQ4w4MAQsgABDiDgsgACgCECIDLwGIASELAkAgAy0AcSIDQTZxRQRAIANBAXFFDQFB7IILKAIADQELIAtBDnEhCiAAEBshCEEAIQMDQCAIBEACQCAIKAIQKAJ8IgtFDQAgCy0AUQRAIAZBAWohBgwBCyAHQQFqIQcLIAAgCBAsIQkDQCAJBEACQCAJKAIQIg4oAmwiC0UNACALLQBRBEAgBkEBaiEGDAELIApFDQAgAyAOKAIIQQBHaiEDCwJAIA4oAmQiC0UNACALLQBRBEAgBkEBaiEGDAELIApFDQAgAyAOKAIIQQBHaiEDCwJAIA4oAmgiC0UNACALLQBRBEAgBkEBaiEGDAELIApFDQAgAyAOKAIIQQBHaiEDCwJAIA4oAmAiC0UNACALLQBRBEAgBkEBaiEGDAELIApFDQAgAyAOKAIIQQBHaiEDCyAAIAkQLSEJDAELCyAAIAgQHCEIDAELCyAAKAIQLQBxQQhxBEAgABDhDiEMCyADIAdqIhRFDQAgABA1IAMgBmogDGpqIhNBKBAgIQ4gFEEoECAhCyACQoCAgP7////vQTcDyAYgAkKAgID+////70E3A8AGIAJCgICA/v///+/BADcDuAYgAkKAgID+////78EANwOwBiAAEBshDSALIQggDiEDA0AgDQRAIA0oAhAiBEEoQSBBkIgLLQAAIgcbaisDACEZIAIrA8gGIRwgAisDuAYhGyACKwOwBiEdIAIrA8AGIR4gAyAEQSBBKCAHG2orAwBEAAAAAAAAUkCiIho5AxggAyAZRAAAAAAAAFJAoiIZOQMQIAMgDSgCECIEKQMQNwMAIAMgBCkDGDcDCCADIAMrAwAgGUQAAAAAAADgP6KhIh85AwAgAyADKwMIIBpEAAAAAAAA4D+ioSIgOQMIIAIgHiAZIB+gIhkgGSAeYxs5A8AGIAIgHSAfIB0gH2MbOQOwBiACIBsgICAbICBjGzkDuAYgAiAcIBogIKAiGSAZIBxjGzkDyAYCQCANKAIQKAJ8IgRFDQAgBC0AUQRAIAIgAikDuAY3A8gFIAIgAikDwAY3A9AFIAIgAikDyAY3A9gFIAIgAikDsAY3A8AFIAJBiAZqIAQgA0EoaiIDIAJBwAVqEOwDIAIgAikDoAY3A8gGIAIgAikDmAY3A8AGIAIgAikDkAY3A7gGIAIgAikDiAY3A7AGDAELAkAgBwRAIAggBCsDIDkDACAIIAQrAxg5AwgMAQsgCCAEKQMYNwMAIAggBCkDIDcDCAsgCEEAOgAkIAggBDYCICADIAg2AiAgCEEoaiEICyADQShqIQMgACANECwhCQNAAkACQAJAAkACQCAJBEAgCSgCECIGKAJgIgQEQAJAIAQtAFEEQCACIAIpA7gGNwOoBSACIAIpA8AGNwOwBSACIAIpA8gGNwO4BSACIAIpA7AGNwOgBSACQYgGaiAEIAMgAkGgBWoQ7AMgAiACKQOgBjcDyAYgAiACKQOYBjcDwAYgAiACKQOQBjcDuAYgAiACKQOIBjcDsAYMAQsgCkUNAyAGKAIIRQ0DIAJBiAZqIAAgCRDFDiADQgA3AxggA0IANwMQIAIpA4gGISEgAyACKQOQBjcDCCADICE3AwACQEGQiAstAAAEQCAIIAQrAyA5AwAgCCAEKwMYOQMIDAELIAggBCkDGDcDACAIIAQpAyA3AwgLIAhBADoAJCAIIAQ2AiAgAyAINgIgIAhBKGohCAsgCSgCECEGIANBKGohAwsgBigCaCIHBEACQCAHLQBRBEAgAiACKQO4BjcD+AQgAiACKQPABjcDgAUgAiACKQPIBjcDiAUgAiACKQOwBjcD8AQgAkGIBmogByADIAJB8ARqEOwDIAIgAikDoAY3A8gGIAIgAikDmAY3A8AGIAIgAikDkAY3A7gGIAIgAikDiAY3A7AGDAELIApFDQQgBigCCEUNBAJAIAkQpgMiBEUEQCACQgA3A5AGIAJCADcDiAYMAQsgBCgCACIEKAIIBEAgAiAEKQMYNwOQBiACIAQpAxA3A4gGDAELIAIgBCgCACIEKQMINwOQBiACIAQpAwA3A4gGCyADQgA3AxAgA0IANwMYIAIpA4gGISEgAyACKQOQBjcDCCADICE3AwACQEGQiAstAAAEQCAIIAcrAyA5AwAgCCAHKwMYOQMIDAELIAggBykDGDcDACAIIAcpAyA3AwgLIAhBADoAJCAIIAc2AiAgAyAINgIgIAhBKGohCAsgCSgCECEGIANBKGohAwsgBigCZCIHBEACQCAHLQBRBEAgAiACKQO4BjcDyAQgAiACKQPABjcD0AQgAiACKQPIBjcD2AQgAiACKQOwBjcDwAQgAkGIBmogByADIAJBwARqEOwDIAIgAikDoAY3A8gGIAIgAikDmAY3A8AGIAIgAikDkAY3A7gGIAIgAikDiAY3A7AGDAELIApFDQUgBigCCEUNBQJAIAkQpgMiBEUEQCACQgA3A5AGIAJCADcDiAYMAQsgBCgCACAEKAIEQQFrQTBsaiIEKAIMBEAgAiAEKQMoNwOQBiACIAQpAyA3A4gGDAELIAIgBCgCACAEKAIEQQR0akEQayIEKQMINwOQBiACIAQpAwA3A4gGCyADQgA3AxAgA0IANwMYIAIpA4gGISEgAyACKQOQBjcDCCADICE3AwACQEGQiAstAAAEQCAIIAcrAyA5AwAgCCAHKwMYOQMIDAELIAggBykDGDcDACAIIAcpAyA3AwgLIAhBADoAJCAIIAc2AiAgAyAINgIgIAhBKGohCAsgCSgCECEGIANBKGohAwsgBigCbCIERQ0FAkAgBC0AUQRAIAIgAikDuAY3A5gEIAIgAikDwAY3A6AEIAIgAikDyAY3A6gEIAIgAikDsAY3A5AEIAJBiAZqIAQgAyACQZAEahDsAyACIAIpA6AGNwPIBiACIAIpA5gGNwPABiACIAIpA5AGNwO4BiACIAIpA4gGNwOwBgwBCyAKRQ0FIAYoAghFDQUgAkGIBmogACAJEMUOIANCADcDGCADQgA3AxAgAikDiAYhISADIAIpA5AGNwMIIAMgITcDAAJAQZCICy0AAARAIAggBCsDIDkDACAIIAQrAxg5AwgMAQsgCCAEKQMYNwMAIAggBCkDIDcDCAsgCEEAOgAkIAggBDYCICADIAg2AiAgCEEoaiEICyADQShqIQMMBQsgACANEBwhDQwHCyACIAQoAgA2ApAFQQBBx94DIAJBkAVqEB8MAwsgAiAHKAIANgLgBEEAQZ7eAyACQeAEahAfDAILIAIgBygCADYCsARBAEHr3gMgAkGwBGoQHwwBCyACIAQoAgA2AoAEQQBB+d0DIAJBgARqEB8LIAAgCRAtIQkMAAsACwsgDARAIAIgAikDyAY3A6AGIAIgAikDwAY3A5gGIAIgAikDuAY3A5AGIAIgAikDsAY3A4gGIAIgAzYCqAYgAkHYA2oiByACQYgGaiIEQSgQIxogAkHgBWoiAyAAIAcQ4A4gBCADQSgQIxogAiACKQOQBjcDuAYgAiACKQOYBjcDwAYgAiACKQOgBjcDyAYgAiACKQOIBjcDsAYLQQAhCCAAIABBAEG7LEEAECRBARC8DiEDIAIgAikDuAY3A5AGIAIgAikDwAY3A5gGIAIgAikDyAY3A6AGIAIgAzoAqAYgAiACKQOwBjcDiAYgAkGIBmohBCMAQdAAayIFJABBHBDcASIPQdj/CUH8vQooAgAQfSIRNgIUAkACQAJAAkACQAJAAkAgEQRAQQFBgA8QWiISBEAQqAgiA0EANgIEIBIgAzYCAAsgDyASNgIYIBJFDQYgDyAENgIQIA8gFDYCDCAPIAs2AgggDyATNgIEIA8gDjYCAAJ/IAIrA5gGIAIrA6AGEDMQ4wIQzwecIhlEAAAAAAAA8EFjIBlEAAAAAAAAAABmcQRAIBmrDAELQQALQQFqIQQCQANAIBAgE0YNAUEgENwBIgYgDiAQQShsaiIMNgIcAn8CfCAMKAIgIgNFBEBEAAAAAAAAAAAhHEQAAAAAAAAAAAwBCyADKwMIIRwgAysDAAsiHSAMKwMAIh4gDCsDEKCgmyIZmUQAAAAAAADgQWMEQCAZqgwBC0GAgICAeAshCgJ/IAwrAwgiGiAcoZwiGZlEAAAAAAAA4EFjBEAgGaoMAQtBgICAgHgLIQ0gCkH/////B0chFQJ/IB4gHaGcIhmZRAAAAAAAAOBBYwRAIBmqDAELQYCAgIB4CyEHIBVFDQMCfyAcIBogDCsDGKCgmyIZmUQAAAAAAADgQWMEQCAZqgwBC0GAgICAeAsiA0H/////B0YNBCAGIAc2AgwgBiADNgIYIAYgCjYCFCAGIA02AhAgAyANa0ECbSANaiEDIAogB2tBAm0gB2ohCUEAIQwgBCEHA0AgB0EASgRAIAkgB0EBayIHdkEBcSIKQQF0IAxBAnRyIAogAyAHdkEBcSINc3IhDCANQQFrIg1BACAKa3EgDSADIAlzcXMiDSADcyEDIAkgDXMhCQwBCwsgBiAMNgIIIBBBAWohECARIAZBASARKAIAEQMADQALDAYLIBFBAEGAASARKAIAEQMAIQcDQCAHBEAgBygCHCENQQAhECMAQTBrIgwkACAMQQA2AiwCQAJAIAdBDGoiCkUgEkVyRQRAIBIoAgAiBCgCBEEASA0BAkACQANAIBBBAkYEQCASIAogDSAEIAxBLGpBABDmDg0CDAMLIBBBAnQhFiAQQQFqIRAgFiAKaiIDKAIAIAMoAghMDQALQZ7AAUH1sgFBwAFBnBsQAAALEKgIIg0gEigCACIDKAIEQQFqNgIEIAxBGGoiBCADEPQFIAwgEigCADYCKCASIAQgDUEAEMQEGiAMQQhqIAwoAiwQ9AUgDCAMKQIQNwMgIAwgDCkCCDcDGCAMIAwoAiw2AiggEiAEIA1BABDEBBogEiANNgIACyAMQTBqJAAMAgtBneoAQfWyAUG9AUGcGxAAAAtB1e4AQfWyAUG+AUGcGxAAAAsgESAHQQggESgCABEDACEHDAELC0EAIQMgERByIQcDQCAREHIEQCARKAIIKAIEIg1FDQUCfyARKAIEKAIIIgRBAEgEQCANKAIIDAELIA0gBGsLIgRFDQUgESAEQYAgIBEoAgARAwAaIAQQGSADQQFqIQMMAQsLIAMgB0cNBCAREHNBAEgNBUEAIQxBACEJA0AgCSATRgRAIBIoAgAQ6A4gEigCABAZIBIQGSAPEBkMBwUCfyAOIAlBKGxqIgYoAiAiCgRAIAYrAxAhHiAGKwMYIRwgCisDCCEbIAorAwAhHSAFQSBqIgRBAEEkEDoaIAogBisDACAdoTkDECAKIBwgBisDCKA5AxggBSAPIAYgBBD2AQJAAkACQCAFKAIAIgNFDQAgBSsDGCEfIAUrAxAhICAFKwMIIRkgCiAGKwMIOQMYIAUgDyAGIAQQ9gEgBSgCACIERQ0AIBkgBSsDCCIaZARAIAUrAxghHyAFKwMQISAgGiEZIAQhAwsgCiAGKwMIIAorAwihOQMYIAUgDyAGIAVBIGoQ9gEgBSgCACIERQ0AIBkgBSsDCCIaZARAIAUrAxghHyAFKwMQISAgGiEZIAQhAwsgCiAGKwMAOQMQIAogBisDCCAGKwMYoDkDGCAFIA8gBiAFQSBqEPYBIAUoAgAiBEUNACAZIAUrAwgiGmQEQCAFKwMYIR8gBSsDECEgIBohGSAEIQMLIAogBisDCCAKKwMIoTkDGCAFIA8gBiAFQSBqEPYBIAUoAgAiBEUNACAZIAUrAwgiGmQEQCAFKwMYIR8gBSsDECEgIBohGSAEIQMLIAogBisDACAGKwMQoDkDECAKIAYrAwggBisDGKA5AxggBSAPIAYgBUEgahD2ASAFKAIAIgRFDQAgGSAFKwMIIhpkBEAgBSsDGCEfIAUrAxAhICAaIRkgBCEDCyAKIAYrAwg5AxggBSAPIAYgBUEgahD2ASAFKAIAIgRFDQAgGSAFKwMIIhpkBEAgBSsDGCEfIAUrAxAhICAaIRkgBCEDCyAKIAYrAwggCisDCKE5AxggBSAPIAYgBUEgahD2ASAFKAIAIgRFDQAgGSAFKwMIIhpkBEAgBSsDGCEfIAUrAxAhICAaIRkgBCEDCyAdIB2gIB6gRAAAAAAAAMA/oiEdIBsgG6AgHKBEAAAAAAAA4D+iIR4CQCAFKAIgIhAgBSgCPCINIAUoAjhyIAUoAiwiByAFKAJAIgRycnJFBEAgBisDCCEbQQAhEAwBCyAGKwMIIRsgBCANcgR/IAcFIAogBisDACIcIAorAwChIho5AxAgCiAbIAYrAxigOQMYA0AgHCAGKwMQoCAaZgRAIAUgDyAGIAVBIGoQ9gEgBSgCACIERQ0EIBkgBSsDCCIaZARAIAUrAxghHyAFKwMQISAgGiEZIAQhAwsgCiAdIAorAxCgIho5AxAgBisDACEcDAELCyAGKwMIIRsgBSgCICEQIAUoAiwLIBByDQAgCiAGKwMAIAorAwChOQMQIBsgBisDGKAhHANAAkAgCiAcOQMYIBwgGyAKKwMIoWZFDQAgBSAPIAYgBUEgahD2ASAFKAIAIgRFDQMgGSAFKwMIIhpkBEAgBSsDGCEfIAUrAxAhICAaIRkgBCEDCyAKKwMYIB6hIRwgBisDCCEbDAELCyAFKAIgIRALIAogBisDACIcIAYrAxCgIho5AxAgCiAbIAorAwihOQMYAkAgBSgCQCINIAUoAiQiBCAFKAIociAFKAI0IgcgEHJyckUNACAEIBByBH8gDQUDQCAcIAorAwChIBplBEAgBSAPIAYgBUEgahD2ASAFKAIAIgRFDQQgGSAFKwMIIhpkBEAgBSsDGCEfIAUrAxAhICAaIRkgBCEDCyAKIAorAxAgHaEiGjkDECAGKwMAIRwMAQsLIAUoAjQhByAFKAJACyAHcg0AIAogHCAGKwMQoDkDECAGKwMIIhsgCisDCKEhHANAIAogHDkDGCAcIBsgBisDGKBlRQ0BIAUgDyAGIAVBIGoQ9gEgBSgCACIERQ0CIBkgBSsDCCIaZARAIAUrAxghHyAFKwMQISAgGiEZIAQhAwsgHiAKKwMYoCEcIAYrAwghGwwACwALIAMNAQsgBigCICEHDAELIBlEAAAAAAAAAABhBEAgBigCICIHICA5AxAgByAfOQMYDAELQQEgAi0AqAZBAUcNAhogBigCICIHICA5AxAgByAfOQMYCyAHQQE6ACQLIAwLIQwgCUEBaiEJDAELAAsACwwFC0HwxAFBp7UBQdkBQd0sEAAAC0HVxAFBp7UBQdsBQd0sEAAAC0GHO0GntQFBqgRB7qwBEAAAC0GArAFBp7UBQbEEQe6sARAAAAsgBUHQAGokAAwBC0HdwQNBDkEBQejeBigCABBGGhAvAAsCQEGoggstAABFDQAgAiACKwOIBjkDsAMgAiACKwOQBjkDuAMgAiACKwOYBjkDwAMgAiACKwOgBjkDyAMgAiATNgKgAyACIBQ2AqQDIAIgAi0AqAY2AqgDQejeBigCACIHQfvXBCACQaADahAxQaiCCy0AAEECSQ0AQZbNA0EIQQEgBxBGGkEAIQkgDiEDA0AgCSATRgRAQeHQA0EIQQEgBxBGGkEAIQkgCyEDA0AgCSAURg0DIAMrAxghHSADLQAkIQQgAysDECEeIAMrAwAhGiADKwMIIRkgAiADKAIgKAIANgLgAiACIBk5A9gCIAIgGjkD0AIgAiAdOQPIAiACIB45A8ACIAIgBDYCuAIgAiADNgK0AiACIAk2ArACIAdBhOoDIAJBsAJqEDEgA0EoaiEDIAlBAWohCQwACwAFIAMrAxghHSADKwMQIR4gAysDCCEaIAMrAwAhGSACIAMoAiAiBAR/IAQoAiAoAgAFQdLnBAs2ApwDIAIgBDYCmAMgAiAdOQOQAyACIB45A4gDIAIgGjkDgAMgAiAZOQP4AiACIAk2AvACIAdBud8EIAJB8AJqEDEgA0EoaiEDIAlBAWohCQwBCwALAAsgCyEDQQAhCQJAA0AgCSAURgRAQaiCCy0AAARAIAIgFDYCpAIgAiAINgKgAkHo3gYoAgBB48wEIAJBoAJqECIMAwsFIAMtACQEQCADKAIgIgRBAToAUSADKwMQIRogAysDACEZIARBQGsgAysDGCADKwMIRAAAAAAAAOA/oqA5AwAgBCAaIBlEAAAAAAAA4D+ioDkDOCAAIAQQhwIgCEEBaiEICyAJQQFqIQkgA0EoaiEDDAELCyAIIBRGDQAgAiAUNgKUAiACIAg2ApACQQBBhs0EIAJBkAJqEB8LIA4QGSALEBkLRAAAAAAAAAAAIR0CQCAAKAIQIgMoAgwiCUUEQEQAAAAAAAAAACEbDAELRAAAAAAAAAAAIRsgCS0AUQ0AIAMtAJcCQQFxIQ4gCSsDGEQAAAAAAAAwQKAhHSAJKwMgRAAAAAAAACBAoCEbQZCICy0AAARAAkAgDgRAIAMgGyADKwMgoDkDIAwBCyADIAMrAxAgG6E5AxALIB0gAysDKCIeIAMrAxgiGqEiGWRFDQEgAyAeIB0gGaFEAAAAAAAA4D+iIhmgOQMoIAMgGiAZoTkDGAwBC0GMiAsoAgAhCwJAIA4EQCALRQRAIAMgGyADKwMooDkDKAwCCyADIAMrAxggG6E5AxgMAQsgC0UEQCADIAMrAxggG6E5AxgMAQsgAyAbIAMrAyigOQMoCyAdIAMrAyAiHiADKwMQIhqhIhlkRQ0AIAMgHiAdIBmhRAAAAAAAAOA/oiIZoDkDICADIBogGaE5AxALAkAgAUUNAAJAAkACQAJAAkACQEGMiAsoAgAiAQ4EBAABAgMLIAMrAyghGUGgiAsgAysDECIaOQMAQZiICyAZmiIeOQMADAQLIAMrAyghGUGYiAsgAysDECIeOQMAQaCICyAZmiIaOQMADAMLIAMrAxghHkGgiAsgAysDECIaOQMAQZiICyAeOQMADAILIAJBoAU2AmQgAkGFugE2AmBB6N4GKAIAQc2rASACQeAAahAiEAEAC0GYiAsgAykDEDcDAEGgiAsgAykDGDcDAEGYiAsrAwAhHkGgiAsrAwAhGgsgASAeRAAAAAAAAAAAYnJFIBpEAAAAAAAAAABhcQ0AIAAQGyEMA0AgDARAQYyICygCAARAIAxBABC5BAsgAiAMKAIQIgEpAxg3A4gCIAIgASkDEDcDgAIgAkGIBmoiAyACQYACahDiASABIAIpA5AGNwMYIAEgAikDiAY3AxAgDCgCECgCfCILBEAgAiALQUBrIgEpAwA3A/gBIAIgCykDODcD8AEgAyACQfABahDiASABIAIpA5AGNwMAIAsgAikDiAY3AzgLAkBB6IILKAIAQQFHDQAgACAMECwhBwNAIAdFDQFBACEIAkAgBygCECIDKAIIIglFBEBB0IILLQAADQEgAy0AcEEGRg0BIAcgBygCAEEDcUEDR0EwbGooAigQISEBIAIgB0FQQQAgBygCAEEDcUECRxtqKAIoECE2AnQgAiABNgJwQQFB35YEIAJB8ABqEB8MAQsDQCAJKAIEIAhKBEBBACEDIAhBMGwiFCAJKAIAaiITKAIEIgFBACABQQBKGyEEIBMoAgwhGCATKAIIIRcgEygCACEBA0AgAyAERwRAIAIgASADQQR0aiITKQMINwOoASACIBMpAwA3A6ABIAJBiAZqIAJBoAFqEOIBIBMgAikDkAY3AwggEyACKQOIBjcDACADQQFqIQMMAQsLIAcoAhAhAyAXBEAgAiADKAIIKAIAIBRqIgEpAxg3A5gBIAIgASkDEDcDkAEgAkGIBmogAkGQAWoQ4gEgASACKQOQBjcDGCABIAIpA4gGNwMQIAcoAhAhAwsgCEEBaiEIIBgEQCACIAMoAggoAgAgFGoiASkDKDcDiAEgAiABKQMgNwOAASACQYgGaiACQYABahDiASABIAIpA5AGNwMoIAEgAikDiAY3AyAgBygCECEDCyADKAIIIQkMAQsLIAMoAmAiCwRAIAIgC0FAayIBKQMANwPoASACIAspAzg3A+ABIAJBiAZqIAJB4AFqEOIBIAEgAikDkAY3AwAgCyACKQOIBjcDOCAHKAIQIQMLIAMoAmwiCwRAIAIgC0FAayIBKQMANwPYASACIAspAzg3A9ABIAJBiAZqIAJB0AFqEOIBIAEgAikDkAY3AwAgCyACKQOIBjcDOCAHKAIQIQMLIAMoAmQiCwR/IAIgC0FAayIBKQMANwPIASACIAspAzg3A8ABIAJBiAZqIAJBwAFqEOIBIAEgAikDkAY3AwAgCyACKQOIBjcDOCAHKAIQBSADCygCaCIDRQ0AIAIgA0FAayIBKQMANwO4ASACIAMpAzg3A7ABIAJBiAZqIAJBsAFqEOIBIAEgAikDkAY3AwAgAyACKQOIBjcDOAsgACAHEC0hBwwACwALIAAgDBAcIQwMAQsLIAAgACgCECgCdEEDcRDkDiAAKAIQIgMoAgwhCQsCQCAJRQ0AIAktAFENAAJ8IAMtAJcCIgFBBHEEQCADKwMgIB1EAAAAAAAA4L+ioAwBCyAdRAAAAAAAAOA/oiADKwMQIhmgIAFBAnENABogGSADKwMgoEQAAAAAAADgP6ILIRogG0QAAAAAAADgP6IhGQJ8IAFBAXEEQCADKwMoIBmhDAELIBkgAysDGKALIRkgCSAaOQM4IAlBQGsgGTkDACAAKAIQKAIMQQE6AFELQcSCCygCAARAIAJCADcDkAYgAkIANwOIBgJAQZCICy0AAARAIAJBmIgLKwMAIho5A1AgAkGgiAsrAwAiGTkDWCACIBo5A0AgAiAZOQNIIAJBiAZqQcCGBCACQUBrEGIMAQsgAkGgiAsrAwAiGjkDICACQZiICysDACIZOQMoIAIgGZo5AzAgAiAamjkDOCACIBo5AxAgAiAZOQMYIAJBiAZqQaWABCACQRBqEGILAkAgAkGIBmoiABApBEAgACAAECUQrgIhBgwBCyACLQCXBkH/AUYEQCACKAKIBiACQYgGahAlEK4CIQYMAQsgAkGIBmoiABAlIAAQQk8EQCAAQQEQtQELIAJBiAZqIgEQJSEAIAEQKQRAIAAgAWpBADoAACACIAItAJcGQQFqOgCXBiABECVBD00EQCACKAKIBiEGDAILQbKkA0Hz+wBBoQJB964BEAAACyACKAKIBiIGIABqQQA6AAALAkBBxIILKAIAIgNByIILKAIARwRAQcCCCygCACEJDAELAkAgAiADQQF0QQEgAxsiAUH/////A0sEf0HEAAVBwIILKAIAIAFBAnQQNyIJDQFBMAsQuQE2AgBB6N4GKAIAQb3oAyACECIQLwALIAlByIILKAIAIgBBAnRqQQAgASAAa0ECdBA6GkHIggsgATYCAEHAggsgCTYCAEHEggsoAgAhAwsgCSADQQJ0aiAGNgIAQcSCCyADQQFqNgIACyACQdAGaiQAC68BAQJ8IAACfyABKAIgIgErAxAiAplEAAAAAAAA4EFjBEAgAqoMAQtBgICAgHgLNgIAIAACfyABKwMYIgOZRAAAAAAAAOBBYwRAIAOqDAELQYCAgIB4CzYCBCAAAn8gAiABKwMAoCICmUQAAAAAAADgQWMEQCACqgwBC0GAgICAeAs2AgggAAJ/IAMgASsDCKAiAplEAAAAAAAA4EFjBEAgAqoMAQtBgICAgHgLNgIMC6EBAQR/IwBBEGsiAyQAAkAgAQRAIAAQ7A5BASEFA0AgBEHAAEYNAiABIARBFGxqIgIoAhgEQCACQQhqIQICQCAFBEAgACACKQIANwIAIAAgAikCCDcCCAwBCyADIAAgAhD1AiAAIAMpAgg3AgggACADKQIANwIAC0EAIQULIARBAWohBAwACwALQaLqAEHWuQFB1ABBkzYQAAALIANBEGokAAvwAQEFfyMAQRBrIgUkACAAQQhqIgYgAUECdCIDakG0DGoiBygCAEUEQCAAQbgKaiIEIANqIAI2AgAgB0EBNgIAIAQgAkEEdGpBkARqIQMCQCAEIAJBAnRqIgRBiARqKAIARQRAIAMgBiABQRRsaiIBKQIANwIAIAMgASkCCDcCCAwBCyAFIAYgAUEUbGogAxD1AiADIAUpAgg3AgggAyAFKQIANwIACyAAQbgKaiIAIAJBA3RqIAAgAkEEdGpBkARqEPYCNwOwBCAEIAQoAogEQQFqNgKIBCAFQRBqJAAPC0H7vwFBkrYBQd0BQd4NEAAACzIAIABBABC4AwJAIAAQKQRAIABBADoADwwBCyAAQQA2AgQLIAAQKQR/IAAFIAAoAgALCzMAIAAoAgAQGSAAKAIEEBkgACgCCBAZIAAoAhAQGSAAKAIMEBkgACgCFBAZIAAoAhgQGQvBAQEBfwJ/IAAoAhAiAigC0AFFBEBBACACLQCEAkEBcUUNARoLIAAQigIgAigC0AELIgAgASgCAEcEQCAAEBkgAiABKAIANgLQAQsgAigC5AEiACABKAIERwRAIAAQGSACIAEoAgQ2AuQBCyACKAL0ASIAIAEoAghHBEAgABAZIAIgASgCCDYC9AELIAIoAtQBIgAgASgCDEcEQCAAEBkgAiABKAIMNgLUAQsgAiABLQAQIAIvAYQCQf7/A3FyOwGEAgvxAgECfyMAQUBqIgUkACAAKAIQIQYgBUIANwM4IAVCADcDMCAEIAYoAtABNgIAIAQgBigC5AE2AgQgBCAGKAL0ATYCCCAEIAYoAtQBNgIMIAQgBi0AhAJBAXE6ABACQCACKAIQIgQEQCAELQAADQELIAEoAjwiBEUEQCAAIAYoAgggBUEwahDOCBBmIQQgAUEBOgBAIAEgBDYCPAtB8IYLQfCGCygCACIBQQFqNgIAIAUgBDYCICAFIAE2AiQgBUEwaiIBQaCtASAFQSBqENcBIAEQ5AEhBAsgAEEAIAIoAgAgAigCDCACKAIIIAQgBigCCBCzDyEBIAVBMGoQgAECQCABRQ0AIAYoAtABRQRAIAYtAIQCQQFxRQ0BCyAFIAMpAxg3AxggBSADKQMQNwMQIAUgAykDCDcDCCAFIAMpAwA3AwAgACAFEIQGIAAgBigC0AEgBigC5AEgBigC9AEgBigC1AEQsgELIAVBQGskACABC2ABA39BEBBOIQRBtIYLKAIAIgUoAlQiA0EAQYACIAMoAgARAwAoAgghAyAEIAA2AgggAyAEQQEgAygCABEDABogACACOgBcIAUtAHBBAnEEQCAAQQE6AGQLIAAgATYCWAvbBQEJfyMAQTBrIgIkACACQQA2AghByMIKQQFByMIKKAIAQQFqIgUgBUEBTRs2AgAgAkIANwMAIAAoAhAiBUEANgLoASAFQQA2AtwBIAAQGyEFIAFBAEwhCQNAIAUEQAJAAkACQCAJDQAgBSgCECIBKALoASIDRQ0AIAMoAhAoApACIAEoAvQBQQJ0aigCACEBDAELIAUiARCcASABRw0BCyABKAIQKAKwAUHIwgooAgBGDQAgACgCEEEANgLAAUHMwgpBADYCACACIAEQmg8DQAJAIAIoAgQiAUUNACACKAIAIAFBAWsiAUECdGooAgAhAyACIAE2AgQgA0UNAEHIwgooAgAiBiADKAIQIgEoArABRg0BIAAoAhAiBCAEKALoAUEBajYC6AEgASAGNgKwAQJ/QczCCigCACIGBEAgBigCEEG4AWoMAQsgBEHAAWoLIAM2AgAgASAGNgK8AUHMwgogAzYCACABQQA2ArgBIAIgAygCECIBKQPIATcDECACIAEpA8ABNwMYIAIgASkD0AE3AyAgAiABKQPYATcDKEEDIQYDQCAGQQBIDQICQCACQRBqIAZBA3RqIgEoAgAiBEUNACAEIAEoAgRBAWsiB0ECdGohBANAIAdBf0YNASADIAQoAgAiCEFQQQAgCCgCAEEDcSIKQQJHG2ooAigiAUYEQCAIIApBA0dBMGxqKAIoIQELAkAgASgCECgCsAFByMIKKAIARg0AIAEQnAEgAUcNACACIAEQmg8LIARBBGshBCAHQQFrIQcMAAsACyAGQQFrIQYMAAsACwsgACgCECIDIgFB3AFqIAEoAtwBIgRBAWoiATYCACABQQJ0IQECfyADKALYASIDBEAgAyABEJMBDAELIAEQeAshASAAKAIQIgMgATYC2AEgASAEQQJ0aiADKALAATYCAAsgACAFEBwhBQwBCwsgAkEANgIEIAIoAgAQGSACQTBqJAALRAEBfyMAQRBrIgEkAEGMhgsoAgBFBEBBjIYLQQE2AgAgARDACDYCBCABIAA2AgBBAUHb4wQgARAfEJ8PCyABQRBqJAALqQMCA38CfAJAIABB+e8AECciAUUNACABLQAARQ0AIAAoAjwoAhAiAiACLQBxQQhyOgBxIAAgASABEKQCQQBHQQF0IAAgAEEAQbqFAUEAECREAAAAAAAALEBEAAAAAAAA8D8QUyAAIABBAEGElQFBABAkQb7oABBNIAAgAEEAQbU1QQAQJEG89AAQTRD3AiEBIAAoAhAgATYCDCAAQcyvARAnIQICfyAAEDQgAEcEQCACBEBBACACLQAAQeIARg0CGgtBAQwBCyACBEBBASACLQAAQfQARg0BGgtBAAshAQJAIABBsxgQJyICRQ0AIAItAAAiAkHyAEcEQCACQewARw0BIAFBAnIhAQwBCyABQQRyIQELIAAoAhAgAToAlwIgABA0IABGDQAgACgCECgCDCIBKwMYRAAAAAAAADBAoCEEIAErAyBEAAAAAAAAIECgIQUgABA0IQMgACgCECIALQCXAiEBIAMoAhAtAHRBAXFFBEAgACABQQV0QSBxaiIAIAU5AzggACAEOQMwDwsgAEEQQTAgAUEBcRtqIgAgBDkDOCAAIAU5AzALC4wDAQN/IAEgAUEwaiIDIAEoAgBBA3FBA0YbKAIoKAIQIgIoAtABIAIoAtQBIgJBAWogAkECahDGASECIAEgAyABKAIAQQNxQQNGGygCKCgCECACNgLQASABIAMgASgCAEEDcUEDRhsoAigoAhAiAkHUAWogAigC1AEiBEEBajYCACACKALQASAEQQJ0aiABNgIAIAEgAyABKAIAQQNxQQNGGygCKCgCECIDKALQASADKALUAUECdGpBADYCACABIAFBMGsiAyABKAIAQQNxQQJGGygCKCgCECICKALYASACKALcASICQQFqIAJBAmoQxgEhAiABIAMgASgCAEEDcUECRhsoAigoAhAgAjYC2AEgASADIAEoAgBBA3FBAkYbKAIoKAIQIgJB3AFqIAIoAtwBIgRBAWo2AgAgAigC2AEgBEECdGogATYCACABIAMgASgCAEEDcUECRhsoAigoAhAiASgC2AEgASgC3AFBAnRqQQA2AgAgACgCEEEBOgD0ASAAEFsoAhBBAToA9AELNQEBfCAAIAArAxAiATkDMCAAIAE5AyAgACAAKwMIOQM4IAAgACsDADkDECAAIAArAxg5AygLgQQCBX8DfCMAQfAAayIJJAAgACgCmAEhCyAJQgA3AzggCUIANwMwAkAgAUUNACABLQBRRQ0AIAcEQEH57wAhCgJAAkACQAJAIAJBBmsOBgACAQEBAwELQdTvACEKDAILIAlB2xQ2AhQgCUHEtAE2AhBB6N4GKAIAQc2rASAJQRBqECIQAQALQd7vACEKCyAJIAo2AiQgCSAHNgIgIAlBMGoiB0GwMiAJQSBqEPIDIAcQ8QMhCgsgACgCECIHKAIMIQwgByACNgIMIAtBBHEiByADIARyIgNFckUEQCAAIAEQpA8gACAEIAUgBiAKELIBCyADQQBHIQ0gACACIAEQrgMCQCAIRQ0AIAEoAgAhAgNAIAIsAAAiC0UNASACQQFqIQIgCxCjAQ0ACyABKwM4IQ4gASsDGCEPIAkgAUFAayICKwMAIAErAyBEAAAAAAAA4D+ioSIQOQNYIAkgEDkDSCAJIA4gD0QAAAAAAADgP6KgIg45A0AgCSAOIA+hOQNQIAkgAikDADcDCCAJIAEpAzg3AwAgCUHgAGogCCAJELgOIAAgACgCACgCyAIQ2QEgACABKAIIEEQgACAJQUBrQQMQNgsgDQRAIAcEQCAAIAEQpA8gACAEIAUgBiAKELIBCyAAEIoCCyAJQTBqEIABIAAoAhAgDDYCDAsgCUHwAGokAAuGAQEBfyAAKAIQQcABaiICIQADQCAAKAIAIgBFIAAgAUZyRQRAIAAoAhBBuAFqIQAMAQsLIAAEQCABKAIQIgAoArgBIgEEQCABKAIQIAAoArwBNgK8AQsgACgCvAEiAAR/IAAoAhBBuAFqBSACCyABNgIADwtBj5QDQey1AUHBAUGnnAEQAAAL3g0BDH8jAEGQAmsiBCQAIAJBCHEhDiACQQRxIQpBASELA0ACQAJAAkAgASgCECIDKAK0ASALTgRAIAMoArgBIAtBAnRqKAIAIQUCQCAAKAKcAUECSA0AIAAgBSAFQQBBjTZBABAkQdLnBBB3IgMQygQNACADLQAADQQgBRAbIQMDQCADRQ0FIAAgBSADEKoPDQEgBSADEBwhAwwACwALIAoEQCAAIAUgAhCCBgtBASEMIAAQzwQiA0EBNgIMIAMgBTYCCCADQQE2AgQgACAFKAIQKAIMIAUQyQgCQCAAKAI8IgNFDQAgAygCICIDRQ0AIAAgAxEBAAsgACgCECIJKALQAUUEQCAJLQCEAkEBcSEMCyAFQeGUARAnEIgGIAogDEVyRQRAIAQgBSgCECIDKQMoNwOoASAEIAMpAyA3A6ABIAQgAykDGDcDmAEgBCADKQMQNwOQASAAIARBkAFqEIQGIAAgCSgC0AEgCSgC5AEgCSgC9AEgCSgC1AEQsgELQQAhBiAEQQA2AowCIAUgBEGMAmoQqw8iAwRAIAAgAxDZASAEKAKMAkEBcSEGC0GIgwshB0GEgwshCCAFKAIQLQBwIgNBAXEEQEHysQEhBkHBhAMhAwwCCyADQQJxBEBBpd0BIQZBloYDIQMMAgsgA0EIcQRAQcCDAyEGQZiDCyEHQciDAyEDQZSDCyEIDAILIANBBHEEQEGd3QEhBkGQgwshB0G/hgMhA0GMgwshCAwCCyAFQdQ1ECciAwR/IANBACADLQAAGwVBAAsiByEIIAVBvzUQJyIDBEAgAyAHIAMtAAAbIQgLIAVByDUQJyIDBEAgAyAHIAMtAAAbIQcLQQEhAyAGIAdBAEdxDQIgBUHSNRAnIg1FBEAgBiEDDAMLQQEgBiANLQAAIgYbIQMgDSAHIAYbIQcMAgsgBEGQAmokAA8LIAUgCCgCACADEE0hCEEBIQMgBSAHKAIAIAYQTSEHCyAEQQA2ArgBIAdB7A0gBxshBgJ/QQAgA0UNABogBiAEQbgBaiAEQbQBahDMBARAIAAgBCgCuAEQVCAAIAQoArwBIgNBvPQAIAMbIAVBqIMLKAIAQQBBABBMIAQqArQBEIEDQQNBAiAELQCMAkECcRsMAQsgACAGEFRBAQshAwJAQaSDCygCACIHRQ0AIAUgBxA5IgdFDQAgBy0AAEUNACAAIAVBpIMLKAIARAAAAAAAAPA/RAAAAAAAAAAAEFMQ+QELIAhBvPQAIAgbIQcCQCAEKAKMAiIIQQRxBEAgBUGggwsoAgBBAUEAEEwiDSADckUNASAEIAUoAhAiBikDEDcDwAEgBCAGKQMYNwPIASAEIAYpAyg3A+gBIAQgBikDIDcD4AEgBCAEKwPgATkD0AEgBCAEKwPIATkD2AEgBCAEKwPAATkD8AEgBCAEKwPoATkD+AEgACAHQZweIA0bEEQgACAEQcABakEEIAggAxCoAwwBCyAIQcAAcQRAIAQgBSgCECIDKQMQNwPAASAEIAMpAxg3A8gBIAQgAykDKDcD6AEgBCADKQMgNwPgASAEIAQrA+ABOQPQASAEIAQrA8gBOQPYASAEIAQrA8ABOQPwASAEIAQrA+gBOQP4ASAAIAdBnB4gBUGggwsoAgBBAUEAEEwbEEQgACAEQcABaiAGQQAQywhBAk4EQCAEIAUQITYCgAFBA0HF2gMgBEGAAWoQHwsgBCAFKAIQIgMpAyg3A3ggBCADKQMgNwNwIAQgAykDGDcDaCAEIAMpAxA3A2AgACAEQeAAakEAEPsBDAELIAVBoIMLKAIAQQFBABBMBEAgACAHEEQgBCAFKAIQIgYpAyg3A1ggBCAGKQMgNwNQIAQgBikDGDcDSCAEIAYpAxA3A0AgACAEQUBrIAMQ+wEMAQsgA0UNACAAQZweEEQgBCAFKAIQIgYpAyg3AzggBCAGKQMgNwMwIAQgBikDGDcDKCAEIAYpAxA3AyAgACAEQSBqIAMQ+wELIAQoArgBEBkgBSgCECgCDCIDBEAgAEEFIAMQrgMLIAwEQCAKBEAgBCAFKAIQIgMpAyg3AxggBCADKQMgNwMQIAQgAykDGDcDCCAEIAMpAxA3AwAgACAEEIQGIAAgCSgC0AEgCSgC5AEgCSgC9AEgCSgC1AEQsgELIAAQigILAkAgDkUNACAFEBshBwNAIAdFDQEgACAHEO8DIAUgBxAsIQMDQCADBEAgACADEMsEIAUgAxAtIQMMAQsLIAUgBxAcIQcMAAsACwJAIAAoAjwiA0UNACADKAIkIgNFDQAgACADEQEACyAAEM4EIAoNACAAIAUgAhCCBgsgC0EBaiELDAALAAukAwIFfAd/IwBBkAFrIggkAAJAAkAgASsDACIEIAArAxAiAmQNACAEIAArAwAiBmMNACABKwMIIgUgACsDGCIEZA0AIAUgACsDCCIDYw0AIAErAxAiBSACZCAFIAZjcg0AIAErAxgiBSAEZCADIAVkcg0AIAErAyAiBSACZCAFIAZjcg0AIAErAygiBSAEZCADIAVkcg0AIAIgASsDMCICYyACIAZjcg0AIAErAzgiAiAEZA0AIAIgA2NFDQELIAEQrw8EQCAAQRBqIQogAEEIaiELIABBGGoiDCsDACEGIAArAxAhBANAIAlBBEYNAiAKIQcgASAJQQR0aiINKwMAIgMhAgJAIAMgBGRFBEAgACEHIAQhAiADIAArAwBjRQ0BCyAHIAM5AwAgAiEECyAMIQcgDSsDCCIDIQICQCADIAZkRQRAIAYhAiADIAsiBysDAGNFDQELIAcgAzkDACACIQYLIAlBAWohCQwACwALIAggAUQAAAAAAADgPyAIQdAAaiIBIAhBEGoiBxCbASAAIAEQgwYgACAHEIMGCyAIQZABaiQAC6EBAQN/AkAgACgCmAEiA0GAgIQCcUUNACAAKAIQIgJBAkEEIANBgIAIcSIEGzYCjAIgAiAEQRB2QQJzNgKIAiACKAKQAhAZIAIgAigCjAJBEBBFIgI2ApACIAIgASkDCDcDCCACIAEpAwA3AwAgAiABKQMQNwMQIAIgASkDGDcDGCADQYDAAHFFBEAgACACIAJBAhCLAhoLIAQNACACEP8FCwv1BQMFfwN8AX0jAEEwayIEJAAgBEEANgIgIAAQZiEDAkAgAQ0AQQEhASADIQUDQAJAIAUtAAAiBkE6RwRAIAYNAQwDCyABQQFqIQELIAVBAWohBQwACwALIAQgAzYCJCAEIAFBAWpBDBBFIgY2AihEAAAAAAAA8D8hCEEAIQUCQAJAAkADQCADQYjXARCgBCIBRQ0BAkACQCABQTsQjQEiA0UEQEQAAAAAAAAAACEJDAELIANBADoAACADQQFqIgMgBEEsahDPASIJRAAAAAAAAAAAZkUgBCgCLCADRnINAQsCQCAJIAihIgpEAAAAAAAAAABkRQ0AQYyCCy0AAEUEQCAKRPFo44i1+OQ+YwRAIAghCSAKRPFo44i1+OS+ZA0CCyAEIAA2AgBBAEH/sgMgBBAfQYyCC0EBOgAAQQMhBwsgCCEJCyAJRAAAAAAAAAAAZARAIAYgBUEMbGpBAToACAsgCCAJoSEIIAEtAAAEQCAGIAVBDGxqIAE2AgALIAYgBUEMbGogCbY4AgQgBUEBaiEFQQAhAyAIRPFo44i1+OQ+Y0UgCETxaOOItfjkvmRFcg0BDAMLC0EBIQdBjIILLQAARQRAIAQgADYCEEEBQavcBCAEQRBqEB9BjIILQQE6AABBAiEHCyAEQSBqEM0EDAILIAhEAAAAAAAAAABkRQ0AQQAhA0EAIQEDQCADIAVGRQRAIAEgBiADQQxsaioCBEMAAAAAXkVqIQEgA0EBaiEDDAELCyABBEAgCCABt6O2IQtBACEDA0AgAyAFRg0CIAYgA0EMbGoiACoCBEMAAAAAXkUEQCAAIAs4AgQLIANBAWohAwwACwALIAVBDGwgBmpBCGsiACAIIAAqAgC7oLY4AgALA0ACQCAFIgNBAEwEQEEAIQMMAQsgBiADQQFrIgVBDGxqKgIEQwAAAABeRQ0BCwsgBiADQQxsakEANgIAIAQgAzYCICACIAQoAig2AgggAiAEKQIgNwIACyAEQTBqJAAgBwsJAEEBIAAQsgMLBABBAQsLAEHY/wogADYCAAvUAgIDfAJ/IwBBEGsiCSQAAkAgAUQAAAAAAAAAAGUEQCACIgYiASEADAELAn9EAAAAAAAAAAAgAEQAAAAAAAAYQKIgAEQAAAAAAADwP2YbIgCZRAAAAAAAAOBBYwRAIACqDAELQYCAgIB4CyEKRAAAAAAAAPA/IAEgACAKt6EiB6KhIAKiIQhEAAAAAAAA8D8gAaEgAqIhACACIQZEAAAAAAAA8D8gAUQAAAAAAADwPyAHoaKhIAKiIgchAQJAAkACQAJAAkACQCAKDgYGBQABAgMECyAAIQYgAiEBIAchAAwFCyAAIQYgCCEBIAIhAAwECyAHIQYgACEBIAIhAAwDCyAAIQEgCCEADAILIAlB0gA2AgQgCUHSuAE2AgBB6N4GKAIAQc2rASAJECIQAQALIAghBiACIQELIAMgBjkDACAEIAE5AwAgBSAAOQMAIAlBEGokAAv8AgIBfwJ8IwBB4ABrIgYkACAGIAAgBRC0AyIIIAiiIgc5AwggBCAFNgIIIAQgASACQQR0aiIFKQMANwMQIAQgBSkDCDcDGAJAIAIgA04NACAHIAUrAwAgASACQQNqIgBBBHRqIgMrAwChIgcgB6IgBSsDCCADKwMIoSIHIAeioGRFDQAgACECCyAGIAJBBHQgAWoiACkDODcDGCAGIAApAzA3AxAgBiAAKQMoNwMoIAYgACkDIDcDICAGIAApAxg3AzggBiAAKQMQNwMwIAYgBSkDCDcDSCAGIAUpAwA3A0AgBkFAayEDIAhEAAAAAAAAAABkBEAgBiADNgJYIAYgBkEIajYCXCAGQdgAakHoASAGQRBqQQAQ7QULIAEgAkEEdGoiASADKQMANwMAIAEgAykDCDcDCCAAIAYpAzg3AxggACAGKQMwNwMQIAAgBikDKDcDKCAAIAYpAyA3AyAgACAGKQMYNwM4IAAgBikDEDcDMCAGQeAAaiQAIAIL/QICAX8CfCMAQeAAayIGJAAgBiAAIAUQtAMiCCAIoiIHOQMIIAQgBTYCDCAEIAEgA0EDakEEdGoiBSkDADcDICAEIAUpAwg3AygCQCACIANODQAgByABIANBBHRqIgArAwAgBSsDAKEiByAHoiAAKwMIIAUrAwihIgcgB6KgZEUNACADQQNrIQMLIAYgASADQQR0aiIAKQMINwNIIAYgACkDADcDQCAGIAApAxg3AzggBiAAKQMQNwMwIAYgACkDKDcDKCAGIAApAyA3AyAgBiAFKQMANwMQIAYgBSkDCDcDGCAIRAAAAAAAAAAAZARAIAYgBkEIajYCXCAGIAZBEGoiAjYCWCAGQdgAakHoASACQQEQ7QULIAAgBkFAayICKQMANwMAIAAgAikDCDcDCCAAIAYpAzg3AxggACAGKQMwNwMQIAAgBikDKDcDKCAAIAYpAyA3AyAgA0EEdCABaiIAIAYpAxg3AzggACAGKQMQNwMwIAZB4ABqJAAgAwteAQF/A0ACQAJAIAEoAgAiAwR/IABFDQEgACADIAMQQCIDEGwNAiACIAIoAgAgASgCBHI2AgAgACADagUgAAsPC0GgygFB1fsAQQpBv/YAEAAACyABQQhqIQEMAAsAC/YCAQR/IwBBEGsiBCQAIAFBADYCACACIAAQKxDVAUEARyIDNgIAAkBBjIULKAIAIgVFDQACQCAAIAUQOSIFLQAARQ0AQaDyBCEDA0AgAygCACIGRQ0BIAUgBhAoBEAgA0EMaiEDDAEFIAEgAygCBDYCACACIAMoAggiAzYCAAwDCwALAAsgAigCACEDCwJAIANBAUcNACAAECtBAkH/rAFBABAkIgNFDQAgACADEDkiAy0AAEUNACADIAIQ1ggLAkAgASgCAEEBRw0AIAAQK0ECQZzuAEEAECQiA0UNACAAIAMQOSIDLQAARQ0AIAMgARDWCAsgACgCEC0AmQEEQCAAIABBMGsiAyAAKAIAQQNxQQJGGygCKBArIAAgAyAAKAIAQQNxIgNBAkYbKAIoIAAgA0EDR0EwbGooAihBAEEAEE8gBEEMaiAEQQhqEI0GIAIgAigCACAEKAIMcjYCACABIAEoAgAgBCgCCHI2AgALIARBEGokAAuwBQIDfwF9IABBuJwBECchAyMAQeAAayIAJAACQAJAIAIEQCACIAE2AhAgAkIANwIYIAJBADYCBCADRQ0CIAMsAAAiAUUNAgJAAkACQAJAIAFB4QBrDgcABgEGBgYCAwsgA0GlDxDXCARAIAJBBDYCECADLQAFQd8ARwRAIANBBWohAwwGCyADQQZqIQMDQCADLAAAIgRFDQYCQAJAAkACQAJAAkACQAJAIARB7ABrDgoEDg4ODg4FDgIBAAsCQCAEQeIAaw4CAwYAC0HAACEBIARB6QBHDQ0MBgtBAiEBDAULQRAhAQwEC0EgIQEMAwtBBCEBDAILQQghAQwBC0EBIQELIAIgAigCHCABcjYCHCADQQFqIQMMAAsACyADQY4jENcIRQ0FIAJBBTYCECAAIABB3ABqNgJQAkAgA0EGakGhhQEgAEHQAGoQR0EATA0AIAAqAlwiBkMAAAAAXkUNACACIAY4AgAMBgsgAkGAgID8AzYCAAwFCyADQak2ECgNBCACQQE2AhAMBAsgA0Gq+QAQKA0DIAJBAzYCEAwDCyABQe4ARw0CIANBs5wBECgNAiACQQI2AhAMAgtBs90AQdq3AUHpCUHz3QAQAAALIAAgAEHcAGo2AkAgA0H0rgEgAEFAaxBHQQBMDQAgACgCXCIBQQBMDQAgAiABNgIEC0GoggstAAAEQEGYvwRBC0EBQejeBigCACIBEEYaIAAgAigCEEEBayIDQQRNBH8gA0ECdEGA8gRqKAIABUHNqQELNgIwIAFBwuoDIABBMGoQIiACKAIQQQVGBEAgACACKgIAuzkDICABQeiOBCAAQSBqEDELIAAgAigCBDYCECABQfmtBCAAQRBqECIgACACKAIcNgIAIAFB7K0EIAAQIgsgAigCECEFIABB4ABqJAAgBQuABgIJfwd8IAYgASgCDEEFdGoiBysDGCEQIAcrAxAhEiAHKwMIIRMgBysDACEUAkAgAEUEQAJ/IBAgE6EgBUEBdLgiEaAgBLciFaObIhaZRAAAAAAAAOBBYwRAIBaqDAELQYCAgIB4C0F+bSEFAn8gEiAUoSARoCAVo5siEZlEAAAAAAAA4EFjBEAgEaoMAQtBgICAgHgLQX5tIAUgASACIAMgBCAGEOMBDQELQQBBACABIAIgAyAEIAYQ4wENAAJ/IBAgE6GbIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyEHQQEhAAJ/IBIgFKGbIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CyAHSARAA0BBACEHQQAgAGshBQNAAkAgBSAHTgRAIAUhCANAIAAgCEYNAiAIIAcgASACIAMgBCAGEOMBIQogCEEBaiEIIApFDQALDAULIAUgByABIAIgAyAEIAYQ4wENBCAHQQFrIQcMAQsLA0AgACAHRwRAIAAgByABIAIgAyAEIAYQ4wEhCyAHQQFqIQcgC0UNAQwECwsgACEHA0ACQCAFIAdOBEAgACEFA0AgBUEATA0CIAcgBSABIAIgAyAEIAYQ4wEhDCAFQQFrIQUgDEUNAAsMBQsgByAAIAEgAiADIAQgBhDjAQ0EIAdBAWshBwwBCwsgAEEBaiEADAALAAsDQEEAIQdBACAAayEIA0AgACAHRgRAIAghBwNAIAAgB0YEQCAAIQcDQAJAIAcgCEwEQCAAIQUDQCAFIAhMDQIgByAFIAEgAiADIAQgBhDjAQ0JIAVBAWshBQwACwALIAcgACABIAIgAyAEIAYQ4wENByAHQQFrIQcMAQsLA0AgBwRAIAcgBSABIAIgAyAEIAYQ4wEhDSAHQQFqIQcgDUUNAQwHCwsgAEEBaiEADAQLIAAgByABIAIgAyAEIAYQ4wEhDiAHQQFqIQcgDkUNAAsMAwsgByAIIAEgAiADIAQgBhDjASEPIAdBAWohByAPRQ0ACwsLC7sKAwR/BXwBfiMAQbABayIHJAAgByABKAIAtzkDkAEgByABKAIEtzkDmAECQAJAIAZFDQAgACgCECgCCCIBRQ0AIAW3IQsgBLchDiADtyEPQQAhBgNAIAYgASgCBE4NAiABKAIAIAZBMGxqIgMoAgwhCiADKAIIIQQgAygCBCEIIAMoAgAhASAHIAMpAyg3A6gBIAcgAykDIDcDoAEgBwJ/IAQEQCAHIAMpAxg3A5gBIAcgAykDEDcDkAFBASEFIAEMAQsgByABKQMINwOYASAHIAEpAwA3A5ABQQIhBSABQRBqCyIEKQMINwOIASAHIAQpAwA3A4ABIAcrA5gBIA6gIQwgBwJ8IAcrA5ABIA+gIg1EAAAAAAAAAABmBEAgDSALowwBCyANRAAAAAAAAPA/oCALo0QAAAAAAADwv6ALOQOQASAHIAxEAAAAAAAAAABmBHwgDCALowUgDEQAAAAAAADwP6AgC6NEAAAAAAAA8L+gCzkDmAEgBysDiAEgDqAhDCAHAnwgBysDgAEgD6AiDUQAAAAAAAAAAGYEQCANIAujDAELIA1EAAAAAAAA8D+gIAujRAAAAAAAAPC/oAs5A4ABIAcgDEQAAAAAAAAAAGYEfCAMIAujBSAMRAAAAAAAAPA/oCALo0QAAAAAAADwv6ALOQOIASAHIAcpA5gBNwN4IAcgBykDiAE3A2ggByAHKQOQATcDcCAHIAcpA4ABNwNgIAdB8ABqIAdB4ABqIAIQ0gQgBSAIIAUgCEobIQMDQCADIAVGRQRAIAcgBykDiAE3A5gBIAcgBykDgAE3A5ABIAcgASAFQQR0aiIEKQMINwOIASAHIAQpAwA3A4ABIAcrA4gBIA6gIQwgBwJ8IAcrA4ABIA+gIg1EAAAAAAAAAABmBEAgDSALowwBCyANRAAAAAAAAPA/oCALo0QAAAAAAADwv6ALOQOAASAHIAxEAAAAAAAAAABmBHwgDCALowUgDEQAAAAAAADwP6AgC6NEAAAAAAAA8L+gCzkDiAEgByAHKQOYATcDWCAHIAcpA4gBNwNIIAcgBykDkAE3A1AgByAHKQOAATcDQCAHQdAAaiAHQUBrIAIQ0gQgBUEBaiEFDAELCyAKBEAgBykDiAEhECAHIAcpA6gBNwOIASAHIBA3A5gBIAcpA4ABIRAgByAHKQOgATcDgAEgByAQNwOQASAHKwOIASAOoCEMIAcCfCAHKwOAASAPoCINRAAAAAAAAAAAZgRAIA0gC6MMAQsgDUQAAAAAAADwP6AgC6NEAAAAAAAA8L+gCzkDgAEgByAMRAAAAAAAAAAAZgR8IAwgC6MFIAxEAAAAAAAA8D+gIAujRAAAAAAAAPC/oAs5A4gBIAcgBykDmAE3AzggByAHKQOIATcDKCAHIAcpA5ABNwMwIAcgBykDgAE3AyAgB0EwaiAHQSBqIAIQ0gQLIAZBAWohBiAAKAIQKAIIIQEMAAsACyAHQYABaiAAQVBBACAAKAIAQQNxQQJHG2ooAigQlQggBysDiAEgBLegIQsgBwJ8IAcrA4ABIAO3oCINRAAAAAAAAAAAZgRAIA0gBbejDAELIA1EAAAAAAAA8D+gIAW3o0QAAAAAAADwv6ALOQOAASAHIAtEAAAAAAAAAABmBHwgCyAFt6MFIAtEAAAAAAAA8D+gIAW3o0QAAAAAAADwv6ALOQOIASAHIAcpA5gBNwMYIAcgBykDiAE3AwggByAHKQOQATcDECAHIAcpA4ABNwMAIAdBEGogByACENIECyAHQbABaiQAC88CAQd/IwBBMGsiAiQAIAJCADcDKCACQgA3AyAgABA1BEBBCkEEEB0hBSACQeIBNgIcIAJB4wE2AhggAkEANgIUIAJCADcCDCAAEBshAwNAIAMEQCADKAIQQQA2ArABIAAgAxAcIQMMAQsLQQohByAAEBshAwJ/A0AgAwRAIANBfyACKAIcEQAARQRAIAJBIGoiBkEAENcEIAIgBDYCACAGIAIQ1gQgACAGEOQBQQEQjwEiBkGgJUGgAkEBEDAaIAAgAyAGIAJBDGoiCBDVBEF/RgRAIAgQ9AMgBRAZQQAhBEEADAQLIAQgB0YEQCAFIAQgBEEBdCIHQQQQiAEhBQsgBSAEQQJ0aiAGNgIAIARBAWohBAsgACADEBwhAwwBCwsgAkEMahD0AyAFIAcgBEEEEIgBCyEDIAJBIGoQgAELIAEgBDYCACACQTBqJAAgAwvYJAIKfwR8IwBBsAJrIgUkAAJ/IAAgAhD+CEHnB0YEQCAFIABBASACEPUDNgIEIAUgAjYCAEEBQZ7YAyAFEB9BfwwBCyMAQRBrIggkACABQaAlQaACQQEQMBogASgCECAANgKQASABEDQgAUcEQCABEDRBoCVBoAJBARAwGiABEDQoAhAgADYCkAELAn8CQAJAAkAgAUGKGBAnIgJFDQAgAEEANgKkASAAIAIQ/ghB5wdHDQAgCCAAQQEgAhD1AzYCBCAIIAI2AgBBAUGe2AMgCBAfDAELIAAoAqQBIgkNAQtBfwwBC0EBEPwCIAAoAqwBKAIAQQFxIQojAEFAaiICJABBAUHgABAdIQAgASgCECAANgIIIAFBwOEAECciAARAIAJCADcDOCACQgA3AzAgARDVASEDIAIgADYCJCACQdn4AEGq+QAgAxs2AiAgAkEwaiEAIwBBEGsiBCQAIAQgAkEgaiIDNgIMIAQgAzYCCAJAAkACQAJAQQBBAEGqCCADEFkiBkEASA0AIAZBAWohAyAGIAAQQiAAECVrIgdPBEAgACADIAdrEI8CCyAAECUhByAGIAAQKQR/IAAgB2oFIAAoAgAgB2oLIANBqgggBCgCDBBZIgNHIANBAE5xDQEgA0EATA0AIAAQKQRAIANBgAJPDQMgACAALQAPIANqOgAPIAAQJUEQSQ0BQbKkA0Hz+wBB6gFB3h0QAAALIAAgACgCBCADajYCBAsgBEEQaiQADAILQe6PA0Hz+wBB5QFB3h0QAAALQYvFAUHz+wBB6AFB3h0QAAALIAAQJSAAEEJPBEAgAEEBEI8CCyAAECUhAwJAIAAQKQRAIAAgA2pBADoAACAAIAAtAA9BAWo6AA8gABAlQRBJDQFBsqQDQfP7AEGhAkH3rgEQAAALIAAoAgAgA2pBADoAACAAIAAoAgRBAWo2AgQLAkAgABApBEAgAEEAOgAPDAELIABBADYCBAsgASAAECkEfyAABSAAKAIACxDXDRogABCAAQsCQCABQbf3ABAnIgBFBEBBos0BEKIEIgBFDQELAkACQEGuzQFBPRC2BSIDQa7NAUcEQCADQa7NAWsiA0GuzQFqLQAARQ0BC0GwjgtBHDYCAAwBCyADIAAQQCIGakECahA4IgRFDQAgBEGuzQEgAxAjGiADIARqIgdBPToAACAHQQFqIAAgBkEBahAjGgJAAkACQAJAQbiOCygCACIARQRAQQAhAAwBCyAAKAIAIgYNAQtBACEDDAELIANBAWohB0EAIQMDQCAEIAYgBxBsRQRAIAAoAgAhCyAAIAQ2AgAgCyAEEMsMDAMLIANBAWohAyAAKAIEIQYgAEEEaiEAIAYNAAtBuI4LKAIAIQALIANBAnQiB0EIaiEGAkACQEGQkAsoAgAgAEYEQCAAIAYQNyIADQEMAgsgBhA4IgBFDQEgAwRAIABBuI4LKAIAIAcQIxoLQZCQCygCABAZCyAAIANBAnRqIgMgBDYCACADQQA2AgRBuI4LIAA2AgBBkJALIAA2AgAgBARAQQAgBBDLDAsMAQsgBBAZCwsLQQEhAAJAIAEgAUEAQYIgQQAQJEH55QEQTSIDQaGAAxAuRQ0AIANByuMCEC5FDQAgA0Gz5AIQLkUNACADQb6AAxAuRQ0AIANBqYADEC5FDQAgA0G0gAMQLkUNACADQfqIAxAuRQ0AQQIhACADQeqQAhAuRQ0AIANB9/8BEC5FDQBBACEAIANB+eUBEC5FDQAgA0GY3QEQLkUNACACIAM2AhBBAEHAvwQgAkEQahAfCyABKAIQIAA6AHNBrIILKAIARQRAQaSCCyABQdP3ABAnNgIACyABIAFBAEG66gBBABAkRAAAAAAAAAAARAAAAAAAAAAAEFMhDSABKAIQKAIIIA05AwACf0EAIAFB/TUQJyIARQ0AGkEBIABBrccBEChFDQAaQQIgAEHWxgEQKEUNABpBAEEDIABBjskBECgbCyEAIAEoAhAgAEEFbCAAQQJ0IAobNgJ0IAIgASABQQBB7dkAQQAQJEQAAAAAAADQP0R7FK5H4XqUPxBTIg05AzAgASgCEAJ/IA1EAAAAAAAAUkCiIg1EAAAAAAAA4D9EAAAAAAAA4L8gDUQAAAAAAAAAAGYboCINmUQAAAAAAADgQWMEQCANqgwBC0GAgICAeAs2AvwBAkAgASABQQBB5dkAQQAQJEEAEHciAwRAIAIgAkEwajYCAAJAIANBgYMBIAIQR0UEQCACQoCAgICAgIDwPzcDMEQAAAAAAADgPyENDAELIAIrAzAiDUR7FK5H4XqUP2NFDQAgAkL7qLi9lNyeyj83AzBEexSuR+F6lD8hDQsgASgCECEAIANBpA0QoQRFDQEgAEEBOgCYAgwBCyACQoCAgICAgIDwPzcDMCABKAIQIQBEAAAAAAAA4D8hDQsgAAJ/IA1EAAAAAAAAUkCiIg1EAAAAAAAA4D9EAAAAAAAA4L8gDUQAAAAAAAAAAGYboCINmUQAAAAAAADgQWMEQCANqgwBC0GAgICAeAs2AoACIAEgAUEAQb8tQQAQJEEAQQAQTCEAIAEoAhAgADoA9QEgASABQQBBui5BABAkQQAQd0GA+wlBkPsJEJQIIQAgASgCECAANgL4AQJAIAFBkt0AECciA0UEQCABKAIQIQAMAQsgA0Gm3AAQKEUEQCABKAIQIgAoAghBBDYCVAwBCyADQYwoEChFBEAgASgCECIAKAIIQQM2AlQMAQsgA0GiowEQKEUEQCABKAIQIgAoAghBBTYCVAwBCyADQfTsABAoRQRAIAEoAhAiACgCCEECNgJUDAELIAEoAhAhACADEJ8CIg1EAAAAAAAAAABkRQ0AIAAoAggiAyANOQMQIANBATYCVAsgAUGhhgEgACgCCEFAaxChDyEAIAEoAhAoAggiAyAAOgBQIAFBw5oBIANBMGoQoQ8aIAFB0zYQJxCFASEAIAEoAhAoAgggADoAUgJAAn8gAUHmjgEQJyIABEAgABDxAUHaAEYMAQsgAUHU4QAQJyIABEAgAC0AAEHfAXFBzABGDAELIAFB75IBECciAEUNASAAEIUBCyEAIAEoAhAoAgggADoAUQtBzIILIAFBq/MAECdB4PoJQfD6CRCUCDYCAEHQggsgAUHtjgEQJxCFAToAAEHoggtBADYCAEHsggtBADYCACABKAIQKAIIQgA3AxgCQAJAIAFBhPUAECciAARAIAAtAAANAQsgAUHc4AAQJyIARQ0BIAAtAABFDQELIAEoAhAoAgggABCfAjkDGAsgARD9BUHwggtCm9LdmoT3hc/HADcDAEGcgwsgAUEAQaX+AEEAECQ2AgBBqIMLIAFBAEGRlwFBABAkNgIAQayDCyABQQBBxuMAQQAQJDYCAEGwgwsgAUEBQdIfQQAQJDYCAEG0gwsgAUEBQZn3AEEAECQ2AgBBuIMLIAFBAUHpkgFBABAkNgIAQbyDCyABQQFB1DVBABAkNgIAQcCDCyABQQFByDVBABAkNgIAQYCECyABQQFBhpYBQQAQJDYCAEHkgwsgAUEBQbqFAUEAECQ2AgBB6IMLIAFBAUGElQFBABAkNgIAQeyDCyABQQFBtTVBABAkNgIAQfSDCyABQQFB+e8AQQAQJCIANgIAIABFBEBB9IMLIAFBAUH57wBBscgBECQ2AgALQfiDCyABQQFBze8AQQAQJDYCAEGEhAsgAUEBQb8tQQAQJDYCAEHAhAsgAUEBQYL3AEEAECQ2AgBBkIQLIAFBAUGl/gBBABAkNgIAQfCDCyABQQFBxuMAQQAQJDYCAEGIhAsgAUEBQbYwQQAQJDYCAEGMhAsgAUEBQaQvQQAQJDYCAEGYhAsgAUEBQbwWQQAQJDYCAEGUhAsgAUEBQdThAEEAECQ2AgBBnIQLIAFBAUHn4ABBABAkNgIAQaCECyABQQFB3oUBQQAQJDYCAEGkhAsgAUEBQdWYAUEAECQ2AgBBqIQLIAFBAUGtKkEAECQ2AgBB/IMLIAFBAUHUDUEAECQ2AgBBrIQLIAFBAUGNNkEAECQ2AgBBsIQLIAFBAUGe1wBBABAkNgIAQbSECyABQQFBwx5BABAkNgIAQbiECyABQQFBwzBBABAkNgIAQbyECyABQQFB/AhBABAkNgIAQcSECyABQQFBkZcBQQAQJDYCAEHIhAsgAUECQcofQQAQJDYCAEHQhAsgAUECQdQ1QQAQJDYCAEHUhAsgAUECQcg1QQAQJDYCAEH4hAsgAUECQbqFAUEAECQ2AgBB/IQLIAFBAkGElQFBABAkNgIAQYCFCyABQQJBtTVBABAkNgIAQYSFCyABQQJB+e8AQQAQJDYCAEGIhQsgAUECQc3vAEEAECQ2AgBBrIULIAFBAkGbJEEAECQ2AgBBjIULIAFBAkGJNkEAECQ2AgBBuIULIAFBAkH/rAFBABAkNgIAQbyFCyABQQJBnO4AQQAQJDYCAEHAhQsgAUECQd7vAEEAECQ2AgBBxIULIAFBAkHU7wBBABAkNgIAQciFCyABQQJBtYUBQQAQJDYCAEHMhQsgAUECQf+UAUEAECQ2AgBB0IULIAFBAkGwNUEAECQ2AgBB1IULIAFBAkGEngFBABAkNgIAQdiFCyABQQJBs5cBQQAQJDYCAEHMhAsgAUECQfHkAEEAECQ2AgBBmIULIAFBAkG/LUEAECQ2AgBBkIULIAFBAkGGlgFBABAkNgIAQZSFCyABQQJB+Y4BQQAQJDYCAEGchQsgAUECQauFAUEAECQ2AgBBoIULIAFBAkGRHkEAECQ2AgBBpIULIAFBAkGNNkEAECQ2AgBBqIULIAFBAkHDHkEAECQ2AgBB3IULIAFBAkGV2QBBABAkNgIAQeCFCyABQQJBntkAQQAQJDYCAEHkhQsgAUECQYL3AEEAECQ2AgBBACEDIwBBIGsiBCQAAkACQCABQYSgARAnIgAEQCAALQAADQELIAFB3L4BECciAEUNASAALQAARQ0BCyAAQfgAEKgNIgMNACAEIAEQITYCEEEAQdTfAyAEQRBqEB8gBCAANgIAQQNByOIEIAQQH0EAIQMLIARBIGokACABKAIQKAIIIAM2AlgCQCABQaOlARAnIgBFDQAgAC0AAEUNACAAIAEQfiEAIAEoAhAoAgggADYCXAsgAkFAayQAIAEoAhAoAgghACABEDQoAhAgADYCCEGwiQtBADYCAEH0iAtBADYCAEHAiQtBADYCAAJAIAkoAgAiAEUNACABIAARAQAgCSgCBCIARQ0AIAEoAhAgADYClAELQQAQ/AJBAAshACAIQRBqJABBfyAAQX9GDQAaAkAgASgCECIAKAIILQBRBEAgACsDGCENIAArAyghDiAAKwMgIQ8gBQJ/IAArAxAiEEQAAAAAAADgP0QAAAAAAADgvyAQRAAAAAAAAAAAZhugIhCZRAAAAAAAAOBBYwRAIBCqDAELQYCAgIB4CzYCJCAFAn8gD0QAAAAAAADgP0QAAAAAAADgvyAPRAAAAAAAAAAAZhugIg+ZRAAAAAAAAOBBYwRAIA+qDAELQYCAgIB4CzYCLCAFAn8gDkQAAAAAAADgP0QAAAAAAADgvyAORAAAAAAAAAAAZhugIg6ZRAAAAAAAAOBBYwRAIA6qDAELQYCAgIB4CzYCKCAFAn8gDUQAAAAAAADgP0QAAAAAAADgvyANRAAAAAAAAAAAZhugIg2ZRAAAAAAAAOBBYwRAIA2qDAELQYCAgIB4CzYCICAFQTBqQYACQcCuASAFQSBqEGkaDAELIAArAxghDSAAKwMgIQ4gACsDKCEPIAUCfyAAKwMQIhBEAAAAAAAA4D9EAAAAAAAA4L8gEEQAAAAAAAAAAGYboCIQmUQAAAAAAADgQWMEQCAQqgwBC0GAgICAeAs2AhAgBQJ/IA9EAAAAAAAA4D9EAAAAAAAA4L8gD0QAAAAAAAAAAGYboCIPmUQAAAAAAADgQWMEQCAPqgwBC0GAgICAeAs2AhwgBQJ/IA5EAAAAAAAA4D9EAAAAAAAA4L8gDkQAAAAAAAAAAGYboCIOmUQAAAAAAADgQWMEQCAOqgwBC0GAgICAeAs2AhggBQJ/IA1EAAAAAAAA4D9EAAAAAAAA4L8gDUQAAAAAAAAAAGYboCINmUQAAAAAAADgQWMEQCANqgwBC0GAgICAeAs2AhQgBUEwakGAAkHArgEgBUEQahBpGgsgAUG4uwEgBUEwahD9B0EACyEMIAVBsAJqJAAgDAvsBAEMf0EAQQFB+e8AQbHIARAkGhDxCCIAQQA2AiQgAEHA1Qc2AiAgAEHgATYCECAAQcSMCDYCAAJAIAAiAigCICIERQ0AA0AgBCgCACIARQ0BAkAgAC0AAEHnAEcNACAAQdwMEKEERQ0AIAQoAgQiAygCACEAQQwQeCIFQQA2AgQgBSAAEGY2AgggBSACKAJkNgIAIAIgBTYCZCADKAIEIQYDQEEAIQcgBigCBCIKBEADQCAKIAdBFGxqIggoAgQiAwRAIAYoAgAhACAIKAIIIQkjAEEwayIBJAAgAxChASILBEAgAUEoaiADQToQ2AEgAiAAQQJ0akE8aiEDA0ACQCADKAIAIgBFDQAgAUEgaiAAKAIEQToQ2AEgASABKQIoNwMYIAEgASkCIDcDECABQRhqIAFBEGoQ7ghBAEwNACADKAIAIQMMAQsLA0ACQCADKAIAIgBFDQAgAUEgaiAAKAIEQToQ2AEgASABKQIoNwMIIAEgASkCIDcDACABQQhqIAEQ2wRFDQAgAygCACIAKAIIIAlMDQAgACEDDAELC0EBQRQQHSIAIAMoAgA2AgAgAyAANgIAIAAgCDYCECAAIAU2AgwgACAJNgIIIAAgCzYCBAsgAUEwaiQAIAdBAWohBwwBCwsgBkEIaiEGDAELCwsgBEEIaiEEDAALAAsgAkEAOgAsIAJBAkHuFxC3AyIABEAgAiAAKAIQKAIMNgKMAQsgAkKAgICAgAQ3AmwgAkEANgKEASACQdsCNgKAASACQdwCNgJ8IAJB3QI2AnggAkF/NgJ0IAIgAkHsAGpB8L0KKAIAEH02AogBIAILLQAgACgCBEGACCAAKAIIEKUEBH8gACAAKAIEIgA2AgAgAC0AAAVBAAtB/wFxC2EBAn8jAEEQayIBJAACQCAAKAIAIgIEQCACIAAoAgQiABDBByICRQ0BIAFBEGokACACDwtBhMsBQbn6AEEqQdszEAAACyABIABBAWo2AgBB6N4GKAIAQdTRAyABECIQLwALXwEBfwJAIAAoAgAiAgRAIAFFDQEgAiABIAAoAgQiACABEEAiASAAIAFJGxBsRSAAIAFNcSAAIAFPcQ8LQafLAUG5+gBB4wBB1DoQAAALQfrKAUG5+gBB5ABB1DoQAAALpxoCEH8EfCMAQYASayIDJAACQAJAIAIEQCACLQAADQELIABCfzcCAAwBCwJ/QayCCygCAARAQbz/CigCAAwBC0G8/wooAgAiBUGkggsoAgAiBEHE/wooAgBGDQAaQcT/CiAENgIAQQAgBUUNABogBRBzGkG8/wpBADYCAEEACyEPIAMgASgCECgCCCsDGCITRAAAAAAAAFhAIBNEAAAAAAAA8D9mGyITOQOgASADIBM5A6gBIA9FBEBBvP8KQdCMCEGIvgooAgAQfTYCAAsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAhDqCCIERQRAQQFBwAAQHSIEQQAgAhCnATYCCCAEEOkIRQ0RIAQoAhQiAUUNAUEAIQIgA0GQCmpBADYCACADQgA3A4gKIANCADcDgAoCQCADQYAKakEBQRQgARC+BUEURw0AA0AgAkEKRg0BIANBgApqIAJBBHQiBSIBQdDwBGooAgAgAUHU8ARqKAIAENEBBEAgAkEBaiECDAEFIAQgBUHY8ARqKAIAIgE2AhggBCAFQdzwBGooAgA2AhwCQAJAIAJBB2sOAgABCAsCQCADQYAKakE+QRQQ3wMNAANAIAQoAhQQ4QMiAUE+Rg0BIAFBf0cNAAsMBwsgA0EANgLwASADQfABaiIBQQFBBCAEKAIUEL4FQQRHDQYgAUEBciEBA0AgAygC8AFBvObZuwZGBEBBCCEBIARBCDYCGCAEQYz9ADYCHAwJCyAEKAIUEOEDIgJBf0YNByABLwAAIQUgAyABLQACOgDyASADIAU7AfABIAMgAjoA8wEMAAsACyADKAKICkHXiomCBUcNBiAEQQs2AhggBEGk2gA2AhwMBwsACwALIARBADYCGCAEQdSWAzYCHAwFCyAEEJgGDBELQZmEAUH7uAFBsQVBuuQAEAAACyAEKAIYIQELIAEODQEEAgMFCwYMCQwMAAoMCyAEQQA2AjAgBCgCFEEPQQAQwgEaIAQoAhQQ4QMhECAEKAIUIQEgEEHYAEcNBiABQRhBABDCARogBCgCFEEEIANBgApqEIkCRQ0LIAQoAhRBBCADQfABahCJAg0HDAsLIAQgBCgCCBCfCCIBNgI0IAENCiADIAQoAgg2AhBBAEGZ8AMgA0EQahAfDAsLIARBADYCMCAEKAIUQQZBABDCARogBCgCFEECIANBgApqEIkCRQ0JIAQoAhRBAiADQfABahCJAkUNCSAEIAMoAoAKNgIoIAQgAygC8AE2AiwMCQsgBEEANgIwIAQoAhRBEEEAEMIBGiAEKAIUQQQgA0GACmoQiAJFDQggBCgCFEEEIANB8AFqEIgCRQ0IIAQgAygCgAo2AiggBCADKALwATYCLAwICyAEQQA2AjAgBCgCFEEQQQAQwgEaIAQoAhRBAiADQYAKahCJAkUNByAEKAIUQQIgA0HwAWoQiQJFDQcgBCgCFEECIANB0AFqEIkCRQ0HIAQoAhRBAiADQfAJahCJAkUNByAEIAMoAvABIAMoAoAKQRB0cjYCKCAEIAMoAvAJIAMoAtABQRB0cjYCLAwHCyAEQQA2AjADQCAEKAIUQQEgA0GACmoQiAJFDQcgAygCgAoiAUH/AUYNAEH18QQgAUELEN8DDQACQAJAAkACQCABQcABaw4DAAMBAwsgBCgCFEEDQQEQwgENCiAEKAIUQQIgA0HQAWoQiAJFDQogBCgCFEECIANB8AlqEIgCDQEMCgsgBCgCFEEDQQEQwgENCSAEKAIUQQIgA0HQAWoQiAJFDQkgBCgCFEECIANB8AlqEIgCRQ0JCyAEIAMoAtABNgIsIAQgAygC8Ak2AigMCAsgBCgCFEECIANB8AFqEIgCRQ0HIAQoAhQgAygC8AFBAmtBARDCARoMAAsACyAEQcgANgIwIAQoAhRBAEEAEMIBGgNAIANBgApqIgFBgAggBCgCFBClBEUNBiABQcTVARChBCIBRQ0AIAMgA0HIAWo2AiwgAyADQfAJajYCKCADIANB0AFqNgIkIAMgA0HwAWo2AiAgAUGvrgEgA0EgahBHQQRHDQALIAQgAygC8AEiATYCICAEIAMoAtABIgI2AiQgBCADKALwCSABazYCKCAEIAMoAsgBIAJrNgIsDAULIAFBGkEAEMIBGiAEKAIUQQIgA0GACmoQiQJFDQQgBCgCFEECIANB8AFqEIkCRQ0ECyAEIAMoAoAKNgIoIAQgAygC8AE2AiwMAwsgA0GICmpCADcDACADQgA3A4AKIAQoAhRBAEEAEMIBGkEAIQEDQAJAIAwgASAGcXJFBEACfwNAIAQoAhQQ4QMiAkF/RwRAQQAgAkEKRg0CGiADQYAKaiACwBDnCAwBCwtBAQshDCADQYAKaiICQQAQ5wgCQCACECkEQCADQQA6AI8KDAELIANBADYChAoLIANBgApqIgIQKSEFIAIgAygCgAogBRshByABIQUDQEEAIQIDQCACIAdqIg0tAAAiCEUNA0EBIQECQCAIQeEAa0H/AXFBGU0EQANAIAEiDkEBaiEBIAcgAiIIQQFqIgJqLQAAIglB3wFxQcEAa0H/AXFBGkkNAAsgCUE9Rw0CIAcgCGotAAJBIkcNAkEAIQEgCEEDaiIIIQIDQCACIAdqLQAAIglFDQMgCUEiRg0CIAFBAWohASACQQFqIQIMAAsACyACQQFqIQIMAQsLIAMgDjYC9AEgAyANNgLwASADIAMpAvABNwOYASADIAcgCGoiAjYC+AEgAyABNgL8ASABIAJqQQFqIQcgA0GYAWpBmfcAEJYGBEAgAyADKQL4ATcDSCADQcgAahCVBiEBIAMgA0HQAWoiAjYCRCADIANB8AlqNgJAAkAgAUGHMSADQUBrEEdBAkYEQEEBIQUgAysD8AkgAhDaBCEKDAELIAMgA0HwCWo2AjAgAUGBgwEgA0EwahBHQQFHDQBBASEFIAMrA/AJQdIbENoEIQoLIAEQGSAGIRFBACEGIBFFDQFBASEGDAMLIAMgAykC8AE3A5ABIANBkAFqQdIfEJYGBEAgAyADKQL4ATcDaCADQegAahCVBiEBIAMgA0HQAWoiAjYCZCADIANB8AlqNgJgAkAgAUGHMSADQeAAahBHQQJGBEBBASEGIAMrA/AJIAIQ2gQhCwwBCyADIANB8AlqNgJQIAFBgYMBIANB0ABqEEdBAUcNAEEBIQYgAysD8AlB0hsQ2gQhCwsgARAZQQEhASAFQQFxIRJBACEFIBINBAwBCyADIAMpAvABNwOIASADQYgBakHIERCWBkUNACADIAMpAvgBNwOAASADQYABahCVBiEBIAMgA0GwAWo2AnwgAyADQbgBajYCeCADIANBwAFqNgJ0IAMgA0HIAWo2AnAgAUH1ggEgA0HwAGoQR0EERwRAIAEQGQwBCwsgAysDyAEhEyADKwO4ASEUIAMrA8ABIRUgAysDsAEhFiABEBkCfyAWIBWhRAAAAAAAAPA/oCIVmUQAAAAAAADgQWMEQCAVqgwBC0GAgICAeAshCwJ/IBQgE6FEAAAAAAAA8D+gIhOZRAAAAAAAAOBBYwRAIBOqDAELQYCAgIB4CyEKQQEhBkEBIQEMAgsgBCALNgIsIAQgCjYCKCAEQQA2AjAgAy0AjwpB/gFHDQQgAygCgAoQGQwECyAFIQEMAAsACyAEQQA2AjAgBCgCFEEGQQAQwgEaIAQoAhRBASADQYAKahCIAkUNASAEKAIUQQEgA0HwAWoQiAJFDQEgBCADKAKACjYCKCAEIAMoAvABNgIsDAELIARBADYCMCAEKAIUQQBBABDCARogBCgCFCEBA0AgA0HwAWoiAkGACCABEKUERQ0BIAJB3BEQoQQiBUUNAAsgAyABNgL4CSADIAVBCWo2AvAJIAMgAjYC9AkgA0HwCWoiARDmCCADKALwCSwAACICBH8gAgUgARCUBgtB2wBHDQAgAyADKALwCUEBajYC8AkgA0HwCWoiAiADQYAKaiIBENkEIAEgA0HQAWoQ2AQNACACIAEQ2QQgASADQdgBahDYBA0AIAIgARDZBCABIANB4AFqENgEDQAgAiABENkEIAEgA0HoAWoQ2AQNACAEAn8gAysD0AEiE5lEAAAAAAAA4EFjBEAgE6oMAQtBgICAgHgLNgIgIAQCfyADKwPYASIUmUQAAAAAAADgQWMEQCAUqgwBC0GAgICAeAs2AiQgBAJ/IAMrA+ABIBOhIhOZRAAAAAAAAOBBYwRAIBOqDAELQYCAgIB4CzYCKCAEAn8gAysD6AEgFKEiE5lEAAAAAAAA4EFjBEAgE6oMAQtBgICAgHgLNgIsCyAEEJgGQbz/CigCACIBIARBASABKAIAEQMAGgwBCyAEKAIIIgEEQEEAIAEQiQEaCyAEEBlBACEECyADIAMpA6gBNwMIIAMgAykDoAE3AwAgA0GACmogBCADEOgIIAAgAykDgAo3AgALIANBgBJqJAALJQEBfwJAIAAtABFFDQAgACgCFCIBRQ0AIAEQ4wMgAEEANgIUCwsVAQF/EP8CIQBBD0G0/wooAgAgABsLWQEDfwJAIAAoAgAiAgRAIAEoAgAiA0UNASAAKAIEIgAgASgCBEYEfyACIAMgABDwAQVBAQtFDwtBp8sBQbn6AEEyQfc6EAAAC0GYywFBufoAQTNB9zoQAAALcQECfwJAIAAoApgBIgJFBEAgABDcBCICNgKcASAAIAI2ApgBDAELQaj/CigCACIDRQ0AIAMoAgQiAg0AENwEIQJBqP8KKAIAIAI2AgQLQaj/CiACNgIAIAIgADYCACACIAE2AjQgAEEDIAEQtwNBAEcL3QEBBn9B4P8KKAIAIgEEQCABEHMaQeD/CkEANgIACyAAKAI0IQEDQCABBEAgASgCBCEEIAEQGSAEIQEMAQsLIAAoAmQhAQNAIAEEQCABKAIAIQUgASgCBBAZIAEoAggQGSABEBkgBSEBDAELCyAAEPYDIAAoAigQGSAAKAIwEBkgACgCiAEQcxoDQCADQQVHBEAgACADQQJ0aigCPCEBA0AgAQRAIAEoAgAhBiABKAIEEBkgARAZIAYhAQwBCwsgA0EBaiEDDAELCyAAEBlBsIILKAIAGkHUiwsoAgAaCxIAIAAoArgBIgAEQCAAEPkDCwu5AQEDfyMAQTBrIgMkAAJAIAIoAgAiBEUNACAELQAARQ0AIAAoAjwhBCAAKAIQIgUEQCAFKAKQAUUNAQsCQCAALQCZAUEgcQRAIAMgASkDCDcDKCADIAEpAwA3AyAMAQsgAyABKQMINwMYIAMgASkDADcDECADQSBqIAAgA0EQahCiBgsgBEUNACAEKAJYIgFFDQAgAyADKQMoNwMIIAMgAykDIDcDACAAIAMgAiABEQUACyADQTBqJAALIgEBfwJAIAAoAjwiAUUNACABKAIwIgFFDQAgACABEQEACwsiAQF/AkAgACgCPCIBRQ0AIAEoAiwiAUUNACAAIAERAQALCyIBAX8CQCAAKAI8IgFFDQAgASgCKCIBRQ0AIAAgAREBAAsLfgEGfCABKwOQBCEHIAErA4AEIQMgASsDiAQhCCABKwPgAiEFIAErA/gDIQQCQCABKALoAgRAIAMgAisDCKCaIQYMAQsgBCACKwMAoCEGIAJBCGohAiADIQQLIAIrAwAhAyAAIAUgCKIgBqI5AwAgACAFIAeiIAQgA6CiOQMICywBAn8CQCAAKAIkIgJFDQAgAC0AkAENACAAKAIAKAJoDQAgAhDiAyEBCyABC2cBAn8jAEEQayIDJAADQAJAIAEtAAAiAkHcAEcEQCACBEAgAsAiAkEATgRAIAAgAhBeDAMLIAMgAjYCACAAQY/eACADEB4MAgsgA0EQaiQADwsgAEGjwQEQGhoLIAFBAWohAQwACwALtgICBH8DfCMAQfAAayIBJABBzP4KQcz+CigCACIEQQFqNgIAAnwgACgCECIDKAKIASICRQRARAAAAAAAAElAIQVEAAAAAAAASUAMAQsgArdEGC1EVPshCUCiRAAAAAAAgGZAoyIFEEghB0QAAAAAAADwPyAFEF2hRAAAAAAAAElAohDjAiEFIAdEAAAAAAAA8D+gRAAAAAAAAElAohDjAgshBiAAQcGtAxAaGiADKALUASICBEAgACACEH8gAEHfABBeCyABIAU5A2AgASAGOQNYIAEgBDYCUCAAQdm7BCABQdAAahAeIAFBKGoiAiADQThqQSgQIxogAEQAAAAAAAAAACACEOEEIABEAAAAAAAA8D8gASADQeAAakEoECMiARDhBCAAQea4BBAaGiABQfAAaiQAIAQL+QICBH8BfSMAQYABayIDJABByP4KQcj+CigCACIFQQFqNgIAIAAoAhAiBCgCiAEhBiADQgA3A3ggA0IANwNwIANCADcDaCADQgA3A2AgASADQeAAaiACIAa3RBgtRFT7IQlAokQAAAAAAIBmQKNBABCPCCAAQaWtAxAaGiAEKALUASIBBEAgACABEH8gAEHfABBeCyADIAU2AlAg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ACAAIABBNGpBABCmCQsOACAAIABBMGpBARCmCQubAQIDfwJ8IAAoAhAiASgCxAEEQCABKALIASEBA0AgASgCACIDKAIQIgJB+ABqIQEgAi0AcA0ACyACKAJgIgErAyAhBCABKwMYIQUgABArIQIgAygCECgCYCIBIAAoAhAiACsDECAEIAUgAigCECgCdEEBcRtEAAAAAAAA4D+ioDkDOCAAKwMYIQQgAUEBOgBRIAFBQGsgBDkDAAsLTwAgAEEANgI0IABBADYCCCAAQgA3AwAgAEIANwIsIABCADcDECAAQgA3AxggAEIANwMgIABBADoAKCABBEAgAUIANwMYIAAgARCoCQsgAAuIAQEBfyAAIAEgAiADIAUQwgYhBiAEIAMgBSgCABEAAAR/IAMgBBCUASADIAIgBSgCABEAAEUEQCAGQQFqDwsgAiADEJQBIAIgASAFKAIAEQAARQRAIAZBAmoPCyABIAIQlAEgASAAIAUoAgARAABFBEAgBkEDag8LIAAgARCUASAGQQRqBSAGCwtpAQF/IAAgASACIAQQuwMhBSADIAIgBCgCABEAAAR/IAIgAxCUASACIAEgBCgCABEAAEUEQCAFQQFqDwsgASACEJQBIAEgACAEKAIAEQAARQRAIAVBAmoPCyAAIAEQlAEgBUEDagUgBQsLxwwBC38DQCABQRhrIQgDQCAAIQQDQAJAAkACQAJAAkACQAJAAkAgASAEayIAQRhtIgUOBgcHAAQBAgMLIAFBGGsiACAEIAIoAgARAABFDQYgBCAAEJQBDwsgBCAEQRhqIARBMGogAUEYayACEMIGGg8LIAQgBEEYaiAEQTBqIARByABqIAFBGGsgAhDBBhoPCyAAQacBTARAIAEhBSMAQSBrIggkACAEIARBGGogBEEwaiIDIAIQuwMaIARByABqIQAgCEEIakEEciEGA0AgBSAAIgFHBEAgACADIAIoAgARAAAEQCAIIAAoAgA2AgggCCAAKAIENgIMIAggACgCCDYCECAAQgA3AgQgCCAAKwMQOQMYA0ACQCAAIAMiABDIASAAIARGBEAgBCEADAELIAhBCGogAEEYayIDIAIoAgARAAANAQsLIAAgCEEIahDIASAGEOUBCyABQRhqIQAgASEDDAELCyAIQSBqJAAPCyADRQRAIAEgBEciAAR/IAAEQCABIARr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ACAEIAJBBHRqIgcgESAAQQR0aiIGKwMAOQMAIAcgBisDCDkDCCAAQQFqIQAgAkEBaiECDAELCyADIAtqIQogBSAOaiEHIAMgDmooAgAhAANAIAAgBygCAE5FBEACQCAJIBMgAEECdGooAgAiA0ECdGooAgAiBiAKKAIASARAIBAgAkECdGogAzYCACAEIAJBBHRqIgMgCCAAQQR0aiIGKwMAOQMAIAMgBisDCDkDCCACQQFqIQIMAQsgBCAGQQR0aiIDIAggAEEEdGoiBisDACADKwMAoDkDACADIAYrAwggAysDCKA5AwgLIABBAWohAAwBCwsgBSALaiACNgIAIAEhAAwACwALIARBACAEQQBKGyEMIA0oAhwhBCABKAIcIQMgACgCHCERQQAhAANAIAAgDEYNAiAPIABBAWoiAUECdCIIaiEKIA8gAEECdCIFaigCACEAA0AgACAKKAIATkUEQCAJIBQgAEECdCIHaigCACIGQQJ0aiACNgIAIBAgAkECdCISaiAGNgIAIAQgEmogByARaigCADYCACAAQQFqIQAgAkEBaiECDAELCyAFIAtqIQogCCAOaiEHIAUgDmooAgAhAANAIAAgBygCAE5FBEACQCAJIBMgAEECdCIFaigCACIGQQJ0aigCACISIAooAgBIBEAgECACQQJ0IhJqIAY2AgAgBCASaiADIAVqKAIANgIAIAJBAWohAgwBCyAEIBJBAnRqIgYgBigCACADIAVqKAIAajYCAAsgAEEBaiEADAELCyAIIAtqIAI2AgAgASEADAALAAsgBEEAIARBAEobIQhBACEAA0AgACAIRg0BIA8gAEEBaiIBQQJ0IgRqIQUgDyAAQQJ0IgNqKAIAIQADQCAAIAUoAgBORQRAIAkgFCAAQQJ0aigCACIMQQJ0aiACNgIAIBAgAkECdGogDDYCACAAQQFqIQAgAkEBaiECDAELCyADIAtqIQUgBCAOaiEMIAMgDmooAgAhAANAIAAgDCgCAE5FBEAgCSATIABBAnRqKAIAIgNBAnRqKAIAIAUoAgBIBEAgECACQQJ0aiADNgIAIAJBAWohAgsgAEEBaiEADAELCyAEIAtqIAI2AgAgASEADAALAAsgDSACNgIICyAJEBkLIA0PC0HT0gFB3LIBQdYFQcKsARAAAAtB+8YBQdyyAUHXBUHCrAEQAAAL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MUHMKkEZQQEgABBGGkGAigsQpQELIAVBAWsiDyAFbEECbSEIAkAgEA0AQQAhACASQQAgEkEAShshBEQAAAAAAADwPyE5A0AgACAERwRAIBUgAEECdGohAkEAIQsDQCALIDFHBEAgAigCACALQQN0aisDAJkiOyA5IDkgO2MbITkgC0EBaiELDAELCyAAQQFqIQAMAQsLRAAAAAAAACRAIDmjITlBACECA0AgAiAERg0BIBUgAkECdGohA0EAIQsDQCALIDFHBEAgAygCACALQQN0aiIAIDkgACsDAKI5AwAgC0EBaiELDAELCyACQQFqIQIMAAsACyAFIAhqIQpEAAAAAAAAAAAhOQJAIDpEAAAAAAAAAABkRQ0AQQAhACAPQQAgD0EAShshAyAIsiFBQQAhBANAIAAgA0cEQCAAQQFqIgIhCwNAIARBAWohBCAFIAtMBEAgAiEADAMFIDkgFSASIAAgCxDlCiAoIARBAnRqKgIAu6OgITkgC0EBaiELDAELAAsACwtBACELIApBACAKQQBKGyECIDkgQbujtiFBA0AgAiALRg0BICggC0ECdGoiACAAKgIAIEGUOAIAIAtBAWohCwwACwALQQAhCyASQQAgEkEAShshMgNAIAsgMkcEQCAFIBUgC0ECdGooAgAQswIgC0EBaiELDAELCyAVKAIEIgIrAwAhOUEAIQsDQCALIDFHBEAgAiALQQN0aiIAIAArAwAgOaE5AwAgC0EBaiELDAELC0EAIQIgEkEEECAhLSAFIBJsIgdBBBAgIQQDQCACIDJHBEAgLSACQQJ0IgBqIAQgAiAFbEECdGoiAzYCACAAIBVqIQBBACELA0AgCyAxRwRAIAMgC0ECdGogACgCACALQQN0aisDALY4AgAgC0EBaiELDAELCyACQQFqIQIMAQsLQQAhAkGoggstAAAEQCAhEIoBOQMAQejeBigCAEH6sQEgIRAxCyAIsiFIIAogKBCRBCAKICgQ+AYgBSAFQQgQICIzEIgFIA9BACAPQQBKGyEXIAUhAEEAIQQDQCACIBdHBEBBASAAIABBAUwbIQhEAAAAAAAAAAAhOUEBIQsDQCAEQQFqIQQgCCALRwRAIDMgAiALakEDdGoiAyADKwMAICggBEECdGoqAgC7IjuhOQMAIAtBAWohCyA5IDugITkMAQsLIDMgAkEDdGoi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IgFFDQADQCABIAFBMGsiBCABKAIAQQNxQQJGGygCKCgCECIFLQCsAUEBRw0BIAVBADYC6AEgASAEIAEoAgBBA3FBAkYbKAIoKAIQKALIASgCACIBDQALCyAAIAMQLSEDDAELCyAAIAIQHCECDAELCyAAEOMKC1sBAn9BASAAIAFBFGxqIgMoAgAiACAAQQFMGyEEQQAhAEEBIQEDQCABIARGRQRAIAAgAiADKAIEIAFBAnRqKAIAQQJ0aigCAEEASmohACABQQFqIQEMAQsLIAAL8xECGX8MfCMAQTBrIgMkAEHUwwooAgAhBUGQwwooAgAhAgNAIAIgD0YEQANAIAJBAWsgC00EQEGoggstAABBAUsEQCADIBI2AiQgAyAANgIgQejeBigCAEHZrQQgA0EgahAiCyADQTBqJAAgEg8LQdTDCigCACALQeAAbGohByALQQFqIg8hCwNAIAIgC00EQCAPIQsMAgUgAyAHKQMQNwMYIAMgBykDCDcDECADQdTDCigCACALQeAAbGoiCCkDEDcDCCADIAgpAwg3AwBBACECQQAhBiMAQaAEayIBJAAgASADKQMYNwOoAyABIAMpAxA3A6ADIAEgBykDMDcDmAMgASAHKQMoNwOQAyABQeADaiABQaADaiABQZADahCaBSABIAMpAxg3A4gDIAEgAykDEDcDgAMgASAHKQNANwP4AiABIAcpAzg3A/ACIAFB0ANqIAFBgANqIAFB8AJqEJoFIAEgAykDCDcD6AIgASADKQMANwPgAiABIAgpAzA3A9gCIAEgCCkDKDcD0AIgAUHAA2ogAUHgAmogAUHQAmoQmgUgASADKQMINwPIAiABIAMpAwA3A8ACIAEgCCkDQDcDuAIgASAIKQM4NwOwAiABQbADaiABQcACaiABQbACahCaBQJAIAErA+ADIAErA7ADZUUNACABKwPAAyABKwPQA2VFDQAgASsD6AMgASsDuANlRQ0AIAErA8gDIAErA9gDZUUNAEEBIQIgBygCUCIFQQFxBEAgCC0AUEEBcQ0BCwJAIAVBAnFFDQAgCC0AUEECcUUNACADKwMQIAMrAwChIhogGqIgAysDGCADKwMIoSIaIBqioCAHKwM4IAcrAyihIAgrAzigIAgrAyihIhogGqJEAAAAAAAA0D+iZEUhAgwBC0GwxQooAgAiBUUEQEGwxQpBrMUKKAIAQRAQIDYCAEG0xQpBrMUKKAIAQRAQIDYCAEGwxQooAgAhBQsgBygCSCIMQQAgDEEAShshCSADKwMYIRogAysDECEbIAcoAkwhBCAFIQIDQCAGIAlHBEAgAiAbIAQrAwCgOQMAIAIgGiAEKwMIoDkDCCAGQQFqIQYgAkEQaiECIARBEGohBAwBCwtBACEGIAgoAkgiDUEAIA1BAEobIQkgAysDCCEaIAMrAwAhGyAIKAJMIQRBtMUKKAIAIhMhAgNAIAYgCUcEQCACIBsgBCsDAKA5AwAgAiAaIAQrAwigOQMIIAZBAWohBiACQRBqIQIgBEEQaiEEDAELCyANQQF0IRYgDEEBdCEXIA1BAWshGCAMQQFrIRlBACECQQAhBEEAIQZBACEJAkACQANAIAEgBSAJQQR0aiIKKQMINwOoAiABIAopAwA3A6ACIAEgBSAJIBlqIAxvQQR0aiIQKQMINwOYAiABIBApAwA3A5ACIAFBkARqIAFBoAJqIAFBkAJqENULIAEgEyAGQQR0aiIOKQMINwOIAiABIA4pAwA3A4ACIAEgEyAGIBhqIA1vQQR0aiIRKQMINwP4ASABIBEpAwA3A/ABIAFBgARqIAFBgAJqIAFB8AFqENULIAFBiMMKKQMANwPoASABIAEpA5gENwPYASABIAEpA4gENwPIASABQYDDCikDADcD4AEgASABKQOQBDcD0AEgASABKQOABDcDwAEgASsD6AEgASsD2AEiGqEgASsDwAEgASsD0AEiG6GiIAErA+ABIBuhIAErA8gBIBqhoqEhHiABIBApAwg3A7gBIAEgECkDADcDsAEgASAKKQMINwOoASABIAopAwA3A6ABIAEgDikDCDcDmAEgASAOKQMANwOQASABQbABaiABQaABaiABQZABahDMCyEUIAEgESkDCDcDiAEgASARKQMANwOAASABIA4pAwg3A3ggASAOKQMANwNwIAEgCikDCDcDaCABIAopAwA3A2AgAUGAAWogAUHwAGogAUHgAGoQzAshFSABIBApAwg3A1ggASAQKQMANwNQIAEgCikDCDcDSCABIAopAwA3A0AgASARKQMINwM4IAEgESkDADcDMCABIA4pAwg3AyggASAOKQMANwMgIAErAzAiHyABKwNYIhogAUFAayIKKwMIIiChoiABKwMgIiQg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IABBAToANgsLCgBBjMQKKAIARQsKACAAIAFqKAIAC10BAX8gACgCECIDRQRAIABBATYCJCAAIAI2AhggACABNgIQDwsCQCABIANGBEAgACgCGEECRw0BIAAgAjYCGA8LIABBAToANiAAQQI2AhggACAAKAIkQQFqNgIkCwtZAQJ/IAAoAhQEQEGIxAooAgAgABCfC0EobGohAQNAIAEiAigCICIBIABHDQALIAIgACgCIDYCIEGMxApBjMQKKAIAQQFrNgIAIAAoAhQQggUgAEEANgIUCwuzAQEDfyMAQRBrIgIkACACIAE2AgwCQAJAAn8gABDBASIERQRAQQEhASAAEKwHDAELIAAQ3QJBAWshASAAKAIECyIDIAFGBEAgACABQQEgASABEJsLIAAQQxoMAQsgABBDGiAEDQAgACIBIANBAWoQwAEMAQsgACgCACEBIAAgA0EBahC+AQsgASADQQJ0aiIAIAJBDGoQygEgAkEANgIIIABBBGogAkEIahDKASACQRBqJAAL0AEBA38jAEEQayIFJAAgAkHv////ByABa00EQCAAEEMhBiAFQQRqIgcgACABQef///8DSQR/IAUgAUEBdDYCDCAFIAEgAmo2AgQgByAFQQxqENgDKAIAENcDQQFqBUHv////BwsQ1gMgBSgCBCECIAUoAggaIAQEQCACIAYgBBCdAgsgAyAERwRAIAIgBGogBCAGaiADIARrEJ0CCyABQQFqIgFBC0cEQCAAIAYgARCmBQsgACACEO0BIAAgBSgCCBDsASAFQRBqJAAPCxDrAQALDQAgACABIAJCfxC0BQsHACAAQQxqC0oBAX8gAEEYaiIDIAFBAnRqIAI2AgAgAhCBBSADQQEgAWtBAnRqKAIABEAgABCyCyAAKAIgEIIFIAAoAiQQggUgAEHYwwoQlgcLCysBAn8gACgCACEBIwBBEGsiACQAIAAgATYCDCAAKAIMIQIgAEEQaiQAIAILFwAgACgCCBBhRwRAIAAoAggQigwLIAALEwAgACABKAIANgIAIAEgADYCAAs6AQJ/IwBBEGsiAyQAIAMgAjYCDCADQQhqIANBDGoQggIhBCAAIAEQugchACAEEIECIANBEGokACAACxMAIAAgACgCAEEBayIANgIAIAALDwAgACAAKAIEQQFqNgIECzcBAn8jAEEQayICJAAg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AgAiATYCACAAIAFBDGsoAgBqQdz9BigCADYCACAAQQRqEKsHGiAAQThqELEMIAALGAAgAEHk+gY2AgAgAEEgahAyGiAAELcHCwsAIAAtAAtB/wBxCx0AIwBBEGsiAyQAIAAgASACEJ4MIANBEGokACAAC1QAAkAgAQRAIAEoAgQgAk0NASAAIAEoAgAgAkEEdGoiASkCADcCACAAIAEpAgg3AggPC0GCygFB5rMBQSFBzCEQAAALQeGiA0HmswFBIUHMIRAAAAsTACAAIAEgAiAAKAIAKAIwEQMACxQAIAAgAUH4JEEhQeazAUEEEIEHC64BAQZ/IwBBEGsiAiQAIAJBCGoiAyAAEKwFGgJAIAMtAABFDQAgAkEEaiIDIAAgACgCAEEMaygCAGoQSyADEKcMIQQgAxBJIAIgABCmDCEFIAAgACgCAEEMaygCAGoiBhDKBiEHIAIgBCAFKAIAIAYgByABIAQoAgAoAiARLgA2AgQgAxCqBUUNACAAIAAoAgBBDGsoAgBqQQUQrQULIAJBCGoQqwUgAkEQaiQAIAALSQEBfyAABEADQCABIAAoAgRPRQRAIAAoAgAgAUEEdGooAAQQGSABQQFqIQEMAQsLIABBADYCBA8LQYLKAUHmswFBIUGLOhAAAAsMACAAQQRqELEMIAALKAECfyMAQRBrIgIkACABKAIAIAAoAgBIIQMgAkEQaiQAIAEgACADGwsQACAAIAE3AwggAEIANwMACwIACxQAIABB9PkGNgIAIABBBGoQSSAAC9MDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACE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QYCAgIB4CyEAIAMgCRDqAyEnDAELIAArAzggACsDKKBEAAAAAAAA4D+iIScgAyAJEOkDIQALIAsCfyAnmUQAAAAAAADgQWMEQCAnqgwBC0GAgICAeAsiAjYCkAEgCyAANgKUASAOQeTwAyALQZABahAiQQEhBEEBIAUgBUEBTRshBSAjIAC3IiEgISAjYxshJyAlIAK3IiMgIyAlYxshJSAiICEgISAiZBshISAkICMgIyAkZBshJAJAAkACfwNAIAQgBUYEQAJAIAdBUEEAIAcoAgBBA3FBAkcbaigCKCgCECgCgAEhACADIAVBOGxqQThrIgItAABFDQQgAEFAaysDACAAKwMwoEQAAAAAAADgP6IiIplEAAAAAAAA4EFjRQ0AICKqDAMLBQJAIAMgBEE4bGoiCC0AAARAIAggCRDqAyIimUQAAAAAAADgQWMEQCAiqiECDAILQYCAgIB4IQIMAQsgCCAJEOkDIQALIAsgAjYCgAEgCyAANgKEASAOQfrwAyALQYABahAiICcgALciIiAiICdjGyEnICUgArciIyAjICVjGyElICEgIiAhICJjGyEhICQgIyAjICRkGyEkIARBAWohBAwBCwtBgICAgHgLIQQgAiAJEOoDISIMAQsgACsDOCAAKwMooEQAAAAAAADgP6IhIiACIAkQ6QMhBAsgCwJ/ICKZRAAAAAAAAOBBYwRAICKqDAELQYCAgIB4CyIANgJwIAsgBDYCdCAOQYCWBCALQfAAahAiICcgBLciIiAiICdjGyEjICEgIiAhICJjGyEiICUgALciISAhICVjGyElICQgISAhICRkGyEkIAZBAWohBgwBCwsgCyAjRAAAAAAAACRAoDkDaCALICVEAAAAAAAAJECgOQNgIAsgIkQAAAAAAAAkQKA5A1ggCyAkRAAAAAAAACRAoDkDUCAOQfCNBCALQdAAahAxBSAJKAIMIARByABsaiIAKwMoISEgACsDMCEiIAArAzghIyALIABBQGsrAwA5AyggCyAjOQMgIAsgIjkDGCALICE5AxAgDkHOmQQgC0EQahAxIARBAWohBAwBCwsLQQAhB0EAIQZBACEEA0AgASAERwRAIBcgBEEDdCICaigCBCIFIAVBMGsiDSAFKAIAQQNxIgNBAkYbKAIoKAIQIggrABAhISAFKAIQIgArADghKyAFIAVB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z9gDIAlB8ABqECILIAAQGyECA0AgAgRAIAIoAhBBADYCuAEgACACEBwhAgwBCwtBqIILLQAAQQJPBEAgASgCECECIAkgABAhNgJkIAkgAjYCYEHo3gYoAgBB5OADIAlB4ABqECILIAEgASgCEEEBajYCECAJQfS7CigCADYCXEHApQEgCUHcAGpBABDDASILQaAlQaACQQEQMBpBOBBOIQIgCygCECACNgKMASAAEDQhAiALKAIQIAIoAhAvAbABOwGwASAAIAtBrdsAENsGIAAgC0Hx2QAQ2wYgACALQe/MARDbBiAJQZgBaiEEIAlBkAFqIQwgCUGIAWohA0EBIQUDQCAAKAIQIgIoArQBIAVOBEAgAigCuAEgBUECdGooAgAiDRD9BSALIA0QIRDaBiIHKAIQIgIgEDYCiAEgAiANNgLoAQJAAkAgASgCBCICRQRARP///////+9/ISZE////////7/8hJQwBC0T////////vfyEmRP///////+//ISUgDSACEDkiBi0AAEUNACANIAEoAgBHBEAgBiANKAI4IAIQORAoRQ0BCyAJQQA6AKwBIAkgAzYCRCAJIAw2AkggCSAENgJMIAkgCUGsAWo2AlAgCSAJQYABajYCQCAGQbe6ASAJQUBrEEdBBE4EQCAJKwOYASElIAkrA5ABISQgCSsDiAEhJiAJKwOAASEjQbiCCysDACInRAAAAAAAAAAAZARAICUgJ6MhJSAkICejISQgJiAnoyEmICMgJ6MhIwsgBygCEEEDQQJBASAJLQCsASICQT9GGyACQSFGGzoAhwEMAgsgDRAhIQIgCSAGNgI0IAkgAjYCMEEAQebSAyAJQTBqEB8LRP///////+//ISRE////////738hIwsgEEEBaiEQIA0QGyECA0AgAgRAIAIoAhAgBzYCuAEgDSACEBwhAgwBCwsgBygCECICLQCHAQRAIAIoApQBIgIgJSAmoEQAAAAAAADgP6I5AwggAiAkICOgRAAAAAAAAOA/ojkDAAsgBUEBaiEFDAELCyAAEBshAgJ/AkADQCACBEACQCACKAIQIgwoArgBDQACQCAMKALoASIDRQ0AIAMgACgCECgCjAEoAjBGDQAgAhAhIQEgABAhIQAgCSACKAIQKALoARAhNgIoIAkgADYCJCAJIAE2AiBBAUHA4QQgCUEgahAf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mZmZuT+iISogKESamZmZmZm5P6IhKSAIEBshBQNAIAVFDQICQCAFKAIQIgIoAoABKAIIRQRAIAIoAugBRQ0BCyACLQCHAQRAIAIoApQBIgIgAisDACAooTkDACACIAIrAwggJqE5AwgMAQtBACEKRAAAAAAAAAAAISMgCCAFEGohAkQAAAAAAAAAACEkA0AgAgRAAkAgAkFQQQAgAigCAEEDcSIDQQJHG2ooAigiBCACIANBA0dBMGxqKAIoIgNGDQAgAyAEIAQgBUYbKAIQIgMtAIcBRQ0AIAoEQCAkIAq3IiuiIAMoApQBIgMrAwigIApBAWoiCrciJaMhJCAjICuiIAMrAwCgICWjISMMAQsgAygClAEiAysDCCEkIAMrAwAhI0EBIQoLIAggAiAFEHAhAgwBCwsCQCAKQQJOBEAgBSgCECICKAKUASIEICM5AwAMAQsgCkEBRgRAIAUoAhAiAigClAEiBCAjRFyPwvUoXO8/oiApoDkDACAkRM3MzMzMzOw/oiAqoCEkDAELELoBITAQugEhK0HA4worAwAhJCAwRBgtRFT7IRlAoiIlEEghIyAFKAIQIgIoApQBIgQgIyAkICtEzczMzMzM7D+iIiSiojkDAEHI4worAwAhIyAlEF0gJCAjoqIhJAsgBCAkOQMIIAJBAToAhwELIAggBRAcIQUMAAsACyAIEBshAiAERQRAA0AgAkUNAkHA4worAwAhIxC6ASEkIAIoAhAoApQBICMgJCAkoEQAAAAAAADwv6CiOQMAQcjjCisDACEjELoBISQgAigCECgClAEgIyAkICSgRAAAAAAAAPC/oKI5AwggCCACEBwhAgwACwALA0AgAkUNAQJAIAIoAhAiAy0AhwEEQCADKAKUASIDIAMrAwAgKKE5AwAgAyADKwMIICahOQMIDAELQcDjCisDACEjELoBISQgAigCECgClAEgIyAkICSgRAAAAAAAAPC/oKI5AwBByOMKKwMAISMQugEhJCACKAIQKAKUASAjICQgJKBEAAAAAAAA8L+gojkDCAsgCCACEBwhAgwACwALAkBB+OIKKAIARQRAQdTjCigCACEEQQAhBQNAIAQgBUwNAkGo4worAwBBiOMKKAIAIgIgBWu3oiACt6MiI0QAAAAAAAAAAGVFBEAgCBAbIQIDQCACBEAgAigCECgCgAEiA0IA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IAAoAhAiCygCBEYEQCALKAIADAELIABBGGoLIgsrAwghCCALKwMAIQcCfyABIAEoAhAiACgCBEYEQCAAKAIADAELIAFBGGoLIgArAwghCSAAKwMAIQogAkF/IAcgBKEiByAFIAOhoiAGIAShIAggA6EiBaKhIgZEAAAAAAAAAABkIAZEAAAAAAAAAABjGyIANgIAIAJBfyAHIAkgA6GiIAogBKEgBaKhIgNEAAAAAAAAAABkIANEAAAAAAAAAABjGyIBNgIEIAIgACABbDYCCAtNAQJ8An9BASAAKAIAIgArAwAiAiABKAIAIgErAwAiA2QNABpBfyACIANjDQAaQQEgACsDCCICIAErAwgiA2QNABpBf0EAIAIgA2MbCwv8DgMWfwp8AX4jAEHwAGsiAyQAIAFBACABQQBKGyERIAFBKBAgIQ8DQCACIBFGRQRAIAAgAkECdGooAgAoAgQgDGohDCACQQFqIQIMAQsLIAxBGBAgIQ0DQCAEIBFGRQRAIA8gBEEobGoiByANIAVBGGxqNgIAIAAgBEECdGohCET////////vfyEbRP///////+//IRpBACECRP///////+//IRxE////////738hHQNAIAIgCCgCACIGKAIETkUEQCAGKAIAIAJBBHRqIgYrAwAhGCAGKwMIIRkgDSAFQRhsaiIGQQA2AhQgBiAHNgIQIAYgGTkDCCAGIBg5AwAgGiAZIBkgGmMbIRogHCAYIBggHGMbIRwgGyAZIBkgG2QbIRsgHSAYIBggHWQbIR0gAkEBaiECIAVBAWohBQwBCwsgByAdOQMIIAcgGjkDICAHIBw5AxggByAbOQMQIAcgBUEYbCANakEYazYCBCAEQQFqIQQMAQsLQQAhAiAMQQAgDEEAShshFSAMQQQQHSEQA0AgAiAVRkUEQCAQIAJBAnRqIA0gAkEYbGo2AgAgAkEBaiECDAELCyAQIAxBBEEvEI4BQQAhCEEAIQcCQAJAA0AgDiAVRwRAIAMgECAOQQJ0aiIWKAIAIgI2AkwgAwJ/IAIoAhAiBigCACACRgRAIAYoAgQMAQsgAkEYawsiBTYCSEEAIRIDQAJAAkAgEkECRwRAIAghAiAHIQYCQCADQcwAaiADQcgAahDKCkEBag4DAAMCAwtBACECIAlBACAJQQBKGyETIAVBGGohFANAAkAgAiAT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ahAiEC8AC6oBAQR/QbzECigCAEUEQEG8xApBkMMKKAIAQQQQHSIANgIAQYDFCiAAQZDDCigCAEECdGo2AgALELwLQbzECigCACEBQZDDCigCACECQQAhAANAIAAgAkYEQCABIAJBBEErEI4BQYTFCkG8xAooAgA2AgAFIAEgAEECdGpB1MMKKAIAIABB4ABsaiIDQQhqNgIAIANBATYCHCADQQA2AlggAEEBaiEADAELCwszAQJ/IwBBIGsiAyQAIAAQNUECTgRAIAAgACABIANBCGoQ9AoQygMhAgsgA0EgaiQAIAIL+gECA38EfCAABEAQ7QoLQaDDCkL/////////dzcDAEGYwwpC//////////f/ADcDAAJAQZDDCigCACICBEBBvMQKKAIAIQFE////////738hBET////////v/yEFQQAhAANAIAAgAkYNAkGYwwogBCABIABBAnRqKAIAIgMrAwAQPyIEOQMAQaDDCiAFIAMrAwAQMyIFOQMAIABBAWohAAwACwALQcaJA0G9swFB4gFBwY8BEAAAC0GowwogASgCACsDCCIGOQMAQbDDCiACQQJ0IAFqQQRrKAIAKwMIIgc5AwBBuMMKIAUgBKE5AwBBwMMKIAcgBqE5AwAL6AICB38EfBDtCkGAxQooAgAhBUG8xAooAgAhAANAAkAgBSAAIgFLBEAgAUEEaiIAIAVPDQIgASgCACIDKwMAIgcgASgCBCICKwMAYg0CIAMrAwgiCCACKwMIYg0CIAFBCGohA0ECIQICQANAIAMgBU8NASADKAIAIgQrAwghCSAEKwMAIgogB2IgCCAJYnJFBEAgA0EEaiEDIAJBAWohAgwBCwsgCCAJYg0AIAogB6EgArejIQdBASEBA0AgACADTw0DIAAoAgAiAiABtyAHoiACKwMAoDkDACAAQQRqIQAgAUEBaiEBDAALAAtB1MMKKAIAIQIDQCAAIANPDQIgACgCACIEIAEoAgAiBisDACACIAYoAhBB4ABsaiIGKwM4IAYrAyihIAIgBCgCEEHgAGxqIgQrAzggBCsDKKGgRAAAAAAAAOA/oqA5AwAgAEEEaiEAIAFBBGohAQwACwALDwsgAyEADAALAAuGAQEEfEGAxAogACsDACIDOQMAQfjDCiABKwMAIgQ5AwBB8MMKIAArAwgiBTkDACABKwMIIQJB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aiAHEJ0CCyABQQFqIgFBC0cEQCAAIAkgARCmBQsgACACEO0BIAAgCCgCCBDsASAAIAQgBmogB2oiABC+ASAIQQA6AAwgACACaiAIQQxqEL8BIAhBEGokAA8LEOsBAAsNACAAQdTTBzYCACAACxYAIAAgASACQoCAgICAgICAgH8QtAULCQAgABBhNgIACyMBAn8gACEBA0AgASICQQRqIQEgAigCAA0ACyACIABrQQJ1Cw8AIAAgACgCAEEEazYCAAsKACAAKAIAQQRrCywAIAAoAgAaIAAoAgAaIAAQjwMaIAAoAgAaIAAQgAIaIAAoAgAaIAAQjwMaCzAAIwBBEGsiAiQAAkAgACABRgRAIAFBADoAeAwBCyACQQ9qIAEQsQsLIAJBEGokAAssAQF/IAAoAgQhAgNAIAEgAkcEQCAAEJADGiACQQRrIQIMAQsLIAAgATYCBAsJACAAQQA2AgALJgAgACgCABogACgCABogABCPAxogACgCABogABCPAxogACgCABoLSwEBfyMAQRBrIgMkAAJAAkAgAkEeSw0AIAEtAHgNACABQQE6AHgMAQsgA0EPaiACELULIQELIANBEGokACAAIAI2AgQgACABNgIAC0QBAn8jAEEQayIBJAAgABCQAxogAUH/////AzYCDCABQf////8HNgIIIAFBDGogAUEIahCbDCgCACECIAFBEGokACACCwsAIABBADYCACAACycBAn8jAEEQayIBJAAgASAANgIMIAFBDGoQlAchAiABQRBqJAAgAgs3AQF/IwBBEGsiAyQAIAMgARCvCzYCDCADIAIQrws2AgggACADQQxqIANBCGoQpwUgA0EQaiQACwkAIAFBBBCWDAv1BQIHfAJ/AkACQCAAKwMAIgNEAAAAAAAA8D9hBEAgAEEYQRwgACsDCCIDRAAAAAAAAAAAZiIIG2ooAgAhCQJAAnwgAEEcQRggCBtqKAIAIggEQCAIKwMIIgVB6MMKKwMAZA0FQfDDCisDACICIAVlBEAgCCsDACEEDAMLIAArAxAgAyACoqEMAQsgACsDECADQfDDCisDACICoqELIQQgAiEFCwJ8IAkEQCAJKwMIIgEgAmMNBEHowworAwAiAiABZgRAIAkrAwAMAgsgACsDECADIAIiAaKhDAELIAArAxAgA0HowworAwAiAaKhCyEGIARB+MMKKwMAIgdkIgggBiAHZHENAkGAxAorAwAiAiAEZCACIAZkcQ0CIAgEQCAAKwMQIAehIAOjIQUgByEECyACIARkBEAgACsDECACoSADoyEFIAIhBAsgBiAHZARAIAArAxAgB6EgA6MhASAHIQYLIAIgBmRFBEAgBiECDAILIAArAxAgAqEgA6MhAQwBCyAAKAIcIQkCQAJ8IAAoAhgiCARAIAgrAwAiBEH4wworAwBkDQRBgMQKKwMAIgEgBGUEQCAIKwMIIQUMAwsgACsDECADIAGioQwBCyAAKwMQIANBgMQKKwMAIgGioQshBSABIQQLAnwgCQRAIAkrAwAiAiABYw0DQfjDCisDACIBIAJmBEAgCSsDCAwCCyABIQIgACsDECADIAGioQwBCyAAKwMQIANB+MMKKwMAIgKioQshBiAFQejDCisDACIHZCIIIAYgB2RxDQFB8MMKKwMAIgEgBWQgASAGZHENASAIBEAgByEFIAArAxAgB6EgA6MhBAsgASAFZARAIAEhBSAAKwMQIAGhIAOjIQQLIAYgB2QEQCAAKwMQIAehIAOjIQIgByEGCyABIAZkRQRAIAYhAQwBCyAAKwMQIAGhIAOjIQILIAAoAiAgBCAFENECIAAoAiAgAiABENECIAAoAiQgBCAFENECIAAoAiQgAiABENECCwvfAgEFfyAAKAIQKALEASIEIAFBBnQiCGoiBSgCBCEGAkAgA0EATARAIAIgA2shAgNAIAJBAWoiByAEIAhqKAIAIgVORQRAIAYgB0ECdGooAgAiBCgCECACIANqIgI2AvgBIAYgAkECdGogBDYCACAAKAIQKALEASEEIAchAgwBCwsgA0EBayIHIAVqIQIgAUEGdCEDA0AgAiAFTg0CIAYgAkECdGpBADYCACACQQFqIQIgACgCECgCxAEiBCADaigCACEFDAALAAsgA0EBayEHIAUoAgAhBAN/IAIgBEEBayIETgR/IAIgA2ohAwNAIAJBAWoiAiADTkUEQCAGIAJBAnRqQQA2AgAMAQsLIAAoAhAoAsQBIgQgAUEGdGooAgAFIAYgBEECdGooAgAiBSgCECAEIAdqIgg2AvgBIAYgCEECdGogBTYCAAwBCwshBQsgBCABQQZ0aiAFIAdqNgIACy8BAX8jAEEQayIDJAAgACACEJIDIANBADoADyABIAJq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DCARIA8oAgAgCygCZCALQQxqEKkBIAsoAgwEQCAFIAUoAgBBBHI2AgAMAQtBASEACyAQEHEaIA0QcRogDhBxGiAMEHEaIBEQMhogDxB1DAMLIAIhAQsgA0EBaiEDDAALAAsgC0GQBGokACAACyAAIAAgARDgAxCMASABEJkEKAIAIQEgABCZBCABNgIACwsAIABB7KYLELgCCxkAQX8gASgCACIAIAIoAgAiAUogACABSBsLCwAgAEH0pgsQuAILxwEBBn8jAEEQayIEJAAgABCZBCgCACEFQQECfyACKAIAIAAoAgBrIgNB/////wdJBEAgA0EBdAwBC0F/CyIDIANBAU0bIQMgASgCACEGIAAoAgAhByAFQcQERgR/QQAFIAAoAgALIAMQNyIIBEAgBUHEBEcEQCAAEOADGgsgBEGRAzYCBCAAIARBCGogCCAEQQRqEHYiBRDeCyAFEHUgASAAKAIAIAYgB2tqNgIAIAIgAyAAKAIAajYCACAEQRBqJAAPCxCXAQALIAEBfyABKAIAEKoMwCECIAAgASgCADYCBCAAIAI6AAALmBABCn8jAEGQBGsiCyQAIAsgCjYCiAQgCyABNgKMBAJAIAAgC0GMBGoQWARAIAUgBSgCAEEEcjYCAEEAIQAMAQsgC0HEBDYCTCALIAtB6ABqIAtB8ABqIAtBzABqIgEQdiIPKAIAIgo2AmQgCyAKQZADajYCYCABEEohESALQUBrEEohDCALQTRqEEohDiALQShqEEohDSALQRxqEEohECMAQRBrIgokACALAn8gAgRAIApBBGoiASADEOELIgIQ1gIgCyAKKAIENgBcIAEgAhDVAiANIAEQqgEgARAyGiABIAIQ6QEgDiABEKoBIAEQMhogCyACEOcBOgBbIAsgAhC3AToAWiABIAIQtgEgESABEKoBIAEQMhogASACEOoBIAwgARCqASABEDIaIAIQ1AIMAQsgCkEEaiIBIAMQ3wsiAhDWAiALIAooAgQ2AFwgASACENUCIA0gARCqASABEDIaIAEgAhDpASAOIAEQqgEgARAyGiALIAIQ5wE6AFsgCyACELcBOgBaIAEgAhC2ASARIAEQqgEgARAyGiABIAIQ6gEgDCABEKoBIAEQMhogAhDUAgs2AhggCkEQaiQAIAkgCCgCADYCACAEQYAEcSEUQQAhA0EAIQED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DCAFIAUoAgAiDkEEajYCACAOIAw2AgAgBkEBaiEGIAlBAWohCQwBCwshBgsgBCAGIAMgASAAa0ECdGogASACRhs2AgAgCkEEahAyGiAKQRBqJAAL+AUBCH8jAEEQayIJJAAgCUH0uwooAgA2AgxBtYEBIAlBDGpBABDDASIIQaAlQaACQQEQMBogARCHASEFA0AgBQRAIAggBSgCFBAhQQEQbyIGQbolQcACQQEQMBogBigCECIHIAU2AoABIAUgBjYCGCAHQQA2AsQBQQFBBBAdIQcgBigCECIKIAc2AsABIApBADYCzAFBAUEEEB0hByAGKAIQIAc2AsgBAn8gBARAIAQoAhBBuAFqDAELIAgoAhBBwAFqCyAGNgIAIAUoAgAhBSAGIQQMAQsLIAEQhwEhBQJAA0AgBQRAIAVBIGohCiAFIQQDQCAEKAIAIgQEQCAFIAQgAhEAAEUNASAKIARBIGogAxEAACEGIAggBSgCGCAEKAIYQQBBARBPIgdBrSVBuAFBARAwGiAGQYCABE4NBCAHKAIQIgtBATYCnAEgCyAGNgKsASAAIAUoAhQgBCgCFEEAQQAQT0UNASAHKAIQQeQANgKcAQwBCwsgBSgCACEFDAELCyABEIcBIQIDQCACBEAgCCACKAIYIgAQLCEEA0AgBARAIAAoAhAiASgCyAEgASgCzAEiAUEBaiABQQJqQQQQiAEhASAAKAIQIgMgATYCyAEgAyADKALMASIDQQFqNgLMASABIANBAnRqIAQ2AgAgACgCECIBKALIASABKALMAUECdGpBADYCACAEIARBMGsiASAEKAIAQQNxQQJGGygCKCgCECIDKALAASADKALEASIDQQFqIANBAmpBBBCIASEDIAQgASAEKAIAQQNxQQJGGygCKCgCECADNgLAASAEIAEgBCgCAEEDcUECRhsoAigoAhAiA0HEAWogAygCxAEiBkEBajYCACADKALAASAGQQJ0aiAENgIAIAQgASAEKAIAQQNxQQJGGygCKCgCECIBKALAASABKALEAUECdGpBADYCACAIIAQQLSEEDAELCyACKAIAIQIMAQsLIAlBEGokACAIDwtBzc4BQYW0AUH3AUG5zQEQAAALNQEBfyAAKAIQIgEtALUBQQdHBEAgABCcAQ8LIAEoAugBKAIQKAKQAiABKAL0AUECdGooAgAL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EGohAQNAIAEEQAJAIAFBUEEAIAEoAgBBA3EiA0ECRxtqKAIoIgUgASABQTBqIgggA0EDRhsoAihGDQACQAJAIAQgBUcNAEGwhQsoAgAiBUUNACABIAUQOSIDLQAADQEgASgCAEEDcSEDCyABIAggA0EDRhsoAiggBEcNAUG0hQsoAgAiA0UNASABIAMQOSIDLQAARQ0BIAJBQGsgASADEJoMDAELIAJB0ABqIAEgAxCaDAsgACABIAQQcCEBDAEFQQAhAQNAIAIoAlQgAU0EQCACQdAAahCyB0EAIQEDQCACKAJEIAFNBEAgAkFAaxCyByAAIAQQHCEEDAcLIAJBQGsiAyABELAHKAIIQQJPBEAgAkEgaiADIAEQrgcgAiAGKAIINgIYIAIgBikCADcDECAEIAJBEGoQnQwLIAFBAWohAQwACwALIAJB0ABqIgMgARCwBygCCEECTwRAIAJBMGogAyABEK4HIAIgBygCCDYCCCACIAcpAgA3AwAgBCACEJ0MCyABQQFqIQEMAAsACwALAAsLIAJB0ABqEJcMIAJBQGsQlwwLIAJB4ABqJAALKgEBfyAAKAIMIgEgACgCEEYEQCAAIAAoAgAoAiQRAgAPCyABLAAAEJcDCw8AIAAgACgCACgCGBECAAsIACAAKAIQRQsEAEF/C4YBAQJ/An8CQCAARSABRXINACAAIAAoAgBBA3EiAkEDR0EwbGooAiggASABKAIAQQNxIgNBA0dBMGxqKAIoRw0AIABBUEEAIAJBAkcbaigCKCABQVBBACADQQJHG2ooAihHDQAgACgCECgCYCABKAIQKAJgRw0AQQEgACABEKwEDQEaC0EACwsIACAAEKYHGgu+DwIFfw9+IwBB0AJrIgUkACAEQv///////z+DIQsgAkL///////8/gyEKIAIgBIVCgICAgICAgICAf4MhDSAEQjCIp0H//wFxIQgCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAIQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgxCgICAgICAwP//AFQgDEKAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCENDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQ0gAyEBDAILIAEgDEKAgICAgIDA//8AhYRQBEAgAyACQoCAgICAgMD//wCFhFAEQEIAIQFCgICAgICA4P//ACENDAMLIA1CgICAgICAwP//AIQhDUIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQEIAIQEMAgsgASAMhFAEQEKAgICAgIDg//8AIA0gAiADhFAbIQ1CACEBDAILIAIgA4RQBEAgDUKAgICAgIDA//8AhCENQgAhAQwCCyAMQv///////z9YBEAgBUHAAmogASAKIAEgCiAKUCIGG3kgBkEGdK18pyIGQQ9rEKsBQRAgBmshBiAFKQPIAiEKIAUpA8ACIQELIAJC////////P1YNACAFQbACaiADIAsgAyALIAtQIgcbeSAHQQZ0rXynIgdBD2sQqwEgBiAHakEQayEGIAUpA7gCIQsgBSkDsAIhAwsgBUGgAmogC0KAgICAgIDAAIQiEkIPhiADQjGIhCICQgBCgICAgLDmvIL1ACACfSIEQgAQmAEgBUGQAmpCACAFKQOoAn1CACAEQgAQmAEgBUGAAmogBSkDmAJCAYYgBSkDkAJCP4iEIgRCACACQgAQmAEgBUHwAWogBEIAQgAgBSkDiAJ9QgAQmAEgBUHgAWogBSkD+AFCAYYgBSkD8AFCP4iEIgRCACACQgAQmAEgBUHQAWogBEIAQgAgBSkD6AF9QgAQmAEgBUHAAWogBSkD2AFCAYYgBSkD0AFCP4iEIgRCACACQgAQmAEgBUGwAWogBEIAQgAgBSkDyAF9QgAQmAEgBUGgAWogAkIAIAUpA7gBQgGGIAUpA7ABQj+IhEIBfSICQgAQmAEgBUGQAWogA0IPhkIAIAJCABCYASAFQfAAaiACQgBCACAFKQOoASAFKQOgASIMIAUpA5gBfCIEIAxUrXwgBEIBVq18fUIAEJgBIAVBgAFqQgEgBH1CACACQgAQmAEgBiAJIAhraiEGAn8gBSkDcCITQgGGIg4gBSkDiAEiD0IBhiAFKQOAAUI/iIR8IhBC5+wAfSIUQiCIIgIgCkKAgICAgIDAAIQiFUIBhiIWQiCIIgR+IhEgAUIBhiIMQiCIIgsgECAUVq0gDiAQVq0gBSkDeEIBhiATQj+IhCAPQj+IfHx8QgF9IhNCIIgiEH58Ig4gEVStIA4gDiATQv////8PgyITIAFCP4giFyAKQgGGhEL/////D4MiCn58Ig5WrXwgBCAQfnwgBCATfiIRIAogEH58Ig8gEVStQiCGIA9CIIiEfCAOIA4gD0IghnwiDlatfCAOIA4gFEL/////D4MiFCAKfiIRIAIgC358Ig8gEVStIA8gDyATIAxC/v///w+DIhF+fCIPVq18fCIOVq18IA4gBCAUfiIYIBAgEX58IgQgAiAKfnwiCiALIBN+fCIQQiCIIAogEFatIAQgGFStIAQgClatfHxCIIaEfCIEIA5UrXwgBCAPIAIgEX4iAiALIBR+fCILQiCIIAIgC1atQiCGhHwiAiAPVK0gAiAQQiCGfCACVK18fCICIARUrXwiBEL/////////AFgEQCAWIBeEIRUgBUHQAGogAiAEIAMgEhCYASABQjGGIAUpA1h9IAUpA1AiAUIAUq19IQpCACABfSELIAZB/v8AagwBCyAFQeAAaiAEQj+GIAJCAYiEIgIgBEIBiCIEIAMgEhCYASABQjCGIAUpA2h9IAUpA2AiDEIAUq19IQpCACAMfSELIAEhDCAGQf//AGoLIgZB//8BTgRAIA1CgICAgICAwP//AIQhDUIAIQEMAQsCfiAGQQBKBEAgCkIBhiALQj+IhCEKIARC////////P4MgBq1CMIaEIQwgC0IBhgwBCyAGQY9/TARAQgAhAQwCCyAFQUBrIAIgBEEBIAZrEJgDIAVBMGogDCAVIAZB8ABqEKsBIAVBIGogAyASIAUpA0AiAiAFKQNIIgwQmAEgBSkDOCAFKQMoQgGGIAUpAyAiAUI/iIR9IAUpAzAiBCABQgGGIgFUrX0hCiAEIAF9CyEEIAVBEGogAyASQgNCABCYASAFIAMgEkIFQgAQmAEgDCACIAIgAyACQgGDIgEgBHwiA1QgCiABIANWrXwiASASViABIBJRG618IgJWrXwiBCACIAIgBEKAgICAgIDA//8AVCADIAUpAxBWIAEgBSkDGCIEViABIARRG3GtfCICVq18IgQgAiAEQoCAgICAgMD//wBUIAMgBSkDAFYgASAFKQMIIgNWIAEgA1Ebca18IgEgAlStfCANhCENCyAAIAE3AwAgACANNwMIIAVB0AJqJAALwAECAX8CfkF/IQMCQCAAQgBSIAFC////////////AIMiBEKAgICAgIDA//8AViAEQoCAgICAgMD//wBRGw0AIAJC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBScQ0AIAAgBCAFhIRQBEBBAA8LIAEgAoNCAFkEQCABIAJSIAEgAlNxDQEgACABIAKFhEIAUg8LIABCAFIgASACVSABIAJRGw0AIAAgASAChYRCAFIhAwsgAwsSACAARQRAQQAPCyAAIAEQugcL3h4CEH8FfiMAQZABayIJJAAgCUEAQZABEDoiCUF/NgJMIAkgADYCLCAJQaQENgIgIAkgADYCVCABIQQgAiEPQQAhACMAQbACayIHJAAgCSIDKAJMGgJAAkACQAJAIAMoAgQNACADEM0HGiADKAIEDQAMAQsgBC0AACIBRQ0CAkACQAJAAkADQAJAAkAgAUH/AXEQowEEQANAIAQiAUEBaiEEIAEtAAEQowENAAsgA0IAEIMCA0ACfyADKAIEIgIgAygCaEcEQCADIAJBAWo2AgQgAi0AAAwBCyADEFELEKMBDQALIAMoAgQhBCADKQNwQgBZBEAgAyAEQQFrIgQ2AgQLIAQgAygCLGusIAMpA3ggFnx8IRYMAQsCfwJAAkAgBC0AAEElRgRAIAQtAAEiAUEqRg0BIAFBJUcNAgsgA0IAEIMCAkAgBC0AAEElRgRAA0ACfyADKAIEIgEgAygCaEcEQCADIAFBAWo2AgQgAS0AAAwBCyADEFELIgEQowENAAsgBEEBaiEEDAELIAMoAgQiASADKAJoRwRAIAMgAUEBajYCBCABLQAAIQEMAQsgAxBRIQELIAQtAAAgAUcEQCADKQNwQgBZBEAgAyADKAIEQQFrNgIECyABQQBODQ1BACEGIA4NDQwLCyADKAIEIAMoAixrrCADKQN4IBZ8fCEWIAQhAQwDC0EAIQggBEECagwBCwJAIAEQ0AFFDQAgBC0AAkEkRw0AIAQtAAFBMGshAiMAQRBrIgEgDzYCDCABIA8gAkECdEEEa0EAIAJBAUsbaiIBQQRqNgIIIAEoAgAhCCAEQQNqDAELIA8oAgAhCCAPQQRqIQ8gBEEBagshAUEAIQlBACEEIAEtAAAQ0AEEQANAIAEtAAAgBEEKbGpBMGshBCABLQABIRIgAUEBaiEBIBIQ0AENAAsLIAEtAAAiDUHtAEcEfyABBUEAIQogCEEARyEJIAEtAAEhDUEAIQAgAUEBagsiAkEBaiEBQQMhBSAJIQYCQAJAAkACQAJAAkAgDUHBAGsOOgQMBAwEBAQMDAwMAwwMDAwMDAQMDAwMBAwMBAwMDAwMBAwEBAQEBAAEBQwBDAQEBAwMBAIEDAwEDAIMCyACQQJqIAEgAi0AAUHoAEYiAhshAUF+QX8gAhshBQwECyACQQJqIAEgAi0AAUHsAEYiAhshAUEDQQEgAhshBQwDC0EBIQUMAgtBAiEFDAELQQAhBSACIQELQQEgBSABLQAAIgZBL3FBA0YiAhshEAJAIAZBIHIgBiACGyILQdsARg0AAkAgC0HuAEcEQCALQeMARw0BQQEgBCAEQQFMGyEEDAILIAggECAWELYMDAILIANCABCDAgNAAn8gAygCBCICIAMoAmhHBEAgAyACQQFqNgIEIAItAAAMAQsgAxBRCxCjAQ0ACyADKAIEIQIgAykDcEIAWQRAIAMgAkEBayICNgIECyACIAMoAixrrCADKQN4IBZ8fCEWCyADIASsIhUQgwICQCADKAIEIgIgAygCaEcEQCADIAJBAWo2AgQMAQsgAxBRQQBIDQYLIAMpA3BCAFkEQCADIAMoAgRBAWs2AgQLQRAhAgJAAkACQAJAAkACQAJAAkACQAJAIAtB2ABrDiEGCQkCCQkJCQkBCQIEAQEBCQUJCQkJCQMGCQkCCQQJCQYACyALQcEAayICQQZLQQEgAnRB8QBxRXINCAsgB0EIaiADIBBBABDADCADKQN4QgAgAygCBCADKAIsa6x9Ug0FDAwLIAtBEHJB8wBGBEAgB0EgakF/QYECEDoaIAdBADoAICALQfMARw0GIAdBADoAQSAHQQA6AC4gB0EANgEqDAYLIAdBIGogAS0AASIFQd4ARiIGQYECEDoaIAdBADoAICABQQJqIAFBAWogBhshAgJ/AkACQCABQQJBASAGG2otAAAiAUEtRwRAIAFB3QBGDQEgBUHeAEchBSACDAMLIAcgBUHeAEciBToATgwBCyAHIAVB3gBHIgU6AH4LIAJBAWoLIQEDQAJAIAEtAAAiAkEtRwRAIAJFDQ8gAkHdAEYNCAwBC0EtIQIgAS0AASIMRSAMQd0ARnINACABQQFqIQYCQCAMIAFBAWstAAAiAU0EQCAMIQIMAQsDQCABQQFqIgEgB0EgamogBToAACABIAYtAAAiAkkNAAsLIAYhAQsgAiAHaiAFOgAhIAFBAWohAQwACwALQQghAgwCC0EKIQIMAQtBACECC0IAIRNBACEFQQAhBkEAIQ0jAEEQayIRJAACQCACQQFHIAJBJE1xRQRAQbCOC0EcNgIADAELA0ACfyADKAIEIgQgAygCaEcEQCADIARBAWo2AgQgBC0AAAwBCyADEFELIgQQowENAAsCQAJAIARBK2sOAwABAAELQX9BACAEQS1GGyENIAMoAgQiBCADKAJoRwRAIAMgBEEBajYCBCAELQAAIQQMAQsgAxBRIQQLAkACQAJAAkAgAkEARyACQRBHcSAEQTBHckUEQAJ/IAMoAgQiBCADKAJoRwRAIAMgBEEBajYCBCAELQAADAELIAMQUQsiBEFfcUHYAEYEQEEQIQICfyADKAIEIgQgAygCaEcEQCADIARBAWo2AgQgBC0AAAwBCyADEFELIgRBkfYGai0AAEEQSQ0DIAMpA3BCAFkEQCADIAMoAgRBAWs2AgQLIANCABCDAgwGCyACDQFBCCECDAILIAJBCiACGyICIARBkfYGai0AAEsNACADKQNwQgBZBEAgAyADKAIEQQFrNgIECyADQgAQgwJBsI4LQRw2AgAMBAsgAkEKRw0AIARBMGsiBUEJTQRAQQAhBANAIARBCmwgBWoiBEGZs+bMAUkCfyADKAIEIgIgAygCaEcEQCADIAJBAWo2AgQgAi0AAAwBCyADEFELQTBrIgVBCU1xDQALIAStIRMLIAVBCUsNAiATQgp+IRUgBa0hFANAAn8gAygCBCICIAMoAmhHBEAgAyACQQFqNgIEIAItAAAMAQsgAxBRCyIEQTBrIgZBCU0gFCAVfCITQpqz5syZs+bMGVRxRQRAQQohAiAGQQlNDQMMBAsgE0IKfiIVIAatIhRCf4VYDQALQQohAgwBCyACIAJBAWtxBEAgBEGR9gZqLQAAIgYgAkkEQANAIAYgAiAFbGoiBUHH4/E4SQJ/IAMoAgQiBiADKAJoRwRAIAMgBkEBajYCBCAGLQAADAELIAMQUQsiBEGR9gZqLQAAIgYgAklxDQALIAWtIRMLIAIgBk0NASACrSEXA0AgEyAXfiIVIAatQv8BgyIUQn+FVg0CIBQgFXwhEyACAn8gAygCBCIGIAMoAmhHBEAgAyAGQQFqNgIEIAYtAAAMAQsgAxBRCyIEQZH2BmotAAAiBk0NAiARIBdCACATQgAQmAEgESkDCFANAAsMAQsgAkEXbEEFdkEHcUGR+AZqLAAAIQwgBEGR9gZqLQAAIgUgAkkEQANAIAUgBiAMdHIiBkGAgIDAAEkCfyADKAIEIgUgAygCaEcEQCADIAVBAWo2AgQgBS0AAAwBCyADEFELIgRBkfYGai0AACIFIAJJcQ0ACyAGrSETCyACIAVNDQBCfyAMrSIViCIUIBNUDQADQCAFrUL/AYMgEyAVhoQhEyACAn8gAygCBCIGIAMoAmhHBEAgAyAGQQFqNgIEIAYtAAAMAQsgAxBRCyIEQZH2BmotAAAiBU0NASATIBRYDQALCyACIARBkfYGai0AAE0NAANAIAICfyADKAIEIgYgAygCaEcEQCADIAZBAWo2AgQgBi0AAAwBCyADEFELQZH2BmotAABLDQALQbCOC0HEADYCAEEAIQ1CfyETCyADKQNwQgBZBEAgAyADKAIEQQFrNgIECyANQQFyRSATQn9RcQRAQbCOC0HEADYCAEJ+IRMMAQsgEyANrCIUhSAUfSETCyARQRBqJAAgAykDeEIAIAMoAgQgAygCLGusfVENByAIRSALQfAAR3JFBEAgCCATPgIADAMLIAggECATELYMDAILIAhFDQEgBykDECEVIAcpAwghFAJAAkACQCAQDgMAAQIECyAIIBQgFRCuBTgCAAwDCyAIIBQgFRC4BzkDAAwCCyAIIBQ3AwAgCCAVNwMIDAELQR8gBEEBaiALQeMARyIMGyEFAkAgEEEBRgRAIAghAiAJBEAgBUECdBA4IgJFDQcLIAdCADcCqAJBACEEA0AgAiEAAkADQAJ/IAMoAgQiAiADKAJoRwRAIAMgAkEBajYCBCACLQAADAELIAMQUQsiAiAHai0AIUUNASAHIAI6ABsgB0EcaiAHQRtqQQEgB0GoAmoQsgUiAkF+Rg0AQQAhCiACQX9GDQsgAARAIAAgBEECdGogBygCHDYCACAEQQFqIQQLIAlFIAQgBUdyDQALQQEhBiAAIAVBAXRBAXIiBUECdBA3IgINAQwLCwtBACEKIAAhBSAHQagCagR/IAcoAqgCBUEACw0IDAELIAkEQEEAIQQgBRA4IgJFDQYDQCACIQADQAJ/IAMoAgQiAiADKAJoRwRAIAMgAkEBajYCBCACLQAADAELIAMQUQsiAiAHai0AIUUEQEEAIQUgACEKDAQLIAAgBGogAjoAACAEQQFqIgQgBUcNAAtBASEGIAAgBUEBdEEBciIFEDciAg0ACyAAIQpBACEADAkLQQAhBCAIBEADQAJ/IAMoAgQiACADKAJoRwRAIAMgAEEBajYCBCAALQAADAELIAMQUQsiACAHai0AIQRAIAQgCGogADoAACAEQQFqIQQMAQVBACEFIAgiACEKDAMLAAsACwNAAn8gAygCBCIAIAMoAmhHBEAgAyAAQQFqNgIEIAAtAAAMAQsgAxBRCyAHai0AIQ0AC0EAIQBBACEKQQAhBQsgAygCBCECIAMpA3BCAFkEQCADIAJBAWsiAjYCBAsgAykDeCACIAMoAixrrHwiFFAgDCAUIBVRckVyDQIgCQRAIAggADYCAAsCQCALQeMARg0AIAUEQCAFIARBAnRqQQA2AgALIApFBEBBACEKDAELIAQgCmpBADoAAAsgBSEACyADKAIEIAMoAixrrCADKQN4IBZ8fCEWIA4gCEEAR2ohDgsgAUEBaiEEIAEtAAEiAQ0BDAgLCyAFIQAMAQtBASEGQQAhCkEAIQAMAgsgCSEGDAMLIAkhBgsgDg0BC0F/IQ4LIAZFDQAgChAZIAAQGQsgB0GwAmokACADQZABaiQAIA4LQwACQCAARQ0AAkACQAJAAkAgAUECag4GAAECAgQDBAsgACACPAAADwsgACACPQEADwsgACACPgIADwsgACACNwMACwsQACAAIAEgAkEAQQAQvAcaC7wCAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEJaw4SAAgJCggJAQIDBAoJCgoICQUGBwsgAiACKAIAIgFBBGo2AgAgACABKAIANgIADwsgAiACKAIAIgFBBGo2AgAgACABMgEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMwEANwMADwsgAiACKAIAIgFBBGo2AgAgACABMAAANwMADwsgAiACKAIAIgFBBGo2AgAgACABMQAANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRBAALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC20BBH8gACgCACwAABDQ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FTcDKCAPIBY3AyAgBEGQxgBqJAAgDykDKCEVIA8pAyAhFgwECyABKQNwQgBZBEAgASABKAIEQQFrNgIECwwBCwJAAn8gASgCBCICIAEoAmhHBEAgASACQQFqNgIEIAItAAAMAQsgARBRC0EoRgRAQQEhBgwBC0KAgICAgIDg//8AIRUgASkDcEIAUw0DIAEgASgCBEEBazYCBAwDCwNAAn8gASgCBCICIAEoAmhHBEAgASACQQFqNgIEIAItAAAMAQsgARBRCyICQTBrQQpJIAJBwQBrQRpJciACQd8ARnJFIAJB4QBrQRpPcUUEQCAGQQFqIQYMAQsLQoCAgICAgOD//wAhFSACQSlGDQIgASkDcCIYQgBZBEAgASABKAIEQQFrNgIECwJAIAMEQCAGDQEMBAsMAQsDQCAYQgBZBEAgASABKAIEQQFrNgIECyAGQQFrIgYNAAsMAgtBsI4LQRw2AgAgAUIAEIMCC0IAIRULIAAgFjcDACAAIBU3AwggD0EwaiQACzcBAX8gACgCBCEBA0AgAUF/RgRAIABBADYCBAUgACgCACABQQJ0akEANgIAIAFBAWshAQwBCwsLygYCBX8EfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABCZA0UNAAJ/IARC////////P4MhCwJ/IARCMIinQf//AXEiBkH//wFHBEBBBCAGDQEaQQJBAyADIAuEUBsMAgsgAyALhFALCyEJIAJCMIinIghB//8BcSIHQf//AUYNACAJDQELIAVBEGogASACIAMgBBBjIAUgBSkDECICIAUpAxgiASACIAEQsgwgBSkDCCECIAUpAwAhBAwBCyABIAJC////////////AIMiCyADIARC////////////AIMiChCZA0EATARAIAEgCyADIAoQmQMEQCABIQQMAgsgBUHwAGogASACQgBCABBjIAUpA3ghAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGIAcEfiABBSAFQeAAaiABIAtCAEKAgICAgIDAu8AAEGMgBSkDaCILQjCIp0H4AGshByAFKQNgCyEEIAZFBEAgBUHQAGogAyAKQgBCgICAgICAwLvAABBjIAUpA1giCkIwiKdB+ABrIQYgBSkDUCEDCyAKQv///////z+DQoCAgICAgMAAhCEMIAtC////////P4NCgICAgICAwACEIQsgBiAHSARAA0ACfiALIAx9IAMgBFatfSIKQgBZBEAgCiAEIAN9IgSEUARAIAVBIGogASACQgBCABBjIAUpAyghAiAFKQMgIQQMBQsgCkIBhiAEQj+IhAwBCyALQgGGIARCP4iECyELIARCAYYhBCAHQQFrIgcgBkoNAAsgBiEHCwJAIAsgDH0gAyAEVq19IgpCAFMEQCALIQoMAQsgCiAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEGMgBSkDOCECIAUpAzAhBAwBCyAKQv///////z9YBEADQCAEQj+IIQ0gB0EBayEHIARCAYYhBCANIApCAYaEIgpCgICAgICAwABUDQALCyAIQYCAAnEhBiAHQQBMBEAgBUFAayAEIApC////////P4MgB0H4AGogBnKtQjCGhEIAQoCAgICAgMDDPxBjIAUpA0ghAiAFKQNAIQQMAQsgCkL///////8/gyAGIAdyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAFQYABaiQAC78CAQF/IwBB0ABrIgQkAAJAIANBgIABTgRAIARBIGogASACQgBCgICAgICAgP//ABBjIAQpAyghAiAEKQMgIQEgA0H//wFJBEAgA0H//wBrIQMMAgsgBEEQaiABIAJCAEKAgICAgICA//8AEGNB/f8CIAMgA0H9/wJOG0H+/wFrIQMgBCkDGCECIAQpAxAhAQwBCyADQYGAf0oNACAEQUBrIAEgAkIAQoCAgICAgIA5EGMgBCkDSCECIAQpA0AhASADQfSAfksEQCADQY3/AGohAwwBCyAEQTBqIAEgAkIAQoCAgICAgIA5EGNB6IF9IAMgA0HogX1MG0Ga/gFqIQMgBCkDOCECIAQpAzAhAQsgBCABIAJCACADQf//AGqtQjCGEGMgACAEKQMINwMIIAAgBCkDADcDACAEQdAAaiQACzUAIAAgATcDACAAIAJC////////P4MgBEIwiKdBgIACcSACQjCIp0H//wFxcq1CMIaENwMICxcBAX8gAEEAIAEQ3wMiAiAAayABIAIbC4QCAQN/AkACQAJAIAEoAhAiAigCyAENACACIAA2AsgBIAAgARC+DCABEBtFDQAgACABELMFQQAhAkHMggsoAgBB5ABGBEAgAUEAEOEMIAEoAhAiBEHAAWohAANAIAAoAgAiAARAIAAoAhAiAygC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DAELCyACRSADRXINACABIAIgA0EAQQEQTygCECIEIAQoApwBQegHajYCnAEgBCAEKAKsASIEQQAgBEEAShs2AqwBCyAAEG4hBANAIAQEQCAEIAEgAiADEN0MIAQQbSEEDAELCwsYAQF/IwBBEGsiASAAOQMIIAErAwggAKILMwEBfAJ+EAVEAAAAAABAj0CjIgCZRAAAAAAAAOBDYwRAIACwDAELQoCAgICAgICAgH8LCxQAIAAQAyIAQQAgAEEbRxsQ2wMaC7YXAxJ/BXwBfiMAQRBrIgskACAAEO4MAkAgAQRAIAAQsQogABDRCiAAIAAQxQcgABDUCiALQQhqIAAQyQwgCykDCCEZIABBABD7BQJAIAAoAhAiAigC3AFBAUsNACACKAK0AUEASg0AIAEhBgwCCyABQQE2AiAMAQsgACAAEMUHIAAQ1AogC0EIaiAAEMkMIAspAwghGSAAQQAQ+wULA0AgACgCECIBKALcASAESwRAIAEgASgC2AEgBEECdGooAgAiATYCwAEgASECA0AgAgRAIAIoAhAiAkEANgKwASACKAK4ASECDAELCwNAIAEEQCABEIANIAEoAhAoArgBIQEMAQsLIARBAWohBAwBCwsCQCAAKAIQIgEoAuQBRQRAIAEoAuABRQ0BCyAZQiCIpyEHIBmnIQUgABAbIQEDQCABBEACQCABEJwBIAFHDQACQCABKAIQIgIoAswBDQAgACgCECgC5AEiBEUgASAERnINACABIARBABDFASIDKAIQIgJBADYCnAEgAiAHNgKsASABKAIQIQILIAIoAsQBDQAgACgCECgC4AEiAkUgASACRnINACACIAFBABDFASIDKAIQIgJBADYCnAEgAiAFNgKsAQsgACABEBwhAQwBCwsgA0UNACAAQQAQ+wULAkAgBgRAIwBBEGsiDCQAIAYoAhghDkGwwgogABA1QRgQHTYCAEG0wgpBADYCACAAEBshAQNAIAEEQCABKAIQQX82AogBIAAgARAcIQEMAQsLIAAQGyEBA0AgAQRAAkAgASgCECgC7AFFBEBBAUEEEB0hA0GwwgooAgBBtMIKKAIAIgRBGGxqIgIgAzYCACADIAE2AgAgAkEBNgIEIAIgASgCECIDKwMgOQMIIAIgAysDKDkDECADIAQ2AogBQbTCCiAEQQFqNgIADAELIAEQnAEi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ASIDQQFqIANBAmoQxgEhAyACIAUgAigCAEEDcUECRhsoAigoAhAgAzYCwAEgAiAFIAIoAgBBA3FBAkYbKAIoKAIQIgYiAyADKALEASIDQQFqNgLEASAGKALAASADQQJ0aiACNgIAIAIgBSACKAIAQQNxQQJGGygCKCgCECIDKALAASADKALEAUECdGpBADYCACAEIAIQLSECDAELCyAEIAoQHCEKDAELCyABBEAgBBCxCiAEENEKCyAEQQEgESAAQcOFARAnIgEEfyABEPEBBUF/CxD8DhogACgCEEL/////dzcC7AFBACEFAkAgCUECSA0AIAlBAWoiARDJByEFQQEhAgNAIAEgAkYNASAFIAJBAnRqQf////8HNgIAIAJBAWohAgwACwALIAAQGyEIA0AgCARAIAgQ8wEhASAIKAIQIgMgASgCECgCpAEoAhAiASgC9AEiAjYC9AEgAiAAKAIQIgYoAvABSgRAIAYgAjYC8AELIAIgBigC7AFIBEAgBiACNgLsAQsgBQRAIAMgASgCkAEiATYCkAEgBSABQQJ0aiIBIAEoAgAiASACIAEgAkgbNgIACyAAIAgQHCEIDAELCwJAIAUEQCAAEBshAgNAIAIEQCACKAIQIgEgASgC9AEgBSABKAKQAUECdGooAgBrNgL0ASAAIAIQHCECDAEFQQEhBwwDCwALAAtBACEHIAAoAhAoAuwBIgNBAEwNACAAEBshAgNAIAIEQCACKAIQIgEgASgC9AEgA2s2AvQBIAAgAhAcIQIMAQsLIAAoAhAiASABKALsASADazYC7AEgASABKALwASADazYC8AELIAAgBxDQDCAEEBshAgNAIAIEQCACKAIQKALAARAZIAIoAhAoAsgBEBkgBCACEBwhAgwBCwsgABAbKAIQKAKAARAZIAAQGyECA0AgAgRAIAIoAhBBADYCgAEgACACEBwhAgwBCwsgBRAZIAQQkgELQaiCCy0AAARAIAsgACgCECkC7AFCIIk3AwBB6N4GKAIAQfCsBCALECILIAtBkAFqJAALgQEBAn8gAkELNgIAQQEhAwJAIAEgAGtBA0cNACAALAAAIgFB+ABGBH9BAAUgAUHYAEcNAUEBCyEBIAAsAAEiBEHtAEcEQCAEQc0ARw0BQQEhAQsgACwAAiIAQewARwRAIABBzABHDQFBAA8LQQAhAyAB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C1UBAn8DQCABBEAgACgCaCICBEAgACgCBCABKAIAKAIAIAIRBAALIAEoAgQhAyABIAAoAvQCNgIEIAAgATYC9AIgASgCACABKAIINgIEIAMhAQwBCwsL0BUCHn8CfiMAQdAAayIMJAACQAJAIAAgACgC4AIiFEEUaiIGIAMoAgBBABCZASINDQBBASEJIBRB0ABqIAMoAgAQog0iB0UNASAAIAYgB0EYEJkBIg1FDQEgAC0A6AFFDQAgACANEI8NRQ0BCyANKAIMIQZBASEJIAEgAiAAKAL4AiAAKAKEAyABKAIkEQYAIgcgBkH/////B3NKDQACQAJAIAYgB2oiCiAAKAL4AiIITA0AIAdB7////wcgBmtKIAZB7////wdKcg0CIAAgCkEQaiIKNgL4AiAKQYCAgIABTw0BIAAoAoQDIApBBHQgACgCEBEAACIKRQ0BIAAgCjYChAMgByAITA0AIAEgAiAHIAogASgCJBEGABoLIAdBACAHQQBKGyEQIAZBACAGQQBKGyERIABBnANqIRIgACgChAMhD0EAIQdBACEKA0ACQAJAAkAgByAQRwRAQQEhCSAAIAEgB0EEdCIGIAAoAoQDaigCACICIAEgAiABKAIcEQAAIAJqEJoNIgJFDQYgAigCAEEBayIILQAABEBBCCEJIAAoApABIAFHDQcgACAGIAAoAoQDaigCADYCnAIMBwsgCEEBOgAAIA8gCkECdGogAigCADYCACAKQQFqIQsgACgChAMgBmoiCC0ADA0BQQAhBiACLQAIRQ0CA0AgBiARRg0DIA0oAhQgBkEMbGoiEygCACACRgRAIBMtAAQhCQwEBSAGQQFqIQYMAQsACwALIAAgCjYC/AICQAJAIA0oAggiAUUEQEF/IQYMAQtBfyEGIAEoAgAiAUEBay0AAEUNAEEAIQYDQCAGIApODQIgDyAGQQJ0aigCACABRg0BIAZBAmohBgwACwALIAAgBjYCgAMLQQAhBgNAIAYgEUcEQAJAIA0oAhQgBkEMbGoiASgCACICKAIAQQFrIgUtAAANACABKAIIIgdFDQACQCACKAIEIggEQCACLQAJBEAgACAIIAIgByAEEOMHIglFDQMMCwsgBUECOgAAIA5BAWohDgwBCyAFQQE6AAALIA8gCkECdGoiAiABKAIAKAIANgIAIAIgASgCCDYCBCAK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AkACQAJAIAAtAA9B/gFrDgIAAQILIANBf0YNBCAAKAIAIQIgAUUEQCACEBlBACECDAMLIAIgARA3IgJFDQUgASADTQ0CIAIgA2pBACABIANrEDoaDAILIAFBARAdIgIgACgCACAFECMaDAELIAFBARAdIgIgACAFECMaIAAgBTYCBAsgAEH+AToADyAAIAE2AgggACACNgIACyAAECUhAQJAIAAQKQRAIAAgAWpBADoAACAAIAAtAA9BAWo6AA8gABAlQRBJDQFBsqQDQfP7AEGhAkH3rgEQAAALIAAoAgAgAWpBADoAACAAIAAoAgRBAWo2AgQLIARBEGokAA8LQaipA0Gp/ABBzQBB1a8BEAAACyAEIAE2AgBB6N4GKAIAQdTRAyAEECIQLwALuQEBBn9BvIYLKAIAIQFBMBBOIQJBuIYLKAIAEHIEQEEAEJYPCyACIAEQciIANgIEAkAgAEUNACACIABBIBAgIgU2AgAgAUEAQYABIAEoAgARAwAhAANAIABFDQEgBSADQQV0aiIEIAApAwg3AwAgBCAAKQMgNwMYIAQgACkDGDcDECAEIAApAxA3AwggA0EBaiEDIAEgAEEIIAEoAgARAwAhAAwACwALIAFBAEHAACABKAIAEQMAGiACCxgBAX9BCBBOIgIgADYCACACIAE6AAQgAgvpAQEEfyMAQRBrIgQkACABKAIQQcjCCigCAEEBajYCsAEgAARAAkAgACgCBCICIAAoAghHBEAgACgCACEDDAELAkAgBCACQQF0QQEgAhsiAkH/////A0sEf0HEAAUgACgCACACQQJ0EDciAw0BQTALELkBNgIAQejeBigCAEG96AMgBBAiEC8ACyADIAAoAggiBUECdGpBACACIAVrQQJ0EDoaIAAgAjYCCCAAIAM2AgAgACgCBCECCyADIAJBAnRqIAE2AgAgACACQQFqNgIEIARBEGokAA8LQYLKAUG8+wBBCkHzogEQAAALDwBB+IULIAAgABBAEL4IC0YBAn8jAEEQayIBJAAgABChASICRQRAIAEgABBAQQFqNgIAQejeBigCAEHU0QMgARAiEC8ACyACEJsPIAIQGSABQRBqJAALQAEBfyMAQRBrIgEkAEGMhgtBATYCAEHwhQtBjAI2AgAgARDACDYCBCABIAA2AgBBAUG04wQgARAfIAFBEGokAAsYACAAECkEQCAAQQA6AA8PCyAAQQA2AgQLbgECfyMAQRBrIgAkAEH0hQsoAgAQng9BoIYLKAIAIgEEQEH0hQsoAgBBmIYLKAIAIAEQvggLQfSFCygCAEGUhgsoAgBBnIYLKAIAEL4IIABB9IULKAIAEL0INgIAQQNB584EIAAQHyAAQRBqJAALZQECfwJ/QQAgACgCECgCCCIBRQ0AGiABKAJYIgIEQCACEKcNQQAgACgCECgCCCIBRQ0BGgsgASgCXBAZIAAoAhAoAggLEBkgACgCECICQQA2AgggAigCDBCxASAAQQBBoCUQsQQL2wMCAn8CfCMAQTBrIgMkACADQQA6AB8CQCAAIAEQJyIARQ0AIAMgA0EfajYCGCADIANBIGo2AhQgAyADQShqNgIQAkAgAEG/ugEgA0EQahBHQQJIDQAgAysDKCIFRAAAAAAAAAAAZEUNACADKwMgIgZEAAAAAAAAAABkRQ0AIAICfyAGRAAAAAAAAFJAoiIGRAAAAAAAAOA/RAAAAAAAAOC/IAZEAAAAAAAAAABmG6AiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLtzkDCCACAn8gBUQAAAAAAABSQKIiBUQAAAAAAADgP0QAAAAAAADgvyAFRAAAAAAAAAAAZhugIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4C7c5AwAgAy0AH0EhRiEEDAELIANBADoAHyADIANBKGo2AgAgAyADQR9qNgIEIABBw7oBIAMQR0EATA0AIAMrAygiBUQAAAAAAAAAAGRFDQAgAgJ/IAVEAAAAAAAAUkCiIgVEAAAAAAAA4D9EAAAAAAAA4L8gBUQAAAAAAAAAAGYboCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAu3IgU5AwggAiAFOQMAIAMtAB9BIUYhBAsgA0EwaiQAIAQLYQEEfCACKwMIIAArAwgiBKEgASsDACAAKwMAIgOhIgWiIAErAwggBKEiBCACKwMAIAOhoqEiAyADoiIDRLu919nffNs9YwR8RAAAAAAAAAAABSADIAUgBaIgBCAEoqCjCwvVAQIBfwJ8IwBBEGsiAyQAIAJFIAJB2gBGciACQbQBRnJFIAJBjgJHcUUEQCACBEAgASsDCCEFIAErAwAhBAJAAkACQCACQY4CRwRAIAJBtAFGDQIgAkHaAEcNASABIAU5AwAgBJohBAwDCyABIAU5AwAMAgsgA0GkATYCBCADQf22ATYCAEHo3gYoAgBBzasBIAMQIhABAAsgBZohBAsgASAEOQMICyAAIAEpAwA3AwAgACABKQMINwMIIANBEGokAA8LQZWFA0H9tgFBkgFBtoIBEAAAC9QBAgN/BHwCQCAAKAKYASIDQYCAhAJxRQ0AIAAoAhAiAkECQQQgA0GAgAhxIgQbNgKMAiACIARBEHZBAnM2AogCIAIoApACEBkgAiACKAKMAkEQEEUiAjYCkAIgAiABKwM4IgUgASsDGEQAAAAAAADgP6IiB6E5AwAgAUFAaysDACEGIAErAyAhCCACIAUgB6A5AxAgAiAGIAhEAAAAAAAA4D+iIgWgOQMYIAIgBiAFoTkDCCADQYDAAHFFBEAgACACIAJBAhCLAhoLIAQNACACEP8FCwtxACAAQgA3AgACQAJAAkACQAJAIAJBH3QgAkHCAGtBAXZyDgoBBAQEBAIEBAMABAsgASABKAKoAUEBazYCsAEgAEF/NgIEDwsgAEEBNgIEDwsgAEEBNgIADwsgASABKAKkAUEBazYCrAEgAEF/NgIACwvkAQEFfyMAQRBrIgYkACAGQQA2AgwgBkEANgIIIAMQZiIIIQdBACEDA0ACQCADQQFxDQAgByAAKAKkAiAGQQxqEL8HIgRFDQBBACEHQQAhAyAEIAAoAqACIAZBCGoiBRC/ByIERQ0BQQAgACgCoAIgBRC/ByIDBEAgACAEQQAQwgghBCAAIAMgAhDCCCEFIARBAEgEQEEAIQMgBUEASA0DCyAEIAUgBCAFSBsgAUwgBCAFIAQgBUobIAFOcSEDDAIFIAAgBCABEMIIIAFGIQMMAgsACwsgCBAZIAZBEGokACADQQFxC9kCAgl8A38CQCABKAIEIg1BAEoEQEEBIQsgDUEDcEEBRw0BIAAgASgCACIMKQMANwMQIAAgDCkDCDcDGCAAIAwpAwg3AwggACAMKQMANwMAIAArAxghAiAAKwMIIQMgACsDECEEIAArAwAhBQNAIAsgDU5FBEAgDCALQQR0aiIBKwMgIQcgASsDACEGIAErAxAhCiAAIAIgASsDCCABKwMYoEQAAAAAAADgP6IiCCACIAhkGyICIAErAygiCSACIAlkGyICOQMYIAAgBCAGIAqgRAAAAAAAAOA/oiIGIAQgBmQbIgQgByAEIAdkGyIEOQMQIAAgAyAIIAMgCGMbIgMgCSADIAljGyIDOQMIIAAgBSAGIAUgBmMbIgUgByAFIAdjGyIFOQMAIAtBA2ohCwwBCwsPC0HJigNBxLQBQfAdQbG7ARAAAAtB5IEDQcS0AUHxHUGxuwEQAAAL8AECAX8CfCAAKAIQIQUCQCACBH8gAwUgBSgC0AELIARyRQRAIAUvAYQCQQFxRQ0BCyAAKAKYASICQYCAhAJxRQ0AIAErAwAhBiABKwMIIQcgBUECQQQgAkGAgAhxIgMbNgKMAiAFIANBEHZBAnM2AogCIAUoApACEBkgBSAFKAKMAkEQEEUiATYCkAIgASAHRAAAAAAAAAhAoDkDGCABIAZEAAAAAAAACECgOQMQIAEgB0QAAAAAAAAIwKA5AwggASAGRAAAAAAAAAjAoDkDACACQYDAAHFFBEAgACABIAFBAhCLAhoLIAMNACABEP8FCwv2BAIIfwR8IwBBEGsiCSQAIAAoAgQiBkEBa0EDbSEFAkAgBkEEa0ECTQRAIAJBBDYCBCACQQRBEBBFNgIAIANBBDYCBCADQQRBEBBFIgM2AgAgCSAAKAIAIAG7IAIoAgAgAxCbAQwBCyAFQQAgBUEAShshBiAFQQgQRSEIIAAoAgAhBANAIAYgB0ZFBEAgCCAHQQN0aiAEKwMAIAQrAxAiDqEiDCAMoiAEKwMIIAQrAxgiD6EiDCAMoqCfIA4gBCsDICIOoSIMIAyiIA8gBCsDKCIPoSIMIAyioJ+gIA4gBCsDMKEiDCAMoiAPIAQrAzihIgwgDKKgn6AiDDkDACANIAygIQ0gB0EBaiEHIARBMGohBAwBCwsgDSABu6IhDEEAIQREAAAAAAAAAAAhDQNAAkAgBCAGRwRAIA0gCCAEQQN0aisDAKAiDSAMZkUNASAEIQYLIAIgBkEDbCILQQRqIgQ2AgQgAiAEQRAQRTYCACADIAUgBmtBA2xBAWoiBDYCBCADIARBEBBFNgIAQQAhBANAIAQgAigCBE5FBEAgBEEEdCIFIAIoAgBqIgogACgCACAFaiIFKQMANwMAIAogBSkDCDcDCCAEQQFqIQQMAQsLIARBBGshB0EAIQQDQCAEIAMoAgRORQRAIAMoAgAgBEEEdGoiCiAAKAIAIAdBBHRqIgUpAwA3AwAgCiAFKQMINwMIIARBAWohBCAHQQFqIQcMAQsLIAkgC0EEdCIEIAAoAgBqIAwgDSAIIAZBA3RqKwMAIgyhoSAMo7a7IAIoAgAgBGogAygCABCbASAIEBkMAgsgBEEBaiEEDAALAAsgCUEQaiQAC4sBAQN/AkACQCAAKAKcAUECSA0AIAAgAkGshAsoAgBB0ucEEHciAxDKBA0AIAMtAAANAUEBIQQgASACEGpFDQEgASACEGohAwNAIANBAEchBCADRQ0CIANBpIULKAIAQdLnBBB3IgUtAABFDQIgACAFEMoEDQIgASADIAIQcCEDDAALAAtBASEECyAEC4gCAQR/An8CQCAAQYaWARAnIgBFDQAgAC0AAEUNACAAEPADGkHw/wohAwNAQfD/CiADKAIAIgBFDQIaIABBt6oBEChFBEAgA0EEaiEDIAJBAXIhAgwBCyAAQbXxABAoRQRAIAMhAANAIAAgACgCBCIENgIAIABBBGohACAEDQALIAJBA3IhAgwBCyAAQbWpARAoRQRAIAMhAANAIAAgACgCBCIENgIAIABBBGohACAEDQALIAJBwAByIQIMAQsgAEGMrAEQKARAIANBBGohAwUgAyEAA0AgACAAKAIEIgQ2AgAgAEEEaiEAIAQNAAsgAkEEciECCwwACwALQQALIQUgASACNgIAIAULOQECfwJAIAAoAsQBIgJBAEgNACACIAAoAqQBTg0AIAAoAsgBIgJBAEgNACACIAAoAqgBSCEBCyABC80BAQN/QQEhBANAIAQgASgCECIDKAK0AUpFBEAgACADKAK4ASAEQQJ0aigCACIDEK0PAkAgA0HUNRAnIgJFDQAgAi0AAEUNACAAIAIQRAsCQCADQb81ECciAkUNACACLQAARQ0AIAAgAhBECwJAIANB0jUQJyICRQ0AIAItAABFDQAgACACEEQLAkAgA0HINRAnIgJFDQAgAi0AAEUNACAAIAIQVAsCQCADQbU1ECciA0UNACADLQAARQ0AIAAgAxBECyAEQQFqIQQMAQsLC6YmBBN/B3wFfgF9IwBB0AFrIgQkACAAIAArA7ADIhVEAAAAAAAAUkCjOQOIBCAAIAArA7gDIhZEAAAAAAAAUkCjIhc5A5AEIAAgFSAAKwPgAiIVokQAAAAAAABSQKMiGDkD6AMgACAVIBaiRAAAAAAAAFJAoyIVOQPwA0GAgwsoAgAgACgCmAEiA0GAIHFyBEAgACAXmjkDkAQLIABBxANBwAMgACgC6AIiAhtqKAIAIQUgACAAQcADQcQDIAIbaigCALggFaM5A/gCIAAgBbggGKM5A/ACIAAgASABQQBBwx5BABAkQdLnBBB3EPcDIABBADYCoAEgABDPBCICQQA2AgwgAiABNgIIIAJBADYCBCAAIAEoAhAoAgwgARDJCAJAIAAoAjwiAkUNACACKAIIIgJFDQAgACACEQEACwJAIANBAnFFDQAgAEHsDRBUAkAgAUHSNRAnIgJFDQAgAi0AAEUNACAAIAIQVAsCQCABQbU1ECciAkUNACACLQAARQ0AIAAgAhBECyAAIAEQrQ8gARAbIQUDQCAFRQ0BAkAgBUHUNRAnIgJFDQAgAi0AAEUNACAAIAIQRAsCQCAFQb81ECciAkUNACACLQAARQ0AIAAgAhBUCwJAIAVByDUQJyICRQ0AIAItAABFDQAgAkE6EI0BBEAgAhBmIgYhAwNAIANBiNcBEKAEIgIEQEEAIQMgAi0AAEUNASAAIAIQRAwBCwsgBhAZDAELIAAgAhBECwJAIAVBtTUQJyICRQ0AIAItAABFDQAgACACEEQLIAEgBRAsIQIDQCACBEACQCACQdQ1ECciA0UNACADLQAARQ0AIANBOhCNAQRAIAMQZiIIIQMDQCADQYjXARCgBCIGBEBBACEDIAYtAABFDQEgACAGEEQMAQsLIAgQGQwBCyAAIAMQRAsCQCACQbU1ECciA0UNACADLQAARQ0AIAAgAxBECyABIAIQLSECDAELCyABIAUQHCEFDAALAAsgARAbIQIDQCACBEAgAigCEEEAOgCEASABIAIQHCECDAELCyAAIAAoAgAiAigCsAIiAzYCnAECQCACKAK0AiICBEACQCACKAIAQQJIDQAgAC0AmAFBwABxDQAgBCAAKAI0NgKQAUEAQa/GAyAEQZABahAfIAIgACgCnAFBAWo2AggLIAJBCGohCyACKAIEIQIMAQtBASECIANBAkgNACAALQCYAUHAAHENACAEIAAoAjQ2AoABQQBBr8YDIARBgAFqEB8gAEEBNgKcAQsgAEGcAWohDiAAQYAEaiESIABB+ANqIQ8DQAJAIAAgAjYCoAEgAiAAKAKcAUoNACAAKAIAKAK0AiICIA4gAhsoAgBBAk4EQAJAIAAoAjwiAkUNACACKAIQIgJFDQAgACAAKAIAKAKsAiAAKAKgASIDQQJ0aigCACADIAAoApwBIAIRCAALCyAAIAApAqwBIhw3AsQBIBynIQIDQAJAAkACQAJAIAAQrA8EQCAAKAKYASEIIAAoAhAhBiAEQgA3A6ABIARCADcDmAECQCAAKAKgAUEBTARAQQAhDCACQQBMDQELIAYoAtQBIQwgACAEQZgBaiICELIPIAIgDBDzAyAGIAIQ8QM2AtQBCyABQeGUARAnEIgGIAApAqQBIhxCIIghHSAAKQLEASIeQiCIIR8CQCAAKALoAiIDRQRAIBwhICAdIRwgHiEdIB8hHgwBCyAdISAgHyEdCyAAIB2ntyIXIAArA8ACIhWiIAArA/ABoSIYOQOgAiAAIB6ntyIaIAArA8gCIhaiIAArA/gBoSIZOQOoAiAAIBYgGaA5A7gCIAAgFSAYoDkDsAICQCAAKAIMKAIcRQRAIAAgACkDyAM3A9gDIAAgACkD0AM3A+ADDAELIAAgACgC2AMiAiAAKALIAyIFIAIgBUgbNgLYAyAAIAAoAtwDIgIgACgCzAMiBSACIAVIGzYC3AMgACAAKALgAyICIAAoAtADIgUgAiAFShs2AuADIAAgACgC5AMiAiAAKALUAyIFIAIgBUobNgLkAwsgACsD2AIhGSAAKwPQAiEbAkAgACgCmAEiAkGAAXEEQCAZIAArA/gCRAAAAAAAAOA/oiIVoCEYIBsgACsD8AJEAAAAAAAA4D+iIhqgIRcgGSAVoSEWIBsgGqEhFQwBCyAWIBYgGiAcp7dEAAAAAAAA4D+ioaIgGaAiFqAhGCAVIBUgFyAgp7dEAAAAAAAA4D+ioaIgG6AiFaAhFwsgACAYOQOYAiAAIBc5A5ACIAAgFjkDiAIgACAVOQOAAgJ/IAMEQCAAIBiaIAArA4gDIAArA+ACIhajoTkDgARBgIMLKAIAIAJBgCBxcgRAIAArA4ADIBajIRUgF5ohFyAPDAILIAArA4ADIBajIRcgDwwBCyAAIAArA4ADIAArA+ACIhejIBWhOQP4AwJ8QYCDCygCACACQYAgcXIEQCAAKwOIAyAXoyEVIBiaDAELIBYhFSAAKwOIAyAXowshFyASCyAXIBWhOQMAAkAgACgCPCICRQ0AIAIoAhgiAkUNACAAIAIRAQALIABBvPQAEEQgAEHsDRBUAkAgCEGAgIQCcUUNACAGKALQAUUEQCAGLQCEAkEBcUUNAQsCfyAIQYCAKHFFBEBBACECQQAMAQsgBiAIQYCACHEiA0EQdkECczYCiAJBAkEEIAMbQRAQRSICIAApA6gCNwMIIAIgACkDoAI3AwAgAiAAKQOwAjcDECACIAApA7gCNwMYQQIgAw0AGiACEP8FQQQLIQMgCEGAwABxRQRAIAAgAiACIAMQiwIaCyAGIAM2AowCIAYgAjYCkAILAkAgCEGAgAJxRQ0AIAEoAhAoAgwiAkUNACAGIAIoAgA2AsABCwJAIAhBBHEiEA0AIAYoAtABRQRAIAYtAIQCQQFxRQ0BCyAEIAApA5gCNwN4IAQgACkDkAI3A3AgBCAAKQOIAjcDaCAEIAApA4ACNwNgIAAgBEHgAGoQhAYgACAGKALQASAGKALkASAGKAL0ASAGKALUARCyAQsCfyABQdI1ECciAkUEQEHIjgEhAkEBDAELIAJByI4BIAItAAAiAxshAiADRQshAyACQZweECghBQJAAkAgACgCmAEiCUGAAnFFBEAgA0EBIAUbIQMgAkHIjgEgBRshAgwBCyAFRQ0BCyAJQYCAgBBxQQAgAxsNACACIARBsAFqIARBrAFqEMwEBEAgBEEANgKoASAAIAQoArABIgIQVCAAQZweEEQgASAEQagBahCrDxogACAEKAK0ASIDQbz0ACADGyABQaiDCygCAEEAQQAQTCAEKgKsARCBAyAEIAApA4gCNwMoIAQgACkDkAI3AzAgBCAAKQOYAjcDOCAEIAApA4ACNwMgIAAgBEEgakEDQQIgBCgCqAFBAnEbEPsBIAIQGQwBCyAAIAIQVCAAQZweEEQgBCAAKQOYAjcDWCAEIAApA5ACNwNQIAQgACkDiAI3A0ggBCAAKQOAAjcDQCAAIARBQGtBARD7AQsgASgCECgCCCgCWCINRQ0EIA0oAgghAkEAIQNBASEFQQAhEUEBIQkDQCANKAIAIANNBEAgEUUNBiAAIAAoAgAoAsgCENkBDAYLAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCACKAIAIgcOEAAAAQECAgMECwUNCAkGBw0KCyACKwBgIAArAIACZkUNDCAAKwCQAiACKwBQZkUNDCACKwBoIAArAIgCZkUNDCAAKwCYAiACKwBYZkUNDCAEIAIrAwggAisDGCIVoTkDsAEgBCACKwMQIAIrAyAiFqE5A7gBIAQgFSACKwMIoDkDwAEgBCAWIAIrAxCgOQPIASAAIARBsAFqQQAgBSAHGxD4AwwMCyACKwBgIAArAIACZkUNCyAAKwCQAiACKwBQZkUNCyACKwBoIAArAIgCZkUNCyAAKwCYAiACKwBYZkUNCyACKAIMIAIoAggQxwghByACKAIIIgpBAEgNDiAAIAcgCiAFQQAgAigCAEECRhsQQSAHEBkMCwsgAisAYCAAKwCAAmZFDQogACsAkAIgAisAUGZFDQogAisAaCAAKwCIAmZFDQogACsAmAIgAisAWGZFDQogAigCDCACKAIIEMcIIQcgAigCCCIKQQBIDQ4gACAHIAogBUEAIAIoAgBBBEYbEPoBIAcQGQwKCyACKwBgIAArAIACZkUNCSAAKwCQAiACKwBQZkUNCSACKwBoIAArAIgCZkUNCSAAKwCYAiACKwBYZkUNCSACKAIMIAIoAggQxwghByACKAIIIgpBAEgNDiAAIAcgChA2IAcQGQwJCyACKwBgIAArAIACZkUNCCAAKwCQAiACKwBQZkUNCCACKwBoIAArAIgCZkUNCCAAKwCYAiACKwBYZkUNCCAEIAIrAwg5A7ABIAQgAisDEDkDuAEgAigCcCEHIAQgBCkDuAE3AxggBCAEKQOwATcDECAAIARBEGogBxCeBgwICyAAIAIoAggQRAwGCyACKwMoIRUgAigCCEECRgRAIAIoAkQiBSoCCCEhIAUoAgQhByAFKAIMIQUCfyACKwMQIhYgFWEEQEEAIAIrAzAgAisDGGENARoLIBYgFaEgAisDIKMQoAJEAAAAAACAZkCiRBgtRFT7IQlAoyIVmUQAAAAAAADgQWMEQCAVqgwBC0GAgICAeAshCiAAIAcQVCAAIAUgCiAhEIEDQQMhBQwHCyACKAI0IgUoAgwhByAFKgIIISEgFSACKwMYoSACKwMgIAIrAxChEKQBIRUgACAFKAIEEFQgACAHAn8gFUQAAAAAAIBmQKJEGC1EVPshCUCjIhWZRAAAAAAAAOBBYwRAIBWqDAELQYCAgIB4CyAhEIEDQQIhBQwGC0EAQeHJBEEAEB8MBQsgAigCCBDwAxpB8P8KIREgAEHw/woQ2QEMBAsgCUUEQEEAIQkMBAtBACEJQQBB7ZEEQQAQHwwDCyAEQZwMNgIEIARBxLQBNgIAQejeBigCAEHNqwEgBBAiEAEACyAAIAIoAggQVAtBASEFCyADQQFqIQMgAkH4AGohAgwACwALIAAoAgAoArQCIgIgDiACGygCAEECTgRAAkAgACgCPCICRQ0AIAIoAhQiAkUNACAAIAIRAQALCyALBEAgCygCACECIAtBBGohCwwHCyAAKAKgAUEBaiECQQAhCwwGC0HgnQNBxLQBQcILQeQbEAAAC0G0ngNBxLQBQc0LQeQbEAAAC0GLnwNBxLQBQdcLQeQbEAAACyABKAIQKAIMIgIEQCAAQQQgAhCuAwsCQCAQRQRAAkAgBigC0AFFBEAgBi0AhAJBAXFFDQELIAAQigILIAAoAgAiAiACKAIcQQFqNgIcIAAgASAIEIIGDAELIAAoAgAiAiACKAIcQQFqNgIcCwJAAkACQAJAIAhBAXEEQCAAEKEGIAEQGyECA0AgAgRAIAAgAhDvAyABIAIQHCECDAELCyAAEKAGIAAQnwYgARAbIQMDQCADRQ0CIAEgAxAsIQIDQCACBEAgACACEMsEIAEgAhAtIQIMAQsLIAEgAxAcIQMMAAsACyAIQRBxBEAgABCfBiABEBshAwNAIAMEQCABIAMQLCECA0AgAgRAIAAgAhDLBCABIAIQLSECDAELCyABIAMQHCEDDAELCyAAEPkIIAAQoQYgARAbIQIDQCACRQ0EIAAgAhDvAyABIAIQHCECDAALAAsgCEEIcUUNASAAEKEGIAEQGyEDA0BBASECIAMEQAJAA0AgASgCECIFKAK0ASACTgRAIAJBAnQhEyACQQFqIQIgEyAFKAK4AWooAgAgAxCoAUUNAQwCCwsgACADEO8DCyABIAMQHCEDDAELCyAAEKAGIAAQnwYgARAbIQUDQCAFRQ0BIAEgBRAsIQMDQEEBIQIgAwRAAkADQCABKAIQIgkoArQBIAJOBEAgAkECdCEUIAJBAWohAiAUIAkoArgBaigCACADEKgBRQ0BDAILCyAAIAMQywQLIAEgAxAtIQMMAQsLIAEgBRAcIQUMAAsACyAAEPkIDAILIAEQGyEDA0AgA0UNAiAAIAMQ7wMgASADECwhAgNAIAIEQCAAIAJBUEEAIAIoAgBBA3FBAkcbaigCKBDvAyAAIAIQywQgASACEC0hAgwBCwsgASADEBwhAwwACwALIAAQoAYLIBAEQCAAIAEgCBCCBgsCQCAAKAI8IgJFDQAgAigCHCICRQ0AIAAgAhEBAAsgDARAIAYgDDYC1AELIARBmAFqEIABIAAgACgAxAEgACgAvAFqIgKtIAAoAMgBIAAoAMABaiIDrUIghoQ3AsQBIAAQrA8NAAJAIAAoArgBIgUEQCAAKAKsASECDAELIAAoArABIQMLIAAgACgAtAEgAmoiAq0gAyAFaq1CIIaENwLEAQwACwALCwJAIAAoAjwiAUUNACABKAIMIgFFDQAgACABEQEACwJAIAAoAkwiAUUNACABKAIEIgFFDQAgACABEQEACyAAEKMGGiAAEM4EIARB0AFqJAALzwECAX8DfCMAQeAAayIBJAAgASAAKQMINwNYIAEgACkDADcDUCABIAApAzg3A0ggASAAKQMwNwNAIAEgACkDGDcDOCABIAApAxA3AzAgAUHQAGogAUFAayABQTBqEKIPIQQgASAAKQMINwMoIAEgACkDADcDICABIAApAzg3AxggASAAKQMwNwMQIAEgACkDKDcDCCABIAApAyA3AwAgAUEgaiABQRBqIAEQog8hAyABQeAAaiQAIAREAAAAAAAAEEBjIANEAAAAAAAAEEBjcQuGEAIdfAZ/IwBBMGsiISQAIAAoAhArA5gBIRAgAkEAICFBJGoQhQYiJUEBa0ECTwRAICEgASsDACABKwMQIgugRAAAAAAAAOA/oiIHOQMQICEgASsDCCABKwMYIgSgRAAAAAAAAOA/oiIDOQMYIBBEAAAAAAAA4D9kBEAgAEQAAAAAAADgPxD5AQsgBCADoSEJIAsgB6EhB0QAAAAAAAAAACEDICEoAiwhAQNAIAEoAgAiAgRAIAEqAgRDAAAAAF4EQCAAIAIQVCABKAIMBHwgASoCBLtEGC1EVPshGUCiIAOgBUQYLURU+yEZQAshCyAhICEpAxg3AwggISAhKQMQNwMAIAACf0EAIQIgCxBIIQggCxBdIR8gAxBIIQYgAxBdIR4gISsDCCERICErAwAhEiAeIAmjIAYgB6MQpAEhBiAfIAmjIAggB6MQpAEiBCAGoUQYLURU+yEZQKOcRBgtRFT7IRnAoiAEoCIERBgtRFT7IRlAoCAEIAQgBqFEGC1EVPshCUBjGyAEIAsgA6FEGC1EVPshCUBkGyAGoSEUIAkgB6MiAyADRFGgT+RJ0g5ARNHxh1VyBLc/IANEAAAAAAAA0D9jIiAbokS0yHa+nzo1wESV1AloIjwzwCAgG6CiRDoi36XUJdW/RGQjEK/rdxDAICAboCADRPOCPkeaLoo/RKchqvBneMc/ICAboKMhGCADIANEn+V5cHfW+b9E2v8Aa9WuwT8gIBuiRH79EBssnOY/RE4oRMAhVPe/ICAboKJEluzYCMTrzD9EqkiFsYUg9T8gIBugIANEzc6idyrg0D9EnWhXIeUn9j8gIBugoyEZIAMgA0Sw479AECDtv0RNLsbAOo7NPyAgG6JEraHUXkTb2D9EWWsotRfR3L8gIBugokQ7oXzmUZZ2P0QDP6phvyfMPyAgG6AgA0TTbnD5eoR7P0SmR1M9mX/aPyAgG6CjIRogAyADRIHMzqJ3KuS/RLaBO1CnPK4/ICAbokTRrdf0oKDIP0RRTN4AM9+5vyAgG6CiRGrfNxmwP4Q/RPV2lf/aC6Y/ICAboCADRL7KkBle/4Q/RNSlNbwP9pQ/ICAboKMhGyADIANEHJYGflTDxL9EH60gvCzckD8gIBuiRKVJKej24iNARCgs8YCyySNAICAboKJEqdkDrcCQwT9EI1rhTAKKtz8gIBugIANECMSQQZNpiT9ESKNlUZYpfz8gIBugoyEcIAMgA0T6RJ4kXTPQv0S7tIb3wZ6TPyAgG6JEAfCZNi3CXj9EF6h7U0d9oL8gIBugokQNnH0vz5SXP0QhK67gbZSLPyAgG6AgA0SJtfgUAOOJP0Qzc9yE1h61vyAgG6CjIR0gAyADROWpWEY0y7G/RKB4hIn1/I8/ICAbokSPAMnPoWemv0RpNSTusfSRvyAgG6CiRFy1xvvMtIg/RLjNM3pev2o/ICAboCADRE2kj1Q6s5A/RJI+raI/NM2/ICAboKMhDCADIANE5scEoWHWoL9EfrDnxk8+mL8gIBuiRMdpZxwT94K/RAcjm1Atx6Q/ICAboKJEKn9r5S1wXL9EPhjCe1i5kb8gIBugIANE5FdiVAiadT9ELXx9rUuNxj8gIBugoyENIAMgA0T8qfHSTWJQP6JE7FG4HoXrE0CgokTl0CLb+X7KP6AgA0RTliGOdXF7P6CjIAeiIQ4gBhBdIg8gCaIiE5ohCiAGEEghFUEBQQgQsgMhIkEBISMDQAJAIAJBAXEgI0H/B0tyRQRAQQAhJEEBISAgBiEDQQAhAiAUICO3oyIIRBgtRFT7Ifk/ZUUNAQNAICBBAXFFBEAgICECDAMLICAhAiAjICRNDQIgAyAIIAOgIgSgRAAAAAAAAOA/oiIFRAAAAAAAABBAohBIIRYgBSAFoBBIIRcgDiAFRAAAAAAAABhAohBIIgUgDaIgFiAMoiAXIB2iIBygoKAgBCADoaIgBSAboiAWIBqiIBcgGaIgGKCgoKAQ3AyiRPFo44i1+OQ+ZSEgICRBAWohJCAEIQMMAAsAC0EAISBB3P8KQeQANgIAICJB5ABBEBCyAyICNgIAIAIgETkDCCACIBI5AwAgIkEBNgIEICIgCkQAAAAAAAAAAKIgEiAVIAeiIgSgoCIDIBMgBEQAAAAAAAAAAKIgEaCgIgoQtw8gDyAHmiIToiIFIBUgCaIiBEQAAAAAAAAAAKKhIQwgBUQAAAAAAAAAAKIgBKAhCCAUICO3oyINRAAAAAAAAOA/ohC8DCEEIA0QXSAEIAREAAAAAAAACECiokQAAAAAAAAQQKCfRAAAAAAAAPC/oKJEAAAAAAAACECjIg6aIQ8DQCAgICNHBEAgIiAOIAyiIAOgIA4gCKIgCqAgDyANIAagIgYQXSIEIBOiIgogBhBIIgMgCaIiCEQAAAAAAAAAAKKhIgyiIBIgAyAHoiIFoCAEIAmiIgREAAAAAAAAAACioSIDoCAPIApEAAAAAAAAAACiIAigIgiiIAQgBUQAAAAAAAAAAKIgEaCgIgqgIAMgChC2DyAgQQFqISAMAQsLICIgIigCACICKwMAIAIrAwgQtw8gIiAiKAIAICIoAgRBBHQQNzYCAEHc/wpBADYCACAiDAILICNBAXQhIwwACwALIgIoAgAgAigCBEEBEPoBIAIQvwQgCyEDCyABQQxqIQEMAQUgEEQAAAAAAADgP2QEQCAAIBAQ+QELICFBJGoQzQQLCwsgIUEwaiQAICULnQEBAX8CQAJAIAJFDQAgAiAAEEIgABAla0sEQCAAIAIQzAgLIAAQJSEDIAAQKQRAIAAgA2ogASACECMaIAJBgAJPDQIgACAALQAPIAJqOgAPIAAQJUEQSQ0BQbKkA0Hz+wBBhAJBmOkAEAAACyAAKAIAIANqIAEgAhAjGiAAIAAoAgQgAmo2AgQLDwtBpMUBQfP7AEGCAkGY6QAQAAALjAEBAn8jAEEgayICJAACQCAAKAKgASIDQQJIDQAgAC0AmAFBwABxRQ0AIAIgACgCACgCrAIgA0ECdGooAgA2AhAgAUHjvgEgAkEQahDyAwsgACgCyAEhAyAAKALEASIAQQBMIANBAExxRQRAIAIgAzYCBCACIAA2AgAgAUHnvgEgAhDyAwsgAkEgaiQAC+cBAQF/IAAoAhAhByABRSAAKAKYASIAQYCAAnFFckUEQCAHIAE2AsABC0EAIQECQCAAQYCABHFFDQAgByAFIAYQfjYC1AEgAkUNACACLQAARQ0AIAcgAiAGEH42AtABQQEhAQsCQCAAQYCAgAJxRQ0AAkAgA0UNACADLQAARQ0AIAcgAyAGEH42AuQBQQEhASAHIAcvAYQCQQFyOwGEAgwBCyAHKALAASICRQ0AIAcgAhBmNgLkAUEBIQELAkAgBEUgAEGAgIAEcUVyDQAgBC0AAEUNACAHIAQgBhB+NgL0AUEBIQELIAEL0gEBBn8jAEEgayIDJAAgACgCECIEKAK0ASICQQAgAkEAShtBAWohBkEBIQUCQANAIAUgBkcEQCAEKAK4ASAFQQJ0aigCACEHIAMgASkDGDcDGCADIAEpAxA3AxAgAyABKQMINwMIIAMgASkDADcDACAFQQFqIQUgByADELQPIgJFDQEMAgsLAkAgASsDECAEKwMQZkUNACAEKwMgIAErAwBmRQ0AIAErAxggBCsDGGZFDQAgACECIAQrAyggASsDCGYNAQtBACECCyADQSBqJAAgAgvXAQEDf0Hh+AAhAyAAQdAEaiICQQAgARA0IAFGBH9B2fgAQar5ACABENUBGwVB4fgACxCwASACQQEgARAhELABIABBAjYC1AQgAEHcBGohBEECIQJBACEDA0AgAUEAIAMQ9AEiAwRAIAQgAiADKAIIELABIAQgAkEBaiABIAMQORCwASAEIAJBAmpBABCwASACQQNqIQIMAQsLIAAgAjYC4AQCQCABQQBB94MBQQAQJCICRQRAIAFBAEGNyQFBABAkIgJFDQELIAAgASACEDkgARB+NgLMBAsLhQEBBH8gACgCACEHIAAoAgQiCUEDaiIIQdz/CigCACIKTgRAQdz/CiAKQQF0NgIAIAAgByAKQQV0EDciBzYCACAAKAIEIglBA2ohCAsgByAJQQR0aiIHIAI5AwggByABOQMAIAcgAzkDECAHIAQ5AxggByAFOQMgIAAgCDYCBCAHIAY5AygLKgAgACAAKAIAIAAoAgRBBHRqQRBrIgArAwAgACsDCCABIAIgASACELYPC5IBAQJ/IAAQQiICIAFqIgEgAkEBdEGACCACGyIDIAEgA0sbIQEgABAlIQMCQAJAAkACQCAALQAPQf4Baw4CAAECCyAAKAIAIAIgARC9DyECDAILIAEQwgMiAiAAKAIAIAMQIxoMAQsgARDCAyICIAAgAxAjGiAAIAM2AgQLIABB/gE6AA8gACABNgIIIAAgAjYCAAurAgEEfyMAQRBrIgMkACADIAI2AgQgAyABNgIAIwBBEGsiAiQAIAIgAzYCDCACIAM2AggCQAJAAkACQEEAQQBBqTIgAxBZIgVBAEgNACAFQQFqIQEgBSAAEEIgABAlayIETwRAIAAgASAEaxC4DwsgABAlIQQgBSAAECkEfyAAIARqBSAAKAIAIARqCyABQakyIAIoAgwQWSIBRyABQQBOcQ0BIAFBAEwNACAAECkEQCABQYACTw0DIAAgAC0ADyABajoADyAAECVBEEkNAUGypANB8/sAQeoBQd4dEAAACyAAIAAoAgQgAWo2AgQLIAJBEGokAAwCC0HujwNB8/sAQeUBQd4dEAAAC0GLxQFB8/sAQegBQd4dEAAACyAAELoPIQYgA0EQaiQAIAYLMgAgAEEAELsPAkAgABApBEAgAEEAOgAPDAELIABBADYCBAsgABApBH8gAAUgACgCAAsLcwEBfyAAECUgABBCTwRAIABBARC4DwsgABAlIQICQCAAECkEQCAAIAJqIAE6AAAgACAALQAPQQFqOgAPIAAQJUEQSQ0BQbKkA0Hz+wBBoQJB964BEAAACyAAKAIAIAJqIAE6AAAgACAAKAIEQQFqNgIECwuaAQEFfyAAIAAoAgBBA3FBA0dBMGxqKAIoKAIQIgIoAuABIQQgAigC5AEhAwJAA0AgASADRwRAIAFBAnQhBSABQQFqIQEgBCAFaigCACAARw0BDAILCyACIAQgA0EBaiADQQJqEMYBIgE2AuABIAIgAigC5AEiAkEBaiIDNgLkASABIAJBAnRqIAA2AgAgASADQQJ0akEANgIACwuBAQEBfyMAQRBrIgMkAAJAIAFBf0cEQAJAIAJFBEAgABAZQQAhAAwBCyAAIAIQNyIARQ0CIAEgAk8NACAAIAFqQQAgAiABaxA6GgsgA0EQaiQAIAAPC0GoqQNBqfwAQc0AQdWvARAAAAsgAyACNgIAQejeBigCAEHU0QMgAxAiEC8AC4QBAQR/Qcz/CigCACECIAAQQCIDQdD/CigCACIBTwRAIAIgASADQQtqIgEQvQ8hAkHQ/wogATYCAEHM/wogAjYCAAsgAiEBA0AgAC0AACIEBEAgAEEBaiEAIAEgBMAiAxDPDAR/IAMQzgEFIAQLOgAAIAFBAWohAQwBCwsgAUEAOgAAIAILmAQDAX8JfAF+IwBBkAFrIgYkACACKwMIIghEAAAAAAAA4L+iIQcgAisDACIJRAAAAAAAAAhAoyEKIAlEAAAAAAAA4L+iIQsgCEQAAAAAAAAIwKMhDAJAIARBgAFxBEAgBkIANwOIASAGQgA3A4ABDAELIAYgByAKoTkDiAEgBiALIAyhOQOAAQsgASsDCCENIAErAwAhDgJAIARBwABxBEAgBkIANwN4IAZCADcDcAwBCyAGIAogB6A5A3ggBiAMIAugOQNwCyAGIAiaOQNoIAYgBikDiAE3AyggBiAGKQN4NwMIIAYgBikDaDcDGCAGIAmaOQNgIAYgBikDgAE3AyAgBiAGKQNwNwMAIAYgBikDYDcDECAGQTBqIAZBIGogBkEQaiAGIAMQ/QIgBisDMCEHIAEgDSAIIAYrAzigIgOhOQMIIAEgDiAJIAegIgehOQMAIAAgCCANoCADoSILOQMIIAAgCSAOoCAHoSIPOQMAIAUgACkDCDcDSCAFIAApAwA3A0AgBSAAKQMINwMIIAApAwAhECAFIAogCEQAAAAAAADgP6IgDaAgA6EiCKA5AxggBSAMIA4gCUQAAAAAAADgP6KgIAehIgmgOQMQIAUgEDcDACAFIAEpAwg3AyggBSABKQMANwMgIAUgCCAKoTkDOCAFIAkgDKE5AzAgACALIAOhOQMIIAAgDyAHoTkDACAGQZABaiQAC6kBAQF/IwBB8ABrIgckACAHIAIpAwg3AxggByACKQMANwMQIAcgAykDCDcDCCAHIAMpAwA3AwAgACAHQRBqIAcgBSAGIAdBIGoQvw8CQCAGQcAAcQRAIAEgB0FAa0EDIAZBf3NBBHZBAXEQQQwBCyAGQX9zQQR2QQFxIQAgBkGAAXEEQCABIAdBIGpBAyAAEEEMAQsgASAHQSBqQQQgABBBCyAHQfAAaiQAC/IDAgR/CnwjAEFAaiIHJAAgAysDCCIEIAIrAwgiDKAhESADKwMAIgsgAisDACIQoCESIAtEmpmZmZmZ2T+iIQ0gBESamZmZmZnZv6IhDiAERJqZmZmZmek/oiAMoCETIAtEmpmZmZmZ6T+iIBCgIRQCfCALRAAAAAAAAAAAYQRARAAAAAAAAAAAIAREAAAAAAAAAABhDQEaCyAFRAAAAAAAAOA/oiIFIASaIgQgC5oiCyAEEFIiBKOiIQ8gBSALIASjogshBSACIAwgD6EiCzkDCCACIBAgBaEiDDkDACAAIBEgD6E5AwggACASIAWhOQMAIAdBOGoiCSANIBMgD6EiBKA5AwAgB0EoaiIDIAQgDaE5AwAgByALIA2hOQMYIAcgDiAUIAWhIgWgOQMwIAcgBSAOoTkDICAHIAwgDqE5AxAgByANIAugOQMIIAcgDiAMoDkDACAHQRBqIQgCQAJ/IAZBwABxBEAgB0EwaiEKIAcMAQsgBkGAAXFFDQEgB0EgaiEKIAMhCSAICyIDIAIpAwA3AwAgAyACKQMINwMIIAogBTkDACAJIAQ5AwALIAEgB0EEIAZBf3NBBHZBAXEQQSAHIAQ5AwggByAFOQMAIAggACkDCDcDCCAIIAApAwA3AwAgASAHQQIQNiAHQUBrJAALZQAgACABokQAAAAAAAAkQKIiAESamZmZmZnJv6IgAkQAAAAAAADgP6IiAaBEAAAAAAAAAIAgAESamZmZmZnZv6IgAaAiAUQAAAAAAAAAAGQiAxsgACABRAAAAAAAAACAIAMboKALnAQCBX8LfCMAQUBqIgckACADKwMIIQQgACADKwMAIgwgAisDACINoCIUOQMAIAAgBCACKwMIIg+gIhU5AwggDSAMRDMzMzMzM+M/oqAhECANIAxEmpmZmZmZyT+ioCEOIA8gBEQzMzMzMzPjP6KgIREgDyAERJqZmZmZmck/oqAhEgJAIAwgBBBSIhNEAAAAAAAAAABkRQ0AIBNEmpmZmZmZyb+iIAVEAAAAAAAA4D+ioCITRAAAAAAAAAAAZEUNACACIA8gEyAEmiIFIAyaIg8gBRBSIhajoiIFoTkDCCACIA0gEyAPIBajoiINoTkDACAAIBUgBaE5AwggACAUIA2hOQMAIBEgBaEhESAQIA2hIRAgEiAFoSESIA4gDaEhDgsgB0E4aiIDIAwgEaA5AwAgB0EoaiIKIBEgDKE5AwAgB0EYaiIIIBIgDKE5AwAgByAQIAShOQMwIAcgBCAQoDkDICAHIAQgDqA5AxAgByAMIBKgOQMIIAcgDiAEoTkDACAHQRBqIQkCQAJ/IAZBwABxBEAgB0EIciEIIAcgDjkDACAHQTBqDAELIAZBgAFxRQ0BIAcgDjkDECAKIQMgB0EgagshCyAIIBI5AwAgCyAQOQMAIAMgETkDAAsgASAHQQRBARBBIAcgAikDCDcDCCAHIAIpAwA3AwAgCSAAKQMINwMIIAkgACkDADcDACABIAdBAhA2IAdBQGskAAvTAgIBfwJ8IwBB4AFrIgQkACAEQgA3A0ggBEIANwNAIARCADcDOCAEQgA3AxggBEIANwMIIAQgACABokQAAAAAAAAkQKI5AzAgBEIANwMQIAQgBCkDMDcDACAEQSBqIARBEGogBCABIAIgAyAEQdAAahDUCAJAAkACQCAEKwMgIgBEAAAAAAAAAABkBEAgACAEKwNgIgUgBCsDgAGhoSIBRAAAAAAAAAAAZEUNASAEKwPIASAEKwNooSIGRAAAAAAAAAAAZEUNAiAGIAGiIAUgBCsDUKGZoyIFRAAAAAAAAAAAZEUNAyAEQeABaiQAIAAgAkQAAAAAAADgP6IgASACoiAFoyADQSBxG6EPC0HspANB27QBQb8KQbwTEAAAC0H2nwNB27QBQcEKQbwTEAAAC0HQpQNB27QBQcQKQbwTEAAAC0GapQNB27QBQcgKQbwTEAAAC5UBAQF/IwBBsAFrIgckACAHIAIpAwg3AxggByACKQMANwMQIAcgAykDCDcDCCAHIAMpAwA3AwAgACAHQRBqIAcgBCAFIAYgB0EgaiIAENQIAkAgBkHAAHEEQCABIABBBUEBEEEMAQsgBkGAAXEEQCABIAdB4ABqQQVBARBBDAELIAEgB0EgakEIQQEQQQsgB0GwAWokAAuhAgEBfyMAQaABayIEJAAgBEIANwNIIARCADcDQCAEQgA3AzggBEIANwMYIARCADcDCCAEIAAgAaJEAAAAAAAAJECiOQMwIARCADcDECAEIAQpAzA3AwAgBEEgaiAEQRBqIAQgAiADIARB0ABqENUIAkACQCAEKwMgIgBEAAAAAAAAAABkBEAgBCsDiAEgBCsDaKEiAUQAAAAAAAAAAGRFDQEgACABoiAEKwNgIAQrA3ChmaMiAUQAAAAAAAAAAGRFDQIgBEGgAWokACAAIAAgAqIgAaMgAkQAAAAAAADgP6IgA0EgcRuhDwtB7KQDQdu0AUG6CUGb8QAQAAALQdClA0HbtAFBvQlBm/EAEAAAC0GapQNB27QBQcEJQZvxABAAAAuoAQEBfyMAQfAAayIHJAAgByACKQMINwMYIAcgAikDADcDECAHIAMpAwg3AwggByADKQMANwMAIAAgB0EQaiAHIAUgBiAHQSBqIgAQ1QgCQCAGQcAAcQRAIAEgAEEDIAZBf3NBBHZBAXEQQQwBCyAGQX9zQQR2QQFxIQAgBkGAAXEEQCABIAdBQGtBAyAAEEEMAQsgASAHQTBqQQMgABBBCyAHQfAAaiQACzMBAXwgACgCBCsDACABKwMAIAAoAgAiACsDAKEiAiACoiABKwMIIAArAwihIgIgAqKgZgs2AQJ8QQFBf0EAIAAoAgAiACsDCCAAKwMAoCICIAEoAgAiACsDCCAAKwMAoCIDZBsgAiADYxsLPwEBf0EBQX9BAEHI/wooAgAiAiAAKAIAKAIQQQJ0aigCACIAIAIgASgCACgCEEECdGooAgAiAUgbIAAgAUobCx8AQX8gASgCACgCACIBIAAoAgAoAgAiAEogACABShsLIQECfyAAKAIQIgAsAAghAyABQQBOBEAgACABOgAICyADCwsAIAEgAEEBEHoaCyQBAn8gACgCECIAKAKwASEDIAFBAE4EQCAAIAHANgKwAQsgAwsxACAAKAIUIgEEQCABEOMDCwJAIAAoAjRFDQAgACgCPCIBRQ0AIAAgAREBAAsgABAZCwkAIAAgARCJAQtxAQN/A0AgACIBKAIQKAJ4IgANAAsCf0EAIAFBUEEAIAEoAgBBA3EiAEECRxtqKAIoKAIQIgIoAvQBIgMgASAAQQNHQTBsaigCKCgCECIBKAL0ASIASg0AGkEBIAAgA0oNABogAigC+AEgASgC+AFICwuOAQIBfwR8IwBBMGsiAyQAIAMgASgCCCIENgIkIAMgBDYCICAAQcDgBCADQSBqEB4gAisDGCEFIAIrAwAhBiACKwMQIQcgAisDCCEIIAMgASgCCDYCECADIAUgCKBEAAAAAAAA4D+iOQMIIAMgByAGoEQAAAAAAADgP6I5AwAgAEHn3QQgAxAeIANBMGokAAsCAAvjAwMBfwJ8AX4jAEGgAWsiBCQAAkACQCAABEAgAUUNASABKAIIRQ0CIAEoAjQEQCAEIAIpAwA3A2AgBCACKQMINwNoIAQgAikDGDcDiAEgAikDECEHIAQgBCsDaCIFOQOYASAEIAQrA4gBOQN4IAQgBzcDgAEgBCAEKwNgIgY5A3AgBCAEKwOAATkDkAEgAwRAQQAhAiAAQaqzA0EAEB4DQCACQQRGRQRAIAQgBEHgAGogAkEEdGoiAysDADkDUCAEIAMrAwg5A1ggAEGUsgMgBEHQAGoQHiACQQFqIQIMAQsLIAQgBTkDSCAEIAY5A0AgAEGUsgMgBEFAaxAeIAQgASgCCDYCNCAEQQQ2AjAgAEGA4QMgBEEwahAeC0EAIQIgAEGqswNBABAeA0AgAkEERkUEQCAEIARB4ABqIAJBBHRqIgMrAwA5AyAgBCADKwMIOQMoIABBlLIDIARBIGoQHiACQQFqIQIMAQsLIAQgBTkDGCAEIAY5AxAgAEGUsgMgBEEQahAeIAQgASgCCDYCBCAEQQQ2AgAgAEGQ4QMgBBAeCyAEQaABaiQADwtBgLsBQei4AUHXAUGEuwEQAAALQfMlQei4AUHYAUGEuwEQAAALQa2VAUHouAFB2QFBhLsBEAAAC/8BAgR/AX4gACgCNCEEIAAoAjghASMAQRBrIgMkACADQQA2AgwCQCABQQACf0H4jgsoAgAiAARAIANBDGohAgNAIAAgBCAAKAIARg0CGiACBEAgAiAANgIACyAAKAIkIgANAAsLQQALIgAbRQRAQWQhAQwBCyABIAAoAgRHBEBBZCEBDAELIAMoAgwiAkEkakH4jgsgAhsgACgCJDYCACAAKAIQIgJBIHFFBEAgBCABIAAoAiAgAiAAKAIMIAApAxgiBacgBUIgiKcQDSIBDQELIAAoAggEQCAAKAIAEBkLQQAhASAALQAQQSBxDQAgABAZCyADQRBqJAAgARDhAhoLiQQCBH8BfCMAQYABayIDJAACQAJAIAAEQCABRQ0BIAEoAghFDQICQAJAIAEoAjQEQCABKAI8IgRB1gFGDQEgASAEEQEAIAFBADYCPCABQgA3AjQLIAEQ6QhFDQEgASgCFBDYDCEGAkAgASgCGEF+cUEGRgRAIAYgA0EgahDUDCABIAMoAjgiBDYCOAJ/IARB/////wdPBEBBsI4LQTA2AgBBfwwBC0FBAn8CQCAEQQFBASAGQQBBAEEoEDgiBUEIaiAFEAwiB0EATgRAIAUgBjYCDAwBCyAFEBkgBwwBCyAFQQE2AiAgBUIANwMYIAVBATYCECAFIAQ2AgQgBUH4jgsoAgA2AiRB+I4LIAU2AgAgBSgCAAsiBCAEQUFGGxDhAgshBCABQQE6ABAgASAEQQAgBEF/RxsiBDYCNAwBCyABKAI0IQQLIAQEQCABQdYBNgI8CyABEJgGIAEoAjRFDQELIAIrAwAhCCABKAIgIQQgAyACKwMIIAEoAiS3oTkDGCADIAggBLehOQMQIABB0voDIANBEGoQHgJAIAEtABAEQCAAIAEQ3g4MAQsgAyABKAIMNgIAIABBr6MEIAMQHgsgAEG4lARBABAeCyADQYABaiQADwtBgLsBQei4AUGZAUHlKRAAAAtB8yVB6LgBQZoBQeUpEAAAC0GtlQFB6LgBQZsBQeUpEAAAC4ACACMAQRBrIgIkAAJAAkACQAJAIAAEQCAAKAIQIgNFDQEgAUUNAiABKAIIRQ0DIAMoAghFDQQgAEHHwANBABAeIABB0MADQQAQHiAAQa7AA0EAEB4gAEHrvwRBABAeIABB0cIEQQAQHiAAQdG4A0EAEB4gAiABKAIINgIAIABBqrgDIAIQHiAAQdO4A0EAEB4gAEGrwANBABAeIAJBEGokAA8LQYC7AUHouAFB+QBBrewAEAAAC0HW9ABB6LgBQfoAQa3sABAAAAtB8yVB6LgBQfsAQa3sABAAAAtBrZUBQei4AUH8AEGt7AAQAAALQcbpAEHouAFB/gBBrewAEAAAC8MEAgR8AX8jAEGAAWsiAyQAAkACQCAABEAgAUUNASABKAIIIgFFDQIgAisDGCEEIAIrAxAhBSACKwMAIQYgAisDCCEHIAMgATYCfCADQQA2AnggA0KAgICA0AA3A3AgA0IANwNoIANCADcDYCADQgA3A1ggA0EANgJQIANCgYCAgHA3A0ggA0FAa0KAgICAcDcDACADQgA3AzggA0KCgICA0AA3AzAgAEGL5QMgA0EwahAeIAMCfyAHRAAAAAAAAOA/RAAAAAAAAOC/IAdEAAAAAAAAAABmG6AiB5lEAAAAAAAA4EFjBEAgB6oMAQtBgICAgHgLIgI2AiQgAwJ/IAZEAAAAAAAA4D9EAAAAAAAA4L8gBkQAAAAAAAAAAGYboCIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAsiATYCICADIAI2AhwgAwJ/IAVEAAAAAAAA4D9EAAAAAAAA4L8gBUQAAAAAAAAAAGYboCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAsiCDYCGCADIAg2AhAgAwJ/IAREAAAAAAAA4D9EAAAAAAAA4L8gBEQAAAAAAAAAAGYboCIEmUQAAAAAAADgQWMEQCAEqgwBC0GAgICAeAsiCDYCFCADIAE2AgggAyACNgIEIAMgATYCACADIAg2AgwgAEGSqwQgAxAeIANBgAFqJAAPC0GAuwFB6LgBQeEAQc+AARAAAAtB8yVB6LgBQeIAQc+AARAAAAtBrZUBQei4AUHjAEHPgAEQAAALzgIBBHwjAEHgAGsiAyQAAkACQCAABEAgAUUNASABKAIIRQ0CIAIrAxghBCACKwMIIQUgAisDECIGIAIrAwAiB6AgBiAHoSIHoUQAAAAAAADgP6IhBiAAQc2sAxAaGiAAIAEoAggQGhogBCAFoCAEIAWhIgWgRAAAAAAAAOC/oiEEAkAgACgC6AIEQCADIAQ5A1ggAyAGOQNQIAMgBzkDSCADIAU5A0AgAEHbpgMgA0FAaxAeIAAoAugCIQEgAyAEOQMwIAMgBjkDKCADIAE2AiAgAEGOrgMgA0EgahAeDAELIAMgBDkDGCADIAY5AxAgAyAFOQMIIAMgBzkDACAAQYymAyADEB4LIABB4roEEBoaIANB4ABqJAAPC0GAuwFB6LgBQTNBzPwAEAAAC0HzJUHouAFBNEHM/AAQAAALQa2VAUHouAFBNUHM/AAQAAALLgEBfyMAQRBrIgIkACACIAE2AgQgAkH97QQ2AgAgAEG+2gMgAhAeIAJBEGokAAsNACAAIAEgAkEAEP8IC5gEAgZ/AnwjAEHwAGsiBCQAIAQgASsDACIKOQNgIAQgASsDCCILOQNoIAQCfyAKRAAAAAAAAOA/RAAAAAAAAOC/IApEAAAAAAAAAABmG6AiCplEAAAAAAAA4EFjBEAgCqoMAQtBgICAgHgLNgIQIAQCfyALRAAAAAAAAOA/RAAAAAAAAOC/IAtEAAAAAAAAAABmG6AiCplEAAAAAAAA4EFjBEAgCqoMAQtBgICAgHgLNgIUIABBm5YDIARBEGoQHkEAIQMDQCACIANBA2oiB0oEQCAEIAQpA2A3AzAgBCAEKQNoNwM4QQEhBkEBIQUDQCAFQQRGRQRAIARBMGogBUEEdGoiCCABIAMgBWpBBHRqIgkrAwA5AwAgCCAJKwMIOQMIIAVBAWohBQwBCwsDQCAGQQdGBEAgByEDDAMFIARBIGogBEEwaiAGt0QAAAAAAAAYQKNBAEEAEJsBIAQCfyAEKwMgIgpEAAAAAAAA4D9EAAAAAAAA4L8gCkQAAAAAAAAAAGYboCIKmUQAAAAAAADgQWMEQCAKqgwBC0GAgICAeAs2AgAgBAJ/IAQrAygiCkQAAAAAAADgP0QAAAAAAADgvyAKRAAAAAAAAAAAZhugIgqZRAAAAAAAAOBBYwRAIAqqDAELQYCAgIB4CzYCBCAAQayWAyAEEB4gBkEBaiEGDAELAAsACwsgAEG45wQQGhogBEHwAGokAAsNACAAIAEgAkEBEP8IC54BAgF/BHwjAEEwayIDJAAgASsDGCEFIAErAxAhBiABKwMAIQQgAyABKwMIIgdEAAAAAAAAUkCjOQMgIAMgBEQAAAAAAABSQKM5AxggAyAFIAehIgUgBaBEAAAAAAAAUkCjOQMQIANBuLEDQdLnBCACGzYCACADIAYgBKEiBCAEoEQAAAAAAABSQKM5AwggAEG1vgQgAxAeIANBMGokAAuZBAIEfwZ8IwBBQGoiAyQAAnwCQCACLAAwIgRB8gBHBEAgBEHsAEcNASACKwMgIQggASsDAAwCCyABKwMAIAIrAyAiCKEMAQsgASsDACACKwMgIghEAAAAAAAA4L+ioAshCSABKwMIIQogAigCBCIBKwMQIgshBwJAIAEoAgAiBUUNAEHo/gooAgAiAQRAIAEgBRAoRQ0BCyAFEEAhBCADAn8DQEEAIQECQANAIAFBIUcEQCAFIAFBA3RBpO4EaigCACIGIAQgBhBAIgYgBCAGSRsQbCAEIAZLckUgBCAGT3ENAiABQQFqIQEMAQsLIAMgBTYCOCADIAQ2AjQgA0GA7gQ2AjBBAUHGyQMgA0EwahAfQZXIAQJ/A0BBACAERQ0BGiAFIARBAWsiBGoiAS0AAEEtRw0ACyABCyIBRQ0CGiABIAVrIQQMAQsLIAFBA3RBoO4Eags2AiAgAEHa2AMgA0EgahAeQej+CiACKAIEIgEoAgA2AgAgASsDECEHC0Hw/gorAwAhDCAHRAAAAAAAAPA/ED8iByAMoZlEAAAAAAAA4D9kBEAgAyAHOQMQIANB4P4KKwMAOQMYIABB+sUDIANBEGoQHkHw/gogBzkDAAsgAEEiEF4gACACKAIAEKQGIAMgCiALRAAAAAAAAGtAo6A5AwggAyAJIAhEAAAAAAAAYkCjoDkDACAAQei+BCADEB4gA0FAayQACwwAIABBsrYEQQAQHgv0CwMGfwl8AX4jAEHgA2siASQAIAAoAtQDIQIgACgC0AMhAyAAKALMAyEEIAAoAsgDIQUCQEHc/gotAAANACAAKALoAiIGRSAGQdoARnINACABQcvhADYC1AMgAUGA7gQ2AtADQQBBnZsEIAFB0ANqEB9B3P4KQQE6AAALIAEgA7cgBbehRAAAAAAAAFJAoyIHIAK3IAS3oUQAAAAAAABSQKMiCSAAKALoAkHaAEYiAhsiDTkDyAMgASAJIAcgAhsiCTkDwAMgAEHfigQgAUHAA2oQHiABQf3tBDYCsAMgAEH/6gMgAUGwA2oQHkHg/gpEAAAAAAAAJEAgCUQAAAAAAAAAAGQEfAJ/AnwCQAJAAkACQCAJIge9IhBCAFkEQCAQQiCIpyICQf//P0sNAQtEAAAAAAAA8L8gByAHoqMgEEL///////////8Ag1ANBBogEEIAWQ0BIAcgB6FEAAAAAAAAAACjDAQLIAJB//+//wdLDQJBgIDA/wMhA0GBeCEEIAJBgIDA/wNHBEAgAiEDDAILIBCnDQFEAAAAAAAAAAAMAwsgB0QAAAAAAABQQ6K9IhBCIIinIQNBy3chBAsgBCADQeK+JWoiAkEUdmq3Ig5EAGCfUBNE0z+iIgggEEL/////D4MgAkH//z9xQZ7Bmv8Daq1CIIaEv0QAAAAAAADwv6AiByAHIAdEAAAAAAAA4D+ioiILob1CgICAgHCDvyIMRAAAIBV7y9s/oiIKoCIPIAogCCAPoaAgByAHRAAAAAAAAABAoKMiCCALIAggCKIiCiAKoiIIIAggCESfxnjQCZrDP6JEr3iOHcVxzD+gokQE+peZmZnZP6CiIAogCCAIIAhERFI+3xLxwj+iRN4Dy5ZkRsc/oKJEWZMilCRJ0j+gokSTVVVVVVXlP6CioKCiIAcgDKEgC6GgIgdEAAAgFXvL2z+iIA5ENivxEfP+WT2iIAcgDKBE1a2ayjiUuz2ioKCgoCEHCyAHCyIHmUQAAAAAAADgQWMEQCAHqgwBC0GAgICAeAshAiAHRAAAAAAAAAhAIAK3oaAFRAAAAAAAAAhACxCmASIHOQMAIAEgBzkDoAMgASAHOQOoAyAAQZaNBCABQaADahAeIAFB/e0ENgKQAyAAQfj7AyABQZADahAeIAFB/e0ENgKAAyAAQZbABCABQYADahAeIAFB/e0ENgLwAiAAQdfDAyABQfACahAeIAFB/e0ENgLgAiAAQcLOAyABQeACahAeIAFB/e0ENgLQAiAAQYDDBCABQdACahAeIAFB/e0ENgLAAiAAQYauBCABQcACahAeIAFB/e0ENgKwAiAAQdLABCABQbACahAeIAFB/e0ENgKgAiAAQfzCAyABQaACahAeIAFB/e0ENgKQAiAAQfD3AyABQZACahAeIAFB/e0ENgKAAiAAQcDBBCABQYACahAeIAFB/e0ENgLwASAAQYTPAyABQfABahAeIABB77QEQQAQHiABQf3tBDYC4AEgAEHDkgQgAUHgAWoQHiABQf3tBDYC0AEgAEGbkgQgAUHQAWoQHiAAQcm9BEEAEB4gAUH97QQ2AsABIABBpNIEIAFBwAFqEB4gAUH97QQ2ArABIABB9LwEIAFBsAFqEB4gAUH97QQ2AqABIABBrrwEIAFBoAFqEB4gAEGWtARBABAeIAFB/e0ENgKQASAAQaHyAyABQZABahAeIAFB/e0ENgKAASAAQYrzAyABQYABahAeIAFB/e0ENgJwIABBiMEDIAFB8ABqEB4gAUH97QQ2AmAgAEHUyAMgAUHgAGoQHiABQf3tBDYCUCAAQa/BAyABQdAAahAeIAFB/e0ENgJAIABB+8cDIAFBQGsQHiAAQfL5A0EAEB4gAUH97QQ2AjAgAEGoxwMgAUEwahAeIAFB/e0ENgIgIABBvPEDIAFBIGoQHiABQf3tBDYCECAAQcSuBCABQRBqEB4gASAJOQMIIAEgDTkDACAAQcGQBCABEB4gAEHYswRBABAeIABB7NwEQQAQHiABQeADaiQACycBAX8jAEEQayIBJAAgAUH47QQ2AgAgAEH+tQQgARAeIAFBEGokAAuIAQIDfwF+IwBBMGsiASQAIAAoAhAhAiAAKAIMKAIAIgMpAgAhBCABIAMoAgg2AiwgASAENwIkIAFB+O0ENgIgIABButUEIAFBIGoQHiABIAIoAggQITYCFCABQfjtBDYCECAAQYzoAyABQRBqEB4gAUH47QQ2AgAgAEG5jQQgARAeIAFBMGokAAslAQF/IwBBEGsiAiQAIAIgATYCACAAQZvmAyACEB4gAkEQaiQAC54DAgR/BHwjAEHAAWsiAyQAIABB+ZQEEBoaQdj+CkHU/gooAgBBBms2AgAgA0GYAWoiBSAAKAIQQRBqQSgQIxogBUMAAAAAEIIDIQUgA0GWlAE2ApABIAMgAjYClAEgAEHI0AQgA0GQAWoQHiACQQAgAkEAShshAgNAIAIgBEYEQCAAQZ7CBBAaGiAAKwPwAyEHIAArA+gDIQggA0KAgICAgICA+D83A2AgAyAHOQNYIAMgCDkDUCAAQcC5BCADQdAAahAeIANBQGsgACgC6AKyuzkDACADQgA3AzggA0IANwMwIABBnLkEIANBMGoQHiADQdj+CigCADYCICADQgA3AxAgA0IANwMYIABBu7oEIANBEGoQHiADIAU2AgAgAEHVtgMgAxAeIAUQGSADQcABaiQABSABIARBBHRqIgYrAwAhByAGKwMIIQggACsD+AMhCSAAKwOABCEKIAMgACgCECsDmAE5A4gBIANCADcDgAEgAyAIIAqgOQN4IAMgByAJoDkDcCAAQdqMBCADQfAAahAeIARBAWohBAwBCwsLxwQCBX8EfCMAQYACayIDJAAgAEGL8AMQGhpB2P4KQdT+CigCAEEEazYCACADQcgBaiIFIAAoAhBBOGpBKBAjGiAFQwAAAAAQggMhBSADQgA3A/gBIANBpJQBNgLAASADIAJBAmo2AsQBIANCADcD8AEgA0HwAWpByNAEIANBwAFqEGIgAkEAIAJBAEobIQYgAkEBayEHA0AgBCAGRwRAIAEgBEEEdGoiAisDACEJIAIrAwghCiAAKwP4AyELIAArA4AEIQwgAyAAKAIQKwOYATkDuAEgA0IANwOwASADIAogDKA5A6gBIAMgCSALoDkDoAEgA0HwAWoiCEHajAQgA0GgAWoQYiAEQQAgBCAHRxtFBEAgACsD+AMhCSACKwMAIQogACsDgAQhCyACKwMIIQwgAyAAKAIQKwOYATkDmAEgA0IANwOQASADIAwgC6A5A4gBIAMgCiAJoDkDgAEgCEHajAQgA0GAAWoQYgsgBEEBaiEEDAELCyADIANB8AFqIgEQ3wQ2AnAgAEGYwgQgA0HwAGoQHiAAKwPwAyEJIAArA+gDIQogA0KAgICAgICA+D83A2AgAyAJOQNYIAMgCjkDUCAAQcC5BCADQdAAahAeIANBQGsgACgC6AKyuzkDACADQgA3AzggA0IANwMwIABBnLkEIANBMGoQHiADQdj+CigCAEECazYCICADQgA3AxAgA0IANwMYIABBu7oEIANBEGoQHiADIAU2AgAgAEHVtgMgAxAeIAUQGSABEIABIANBgAJqJAAL4gYCBX8EfCMAQaADayIEJAAgAEHk8wMQGhpB2P4KQdT+CigCAEECazYCACAEQfgCaiIGIAAoAhBBEGpBKBAjGiAGQwAAAAAQggMhBiAEIAJBAWo2AvQCIARBlpQBNgLwAiAAQcjQBCAEQfACahAeIAJBACACQQBKGyEHA0AgBSAHRgRAAkAgACsD+AMhCSABKwMAIQogACsDgAQhCyABKwMIIQwgBCAAKAIQKwOYATkDyAIgBEIANwPAAiAEIAwgC6A5A7gCIAQgCiAJoDkDsAIgAEHajAQgBEGwAmoQHiAAQbLCBBAaGiAAKwPwAyEJIAArA+gDIQogBEKAgICAgICA+D83A6ACIAQgCTkDmAIgBCAKOQOQAiAAQcC5BCAEQZACahAeIAQgACgC6AKyuzkDgAIgBEIANwP4ASAEQgA3A/ABIABBnLkEIARB8AFqEB5BACEFIARB2P4KKAIAQQJrNgLgASAEQgA3A9ABIARCADcD2AEgAEG7ugQgBEHQAWoQHiAEIAY2AsABIABB1bYDIARBwAFqEB4gBhAZIANFDQAgBEGYAWoiAyAAKAIQQThqQSgQIxogA0MAAIA+EIIDIQMgBCACNgKQASAAQZ7QBCAEQZABahAeA0AgBSAHRgRAIABBy7YDEBoaIAArA+gDIQkgACsD8AMhCiAEQoCAgICAgID4PzcDYCAEIAo5A1ggBCAJOQNQIABBwLkEIARB0ABqEB4gBEFAayAAKALoArK7OQMAIARCADcDOCAEQgA3AzAgAEGcuQQgBEEwahAeIARB2P4KKAIAQQJrNgIgIARCADcDECAEQgA3AxggAEG7ugQgBEEQahAeIAQgAzYCACAAQdW2AyAEEB4gAxAZBSABIAVBBHRqIgIrAwAhCSACKwMIIQogACsD+AMhCyAAKwOABCEMIARCADcDgAEgBCAKIAygOQN4IAQgCSALoDkDcCAAQarTASAEQfAAahAeIAVBAWohBQwBCwsLBSABIAVBBHRqIggrAwAhCSAIKwMIIQogACsD+AMhCyAAKwOABCEMIAQgACgCECsDmAE5A+gCIARCADcD4AIgBCAKIAygOQPYAiAEIAkgC6A5A9ACIABB2owEIARB0AJqEB4gBUEBaiEFDAELCyAEQaADaiQAC7sFAwJ/CXwCfSMAQfACayIDJAAgAEGtkwQQGhpB2P4KQdT+CigCAEEGazYCACAAKwOABCELIAArA/ADIQYgASsDGCEFIAArA/gDIQwgACgCECIEKwOYASEIIAArA+gDIQcgASsDACEJIAErAxAhDSABKwMIIQogA0G4AmoiASAEQRBqQSgQIxogAUMAAAAAEIIDIQEgA0IANwPoAiADQoCAgICAgID4PzcDoAIgA0IANwPgAiADIAggByANIAmhorYiDiAGIAUgCqGitiIPkrsiBaNEAAAAAAAA4D+iRAAAAAAAABRAora7OQOoAiADQeACaiIEQcaMBCADQaACahBiIAMgD7siCDkDkAIgAyAFRAAAAAAAANA/ojkDiAIgAyAOuyIFOQOAAiAEQcC5BCADQYACahBiIAMgACgC6AKyuzkD8AEgA0IANwPoASADQoCAgICAgKCrwAA3A+ABIARBnLkEIANB4AFqEGIgA0HY/gooAgA2AtABIAMgByAJIAygora7Igc5A8ABIAMgBiAKIAugora7IgY5A8gBIARBu7oEIANBwAFqEGIgAyABNgKwASAEQdW2AyADQbABahBiIAAgBBDfBBAaGiABEBkgAgRAIANBiAFqIgEgACgCEEE4akEoECMaIAFDAAAAABCCAyEBIANCADcDgAEgA0IANwN4IANCADcDcCAAQbPDBCADQfAAahAeIANCgICAgICAgPg/NwNgIAMgCDkDWCADIAU5A1AgAEHAuQQgA0HQAGoQHiADQUBrIAAoAugCsrs5AwAgA0IANwM4IANCADcDMCAAQZy5BCADQTBqEB4gA0HY/gooAgA2AiAgAyAHOQMQIAMgBjkDGCAAQbu6BCADQRBqEB4gAyABNgIAIABB1bYDIAMQHiABEBkLIANB4AJqEIABIANB8AJqJAAL8QMCA38GfCMAQdABayIDJAAgAigCACEEIAIoAgQiBSsDECEGIAMgBSgCADYCsAEgAyAGOQOoASADIAQ2AqABIABB0OUDIANBoAFqEB5B2P4KQdT+CigCAEEJazYCAAJ8AkAgAiwAMCIEQfIARwRAIARB7ABHDQEgASsDAAwCCyABKwMAIAIrAyChDAELIAErAwAgAisDIEQAAAAAAADgv6KgCyEGIAArA/ADIQcgACsDgAQhCCABKwMIIQkgACsD6AMhCiAAKwP4AyELIANB+ABqIgEgACgCEEEQakEoECMaIAFDAAAAABCCAyEBIANCADcDyAEgA0IANwPAASACKAIEKAIAIQQgAigCACEFIANCADcDcCADQoCAgICAgIDoPzcDaCADIAU2AmQgAyAENgJgIANBwAFqIgRB/8QDIANB4ABqEGIgAyACKAIEKwMQIAArA+gDojkDUCAEQbaMBCADQdAAahBiIANBQGsgACgC6AKyuzkDACADQgA3AzggA0IANwMwIARBnLkEIANBMGoQYiADQdj+CigCADYCICADIAogBiALoKI5AxAgAyAHIAkgCKCiOQMYIARBu7oEIANBEGoQYiADIAE2AgAgBEHVtgMgAxBiIAAgBBDfBBAaGiAEEIABIAEQGSADQdABaiQACxwAIABBz5YEEBoaQdT+CkHU/gooAgBBBWo2AgALHAAgAEG9lgQQGhpB1P4KQdT+CigCAEEFazYCAAsLACAAQeiYBBAaGgstAQF/IwBBEGsiASQAIAEgACgCECgCCBAhNgIAIABBp+gDIAEQHiABQRBqJAALCwAgAEHP7gMQGhoLHAAgAEG67gMQGhpB1P4KQdT+CigCAEECazYCAAsLACAAQZ6YBBAaGgsLACAAQYyYBBAaGgsLACAAQcftAxAaGgs/AQF/IwBBEGsiBCQAIAQgAzYCCCAEIAE2AgAgBCACNgIEIABBsaQEIAQQHkHU/gogAkF2bDYCACAEQRBqJAALCwAgAEHx+gMQGhoLgQICAX8DfCMAQUBqIgEkACABIAAoAhAoAggQITYCMCAAQZTfAyABQTBqEB4gACsD8AIhAyAAKwPoAyECIAEgACsD+AJEAAAAAAAA4D+iIAArA/ADoiIEOQMYIAEgAiADRAAAAAAAAOA/oqIiAzkDECABIANE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IAYLIAEBfyAAKAIgIAEoAihMBH8gASgCICAAKAIoTAVBAAsLvAMBAX8jAEGAAmsiACQAIAAgAjYC+AEgACABNgL8ASAAQcABaiADIABB0AFqIABBzwFqIABBzgFqEKUHIABBtAFqEEoiASABEFAQOyAAIAFBABA+IgI2ArABIAAgAEEQajYCDCAAQQA2AgggAEEBOgAHIABBxQA6AAYDQAJAIABB/AFqIABB+AFqEFgNACAAKAKwASABECYgAmpGBEAgARAmIQMgASABECZBAXQQOyABIAEQUBA7IAAgAyABQQAQPiICajYCsAELIABB/AFqIgMQfCAAQQdqIABBBmogAiAAQbABaiAALADPASAALADOASAAQcABaiAAQRBqIABBDGogAEEIaiAAQdABahCkBw0AIAMQkQEaDAELCwJAIABBwAFqECZFDQAgAC0AB0UNACAAKAIMIgMgAEEQamtBnwFKDQAgACADQQRqNgIMIAMgACgCCDYCAAsgBSACIAAoArABIAQQ/ws4AgAgAEHAAWogAEEQaiAAKAIMIAQQqQEgAEH8AWogAEH4AWoQWARAIAQgBCgCAEECcjYCAAsgACgC/AEhBiABEDIaIABBwAFqEDIaIABBgAJqJAAgBguSAwECfyMAQYACayIAJAAgACACNgL4ASAAIAE2AvwBIAMQmwIhBiAAQcQBaiADIABB9wFqEJ4EIABBuAFqEEoiASABEFAQOyAAIAFBABA+IgI2ArQBIAAgAEEQajYCDCAAQQA2AggDQAJAIABB/AFqIABB+AFqEFgNACAAKAK0ASABECYgAmpGBEAgARAmIQMgASABECZBAXQQOyABIAEQUBA7IAAgAyABQQAQPiICajYCtAELIABB/AFqIgMQfCAGIAIgAEG0AWogAEEIaiAALAD3ASAAQcQBaiAAQRBqIABBDGpBoJcHENMDDQAgAxCRARoMAQsLAkAgAEHEAWoQJkUNACAAKAIMIgMgAEEQamtBnwFKDQAgACADQQRqNgIMIAMgACgCCDYCAAsgBSACIAAoArQBIAQgBhCADDcDACAAQcQBaiAAQRBqIAAoAgwgBBCpASAAQfwBaiAAQfgBahBYBEAgBCAEKAIAQQJyNgIACyAAKAL8ASEHIAEQMhogAEHEAWoQMhogAEGAAmokACAHC5IDAQJ/IwBBgAJrIgAk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RQ0BIAEoAgQgAzYCACADIAEoAgQ2AgQgAUEEagwCCyAFKAIMRQ0FIAUoAhAiAEUNBSABIAUgABEEAEEADwsgAiADNgIIIANBBGoLIAM2AgAgA0EANgIAIAAoAggiACgCECIBQQBOBEAgACABQQFqNgIQCyAAIAM2AgQMBQsgACgCCCEJAkACQCACQYAEcQ0AIAkoAgQiAwRAAn8gBkEASARAIAMoAggMAQsgAyAGawsgAUYNAgsgASALaiEBIAhBAE4NACABKAIAIQELQQAgBmshDCAJQQhqIQMgBkEATiEJA0AgAygCACIDRQ0EAn8gCUUEQCADKAIIDAELIAMgDGoLIAtqIQQgCEEASARAIAQoAgAhBAsCfyAKBEAgACABIAQgBSAKEQYADAELIAhBAEwEQCABIAQQKAwBCyABIAQgCBDRAQsNAAsgACgCFCEECyAAIARBgIACcjYCFCACQYIgcUUNAQsgAygCACIBBEAgASADKAIENgIECyADKAIAIQECQCAAKAIIIgcoAggiBCADRgRAIAcgATYCCCAAKAIIKAIIIgFFDQEgASADKAIENgIEDAELIAMoAgQgATYCACADIAQoAgRHDQAgBCADKAIENgIEC0EAIQQgACgCCCIBKAIEIANGBEAgAygCACEECyABIAQ2AgQgASABKAIQQQFrNgIQAn8gBkEASARAIAMoAggMAQsgAyAGawshBwJAIAJBAnFFDQAgBSgCECIBRQ0AIAcgBSABEQQACyAFKAIIQQBODQEgACADQQAgBSAAKAIMEQYAGiAHDwsCQAJAIAJBCHEEQCAAKAIIIQQMAQsgACgCCCEEIAJBEHFFBEAgBCADNgIEDAILIAQoAgggA0YEQCAEQQA2AgRBAA8LIANBBGohAwsgBCADKAIAIgM2AgQgA0UNAgsgBkEASARAIAMoAggPCyADIAZrIQcLIAcPC0EADwsgBkEASARAIAMoAggPCyADIAZrCysAAkACQCABBEAgAkUEQCABEBkMAgsgASACEDcPCyACDQELQQAPCyACEDgLFQBBmI4LKAIABEAgABAZDwsgABAZCzIAQZiOCygCACIABEAgAQRAIAEQGUEADwsgACACENQBDwsgAQRAIAEQGUEADwsgAhA4CwkAIAEgAhDTAQslAEF/IAEoAhAoAgBBBHYiACACKAIQKAIAQQR2IgFLIAAgAUkbCxwAIAAgACgCECIBQRxqRwRAIAEoAhgaIAAQGQsLIQECfkF/IAEoAhApAwgiBCACKAIQKQMIIgVWIAQgBVQbC2IBAn9BmI0LIAE2AgAgACABEGohAgNAIAIEQCAAIAIgARBwIQQgACACQQAQ8Q0gBCECDAELCyAAKAIoIgFBiI0LQQIgASgCABEDABogACgCJCIAQYiNC0ECIAAoAgARAwAaCwsAIAAgASACEP0HC3EBA38CQCACRQ0AIAAoAggiAyAAKAIETw0AIAAoAgAgA2oiBS0AACEDA0ACQCABIAM6AAAgA0EKRiAEQQFqIgQgAk5yDQAgAUEBaiEBIAUtAAEhAyAFQQFqIQUgAw0BCwsgACAAKAIIIARqNgIICyAECwcAIAAQ4gMLCQAgASAAEIEBCxYAIAEgAiAAEKUERQRAQQAPCyABEEALIAECfkEBQX9BACABKQMQIgQgAikDECIFVBsgBCAFVhsLHgBBAUF/QQAgASgCGCIAIAIoAhgiAUkbIAAgAUsbCwIACw4AIAKnQQAgAkIBg1AbCxYAIAKnIgFBAXFFBEAgACABEIkBGgsLBABBAAtIAQF+AkAgAgRAIAMCfyAEBEAgACACEKcBDAELIAAgAhDJDQutNwMADAELIANBqLwKKQMAIgU3AwBBqLwKIAVCAnw3AwALQQELGwECfkF/IAEpAwgiBCACKQMIIgVWIAQgBVQbC2gBAn5BfyEAAkAgASgCKCkDCCIEIAIoAigpAwgiBVQNACAEIAVWBEBBAQ8LAkAgAS0AAEEDcUUNACACLQAAQQNxRQ0AIAEpAwgiBCACKQMIIgVUDQFBASEAIAQgBVYNAQtBACEACyAAC44BAQF/IAFFIAJFckUEQAJAAkAgASgCKCIDIAIoAigiBEcEQEF/IQAgAygCAEEEdiIBIAQoAgBBBHYiAkkNAkEBIQAgASACTQ0BDAILQX8hACABKAIAQQR2IgEgAigCAEEEdiICSQ0BQQEhACABIAJLDQELQQAhAAsgAA8LQannAkGquQFBlgNBp4IBEAAACycAQX8gACgCACgCECgC+AEiACABKAIAKAIQKAL4ASIBSiAAIAFIGwsNACAAQQIgASACECQaCwcAIAAQ9g0LLgBB4IsLKAIAIAAoAggQiQEaQeCLCygCACAAKAIMEIkBGkHgiwsoAgAaIAAQGQsYACABECsgAEcEfyAAIAFBABC6AgUgAQsLFwAgARArIABHBH8gACABQQAQegUgAQsLQgECfCABKwMAIgQgAisDACIFZARAIAErAwggAisDCGVFDwtBACEAIAQgBWMEf0EAQX8gASsDCCACKwMIZhsFQQALC04BAn8gACgCICECQQAhAQNAIAIoAgQhAyACKAIAIAFKBEAgAyABQQxsaigCCBBzGiABQQFqIQEMAQsLIAMQGSACEBkgACgCHBAZIAAQGQsgAQJ8QQFBf0EAIAErAwAiBCACKwMAIgVjGyAEIAVkGwsOACAAKAIQEHMaIAAQGQsNACAAKAIAIAEoAgBrC1gBAXxBfyABKwMIIAIrAwihIgRESK+8mvLXej5kIARESK+8mvLXer5jGyIABH8gAAVBfyABKwMAIAIrAwChIgRESK+8mvLXej5kIARESK+8mvLXer5jGwsLWAEBfEF/IAErAwAgAisDAKEiBERIr7ya8td6PmQgBERIr7ya8td6vmMbIgAEfyAABUF/IAErAwggAisDCKEiBERIr7ya8td6PmQgBERIr7ya8td6vmMbCws8AAJ/QX8gASgCACIDIAIoAgAiAEkNABpBASAAIANJDQAaQX8gASgCBCIBIAIoAgQiAkkNABogASACSwsLMABBGBBOIgEgACgCCDYCCCABIAAoAgw2AgwgASAAKAIQNgIQIAEgACgCFDYCFCABCw0AIABBASABIAIQJBoLWAEBf0EBQSAQWiEBIAAoAgAiAgRAIAEgAhChATYCAAsgACgCBCICBEAgASACEKEBNgIECyABIAAoAhhB/wBxNgIYIAEgACsDEDkDECABIAAoAgg2AgggAQsUACAAKAIAEBkgACgCBBAZIAAQGQuzAQIBfwJ8IAIoAgAhAwJAAkACQCABKAIAIgBFBEBBfyEAIANFDQEMAgsgA0UNAiAAIAMQKCIADQELIAIoAgQhAwJAIAEoAgQiAEUEQEF/IQAgA0UNAQwCCyADRQ0CIAAgAxAoIgANAQtBfyEAIAEoAhhB/wBxIgMgAigCGEH/AHEiBEkNAEEBIQAgAyAESw0AQX8hACABKwMQIgUgAisDECIGYw0AIAUgBmQhAAsgAA8LQQELqgICBnwDfwJAIAErAwgiBCABKwMAIgOjIgJEAFVEEw5v7j9kBEAgBEQA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CwsgAyEHIAJBAXFFDQELQcAAEE4iAiABKAJcIgM2AiAgAiABKAJYIgU2AiQgAiABKAJUIANrNgIoIAEoAlAhAyACIAQ2AgggAiADIAVrNgIsQcCIC0HAiAsoAgAiA0EBajYCACACIAM2AgwgBhDYDCABQeAAahDUDCACIAEoAngiBUEBakEBEB0iAzYCNCAGQQBBABDCARogAyAFQQEgBhC+BUEBRgRAIAMgBWpBADoAAEGoiAsoAgAiAyACQQEgAygCABEDABogAiAHQQFxOgAQDAILIAEgBDYCIEEAQZPjAyABQSBqEB8gAxAZIAIQGUEAIQIMAQsgASAENgIwQQAhAkEAQdDiAyABQTBqEB8LIAYQ4wMgAkUNAwsgAigCKCEHIAAoAhAiAyACKAIsIgS3RAAAAAAAAFJAozkDKCADIAe3RAAAAAAAAFJAozkDIEEMEE4hAyAAKAIQIAM2AgwgAyACKAIMNgIAIAMgB0F+bSACKAIgazYCBCADIARBfm0gAigCJGs2AggMAgsgASAAECE2AgBBAEHA4wMgARAfDAELIAEgBDYCEEEAQffiAyABQRBqEB8LIAFBwAlqJAALEwAgACABKAIcNgIAIAEgADYCHAs6AQF/AkAgASgCHCICBEAgASACKAIANgIcDAELQRQQ3AEhAgsgAiAAKQIINwIIIAIgACgCEDYCECACC0EAAn9BASABKAIAIgMgAigCACIASg0AGkF/IAAgA0oNABpBASABKAIEIgEgAigCBCICSg0AGkF/QQAgASACSBsLCycAQX8gACgCACgCECgC9AEiACABKAIAKAIQKAL0ASIBSiAAIAFIGwsnAEF/IAEoAgAoAhAoAvQBIgEgACgCACgCECgC9AEiAEogACABShsLCwAgACABQQEQjwELGQBBfyAAKAIAIgAgASgCACIBSiAAIAFIGwseAEEBQX9BACABKAIAIgAgAigCACIBSBsgACABShsLRQEBfyMAQRBrIgEkAEEBQQwQWiICRQRAIAFBDDYCAEHo3gYoAgBB1NEDIAEQIhAvAAsgAiAAKAIANgIAIAFBEGokACACCw4AIAAoAggQcxogABAZC0oBAn8gACgCDCIDBEAgACgCCCEBA0AgAiADTwRAIAAoAggQGQUgASgCABAZIAJBAWohAiABQThqIQEgACgCDCEDDAELCwsg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dGl0eQBYTUwgb3IgdGV4dCBkZWNsYXJhdGlvbiBub3QgYXQgc3RhcnQgb2YgZW50aXR5AHVuZGVmaW5lZCBlbnRpdHkAaW5maW5pdHkAZmFudGFzeQBTcGFyc2VNYXRyaXhfY29vcmRpbmF0ZV9mb3JtX2FkZF9lbnRyeQAvc3ZnL2l2b3J5AG91dCBvZiBtZW1vcnkARmVicnVhcnkASmFudWFyeQBndnBsdWdpbl9kb3RfbGF5b3V0X0xUWF9saWJyYXJ5AGd2cGx1Z2luX25lYXRvX2xheW91dF9MVFhfbGlicmFyeQBndnBsdWdpbl9jb3JlX0xUWF9saWJyYXJ5AGdhdGhlcl90aW1lX2VudHJvcHkAY29weQBhbGJhbnkASnVseQBTcGFyc2VNYXRyaXhfbXVsdGlwbHkAZXF1YWxseQBhc3NlbWJseQBzdW1tZXJza3kAc2h5AHNhdGlzZnkAYmVhdXRpZnkAbm9qdXN0aWZ5AENsYXNzaWZ5AC9zdmcvbGlnaHRncmV5AC9zdmcvZGltZ3JleQAvc3ZnL2RhcmtncmV5AC9zdmcvbGlnaHRzbGF0ZWdyZXkAL3N2Zy9kYXJrc2xhdGVncmV5AC9zdmcvc2xhdGVncmV5AHdlYmdyZXkAeDExZ3JleQAvc3ZnL2dyZXkAa2V5AG1vdmUgdG8gZnJvbnQgbG9jayBpbmNvbnNpc3RlbmN5AGV4dHJhY3RfYWRqYWNlbmN5AG1lcmdlX29uZXdheQBhcnJheQBhbGxvY0FycmF5AC9zdmcvbGlnaHRncmF5AC9zdmcvZGltZ3JheQAvc3ZnL2RhcmtncmF5AC9zdmcvbGlnaHRzbGF0ZWdyYXkAL3N2Zy9kYXJrc2xhdGVncmF5AC9zdmcvc2xhdGVncmF5AHdlYmdyYXkAeDExZ3JheQAvc3ZnL2dyYXkAVGh1cnNkYXkAVHVlc2RheQBXZWRuZXNkYXkAU2F0dXJkYXkAU3VuZGF5AE1vbmRheQBGcmlkYXkATWF5AC4uLy4uL2xpYi9jZ3JhcGgvZ3JhbW1hci55AFIueCAhPSBRLnggfHwgUi55ICE9IFEueQAlbS8lZC8leQBwb3J0aG95eABwb3J0aG9feXgAeHh4AHB4AGJveAB2aWV3Qm94AGNoa0JvdW5kQm94AC9NZWRpYUJveABnZXRfZWRnZV9sYWJlbF9tYXRyaXgAaWRlYWxfZGlzdGFuY2VfbWF0cml4AG11c3Qgbm90IHVuZGVjbGFyZSBwcmVmaXgAdW5ib3VuZCBwcmVmaXgAaHRtbGxleABtYXgAIyUwMnglMDJ4JTAyeCUwMngAIyUwMnglMDJ4JTAyeAAjJTJ4JTJ4JTJ4JTJ4ACMlMXglMXglMXgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAByYXJyb3cAbGFycm93AEhlbHZldGljYS1OYXJyb3cAYXJyb3dfbGVuZ3RoX2Nyb3cAL3N2Zy9zbm93AHNwcmluZ19lbGVjdHJpY2FsX2VtYmVkZGluZ19zbG93AC9zdmcvbGlnaHR5ZWxsb3cAL3N2Zy9ncmVlbnllbGxvdwAvc3ZnL2xpZ2h0Z29sZGVucm9keWVsbG93AC9zdmcveWVsbG93AGZhdGFsIGVycm9yIC0gc2Nhbm5lciBpbnB1dCBidWZmZXIgb3ZlcmZsb3cAZmxleCBzY2FubmVyIHB1c2gtYmFjayBvdmVyZmxvdwBjb3VyaWVybmV3AFNwcmluZ1Ntb290aGVyX25ldwBUcmlhbmdsZVNtb290aGVyX25ldwBPcGVyYXRvcl91bmlmb3JtX3N0cmVzc19kaWFnX3ByZWNvbl9uZXcAT3BlcmF0b3JfZGlhZ19wcmVjb25fbmV3AFF1YWRUcmVlX25ldwBTdHJlc3NNYWpvcml6YXRpb25TbW9vdGhlcjJfbmV3AHIgJiYgbiAmJiBuZXcAc2tldwBzdHJ2aWV3AC9zdmcvaG9uZXlkZXcAIC1hbmNob3IgdwBzb3J0dgBwb3Y6cG92AE5vdgBpbnYAZXF1aXYAcGl2AG5vbmFtZS5ndgAlenUAL3N2Zy9wZXJ1AG51AG11ACVjJWxsdQBUaHUAdGF1AFRhdQBOdQBNdQBfcG9ydF8lc18oJWQpXyglZClfJXUAcGxhaW50ZXh0ADx0ZXh0AHN0cmVzc3d0AGlucHV0AHRleHRsYXlvdXQAZG90X2xheW91dABuZWF0b19sYXlvdXQAaW5pdExheW91dAB1c2Vyb3V0AGNsdXN0AG1hcENsdXN0AGxhYmVsanVzdABzY0FkanVzdABBdWd1c3QAZWRnZXNmaXJzdABub2Rlc2ZpcnN0AG1heGltYWxfaW5kZXBlbmRlbnRfZWRnZV9zZXRfaGVhdmVzdF9lZGdlX3Blcm5vZGVfc3VwZXJub2Rlc19maXJzdABleGlzdAByZWFsaWduTm9kZWxpc3QAYXBwZW5kTm9kZWxpc3QAZGVmYXVsdGRpc3QAbWluZGlzdABwb3dlcl9kaXN0AGdyYXBoX2Rpc3QAYXZnX2Rpc3QAZ2V0RWRnZUxpc3QAaXF1ZXN0AGxvd2FzdABzcHJpbmdfZWxlY3RyaWNhbF9lbWJlZGRpbmdfZmFzdABndl9zb3J0AGRlZ2xpc3Rfc29ydAB2aWV3cG9ydAB0YWlscG9ydAB1bmV4cGVjdGVkIHBhcnNlciBzdGF0ZSAtIHBsZWFzZSBzZW5kIGEgYnVnIHJlcG9ydABoZWFkcG9ydABSVHJlZUluc2VydABmaW5kU1ZlcnQAc3RhcnQAcGFydABlc3RpbWF0ZV90ZXh0X3dpZHRoXzFwdABxdW90AH9yb290AG5vdABlbWl0X3hkb3QAeGRvdDp4ZG90AGVwczp4ZG90AHN2Zzp4ZG90AGpwZzp4ZG90AHBuZzp4ZG90AGpwZWc6eGRvdABnaWY6eGRvdABqcGU6eGRvdAB4ZG90MS40Onhkb3QAeGRvdDEuMjp4ZG90AHNkb3QAbWlkZG90AGd2OmRvdABwbGFpbi1leHQ6ZG90AGRvdDpkb3QAZXBzOmRvdABjYW5vbjpkb3QAcGxhaW46ZG90AHN2Zzpkb3QAanBnOmRvdABwbmc6ZG90AGpwZWc6ZG90AGdpZjpkb3QAanBlOmRvdAB/Ym90AGRvRG90AHNwYW4tPmZvbnQAYWd4YnByaW50AGxvY2F0ZV9lbmRwb2ludABkZWNpZGVfcG9pbnQAVW5zYXRpc2ZpZWQgY29uc3RyYWludAB0cmFuc3BhcmVudABjb21wb25lbnQAaW52YWxpZCBhcmd1bWVudABjb21tZW50AGp1bmsgYWZ0ZXIgZG9jdW1lbnQgZWxlbWVudABjZW50AGkgPT0gZWNudABhcmlhbG10AGx0AGNpcmN1aXQAcG9seV9pbml0AE11bHRpbGV2ZWxfaW5pdABuc2xpbWl0AG1jbGltaXQAUG9ydHJhaXQAbGlnaHQAdmlydHVhbF93ZWlnaHQAbGhlaWdodABLUF9SaWdodABCb29rbWFuLUxpZ2h0AGd0AEtQX0xlZnQAYWd4c2V0AGNoYXJzZXQAaW5zZXQAYml0YXJyYXlfcmVzZXQAc3Vic2V0AGJpdGFycmF5X3NldABub2RlbGlzdF9zZXQAc2NhcmxldAAvc3ZnL2Rhcmt2aW9sZXQAL3N2Zy9ibHVldmlvbGV0AC9zdmcvdmlvbGV0AFRyZWJ1Y2hldABhZ3hnZXQAdGFpbHRhcmdldABsYWJlbHRhcmdldABlZGdldGFyZ2V0AGhlYWR0YXJnZXQAYml0YXJyYXlfZ2V0AG5vZGVsaXN0X2dldABzYW1lX2xpc3RfZ2V0AGVkZ2VfbGlzdF9nZXQAcG9pbnRzX2dldAB0cmlhbmdsZXNfZ2V0AHZlY19nZXQAc3R5bGVzaGVldABzdHJpY3QAYWdjb3B5ZGljdABhZ21ha2VkYXRhZGljdAByZWMtPmRpY3QgPT0gZGF0YWRpY3QAd3JpdGVfZGljdABzZWN0AGVuY29kaW5nIHNwZWNpZmllZCBpbiBYTUwgZGVjbGFyYXRpb24gaXMgaW5jb3JyZWN0AGFzcGVjdABsYXllcnNlbGVjdABDb21iaW5lUmVjdABLUF9TdWJ0cmFjdABRdWFkVHJlZV9yZXB1bHNpdmVfZm9yY2VfaW50ZXJhY3QAY29tcGFjdABPY3QAcmVxdWVzdGVkIGZlYXR1cmUgcmVxdWlyZXMgWE1MX0RURCBzdXBwb3J0IGluIEV4cGF0AGxhYmVsZmxvYXQAbGFiZWxfZmxvYXQAU3BhcnNlTWF0cml4X2Zyb21fY29vcmRpbmF0ZV9mb3JtYXQAL3N2Zy93aGVhdABvYmpsaXN0X2F0AG5vZGVsaXN0X2F0AHNhbWVfbGlzdF9hdABwb2ludHNfYXQAdHJpYW5nbGVzX2F0AFNhdABBZ3JhcGhpbmZvX3QAQWdlZGdlaW5mb190AEFnbm9kZWluZm9fdABcdABmbGF0aW5kZXgoYWdoZWFkKGUpKSA8IE0tPm5yb3dzAG1pbnVzAG9wbHVzAGhlYXJ0cwBzYW1wbGVwb2ludHMAZGlyZWRnZWNvbnN0cmFpbnRzAGxldmVsIGFzc2lnbm1lbnQgY29uc3RyYWludHMAeHkgcHNldWRvLW9ydGhvZ29uYWwgY29uc3RyYWludHMAeXggcHNldWRvLW9ydGhvZ29uYWwgY29uc3RyYWludHMAeHkgb3J0aG9nb25hbCBjb25zdHJhaW50cwB5eCBvcnRob2dvbmFsIGNvbnN0cmFpbnRzAGxpbmUgc2VnbWVudHMAcmVjdHMAYWNjb3VudGluZ1JlcG9ydFN0YXRzAGVudGl0eVRyYWNraW5nUmVwb3J0U3RhdHMAWmFwZkRpbmdiYXRzAHJlbWluY3Jvc3MAY29tcHJlc3MAZ3Z1c2Vyc2hhcGVfZmlsZV9hY2Nlc3MAYnJhc3MAY2xhc3MAYXBwbHlhdHRycwBhZ21ha2VhdHRycwBiaW5kYXR0cnMAcGFyc2VfbGF5ZXJzAG1rQ2x1c3RlcnMAcm91bmRfY29ybmVycwBtYWtlX2JhcnJpZXJzAGNkYXRhLT5udG9wbGV2ZWw9PWFnbm5vZGVzKGcpLWNkYXRhLT5udmFycwBjYW5ub3QgcmVhbGxvYyBvcHMAY2Fubm90IHJlYWxsb2MgcG5scHMAZXBzAGNvcmVfbG9hZGltYWdlX3BzAGVwczpwcwBwczI6cHMAKGxpYik6cHMAYWd4YnVmX3RyaW1femVyb3MAdGV4Z3lyZWhlcm9zAGltYWdlcG9zAHRpbm9zAHNldEVkZ2VMYWJlbFBvcwBTZXR0aW5nIGluaXRpYWwgcG9zaXRpb25zAHhsaW50ZXJzZWN0aW9ucwBjb2x1bW5zAGRlamF2dXNhbnMAbmltYnVzc2FucwBsaWJlcmF0aW9uc2FucwBmcmVlc2FucwBPcGVuU2FucwBvZmZzZXQgPT0gbl90ZXJtcwBkaXRlbXMAaW5kZXggPCBwdmVjLT5fZWxlbXMAZGlhbXMAZmxhdGluZGV4KGFndGFpbChlKSkgPCBNLT5uY29scwBjYW5ub3QgcmVhbGxvYyBkcS5wbmxzAGNhbm5vdCByZWFsbG9jIHBubHMAbGV2ZWxzAGZvcmNlbGFiZWxzAGRpYWdvbmFscwBtZXJnZV9yYW5rcwBvYmpwbHBta3MAc3BsaXRCbG9ja3MAaW52aXMAY2Fubm90IHJlYWxsb2MgdHJpcwBjb21wdXRlTGF5ZXJXaWR0aHMAQ2FsY3VsYXRpbmcgc2hvcnRlc3QgcGF0aHMAeWVzAHNob3dib3hlcwBiZWF1dGlmeV9sZWF2ZXMAYXR0YWNoX2VkZ2VfbGFiZWxfY29vcmRpbmF0ZXMAcG9seWxpbmVzAF9kb3Rfc3BsaW5lcwBvcnRob2dvbmFsIGxpbmVzAHRleGd5cmV0ZXJtZXMAb3RpbWVzAFRpbWVzAGZvbnRuYW1lcwBwcmVmaXggbXVzdCBub3QgYmUgYm91bmQgdG8gb25lIG9mIHRoZSByZXNlcnZlZCBuYW1lc3BhY2UgbmFtZXMAU3BhcnNlTWF0cml4X3N1bV9yZXBlYXRfZW50cmllcwBwZXJpcGhlcmllcwBHZXRCcmFuY2hlcwBmIDwgZ3JhcGhbal0ubmVkZ2VzAG1pbm1heF9lZGdlcwB1bmRvQ2x1c3RlckVkZ2VzAGNvbXBvdW5kRWRnZXMAbWVyZ2VfdHJlZXMAX19jbHVzdGVybm9kZXMATkRfaWQobnApID09IG5fbm9kZXMATG9hZE5vZGVzAHNpZGVzAHNwYWRlcwB2ZXJ0aWNlcwBjb29yZHMAc2V0Ym91bmRzAG1kcwBjZHMAZW1pdF9lZGdlX2dyYXBoaWNzAGNsdWJzAGNvbnNvbGFzACVsZiUycwAKU3RyaW5nIHN0YXJ0aW5nOjwlLjgwcwAKU3RyaW5nIHN0YXJ0aW5nOiIlLjgwcwAgJS4qcwAlLipzJXMlcwBleHBhdDogQWNjb3VudGluZyglcCk6IERpcmVjdCAlMTBsbHUsIGluZGlyZWN0ICUxMGxsdSwgYW1wbGlmaWNhdGlvbiAlOC4yZiVzACAlczolcwBfXyVkOiVzAC8lcy8lcwAlcy0lcwAsJXMAIGZvbnQtZmFtaWx5PSIlcwAiIHN0cm9rZS1kYXNoYXJyYXk9IiVzACIgY2xhc3M9IiVzAHBvbHkgJXMAKCglZiwlZiksKCVmLCVmKSkgJXMgJXMAY29sb3IgJXMAIFRpdGxlOiAlcwAic3RyaWN0IjogJXMAciAmJiBzAGNvdXIAdXRyAGFwcGVuZGF0dHIAYWRkYXR0cgBiZWdpbnN0cgBzdHJ2aWV3X3N0cgBwb3ZfY29sb3JfYXNfc3RyAHZwc2MhPW51bGxwdHIAYmVuZFRvU3RyAHVhcnIAY3JhcnIAbGFycgBoYXJyAGRhcnIAdUFycgByQXJyAGxBcnIAaEFycgBkQXJyAHIgJiYgcnIAQXByAFNwYXJzZU1hdHJpeF9tdWx0aXBseV92ZWN0b3IAdGVybWluYXRvcgBpbnN1bGF0b3IAdGV4Z3lyZWN1cnNvcgBzeW50YXggZXJyb3IARXJyb3IAcmZsb29yAGxmbG9vcgBsYWJlbGZvbnRjb2xvcgBwZW5jb2xvcgBmaWxsY29sb3IAYmdjb2xvcgByb3cgbWFqb3IAY29sdW1uIG1ham9yAG5laWdoYm9yAG1yAHJhbmtkaXIAcGFnZWRpcgBsYXllcgBOb2RlQ292ZXIAL3N2Zy9zaWx2ZXIAY2x1c3RlcgBleHBhbmRDbHVzdGVyAHJwcm9tb3RlcgBscHJvbW90ZXIAY2VudGVyAG1heGl0ZXIAcGFydGlhbCBjaGFyYWN0ZXIAISByb290UGFyc2VyLT5tX3BhcmVudFBhcnNlcgBka2dyZWVuY29wcGVyAGNvb2xjb3BwZXIAZ3Zfc29ydF9jb21wYXJfd3JhcHBlcgB0YXBlcgBvdmVybGFwX2JlemllcgB0a2dlbl9iZXppZXIAZmlnX2JlemllcgBjb3VyaWVyAENvdXJpZXIAaGllcgBkYWdnZXIARGFnZ2VyAG91dHB1dG9yZGVyAHBvc3RvcmRlcgBmbGF0X3Jlb3JkZXIAY2VsbGJvcmRlcgBmaXhMYWJlbE9yZGVyAGN5bGluZGVyAC9zdmcvbGF2ZW5kZXIAcmVuZGVyAGZvbGRlcgBjbHVzdGVyX2xlYWRlcgBORF9VRl9zaXplKG4pIDw9IDEgfHwgbiA9PSBsZWFkZXIAT2N0b2JlcgByZWZlcmVuY2UgdG8gaW52YWxpZCBjaGFyYWN0ZXIgbnVtYmVyAE5vdmVtYmVyAFNlcHRlbWJlcgBEZWNlbWJlcgBtYWNyAGJyAHN0YXIAZmVsZHNwYXIAcmVndWxhcgBzYW1lX2xpc3RfY2xlYXIAaW9zX2Jhc2U6OmNsZWFyAGJydmJhcgBNYXIAXHIATkRfcmFuayh2KSA9PSByAHN0cnZpZXdfZXEAc3Rydmlld19zdHJfZXEAc3Rydmlld19jYXNlX3N0cl9lcQBzdHJ2aWV3X2Nhc2VfZXEAdnAAJSVCZWdpblByb2xvZwovRG90RGljdCAyMDAgZGljdCBkZWYKRG90RGljdCBiZWdpbgoKL3NldHVwTGF0aW4xIHsKbWFyawovRW5jb2RpbmdWZWN0b3IgMjU2IGFycmF5IGRlZgogRW5jb2RpbmdWZWN0b3IgMAoKSVNPTGF0aW4xRW5jb2RpbmcgMCAyNTUgZ2V0aW50ZXJ2YWwgcHV0aW50ZXJ2YWwKRW5jb2RpbmdWZWN0b3IgNDUgL2h5cGhlbiBwdXQKCiUgU2V0IHVwIElTTyBMYXRpbiAxIGNoYXJhY3RlciBlbmNvZGluZwovc3Rhcm5ldElTTyB7CiAgICAgICAgZHVwIGR1cCBmaW5kZm9udCBkdXAgbGVuZ3RoIGRpY3QgYmVnaW4KICAgICAgICB7IDEgaW5kZXggL0ZJRCBuZSB7IGRlZiB9eyBwb3AgcG9wIH0gaWZlbHNlCiAgICAgICAgfSBmb3JhbGwKICAgICAgICAvRW5jb2RpbmcgRW5jb2RpbmdWZWN0b3IgZGVmCiAgICAgICAgY3VycmVudGRpY3QgZW5kIGRlZmluZWZvbnQKfSBkZWYKL1RpbWVzLVJvbWFuIHN0YXJuZXRJU08gZGVmCi9UaW1lcy1JdGFsaWMgc3Rhcm5ldElTTyBkZWYKL1RpbWVzLUJvbGQgc3Rhcm5ldElTTyBkZWYKL1RpbWVzLUJvbGRJdGFsaWMgc3Rhcm5ldElTTyBkZWYKL0hlbHZldGljYSBzdGFybmV0SVNPIGRlZgovSGVsdmV0aWNhLU9ibGlxdWUgc3Rhcm5ldElTTyBkZWYKL0hlbHZldGljYS1Cb2xkIHN0YXJuZXRJU08gZGVmCi9IZWx2ZXRpY2EtQm9sZE9ibGlxdWUgc3Rhcm5ldElTTyBkZWYKL0NvdXJpZXIgc3Rhcm5ldElTTyBkZWYKL0NvdXJpZXItT2JsaXF1ZSBzdGFybmV0SVNPIGRlZgovQ291cmllci1Cb2xkIHN0YXJuZXRJU08gZGVmCi9Db3VyaWVyLUJvbGRPYmxpcXVlIHN0YXJuZXRJU08gZGVmCmNsZWFydG9tYXJrCn0gYmluZCBkZWYKCiUlQmVnaW5SZXNvdXJjZTogcHJvY3NldCBncmFwaHZpeiAwIDAKL2Nvb3JkLWZvbnQtZmFtaWx5IC9UaW1lcy1Sb21hbiBkZWYKL2RlZmF1bHQtZm9udC1mYW1pbHkgL1RpbWVzLVJvbWFuIGRlZgovY29vcmRmb250IGNvb3JkLWZvbnQtZmFtaWx5IGZpbmRmb250IDggc2NhbGVmb250IGRlZgoKL0ludlNjYWxlRmFjdG9yIDEuMCBkZWYKL3NldF9zY2FsZSB7CiAgICAgICBkdXAgMSBleGNoIGRpdiAvSW52U2NhbGVGYWN0b3IgZXhjaCBkZWYKICAgICAgIHNjYWxlCn0gYmluZCBkZWYKCiUgc3R5bGVzCi9zb2xpZCB7IFtdIDAgc2V0ZGFzaCB9IGJpbmQgZGVmCi9kYXNoZWQgeyBbOSBJbnZTY2FsZUZhY3RvciBtdWwgZHVwIF0gMCBzZXRkYXNoIH0gYmluZCBkZWYKL2RvdHRlZCB7IFsxIEludlNjYWxlRmFjdG9yIG11bCA2IEludlNjYWxlRmFjdG9yIG11bF0gMCBzZXRkYXNoIH0gYmluZCBkZWYKL2ludmlzIHsvZmlsbCB7bmV3cGF0aH0gZGVmIC9zdHJva2Uge25ld3BhdGh9IGRlZiAvc2hvdyB7cG9wIG5ld3BhdGh9IGRlZn0gYmluZCBkZWYKL2JvbGQgeyAyIHNldGxpbmV3aWR0aCB9IGJpbmQgZGVmCi9maWxsZWQgeyB9IGJpbmQgZGVmCi91bmZpbGxlZCB7IH0gYmluZCBkZWYKL3JvdW5kZWQgeyB9IGJpbmQgZGVmCi9kaWFnb25hbHMgeyB9IGJpbmQgZGVmCi90YXBlcmVkIHsgfSBiaW5kIGRlZgoKJSBob29rcyBmb3Igc2V0dGluZyBjb2xvciAKL25vZGVjb2xvciB7IHNldGhzYmNvbG9yIH0gYmluZCBkZWYKL2VkZ2Vjb2xvciB7IHNldGhzYmNvbG9yIH0gYmluZCBkZWYKL2dyYXBoY29sb3IgeyBzZXRoc2Jjb2xvciB9IGJpbmQgZGVmCi9ub3Bjb2xvciB7cG9wIHBvcCBwb3B9IGJpbmQgZGVmCgovYmVnaW5wYWdlIHsJJSBpIGogbnBhZ2VzCgkvbnBhZ2VzIGV4Y2ggZGVmCgkvaiBleGNoIGRlZgoJL2kgZXhjaCBkZWYKCS9zdHIgMTAgc3RyaW5nIGRlZgoJbnBhZ2VzIDEgZ3QgewoJCWdzYXZlCgkJCWNvb3JkZm9udCBzZXRmb250CgkJCTAgMCBtb3ZldG8KCQkJKFwoKSBzaG93IGkgc3RyIGN2cyBzaG93ICgsKSBzaG93IGogc3RyIGN2cyBzaG93IChcKSkgc2hvdwoJCWdyZXN0b3JlCgl9IGlmCn0gYmluZCBkZWYKCi9zZXRfZm9udCB7CglmaW5kZm9udCBleGNoCglzY2FsZWZvbnQgc2V0Zm9udAp9IGRlZgoKJSBkcmF3IHRleHQgZml0dGVkIHRvIGl0cyBleHBlY3RlZCB3aWR0aAovYWxpZ25lZHRleHQgewkJCSUgd2lkdGggdGV4dAoJL3RleHQgZXhjaCBkZWYKCS93aWR0aCBleGNoIGRlZgoJZ3NhdmUKCQl3aWR0aCAwIGd0IHsKCQkJW10gMCBzZXRkYXNoCgkJCXRleHQgc3RyaW5nd2lkdGggcG9wIHdpZHRoIGV4Y2ggc3ViIHRleHQgbGVuZ3RoIGRpdiAwIHRleHQgYXNob3cKCQl9IGlmCglncmVzdG9yZQp9IGRlZgoKL2JveHByaW0gewkJCQklIHhjb3JuZXIgeWNvcm5lciB4c2l6ZSB5c2l6ZQoJCTQgMiByb2xsCgkJbW92ZXRvCgkJMiBjb3B5CgkJZXhjaCAwIHJsaW5ldG8KCQkwIGV4Y2ggcmxpbmV0bwoJCXBvcCBuZWcgMCBybGluZXRvCgkJY2xvc2VwYXRoCn0gYmluZCBkZWYKCi9lbGxpcHNlX3BhdGggewoJL3J5IGV4Y2ggZGVmCgkvcnggZXhjaCBkZWYKCS95IGV4Y2ggZGVmCgkveCBleGNoIGRlZgoJbWF0cml4IGN1cnJlbnRtYXRyaXgKCW5ld3BhdGgKCXggeSB0cmFuc2xhdGUKCXJ4IHJ5IHNjYWxlCgkwIDAgMSAwIDM2MCBhcmMKCXNldG1hdHJpeAp9IGJpbmQgZGVmCgovZW5kcGFnZSB7IHNob3dwYWdlIH0gYmluZCBkZWYKL3Nob3dwYWdlIHsgfSBkZWYKCi9sYXllcmNvbG9yc2VxCglbCSUgbGF5ZXIgY29sb3Igc2VxdWVuY2UgLSBkYXJrZXN0IHRvIGxpZ2h0ZXN0CgkJWzAgMCAwXQoJCVsuMiAuOCAuOF0KCQlbLjQgLjggLjhdCgkJWy42IC44IC44XQoJCVsuOCAuOCAuOF0KCV0KZGVmCgovbGF5ZXJsZW4gbGF5ZXJjb2xvcnNlcSBsZW5ndGggZGVmCgovc2V0bGF5ZXIgey9tYXhsYXllciBleGNoIGRlZiAvY3VybGF5ZXIgZXhjaCBkZWYKCWxheWVyY29sb3JzZXEgY3VybGF5ZXIgMSBzdWIgbGF5ZXJsZW4gbW9kIGdldAoJYWxvYWQgcG9wIHNldGhzYmNvbG9yCgkvbm9kZWNvbG9yIHtub3Bjb2xvcn0gZGVmCgkvZWRnZWNvbG9yIHtub3Bjb2xvcn0gZGVmCgkvZ3JhcGhjb2xvciB7bm9wY29sb3J9IGRlZgp9IGJpbmQgZGVmCgovb25sYXllciB7IGN1cmxheWVyIG5lIHtpbnZpc30gaWYgfSBkZWYKCi9vbmxheWVycyB7CgkvbXl1cHBlciBleGNoIGRlZgoJL215bG93ZXIgZXhjaCBkZWYKCWN1cmxheWVyIG15bG93ZXIgbHQKCWN1cmxheWVyIG15dXBwZXIgZ3QKCW9yCgl7aW52aXN9IGlmCn0gZGVmCgovY3VybGF5ZXIgMCBkZWYKCiUlRW5kUmVzb3VyY2UKJSVFbmRQcm9sb2cKJSVCZWdpblNldHVwCjE0IGRlZmF1bHQtZm9udC1mYW1pbHkgc2V0X2ZvbnQKJSAvYXJyb3dsZW5ndGggMTAgZGVmCiUgL2Fycm93d2lkdGggNSBkZWYKCiUgbWFrZSBzdXJlIHBkZm1hcmsgaXMgaGFybWxlc3MgZm9yIFBTLWludGVycHJldGVycyBvdGhlciB0aGFuIERpc3RpbGxlcgovcGRmbWFyayB3aGVyZSB7cG9wfSB7dXNlcmRpY3QgL3BkZm1hcmsgL2NsZWFydG9tYXJrIGxvYWQgcHV0fSBpZmVsc2UKJSBtYWtlICc8PCcgYW5kICc+Picgc2FmZSBvbiBQUyBMZXZlbCAxIGRldmljZXMKL2xhbmd1YWdlbGV2ZWwgd2hlcmUge3BvcCBsYW5ndWFnZWxldmVsfXsxfSBpZmVsc2UKMiBsdCB7CiAgICB1c2VyZGljdCAoPDwpIGN2biAoWykgY3ZuIGxvYWQgcHV0CiAgICB1c2VyZGljdCAoPj4pIGN2biAoWykgY3ZuIGxvYWQgcHV0Cn0gaWYKCiUlRW5kU2V0dXAAc3VwAGdyb3VwAGN1cAB0aGluc3AAZW5zcABlbXNwAG5ic3AAcGVycAB3ZWllcnAAZ2VuZXJhdGUtY29uc3RyYWludHMuY3BwAGNzb2x2ZV9WUFNDLmNwcAB/dG9wAHByb3AAYWd4YnBvcABlc3RhY2tfcG9wAG5vcABhc3ltcABjb21wAGZpbmRDQ29tcABibXAAc2NhbGVfY2xhbXAAbXA6bXAAeGxwAGxwICE9IGNscAB0YWlsX2xwAGhlYWRfbHAAdGFpbHRvb2x0aXAAbGFiZWx0b29sdGlwAGVkZ2V0b29sdGlwAGhlYWR0b29sdGlwAGhlbGxpcAB0YWlsY2xpcABoZWFkY2xpcAAvc3ZnL3BhcGF5YXdoaXAAaHAAdHJhbnNwb3NlX3N0ZXAAbGF5ZXJsaXN0c2VwAGxheWVyc2VwAGlwc2VwAHJhbmtzZXAAbm9kZXNlcABzdWJncmFwaHMgbmVzdGVkIG1vcmUgdGhhbiAlZCBkZWVwAFNlcABzZmRwAGNwAHdlYnAAY2x1c3Rlcl9tYXAAY21hcHg6bWFwAGVwczptYXAAY21hcHhfbnA6bWFwAGltYXBfbnA6bWFwAGlzbWFwOm1hcABpbWFwOm1hcABjbWFwOm1hcABzdmc6bWFwAGpwZzptYXAAcG5nOm1hcABqcGVnOm1hcABnaWY6bWFwAGpwZTptYXAAb3ZlcmxhcABPdmVybGFwAGxldmVsc2dhcABjYXAAS1BfVXAAJUk6JU06JVMgJXAAc3RhcnQgPD0gcAByc3F1bwBsc3F1bwByZHF1bwBsZHF1bwBiZHF1bwBzYnF1bwByc2FxdW8AbHNhcXVvAHJhcXVvAGxhcXVvAGF1dG8ATnVuaXRvAC9zdmcvdG9tYXRvAG5lYXRvAGV1cm8AL3N2Zy9nYWluc2Jvcm8ATWV0aG9kWmVybwBtaWNybwBuaW1idXNtb25vAGxpYmVyYXRpb25tb25vAGZyZWVtb25vAGFyaW1vAHJhdGlvAHBvcnRobwByaG8AUmhvAC9zdmcvaW5kaWdvAHBpbmZvAGNjZ3JhcGhpbmZvAGNjZ25vZGVpbmZvAGNsX2VkZ2VfaW5mbwBnZXRQYWNrSW5mbwBtYWtlSW5mbwBwYXJzZVBhY2tNb2RlSW5mbwBjaXJjbwBpY28AJTAzbwAvc3ZnL3Jvc3licm93bgAvc3ZnL3NhbmR5YnJvd24AdmVyeWRhcmticm93bgAvc3ZnL3NhZGRsZWJyb3duAC9zdmcvYnJvd24AS1BfRG93bgBjYW5ub3QgY2hhbmdlIHNldHRpbmcgb25jZSBwYXJzaW5nIGhhcyBiZWd1bgBTdW4ASnVuAHRob3JuAC9zdmcvY3JpbXNvbgB4ZG90X2pzb24AeGRvdF9qc29uOmpzb24AanNvbjA6anNvbgBvbWljcm9uAE9taWNyb24Ac2Nhcm9uAFNjYXJvbgB3ZWJtYXJvb24AeDExbWFyb29uAC9zdmcvbWFyb29uAC9zdmcvbGlnaHRzYWxtb24AL3N2Zy9kYXJrc2FsbW9uAC9zdmcvc2FsbW9uAHVwc2lsb24AZXBzaWxvbgBVcHNpbG9uAEVwc2lsb24AcmVzb2x1dGlvbgBkaXN0b3J0aW9uAHN0ZDo6ZXhjZXB0aW9uAGRvdF9wb3NpdGlvbgBTZXR0aW5nIHVwIHN0cmVzcyBmdW5jdGlvbgB1bmNsb3NlZCBDREFUQSBzZWN0aW9uAHBvc3RhY3Rpb24Acm90YXRpb24Ab3JpZW50YXRpb24AYWJvbWluYXRpb24AYWNjb3VudGluZ0dldEN1cnJlbnRBbXBsaWZpY2F0aW9uAHhkb3R2ZXJzaW9uAFNUc2V0VW5pb24AZ3ZyZW5kZXJfcG9seWdvbgB0a2dlbl9wb2x5Z29uADxwb2x5Z29uAGhleGFnb24Ac2VwdGFnb24AcGVudGFnb24AdHJpcGxlb2N0YWdvbgBkb3VibGVvY3RhZ29uAC9zdmcvbGVtb25jaGlmZm9uAE1vbgBwbHVzbW4Abm90aW4AaXNpbgAvc3ZnL21vY2Nhc2luAHBpbgBtaW4Adm9yb19tYXJnaW4AaW5maW4Ab25lZF9vcHRpbWl6ZXJfdHJhaW4AcGxhaW4AbWFrZV9jaGFpbgBtZXJnZV9jaGFpbgB2YWxpZ24AYmFsaWduAHllbgBNdWx0aWxldmVsX2NvYXJzZW4AY3VycmVuAFBvYnNvcGVuAGd2dXNlcnNoYXBlX29wZW4AZW50aXR5VHJhY2tpbmdPbk9wZW4AL3N2Zy9saW5lbgBkaW1lbgBtaW5sZW4Ac3R5bGVfdG9rZW4AdW5jbG9zZWQgdG9rZW4AL3N2Zy95ZWxsb3dncmVlbgBtZWRpdW1mb3Jlc3RncmVlbgAvc3ZnL2ZvcmVzdGdyZWVuAC9zdmcvbGlnaHRncmVlbgBodW50ZXJzZ3JlZW4AL3N2Zy9sYXduZ3JlZW4AL3N2Zy9kYXJrZ3JlZW4AL3N2Zy9tZWRpdW1zcHJpbmdncmVlbgAvc3ZnL3NwcmluZ2dyZWVuAC9zdmcvZGFya29saXZlZ3JlZW4AL3N2Zy9saW1lZ3JlZW4AL3N2Zy9wYWxlZ3JlZW4Ad2ViZ3JlZW4AL3N2Zy9saWdodHNlYWdyZWVuAC9zdmcvbWVkaXVtc2VhZ3JlZW4AL3N2Zy9kYXJrc2VhZ3JlZW4AL3N2Zy9zZWFncmVlbgB4MTFncmVlbgAvc3ZnL2dyZWVuAEdyZWVuAC9zdmcvbGlnaHRjeWFuAC9zdmcvZGFya2N5YW4AL3N2Zy9jeWFuAG5ld3RhbgBkYXJrdGFuAC9zdmcvdGFuAHJvd3NwYW4AY29sc3BhbgBuYW4AdGltZXNuZXdyb21hbgBuaW1idXNyb21hbgB0aW1lc3JvbWFuAFRpbWVzLVJvbWFuAFBhbGF0aW5vLVJvbWFuAE5ld0NlbnR1cnlTY2hsYmstUm9tYW4ASmFuAEdEX3JhbmsoZylbcl0ubiA8PSBHRF9yYW5rKGcpW3JdLmFuAGFneGJwdXRfbgBcbgBuX25vZGVzID09IGdyYXBoLT5uAEEtPm0gPT0gQS0+bgBqb2ItPm9iai0+dS5uAHMsJWxmLCVsZiVuACBlLCVsZiwlbGYlbgAlZCAlMVsiXSVuAHYgPT0gbgBuemMgPT0gbgBiID09IG4AbmNsdXN0ZXIgPD0gbgByICYmIG4AcHN5bQBhbGVmc3ltAHRoZXRhc3ltAHF1YW50dW0Ac3VtAC9zdmcvcGx1bQBpbnZ0cmFwZXppdW0AbWVkaXVtADk6cHJpc20AbHJtAGN1c3RvbQBhcHRyLT50YWcgPT0gVF9hdG9tAC9kZXYvdXJhbmRvbQBtbQBybG0Ac2ltAElNRFNfZ2l2ZW5fZGltAG9yZG0AY20AcGFyYWxsZWxvZ3JhbQAvc3ZnL21pbnRjcmVhbQBKdWwAdGwAZnJhc2wAU3ltYm9sADw/eG1sAHl1bWwAdXVtbABvdW1sAGl1bWwAZXVtbABhdW1sAFl1bWwAVXVtbABPdW1sAEl1bWwARXVtbABBdW1sAGNvcmVfbG9hZGltYWdlX3ZybWwAanBnOnZybWwAcG5nOnZybWwAanBlZzp2cm1sAGdpZjp2cm1sAGpwZTp2cm1sAGJ1bGwAZmlsbABydHAtPnNwbGl0LlBhcnRpdGlvbnNbMF0uY291bnRbMF0gPj0gcnRwLT5NaW5GaWxsICYmIHJ0cC0+c3BsaXQuUGFydGl0aW9uc1swXS5jb3VudFsxXSA+PSBydHAtPk1pbkZpbGwAL3N2Zy9zZWFzaGVsbABmb3JhbGwAQXByaWwAcGVybWlsAHJjZWlsAGxjZWlsAGNjZWRpbABDY2VkaWwAYXJyb3d0YWlsAGx0YWlsAHNhbWV0YWlsAGxldmVsID49IDAgJiYgbGV2ZWwgPD0gbi0+bGV2ZWwAbGV2ZWwgPj0gMCAmJiBsZXZlbCA8PSAoKm4pLT5sZXZlbABpc19wYXJhbGxlbABDYWxjdWxhdGluZyBjaXJjdWl0IG1vZGVsAENhbGN1bGF0aW5nIHN1YnNldCBtb2RlbABDYWxjdWxhdGluZyBNRFMgbW9kZWwAeGxhYmVsAHRhaWxsYWJlbABoZWFkbGFiZWwAbWFrZV9sYWJlbABncmFwaCBsYWJlbABpZXhjbABvYmpwLT5sYmwAb3ZhbABtZXJnZXZpcnR1YWwAL3N2Zy9saWdodGNvcmFsAC9zdmcvY29yYWwAU3BhcnNlTWF0cml4X2Zyb21fY29vcmRpbmF0ZV9hcnJheXNfaW50ZXJuYWwATXVsdGlsZXZlbF9jb2Fyc2VuX2ludGVybmFsAFF1YWRUcmVlX2FkZF9pbnRlcm5hbABhcnJvd19sZW5ndGhfbm9ybWFsAGFyaWFsAHJhZGlhbAAvc3ZnL3RlYWwAcmVhbABsb2NhbABlc3RpbWF0ZV9jaGFyYWN0ZXJfd2lkdGhfY2Fub25pY2FsAGdsb2JhbABxLT5sAC4uLy4uL2xpYi9jZ3JhcGgvc2Nhbi5sAHRrOnRrAGdpZjp0awBwYXRjaHdvcmsAdG9rAGJvb2sAQXZhbnRHYXJkZS1Cb29rAHNpbmsAb3ZlcmxhcF9zaHJpbmsAc3BpY3lwaW5rAC9zdmcvaG90cGluawAvc3ZnL2xpZ2h0cGluawAvc3ZnL2RlZXBwaW5rAG5lb25waW5rAC9zdmcvcGluawBuZXdyYW5rAGNsdXN0ZXJyYW5rAF9uZXdfcmFuawBpbnN0YWxsX2luX3JhbmsAcmVtb3ZlX2Zyb21fcmFuawAvc3ZnL2Nvcm5zaWxrAG9uZWJsb2NrAHYtPmxlZnQtPmJsb2NrID09IHYtPnJpZ2h0LT5ibG9jawAvc3ZnL2ZpcmVicmljawBQUWNoZWNrAHBhY2sAL3N2Zy9ibGFjawBCbGFjawBiYWNrAHp3agB6d25qAGpvYi0+b2JqAGdldGludHJzeGkAcHNpAFBzaQBDYWxpYnJpAEZyaQB0d29waQBkcGkAdm9yb25vaQBWb3Jvbm9pAGNoYW5pAGRlbWkAQm9va21hbi1EZW1pAEF2YW50R2FyZGUtRGVtaQAvc3ZnL2RhcmtraGFraQAvc3ZnL2toYWtpAHBoaQBjaGkAUGhpAENoaQBkaQBYaQBQaQBORF9pZChucCkgPT0gaQBTdHJlc3NNYWpvcml6YXRpb25TbW9vdGhlcl9zbW9vdGgAU3ByaW5nU21vb3RoZXJfc21vb3RoAGJvdGgAc3RhcnRzd2l0aABsaW5lbGVuZ3RoAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGF2ZXJhZ2VfZWRnZV9sZW5ndGgAZXRoAHBlbndpZHRoAGx3aWR0aABzZXRsaW5ld2lkdGgAUHNob3J0ZXN0cGF0aABzaG9ydHBhdGgAZm9udHBhdGgAUG9ic3BhdGgAYmVnaW5wYXRoAGltYWdlcGF0aABlbmRwYXRoAHN0cmFpZ2h0X3BhdGgAbWFwX3BhdGgAPHBhdGgAY2Fubm90IGZpbmQgdHJpYW5nbGUgcGF0aAAvc3ZnL2xhdmVuZGVyYmx1c2gAZmxlc2gAb3NsYXNoAE9zbGFzaABkdHN0cmhhc2gAbmRhc2gAbWRhc2gAZGlncmFwaABzdWJncmFwaABjb25zdHJ1Y3RfZ3JhcGgAY2hrU2dyYXBoAGNsb3Nlc3RfcGFpcnMyZ3JhcGgAYWdkZWxldGUgb24gd3JvbmcgZ3JhcGgAY29ubmVjdEdyYXBoAHVwc2loACVzbGluZS10aHJvdWdoAGZsYXRfc2VhcmNoAGNoYW5TZWFyY2gAUlRyZWVTZWFyY2gATWFyY2gARGlzY29uQnJhbmNoAFBpY2tCcmFuY2gAQWRkQnJhbmNoAC4uLy4uL2xpYi9jZ3JhcGgvYml0YXJyYXkuaAAuLi8uLi9saWIvY2dyYXBoL3N0cnZpZXcuaAAuLi8uLi9saWIvY2lyY29nZW4vbm9kZWxpc3QuaAAuLi8uLi9saWIvY2dyYXBoL3NvcnQuaAAuLi8uLi9saWIvY29tbW9uL2JveGVzLmgALi4vLi4vbGliL2NncmFwaC9jbGFtcC5oAC4uLy4uL2xpYi9jZ3JhcGgvc3RhY2suaAAuLi8uLi9saWIvY2dyYXBoL3N0YXJ0c3dpdGguaAAuLi8uLi9saWIvY2dyYXBoL2FneGJ1Zi5oAC4uLy4uL2xpYi9jZ3JhcGgvdG9rZW5pemUuaAAuLi8uLi9saWIvY2dyYXBoL2FsbG9jLmgAYXV4ZwByb3dnAGNvcmVfbG9hZGltYWdlX3N2ZwBzdmc6c3ZnAGpwZzpzdmcAcG5nOnN2ZwBqcGVnOnN2ZwBnaWY6c3ZnAGpwZTpzdmcAQXVnAGRvUHJvbG9nAHBuZwBpZGVhbF9kaXN0X3NjaGVtZSB2YWx1ZSB3cm9uZwB4ZG90IHZlcnNpb24gIiVzIiB0b28gbG9uZwBjb25nAGxibGVuY2xvc2luZwBiYXNpY19zdHJpbmcAZmFpbHVyZSBtYWxsb2MnaW5nIGZvciByZXN1bHQgc3RyaW5nAHNwcmluZwBvcmRlcmluZwBhcmluZwBBcmluZwBEYW1waW5nAFdhcm5pbmcAb3ZlcmxhcF9zY2FsaW5nAHggYW5kIHkgc2NhbGluZwBvbGQgc2NhbGluZwBzbW9vdGhpbmcAdW5rbm93biBlbmNvZGluZwBzcHJpbmdfZWxlY3RyaWNhbF9lbWJlZGRpbmcAc3ByaW5nX2VsZWN0cmljYWxfc3ByaW5nX2VtYmVkZGluZwBjZWxscGFkZGluZwBjZWxsc3BhY2luZwByYW5nAGxhbmcAZml2ZXBvdmVyaGFuZwB0aHJlZXBvdmVyaGFuZwBub3ZlcmhhbmcAZW1pdF9odG1sX2ltZwBjb2xnAG9yaWcAc3psaWcAb2VsaWcAYWVsaWcAT0VsaWcAQUVsaWcAY29yZV9sb2FkaW1hZ2VfZmlnAGpwZzpmaWcAcG5nOmZpZwBmaWc6ZmlnAGpwZWc6ZmlnAGdpZjpmaWcAanBlOmZpZwBlZ2cAbmV4dF9zZWcAcmVnAGpwZWcAaSA9PSBkZWcAZGcAY2cAY2xvc2VzdWJnAG1pc21hdGNoZWQgdGFnAGJlei0+c2ZsYWcAYmV6LT5lZmxhZwAhZmxhZwA8ZwAlLjVnLCUuNWcsJS41ZywlLjVnACUuNWcgJS41ZwAlZyAlZwBib3hJbnRlcnNlY3RmAGVwc2YAYWdlZGdlc2VxY21wZgBjY3dyb3RhdGVwZgBmbm9mAGluZgBzZWxmAGhhbGYAJWxmJWxmJWxmJWxmACVsZiwlbGYsJWxmLCVsZiwlbGYAJWxmICVsZiAlbGYgJWxmAGxpYmVyYXRpb25zZXJpZgBmcmVlc2VyaWYAc2Fucy1TZXJpZgBnaWYAL3N2Zy9wZWFjaHB1ZmYAcmlmZgBhY2NvdW50aW5nUmVwb3J0RGlmZgB0YWlsaHJlZgBsYWJlbGhyZWYAZWRnZWhyZWYAaGVhZGhyZWYAb3JkZgBwZGYAc2lnbWFmAFxmACUuMExmACVMZgB1cy0+ZgAlLjAzZgAlcyB0cmFuc21pdCAlLjNmAHJnYjwlOS4zZiwgJTkuM2YsICU5LjNmPiB0cmFuc21pdCAlLjNmACUuMDJmACUuMmYAJWYsJWYAIiBmaWxsLW9wYWNpdHk9IiVmACIgc3Ryb2tlLW9wYWNpdHk9IiVmAApmaW5hbCBlID0gJWYAYnJvbnplAGFycm93c2l6ZQBsYWJlbGZvbnRzaXplAHNlYXJjaHNpemUAbm9kZWxpc3RfcmVzaXplAGZpeGVkc2l6ZQBub2RlbGlzdF9zaXplAHNhbWVfbGlzdF9zaXplAHRleHRzcGFuX3NpemUAYnouc2l6ZQBwb2ludC1zaXplAG5vcm1hbGl6ZQBndnJlbmRlcl9iZXppZXJjdXJ2ZQBpY3VydmUAbm9kZWxpc3RfcmVtb3ZlACF2LT5hY3RpdmUALWFjdGl2ZQBmb250X2luX2xpc3RfcGVybWlzc2l2ZQAvc3ZnL29saXZlAHVncmF2ZQBvZ3JhdmUAaWdyYXZlAGVncmF2ZQBhZ3JhdmUAVWdyYXZlAE9ncmF2ZQBJZ3JhdmUARWdyYXZlAEFncmF2ZQB0cnVlAC9zdmcvYmlzcXVlAG9ibGlxdWUAQXZhbnRHYXJkZS1Cb29rT2JsaXF1ZQBBdmFudEdhcmRlLURlbWlPYmxpcXVlAEhlbHZldGljYS1OYXJyb3ctQm9sZE9ibGlxdWUAQ291cmllci1Cb2xkT2JsaXF1ZQBIZWx2ZXRpY2EtQm9sZE9ibGlxdWUASGVsdmV0aWNhLU5hcnJvdy1PYmxpcXVlAENvdXJpZXItT2JsaXF1ZQBIZWx2ZXRpY2EtT2JsaXF1ZQBuYXZ5Ymx1ZQAvc3ZnL2xpZ2h0c2t5Ymx1ZQAvc3ZnL2RlZXBza3libHVlAC9zdmcvc2t5Ymx1ZQBuZXdtaWRuaWdodGJsdWUAL3N2Zy9taWRuaWdodGJsdWUAL3N2Zy9saWdodGJsdWUAL3N2Zy9jYWRldGJsdWUAL3N2Zy9jb3JuZmxvd2VyYmx1ZQAvc3ZnL2RvZGdlcmJsdWUAL3N2Zy9wb3dkZXJibHVlAG5lb25ibHVlAC9zdmcvbWVkaXVtYmx1ZQAvc3ZnL2xpZ2h0c3RlZWxibHVlAC9zdmcvc3RlZWxibHVlAC9zdmcvcm95YWxibHVlAC9zdmcvZGFya2JsdWUAcmljaGJsdWUAbGlnaHRzbGF0ZWJsdWUAL3N2Zy9tZWRpdW1zbGF0ZWJsdWUAL3N2Zy9kYXJrc2xhdGVibHVlAC9zdmcvc2xhdGVibHVlAC9zdmcvYWxpY2VibHVlAC9zdmcvYmx1ZQBCbHVlAG5lYXRvX2VucXVldWUAVHVlAGNvbnZlcnRTUHRvUm91dGUAeWFjdXRlAHVhY3V0ZQBvYWN1dGUAaWFjdXRlAGVhY3V0ZQBhYWN1dGUAWWFjdXRlAFVhY3V0ZQBPYWN1dGUASWFjdXRlAEVhY3V0ZQBBYWN1dGUAcmVmZXJlbmNlIHRvIGV4dGVybmFsIGVudGl0eSBpbiBhdHRyaWJ1dGUAZHVwbGljYXRlIGF0dHJpYnV0ZQBub3RlAHByaW1lcnNpdGUAcmlib3NpdGUAcmVzdHJpY3Rpb25zaXRlAHByb3RlYXNlc2l0ZQAvc3ZnL2dob3N0d2hpdGUAL3N2Zy9uYXZham93aGl0ZQAvc3ZnL2Zsb3JhbHdoaXRlAC9zdmcvYW50aXF1ZXdoaXRlAC9zdmcvd2hpdGUAV2hpdGUAcG9wX29ial9zdGF0ZQBwY3Bfcm90YXRlAGNvbmNlbnRyYXRlAGRlY29yYXRlAFF1YWRUcmVlX3JlcHVsc2l2ZV9mb3JjZV9hY2N1bXVsYXRlAG5vdHJhbnNsYXRlAC9zdmcvY2hvY29sYXRlAGdlb21VcGRhdGUAaW52aG91c2UAL3N2Zy9jaGFydHJldXNlADxlbGxpcHNlAGR1c3R5cm9zZQAvc3ZnL21pc3R5cm9zZQBTcGFyc2VNYXRyaXhfdHJhbnNwb3NlAGFnY2xvc2UAZW50aXR5VHJhY2tpbmdPbkNsb3NlAGZhbHNlAC9zdmcvbWVkaXVtdHVycXVvaXNlAC9zdmcvZGFya3R1cnF1b2lzZQAvc3ZnL3BhbGV0dXJxdW9pc2UAL3N2Zy90dXJxdW9pc2UAcGhhc2UAL3N2Zy9henVyZQBzaWduYXR1cmUAbWVtb3J5IHJlLWFsbG9jYXRpb24gZmFpbHVyZQBtZW1vcnkgYWxsb2NhdGlvbiBmYWlsdXJlAG11bHRpbGV2ZWxfc3ByaW5nX2VsZWN0cmljYWxfZW1iZWRkaW5nX2NvcmUATXNxdWFyZQBQYWxhdGlubyBMaW5vdHlwZQBBLT50eXBlID09IEItPnR5cGUAc3VwZQBndnJlbmRlcl91c2Vyc2hhcGUAcHNnZW5fbGlicmFyeV9zaGFwZQBtaXRlcl9zaGFwZQBsYW5kc2NhcGUATGFuZHNjYXBlAEp1bmUAbm9uZQBkb2N1bWVudCBpcyBub3Qgc3RhbmRhbG9uZQBjb3VzaW5lAC9zdmcvbWVkaXVtYXF1YW1hcmluZQAvc3ZnL2FxdWFtYXJpbmUAZ3ZyZW5kZXJfcG9seWxpbmUAdGtnZW5fcG9seWxpbmUAPHBvbHlsaW5lACVzb3ZlcmxpbmUAdW5kZXJsaW5lAGxpbmVhcl9zcGxpbmUAYl9zcGxpbmUAb2xpbmUAYWd4YnVmX2lzX2lubGluZQByZWZpbmUAcHJpbWUAUHJpbWUAL3N2Zy9saW1lAGNvbG9yc2NoZW1lAGxhYmVsX3NjaGVtZQBzYW1lAGxhYmVsZm9udG5hbWUAVUZfc2V0bmFtZQBmb250X25hbWUAZm9udC0+bmFtZQB1cy0+bmFtZQByZXNlcnZlZCBwcmVmaXggKHhtbCkgbXVzdCBub3QgYmUgdW5kZWNsYXJlZCBvciBib3VuZCB0byBhbm90aGVyIG5hbWVzcGFjZSBuYW1lAHN0eWxlAC9zdmcvdGhpc3RsZQB0aXRsZQAvc3ZnL21lZGl1bXB1cnBsZQBkYXJrcHVycGxlAHdlYnB1cnBsZQByZWJlY2NhcHVycGxlAHZlcnlfbGlnaHRfcHVycGxlAG1lZF9wdXJwbGUAeDExcHVycGxlAC9zdmcvcHVycGxlAHNoYXBlZmlsZQBncmFkaWVudGFuZ2xlAHJlY3RhbmdsZQBSZWN0YW5nbGUAbGFiZWxhbmdsZQBpbnZ0cmlhbmdsZQBkZXN0aW5hdGlvbiBwb2ludCBub3QgaW4gYW55IHRyaWFuZ2xlAHNvdXJjZSBwb2ludCBub3QgaW4gYW55IHRyaWFuZ2xlAGRmc0N5Y2xlAGRvdWJsZWNpcmNsZQBNY2lyY2xlAGludmlzaWJsZQB0aG9ybmRhbGUAaW5wdXRzY2FsZQBvc2NhbGUAaW1hZ2VzY2FsZQAvc3ZnL3doaXRlc21va2UAbWFuZGFyaW5vcmFuZ2UAL3N2Zy9kYXJrb3JhbmdlAC9zdmcvb3JhbmdlAC9zdmcvYmVpZ2UAbmV3ZWRnZQBkZWxldGVfZmFzdF9lZGdlAGRlbGV0ZV9mbGF0X2VkZ2UAbWFrZV9yZWd1bGFyX2VkZ2UAZW1pdF9iZWdpbl9lZGdlAGFkZF90cmVlX2VkZ2UAZW1pdF9lbmRfZWRnZQBtYWtlU3RyYWlnaHRFZGdlAG1ha2VTZWxmRWRnZQBtYWtlQ29tcG91bmRFZGdlAG9zYWdlAHBhZ2UAZ3Zsb2FkaW1hZ2UAdmVlAHRlZQBRVUFEX1RSRUVfSFlCUklELCBzaXplIGxhcmdlciB0aGFuICVkLCBzd2l0Y2ggdG8gZmFzdCBxdWFkdHJlZQBmZWFzaWJsZV90cmVlAFNwYXJzZU1hdHJpeF9kaXZpZGVfcm93X2J5X2RlZ3JlZQBvYmpsaXN0X2ZyZWUAc2FtZV9saXN0X2ZyZWUAcG9pbnRzX2ZyZWUAYm94ZXNfZnJlZQBndl9zdGFja19mcmVlAG5ld25vZGUAaW5zdGFsbG5vZGUAYWdub2RlAGRlbGV0ZV9mYXN0X25vZGUAcGFja21vZGUAU3BsaXROb2RlAG90aWxkZQBudGlsZGUAYXRpbGRlAE90aWxkZQBOdGlsZGUAQXRpbGRlAGRpdmlkZQB0cmFkZQBzb3VyY2UAcmVwdWxzaXZlZm9yY2UAaWxsZWdhbCBwYXJhbWV0ZXIgZW50aXR5IHJlZmVyZW5jZQBlcnJvciBpbiBwcm9jZXNzaW5nIGV4dGVybmFsIGVudGl0eSByZWZlcmVuY2UAcmVjdXJzaXZlIGVudGl0eSByZWZlcmVuY2UAbGFiZWxkaXN0YW5jZQBUQmJhbGFuY2UAZGV2aWNlAG1vbm9zcGFjZQAvc3ZnL29sZGxhY2UAZmFjZQBzdWJlACAtYW5jaG9yIGUAczEtPmNvbW1fY29vcmQ9PXMyLT5jb21tX2Nvb3JkAE1yZWNvcmQAZm9yd2FyZABwcm9kAGxpZ2h0Z29sZGVucm9kAG1lZGl1bWdvbGRlbnJvZAAvc3ZnL2Rhcmtnb2xkZW5yb2QAL3N2Zy9wYWxlZ29sZGVucm9kAC9zdmcvZ29sZGVucm9kAC9zdmcvYnVybHl3b29kAGxpZ2h0d29vZABtZWRpdW13b29kAGRhcmt3b29kAF9iYWNrZ3JvdW5kAGNvbXBvdW5kAG5vIGVsZW1lbnQgZm91bmQAZmF0YWwgZmxleCBzY2FubmVyIGludGVybmFsIGVycm9yLS1ubyBhY3Rpb24gZm91bmQAL3N2Zy9ibGFuY2hlZGFsbW9uZABhcnJvd19sZW5ndGhfZGlhbW9uZABNZGlhbW9uZABndnVzZXJzaGFwZV9maW5kAG9iamxpc3RfdHJ5X2FwcGVuZABkZWdsaXN0X3RyeV9hcHBlbmQAbm9kZWxpc3RfdHJ5X2FwcGVuZABjbGlzdF90cnlfYXBwZW5kAHNhbWVfbGlzdF90cnlfYXBwZW5kAGVkZ2VfbGlzdF90cnlfYXBwZW5kAHBvaW50c190cnlfYXBwZW5kAGJveGVzX3RyeV9hcHBlbmQAbGF5ZXJfbmFtZXNfdHJ5X2FwcGVuZAB2YXJhcnJfdHJ5X2FwcGVuZABlc3RhY2tfdHJ5X2FwcGVuZABndl9zdGFja190cnlfYXBwZW5kAGludF9zdGFja190cnlfYXBwZW5kAGlyYW5kAGV4cGFuZABjdW1iZXJsYW5kAGJyaWdodGdvbGQAb2xkZ29sZAAvc3ZnL2dvbGQAYm9sZABIZWx2ZXRpY2EtTmFycm93LUJvbGQAVGltZXMtQm9sZABDb3VyaWVyLUJvbGQAUGFsYXRpbm8tQm9sZABOZXdDZW50dXJ5U2NobGJrLUJvbGQASGVsdmV0aWNhLUJvbGQAbi0+YnJhbmNoW2ldLmNoaWxkACVzJWxkAHNvbGlkAC9zdmcvbWVkaXVtb3JjaGlkAC9zdmcvZGFya29yY2hpZAAvc3ZnL29yY2hpZABpbGxlZ2FsIGNoYXJhY3RlcihzKSBpbiBwdWJsaWMgaWQAZGlqa3N0cmFfc2dkAGZpeGVkAGN1cnZlZABkZXJpdmVkAGRvdHRlZABtZW1vcnkgZXhoYXVzdGVkAHBhcnNpbmcgYWJvcnRlZABhdHRyaWJ1dGUgbWFjcm9zIG5vdCBpbXBsZW1lbnRlZABhY2NvdW50aW5nRGlmZlRvbGVyYXRlZABmYXRhbCBmbGV4IHNjYW5uZXIgaW50ZXJuYWwgZXJyb3ItLWVuZCBvZiBidWZmZXIgbWlzc2VkAGNvbmRlbnNlZAAvc3ZnL21lZGl1bXZpb2xldHJlZAAvc3ZnL3BhbGV2aW9sZXRyZWQASW1wcm9wZXIgJXMgdmFsdWUgJXMgLSBpZ25vcmVkACVzIHZhbHVlICVzIDwgJWQgLSB0b28gc21hbGwgLSBpZ25vcmVkACVzIHZhbHVlICVzID4gJWQgLSB0b28gbGFyZ2UgLSBpZ25vcmVkAC9zdmcvaW5kaWFucmVkAC9zdmcvZGFya3JlZABhIHN1Y2Nlc3NmdWwgcHJpb3IgY2FsbCB0byBmdW5jdGlvbiBYTUxfR2V0QnVmZmVyIGlzIHJlcXVpcmVkAHRhcGVyZWQAL3N2Zy9vcmFuZ2VyZWQAcmVzZXJ2ZWQgcHJlZml4ICh4bWxucykgbXVzdCBub3QgYmUgZGVjbGFyZWQgb3IgdW5kZWNsYXJlZAAvc3ZnL3JlZABzdHJpcGVkAGlsbC1jb25kaXRpb25lZAB1bmRlZmluZWQAbm90IGNvbnN0cmFpbmVkAGxhYmVsYWxpZ25lZAB0ZXh0IGRlY2xhcmF0aW9uIG5vdCB3ZWxsLWZvcm1lZABYTUwgZGVjbGFyYXRpb24gbm90IHdlbGwtZm9ybWVkAHVuZmlsbGVkAGlucHV0IGluIGZsZXggc2Nhbm5lciBmYWlsZWQAdHJpYW5ndWxhdGlvbiBmYWlsZWQAcGFyc2luZyBmaW5pc2hlZABkYXNoZWQAbGltaXQgb24gaW5wdXQgYW1wbGlmaWNhdGlvbiBmYWN0b3IgKGZyb20gRFREIGFuZCBlbnRpdGllcykgYnJlYWNoZWQAJXM6JWQ6IGNsYWltZWQgdW5yZWFjaGFibGUgY29kZSB3YXMgcmVhY2hlZAB3ZWRnZWQAc2l6ZT09ZnJlZWQAcm91bmRlZABwYXJzZXIgbm90IHN1c3BlbmRlZABwYXJzZXIgc3VzcGVuZGVkAFdlZABSZWQAU3BhcnNlTWF0cml4X2FkZABkZCAhPSBwYXJlbnRfZGQAS1BfQWRkAHBhZAB4bGhkeHVubG9hZAByZWFkAGFycm93aGVhZABsaGVhZABzYW1laGVhZABib3gzZABjYyVzXyVkAF9zcGFuXyVkAF9ibG9ja18lZABfd2Vha18lZABfY2xvbmVfJWQALiVkACVsZiwlZAAlZCwlZCwlZCwlZAAgJWQsJWQAY2MlcyslZAAlcyBpbiBsaW5lICVkACVkICVkICVkICVkICVkICVkICUuMWYgJS40ZiAlZCAlLjFmICUuMWYgJWQgJWQAJSUlJUJvdW5kaW5nQm94OiAlZCAlZCAlZCAlZAAiX3N1YmdyYXBoX2NudCI6ICVkACJfZ3ZpZCI6ICVkACJoZWFkIjogJWQAYWd4YnB1dGMAdnBzYwBjcC0+c3JjAHVjaXJjAG9jaXJjAGljaXJjAGVjaXJjAGFjaXJjAFVjaXJjAE9jaXJjAEljaXJjAEVjaXJjAEFjaXJjAHBjAGxhYmVsbG9jAGd2X3JlY2FsbG9jAHN0ZDo6YmFkX2FsbG9jAGJha2Vyc2Nob2MAc2VtaVN3ZWV0Q2hvYwBtYwBTcGFyc2VNYXRyaXhfaXNfc3ltbWV0cmljAHBpYzpwaWMAaXRhbGljAEJvb2ttYW4tTGlnaHRJdGFsaWMAWmFwZkNoYW5jZXJ5LU1lZGl1bUl0YWxpYwBCb29rbWFuLURlbWlJdGFsaWMAVGltZXMtQm9sZEl0YWxpYwBQYWxhdGluby1Cb2xkSXRhbGljAE5ld0NlbnR1cnlTY2hsYmstQm9sZEl0YWxpYwBUaW1lcy1JdGFsaWMAUGFsYXRpbm8tSXRhbGljAE5ld0NlbnR1cnlTY2hsYmstSXRhbGljAHJhZGljACNmY2ZjZmMAOiAlLjJmIHNlYwBsaXN0ZGVscmVjAGxldmVsIGdyYXBoIHJlYwBsZXZlbCBlZGdlIHJlYwBsZXZlbCBub2RlIHJlYwBEZWMAX25lYXRvX2NjAGJjAHZpc2liaWxpdHkuYwBTcGFyc2VNYXRyaXguYwBodG1sbGV4LmMAaW5kZXguYwBzbWFydF9pbmlfeC5jAGd2cmVuZGVyX2NvcmVfcG92LmMAY3Z0LmMAbGF5b3V0LmMAdGV4dHNwYW5fbHV0LmMAYWRqdXN0LmMAbm9kZWxpc3QuYwBzaG9ydGVzdC5jAGNsb3Nlc3QuYwBzYW1lcG9ydC5jAGd2cmVuZGVyX2NvcmVfZG90LmMAY29uc3RyYWludC5jAGRvdGluaXQuYwBuZWF0b2luaXQuYwBwYXRjaHdvcmtpbml0LmMAb3NhZ2Vpbml0LmMAZW1pdC5jAGFzcGVjdC5jAGZsYXQuYwBhcnJvd3MuYwBtaW5jcm9zcy5jAHBvc3RfcHJvY2Vzcy5jAGNjb21wcy5jAGd2cmVuZGVyX2NvcmVfcHMuYwBucy5jAHV0aWxzLmMAeGxhYmVscy5jAHNoYXBlcy5jAGRvdHNwbGluZXMuYwBuZWF0b3NwbGluZXMuYwBjbHVzdGVyZWRnZXMuYwBhdHRyLmMAZmFzdGdyLmMAY2x1c3Rlci5jAHRhcGVyLmMAZ3ZyZW5kZXIuYwBzcGxpdC5xLmMAY29tcC5jAGd2cmVuZGVyX2NvcmVfbXAuYwBndnJlbmRlcl9jb3JlX21hcC5jAG9ydGhvLmMAZ3ZyZW5kZXJfY29yZV9qc29uLmMAcG9zaXRpb24uYwB0ZXh0c3Bhbi5jAGdlb20uYwByb3V0ZXNwbC5jAHhtbC5jAE11bHRpbGV2ZWwuYwBnZW5lcmFsLmMAc3ByaW5nX2VsZWN0cmljYWwuYwBndnJlbmRlcl9jb3JlX3RrLmMAcmFuay5jAHBhY2suYwBibG9ja3BhdGguYwBkdHN0cmhhc2guYwByYXdncmFwaC5jAGd2cmVuZGVyX2NvcmVfc3ZnLmMAZ3ZyZW5kZXJfY29yZV9maWcuYwBzdHVmZi5jAG1hemUuYwBzcGFyc2Vfc29sdmUuYwB3cml0ZS5jAGNvbHhsYXRlLmMAeG1scGFyc2UuYwBndmxvYWRpbWFnZV9jb3JlLmMAZ3Z1c2Vyc2hhcGUuYwByZWN0YW5nbGUuYwBjaXJjbGUuYwBodG1sdGFibGUuYwBlZGdlLmMAZ3Zsb2FkaW1hZ2UuYwBibG9ja3RyZWUuYwBRdWFkVHJlZS5jAG5vZGUuYwBndmRldmljZS5jAGNvbXBvdW5kLmMAdHJhcGV6b2lkLmMAc2dkLmMAcG9zdHByb2MuYwBjb25jLmMAcmVjLmMAZGlqa3N0cmEuYwBmUFEuYwBjbGFzczIuYwAlbGYsJWxmLCVsZiwlbGYlYwAlbGYsJWxmLCVsZiwlW14sXSVjAFwlYwAkYwBuc3ViAHNldGhzYgByYgBwcm90ZWN0X3JzcWIAam9iAGNvcmVfbG9hZGltYWdlX3BzbGliAEZlYgBvZGIAaW5pdF9zcGxpbmVzX2JiAGJlemllcl9iYgBwcm90ZWluc3RhYgBybmFzdGFiAC9zdmcvb2xpdmVkcmFiAFxiAHJ3YQAvc3ZnL2FxdWEAaW90YQBJb3RhAC9zdmcvZGFya21hZ2VudGEAL3N2Zy9tYWdlbnRhAGRlbHRhAERlbHRhAHpldGEAdGhldGEAVGhldGEAYmV0YQBaZXRhAEJldGEAX0FHX3N0cmRhdGEAcHJldiAhPSBvYmotPmRhdGEAbWFrZUdyYXBoRGF0YQBFdGEAbmltYnVzc2Fuc2EAcGFyYQBrYXBwYQBLYXBwYQAvc3ZnL3NpZW5uYQBWZXJkYW5hAGdhbW1hAEdhbW1hAHNpZ21hAFNpZ21hAGNvbnNvbGEAbmFibGEAL3N2Zy9mdWNoc2lhAEdlb3JnaWEAYWxwaGEAQWxwaGEAb21lZ2EAT21lZ2EAYXJlYQBSZWN0QXJlYQBsYW1iZGEATGFtYmRhAGhlbHZldGljYQBIZWx2ZXRpY2EAbWljYQA+PGEAYABfdGRyYXdfAF90bGRyYXdfAF9obGRyYXdfAF9sZHJhd18AX2hkcmF3XwBfZHJhd18AJXNfAHBhZ2UlZCwlZF8AX2NjXwAgaWQ9ImFfAF4Abl9lZGdlcyA9PSBncmFwaC0+c291cmNlc1tncmFwaC0+bl0AamRbbWFza1tqY1trXV1dID09IGpjW2tdAGpjW21hc2tbamJba11dXSA9PSBqYltrXQBqYVttYXNrW2phW2pdXV0gPT0gamFbal0AcS0+cXRzW2lpXQAhcnRwLT5zcGxpdC5QYXJ0aXRpb25zWzBdLnRha2VuW2ldAHItPmJvdW5kYXJ5W2ldIDw9IHItPmJvdW5kYXJ5W05VTURJTVMgKyBpXQBbJS4wM2YsJS4wM2ZdAFtpbnRlcm5hbCBoYXJkLWNvZGVkXQBucC0+Y2VsbHNbMV0AbnAtPmNlbGxzWzBdAHVzLT5uYW1lWzBdAGNwLT5zcmNbMF0AWy4uXQBcXAAicG9pbnRzIjogWwAic3RvcHMiOiBbAAlbAFoAY29tcHV0ZVNjYWxlWFkAeTw9WQAlYSAlYiAlZCAlSDolTTolUyAlWQBQT1NJWAB0YXJnZXQgPD0gKHNpemVfdClJTlRfTUFYAHBhdGhjb3VudCA8PSBJTlRfTUFYAGVfY250IDw9IElOVF9NQVgAcGFpci5yaWdodCA8PSBJTlRfTUFYAHBhaXIubGVmdCA8PSBJTlRfTUFYAG5fZWRnZXMgPD0gSU5UX01BWABzdHAubnZlcnRpY2VzIDw9IElOVF9NQVgAb3BuIDw9IElOVF9NQVgAZ3JhcGgtPm4gPD0gSU5UX01BWABpIDw9IElOVF9NQVgAVHJlZV9lZGdlLnNpemUgPD0gSU5UX01BWABjbGlzdF9zaXplKCZsaXN0KSAtIDEgPD0gSU5UX01BWABsYXllcl9uYW1lc19zaXplKCZsYXllcklEcykgLSAxIDw9IElOVF9NQVgAc3RybGVuKGFyZ3MpIDw9IElOVF9NQVgAb2JqbGlzdF9zaXplKCZvYmpsKSA8PSBJTlRfTUFYAHJlY3QuYm91bmRhcnlbM10gPCBJTlRfTUFYAHJlY3QuYm91bmRhcnlbMl0gPCBJTlRfTUFYAHJlc3VsdCA8PSAoaW50KVVDSEFSX01BWABzc3ogPD0gVUNIQVJfTUFYAHg8PVgAVwBWAFUAXFQAVEVYVABTVFJFU1NfTUFKT1JJWkFUSU9OX1BPV0VSX0RJU1QAU1RSRVNTX01BSk9SSVpBVElPTl9HUkFQSF9ESVNUAFNUUkVTU19NQUpPUklaQVRJT05fQVZHX0RJU1QARkFTVABGT05UAGIgPT0gQl9SSUdIVABIRUlHSFQAQl9MRUZUAF8lbGx1X1NVU1BFQ1QAQlQAVHJlYnVjaGV0IE1TAElOVklTACVIOiVNOiVTAFZSAFRSAEEtPmZvcm1hdCA9PSBCLT5mb3JtYXQgJiYgQS0+Zm9ybWF0ID09IEZPUk1BVF9DU1IATFIARElSAEhSAENFTlRFUgAlJVRSQUlMRVIAQS0+dHlwZSA9PSBNQVRSSVhfVFlQRV9SRUFMIHx8IEEtPnR5cGUgPT0gTUFUUklYX1RZUEVfSU5URUdFUgBDRUxMQk9SREVSAEJSACpSAFEARVhQAEJfVVAAU1VQAFRPUABPAG1hcE4AXE4AQl9ET1dOAFRIT1JOACUlQkVHSU4AUk9XU1BBTgBDT0xTUEFOAE5BTgBQTQBCT1RUT00AQk0AQU0AXEwAdGFpbFVSTABsYWJlbFVSTABlZGdlVVJMAGhlYWRVUkwASFRNTAB4IT1OVUxMAEVEX3RvX3ZpcnQob3JpZykgPT0gTlVMTABFRF90b192aXJ0KGUpID09IE5VTEwAcHJlZml4ICE9IE5VTEwAZHRkLT5zY2FmZkluZGV4ICE9IE5VTEwAaW5wdXQgIT0gTlVMTABsaXN0ICE9IE5VTEwAcmVmZXJlbnQgIT0gTlVMTABzICE9IE5VTEwAYXR0ciAhPSBOVUxMAGxlYWRlciAhPSBOVUxMAHNlbGYgIT0gTlVMTAB2YWx1ZSAhPSBOVUxMAGpvYi0+b3V0cHV0X2ZpbGUgIT0gTlVMTABiICE9IE5VTEwAc291cmNlLmRhdGEgIT0gTlVMTABiLmRhdGEgIT0gTlVMTABhLmRhdGEgIT0gTlVMTABsaXN0ICYmIGxpc3RbMF0gIT0gTlVMTABFRF90b192aXJ0KG9yaWcpICE9IE5VTEwATENfQUxMAEJMAGJlc3Rjb3N0IDwgSFVHRV9WQUwATk9STUFMAFJBRElBTABBLT50eXBlID09IE1BVFJJWF9UWVBFX1JFQUwAVVJXIENoYW5jZXJ5IEwAVVJXIEJvb2ttYW4gTABDZW50dXJ5IFNjaG9vbGJvb2sgTABVUlcgR290aGljIEwAS0sASgBpIDwgTUFYX0kAUC0+ZW5kLnRoZXRhIDwgMiAqIE1fUEkAXEgARVRIAFdJRFRIAERPVEZPTlRQQVRIAEdERk9OVFBBVEgAbWtOQ29uc3RyYWludEcAXEcARVhQQVRfRU5USVRZX0RFQlVHAEVYUEFUX0VOVFJPUFlfREVCVUcARVhQQVRfQUNDT1VOVElOR19ERUJVRwBSTkcAU1BSSU5HAENFTExQQURESU5HAENFTExTUEFDSU5HAExBTkcASU1HAFx4RgAlJUVPRgBJTkYAXHhGRgBSSUZGAGRlbHRhIDw9IDB4RkZGRgBceEVGAFx4REYAXHhDRgBceEJGAFx4QUYAXHg5RgBceDhGAFx4N0YAXHgxRgBceEUAXEUAUE9JTlQtU0laRQBUUlVFAENMT1NFAEZBTFNFAGtpbmQgPT0gTFRfTk9ORQBHUkFESUVOVEFOR0xFAFRSSUFOR0xFAE1JRERMRQBJTlZJU0lCTEUAVEFCTEUAQUdUWVBFKG9iaikgPT0gQUdJTkVER0UgfHwgQUdUWVBFKG9iaikgPT0gQUdPVVRFREdFAFx4RkUAXHhFRQBceERFAEJfTk9ERQBceENFAFx4QkUAXHhBRQBceDlFAFx4OEUAXHgxRQBURABBLT5mb3JtYXQgPT0gRk9STUFUX0NPT1JEAG4gJiYgaSA+PSAwICYmIGkgPCBOT0RFQ0FSRAAlJUVORABIWUJSSUQAU09MSUQAXHhGRABceEVEAERPVFRFRABEQVNIRUQAUk9VTkRFRABceEREAFx4Q0QAXHhCRABceEFEAFx4OUQAXHg4RABceDFEAFx4QwBkZWxldGVWUFNDAFx4RkMAXHhFQwBceERDAFx4Q0MAXHhCQwBceEFDAFx4OUMAXHg4QwBceDFDAFx4QgBTVUIAXHhGQgBceEVCAFx4REIAXHhDQgBceEJCAFx4QUIAXHg5QgBceDhCAFx4MUIAQSAmJiBCAFx4RkEAXHhFQQBceERBAFx4Q0EAXHhCQQBceEFBAFx4OUEAXHg4QQBceDFBAEAAPwA8JXM+ADxuaWw+ADwvdHNwYW4+PC90ZXh0UGF0aD4ACiAgICA8JTkuM2YsICU5LjNmLCAlOS4zZj4APgo8dGl0bGU+ADxGT05UPgA8QlI+ADxIVE1MPgA8L0hUTUw+ADxJTUc+AFN5bnRheCBlcnJvcjogbm9uLXNwYWNlIHN0cmluZyB1c2VkIGJlZm9yZSA8VEFCTEU+AFN5bnRheCBlcnJvcjogbm9uLXNwYWNlIHN0cmluZyB1c2VkIGFmdGVyIDwvVEFCTEU+ADxURD4ALT4AIj4ACVtrZXk9ADw9ADwAJiN4JXg7ACZxdW90OwAmbHQ7ACZndDsAJmFtcDsAIyVkOwAmIzM5OwAmIzQ1OwAmIzkzOwAmIzEzOwAmIzE2MDsAJiMxMDsAO3N0b3Atb3BhY2l0eToAJSVCb3VuZGluZ0JveDoAY2FsY3VsYXRpbmcgc2hvcnRlc3QgcGF0aHMgYW5kIHNldHRpbmcgdXAgc3RyZXNzIHRlcm1zOgA8c3RvcCBvZmZzZXQ9IiUuMDNmIiBzdHlsZT0ic3RvcC1jb2xvcjoAPHN0b3Agb2Zmc2V0PSIxIiBzdHlsZT0ic3RvcC1jb2xvcjoAPHN0b3Agb2Zmc2V0PSIwIiBzdHlsZT0ic3RvcC1jb2xvcjoAc29sdmluZyBtb2RlbDoAZ3JleTkAZ3JheTkAXHhGOQBceEU5AFx4RDkAXHhDOQBceEI5AFx4QTkAZ3JleTk5AGdyYXk5OQBceDk5AGdyZXk4OQBncmF5ODkAXHg4OQAwMTIzNDU2Nzg5AGdyZXk3OQBncmF5NzkAZ3JleTY5AGdyYXk2OQBncmV5NTkAZ3JheTU5AGdyZXk0OQBncmF5NDkAZ3JleTM5AGdyYXkzOQBncmV5MjkAZ3JheTI5AGdyZXkxOQBncmF5MTkAXHgxOQAvcmRneTkvOQAvYnVwdTkvOQAvcmRwdTkvOQAvcHVidTkvOQAveWxnbmJ1OS85AC9nbmJ1OS85AC9yZHlsYnU5LzkAL3JkYnU5LzkAL2dyZXlzOS85AC9ncmVlbnM5LzkAL2JsdWVzOS85AC9wdXJwbGVzOS85AC9vcmFuZ2VzOS85AC9yZWRzOS85AC9wdW9yOS85AC95bG9yYnI5LzkAL3B1YnVnbjkvOQAvYnVnbjkvOQAvcHJnbjkvOQAvcmR5bGduOS85AC95bGduOS85AC9zcGVjdHJhbDkvOQAvcGl5ZzkvOQAvYnJiZzkvOQAvcHVyZDkvOQAveWxvcnJkOS85AC9vcnJkOS85AC9wYWlyZWQ5LzkAL3NldDM5LzkAL3NldDE5LzkAL3Bhc3RlbDE5LzkAL3BhaXJlZDEyLzkAL3NldDMxMi85AC9yZGd5MTEvOQAvcmR5bGJ1MTEvOQAvcmRidTExLzkAL3B1b3IxMS85AC9wcmduMTEvOQAvcmR5bGduMTEvOQAvc3BlY3RyYWwxMS85AC9waXlnMTEvOQAvYnJiZzExLzkAL3BhaXJlZDExLzkAL3NldDMxMS85AC9yZGd5MTAvOQAvcmR5bGJ1MTAvOQAvcmRidTEwLzkAL3B1b3IxMC85AC9wcmduMTAvOQAvcmR5bGduMTAvOQAvc3BlY3RyYWwxMC85AC9waXlnMTAvOQAvYnJiZzEwLzkAL3BhaXJlZDEwLzkAL3NldDMxMC85AGdyZXk4AGdyYXk4AFx4OAB1dGY4ACNmOGY4ZjgAI2U4ZThlOABceEY4AEdJRjgAXHhFOABceEQ4AFx4QzgAXHhCOABceEE4AGdyZXk5OABncmF5OTgAXHg5OABncmV5ODgAZ3JheTg4AFx4ODgAZ3JleTc4AGdyYXk3OABncmV5NjgAZ3JheTY4AGdyZXk1OABncmF5NTgAZ3JleTQ4AGdyYXk0OABncmV5MzgAZ3JheTM4AGdyZXkyOABncmF5MjgAZ3JleTE4AGdyYXkxOABceDE4AC9yZGd5OS84AC9idXB1OS84AC9yZHB1OS84AC9wdWJ1OS84AC95bGduYnU5LzgAL2duYnU5LzgAL3JkeWxidTkvOAAvcmRidTkvOAAvZ3JleXM5LzgAL2dyZWVuczkvOAAvYmx1ZXM5LzgAL3B1cnBsZXM5LzgAL29yYW5nZXM5LzgAL3JlZHM5LzgAL3B1b3I5LzgAL3lsb3JicjkvOAAvcHVidWduOS84AC9idWduOS84AC9wcmduOS84AC9yZHlsZ245LzgAL3lsZ245LzgAL3NwZWN0cmFsOS84AC9waXlnOS84AC9icmJnOS84AC9wdXJkOS84AC95bG9ycmQ5LzgAL29ycmQ5LzgAL3BhaXJlZDkvOAAvc2V0MzkvOAAvc2V0MTkvOAAvcGFzdGVsMTkvOAAvcmRneTgvOAAvYnVwdTgvOAAvcmRwdTgvOAAvcHVidTgvOAAveWxnbmJ1OC84AC9nbmJ1OC84AC9yZHlsYnU4LzgAL3JkYnU4LzgAL2FjY2VudDgvOAAvZ3JleXM4LzgAL2dyZWVuczgvOAAvYmx1ZXM4LzgAL3B1cnBsZXM4LzgAL29yYW5nZXM4LzgAL3JlZHM4LzgAL3B1b3I4LzgAL3lsb3JicjgvOAAvcHVidWduOC84AC9idWduOC84AC9wcmduOC84AC9yZHlsZ244LzgAL3lsZ244LzgAL3NwZWN0cmFsOC84AC9waXlnOC84AC9icmJnOC84AC9wdXJkOC84AC95bG9ycmQ4LzgAL29ycmQ4LzgAL3BhaXJlZDgvOAAvc2V0MzgvOAAvc2V0MjgvOAAvcGFzdGVsMjgvOAAvZGFyazI4LzgAL3NldDE4LzgAL3Bhc3RlbDE4LzgAL3BhaXJlZDEyLzgAL3NldDMxMi84AC9yZGd5MTEvOAAvcmR5bGJ1MTEvOAAvcmRidTExLzgAL3B1b3IxMS84AC9wcmduMTEvOAAvcmR5bGduMTEvOAAvc3BlY3RyYWwxMS84AC9waXlnMTEvOAAvYnJiZzExLzgAL3BhaXJlZDExLzgAL3NldDMxMS84AC9yZGd5MTAvOAAvcmR5bGJ1MTAvOAAvcmRidTEwLzgAL3B1b3IxMC84AC9wcmduMTAvOAAvcmR5bGduMTAvOAAvc3BlY3RyYWwxMC84AC9waXlnMTAvOAAvYnJiZzEwLzgAL3BhaXJlZDEwLzgAL3NldDMxMC84AHV0Zi04AEMuVVRGLTgAZ3JleTcAZ3JheTcAXHg3AFx4RjcAXHhFNwBceEQ3AFx4QzcAXHhCNwBceEE3AGdyZXk5NwBncmF5OTcAXHg5NwBncmV5ODcAZ3JheTg3AFx4ODcAZ3JleTc3AGdyYXk3NwBncmV5NjcAZ3JheTY3AGdyZXk1NwBncmF5NTcAZ3JleTQ3AGdyYXk0NwBncmV5MzcAZ3JheTM3AGdyZXkyNwBncmF5MjcAMjAyMzA5MTEuMTgyNwBncmV5MTcAZ3JheTE3AFx4MTcAL3JkZ3k5LzcAL2J1cHU5LzcAL3JkcHU5LzcAL3B1YnU5LzcAL3lsZ25idTkvNwAvZ25idTkvNwAvcmR5bGJ1OS83AC9yZGJ1OS83AC9ncmV5czkvNwAvZ3JlZW5zOS83AC9ibHVlczkvNwAvcHVycGxlczkvNwAvb3JhbmdlczkvNwAvcmVkczkvNwAvcHVvcjkvNwAveWxvcmJyOS83AC9wdWJ1Z245LzcAL2J1Z245LzcAL3ByZ245LzcAL3JkeWxnbjkvNwAveWxnbjkvNwAvc3BlY3RyYWw5LzcAL3BpeWc5LzcAL2JyYmc5LzcAL3B1cmQ5LzcAL3lsb3JyZDkvNwAvb3JyZDkvNwAvcGFpcmVkOS83AC9zZXQzOS83AC9zZXQxOS83AC9wYXN0ZWwxOS83AC9yZGd5OC83AC9idXB1OC83AC9yZHB1OC83AC9wdWJ1OC83AC95bGduYnU4LzcAL2duYnU4LzcAL3JkeWxidTgvNwAvcmRidTgvNwAvYWNjZW50OC83AC9ncmV5czgvNwAvZ3JlZW5zOC83AC9ibHVlczgvNwAvcHVycGxlczgvNwAvb3JhbmdlczgvNwAvcmVkczgvNwAvcHVvcjgvNwAveWxvcmJyOC83AC9wdWJ1Z244LzcAL2J1Z244LzcAL3ByZ244LzcAL3JkeWxnbjgvNwAveWxnbjgvNwAvc3BlY3RyYWw4LzcAL3BpeWc4LzcAL2JyYmc4LzcAL3B1cmQ4LzcAL3lsb3JyZDgvNwAvb3JyZDgvNwAvcGFpcmVkOC83AC9zZXQzOC83AC9zZXQyOC83AC9wYXN0ZWwyOC83AC9kYXJrMjgvNwAvc2V0MTgvNwAvcGFzdGVsMTgvNwAvcmRneTcvNwAvYnVwdTcvNwAvcmRwdTcvNwAvcHVidTcvNwAveWxnbmJ1Ny83AC9nbmJ1Ny83AC9yZHlsYnU3LzcAL3JkYnU3LzcAL2FjY2VudDcvNwAvZ3JleXM3LzcAL2dyZWVuczcvNwAvYmx1ZXM3LzcAL3B1cnBsZXM3LzcAL29yYW5nZXM3LzcAL3JlZHM3LzcAL3B1b3I3LzcAL3lsb3JicjcvNwAvcHVidWduNy83AC9idWduNy83AC9wcmduNy83AC9yZHlsZ243LzcAL3lsZ243LzcAL3NwZWN0cmFsNy83AC9waXlnNy83AC9icmJnNy83AC9wdXJkNy83AC95bG9ycmQ3LzcAL29ycmQ3LzcAL3BhaXJlZDcvNwAvc2V0MzcvNwAvc2V0MjcvNwAvcGFzdGVsMjcvNwAvZGFyazI3LzcAL3NldDE3LzcAL3Bhc3RlbDE3LzcAL3BhaXJlZDEyLzcAL3NldDMxMi83AC9yZGd5MTEvNwAvcmR5bGJ1MTEvNwAvcmRidTExLzcAL3B1b3IxMS83AC9wcmduMTEvNwAvcmR5bGduMTEvNwAvc3BlY3RyYWwxMS83AC9waXlnMTEvNwAvYnJiZzExLzcAL3BhaXJlZDExLzcAL3NldDMxMS83AC9yZGd5MTAvNwAvcmR5bGJ1MTAvNwAvcmRidTEwLzcAL3B1b3IxMC83AC9wcmduMTAvNwAvcmR5bGduMTAvNwAvc3BlY3RyYWwxMC83AC9waXlnMTAvNwAvYnJiZzEwLzcAL3BhaXJlZDEwLzcAL3NldDMxMC83ADEuNwBncmV5NgBncmF5NgBceDYAXHhGNgBceEU2AFx4RDYAXHhDNgBceEI2AFx4QTYAZ3JleTk2AGdyYXk5NgBceDk2AGdyZXk4NgBncmF5ODYAXHg4NgBncmV5NzYAZ3JheTc2AGdyZXk2NgBncmF5NjYAZ3JleTU2AGdyYXk1NgBncmV5NDYAZ3JheTQ2AGdyZXkzNgBncmF5MzYAZ3JleTI2AGdyYXkyNgBncmV5MTYAZ3JheTE2AFx4MTYAL3JkZ3k5LzYAL2J1cHU5LzYAL3JkcHU5LzYAL3B1YnU5LzYAL3lsZ25idTkvNgAvZ25idTkvNgAvcmR5bGJ1OS82AC9yZGJ1OS82AC9ncmV5czkvNgAvZ3JlZW5zOS82AC9ibHVlczkvNgAvcHVycGxlczkvNgAvb3JhbmdlczkvNgAvcmVkczkvNgAvcHVvcjkvNgAveWxvcmJyOS82AC9wdWJ1Z245LzYAL2J1Z245LzYAL3ByZ245LzYAL3JkeWxnbjkvNgAveWxnbjkvNgAvc3BlY3RyYWw5LzYAL3BpeWc5LzYAL2JyYmc5LzYAL3B1cmQ5LzYAL3lsb3JyZDkvNgAvb3JyZDkvNgAvcGFpcmVkOS82AC9zZXQzOS82AC9zZXQxOS82AC9wYXN0ZWwxOS82AC9yZGd5OC82AC9idXB1OC82AC9yZHB1OC82AC9wdWJ1OC82AC95bGduYnU4LzYAL2duYnU4LzYAL3JkeWxidTgvNgAvcmRidTgvNgAvYWNjZW50OC82AC9ncmV5czgvNgAvZ3JlZW5zOC82AC9ibHVlczgvNgAvcHVycGxlczgvNgAvb3JhbmdlczgvNgAvcmVkczgvNgAvcHVvcjgvNgAveWxvcmJyOC82AC9wdWJ1Z244LzYAL2J1Z244LzYAL3ByZ244LzYAL3JkeWxnbjgvNgAveWxnbjgvNgAvc3BlY3RyYWw4LzYAL3BpeWc4LzYAL2JyYmc4LzYAL3B1cmQ4LzYAL3lsb3JyZDgvNgAvb3JyZDgvNgAvcGFpcmVkOC82AC9zZXQzOC82AC9zZXQyOC82AC9wYXN0ZWwyOC82AC9kYXJrMjgvNgAvc2V0MTgvNgAvcGFzdGVsMTgvNgAvcmRneTcvNgAvYnVwdTcvNgAvcmRwdTcvNgAvcHVidTcvNgAveWxnbmJ1Ny82AC9nbmJ1Ny82AC9yZHlsYnU3LzYAL3JkYnU3LzYAL2FjY2VudDcvNgAvZ3JleXM3LzYAL2dyZWVuczcvNgAvYmx1ZXM3LzYAL3B1cnBsZXM3LzYAL29yYW5nZXM3LzYAL3JlZHM3LzYAL3B1b3I3LzYAL3lsb3JicjcvNgAvcHVidWduNy82AC9idWduNy82AC9wcmduNy82AC9yZHlsZ243LzYAL3lsZ243LzYAL3NwZWN0cmFsNy82AC9waXlnNy82AC9icmJnNy82AC9wdXJkNy82AC95bG9ycmQ3LzYAL29ycmQ3LzYAL3BhaXJlZDcvNgAvc2V0MzcvNgAvc2V0MjcvNgAvcGFzdGVsMjcvNgAvZGFyazI3LzYAL3NldDE3LzYAL3Bhc3RlbDE3LzYAL3JkZ3k2LzYAL2J1cHU2LzYAL3JkcHU2LzYAL3B1YnU2LzYAL3lsZ25idTYvNgAvZ25idTYvNgAvcmR5bGJ1Ni82AC9yZGJ1Ni82AC9hY2NlbnQ2LzYAL2dyZXlzNi82AC9ncmVlbnM2LzYAL2JsdWVzNi82AC9wdXJwbGVzNi82AC9vcmFuZ2VzNi82AC9yZWRzNi82AC9wdW9yNi82AC95bG9yYnI2LzYAL3B1YnVnbjYvNgAvYnVnbjYvNgAvcHJnbjYvNgAvcmR5bGduNi82AC95bGduNi82AC9zcGVjdHJhbDYvNgAvcGl5ZzYvNgAvYnJiZzYvNgAvcHVyZDYvNgAveWxvcnJkNi82AC9vcnJkNi82AC9wYWlyZWQ2LzYAL3NldDM2LzYAL3NldDI2LzYAL3Bhc3RlbDI2LzYAL2RhcmsyNi82AC9zZXQxNi82AC9wYXN0ZWwxNi82AC9wYWlyZWQxMi82AC9zZXQzMTIvNgAvcmRneTExLzYAL3JkeWxidTExLzYAL3JkYnUxMS82AC9wdW9yMTEvNgAvcHJnbjExLzYAL3JkeWxnbjExLzYAL3NwZWN0cmFsMTEvNgAvcGl5ZzExLzYAL2JyYmcxMS82AC9wYWlyZWQxMS82AC9zZXQzMTEvNgAvcmRneTEwLzYAL3JkeWxidTEwLzYAL3JkYnUxMC82AC9wdW9yMTAvNgAvcHJnbjEwLzYAL3JkeWxnbjEwLzYAL3NwZWN0cmFsMTAvNgAvcGl5ZzEwLzYAL2JyYmcxMC82AC9wYWlyZWQxMC82AC9zZXQzMTAvNgBncmV5NQBncmF5NQBceDUAYmlnNQBceEY1AFx4RTUAXHhENQBceEM1AFx4QjUAXHhBNQBncmV5OTUAZ3JheTk1AFx4OTUAZ3JleTg1AGdyYXk4NQBceDg1AGdyZXk3NQBncmF5NzUAZ3JleTY1AGdyYXk2NQBncmV5NTUAZ3JheTU1AGdyZXk0NQBncmF5NDUAZ3JleTM1AGdyYXkzNQBncmV5MjUAZ3JheTI1AGdyZXkxNQBncmF5MTUAXHgxNQBncmF5MDUAL3JkZ3k5LzUAL2J1cHU5LzUAL3JkcHU5LzUAL3B1YnU5LzUAL3lsZ25idTkvNQAvZ25idTkvNQAvcmR5bGJ1OS81AC9yZGJ1OS81AC9ncmV5czkvNQAvZ3JlZW5zOS81AC9ibHVlczkvNQAvcHVycGxlczkvNQAvb3JhbmdlczkvNQAvcmVkczkvNQAvcHVvcjkvNQAveWxvcmJyOS81AC9wdWJ1Z245LzUAL2J1Z245LzUAL3ByZ245LzUAL3JkeWxnbjkvNQAveWxnbjkvNQAvc3BlY3RyYWw5LzUAL3BpeWc5LzUAL2JyYmc5LzUAL3B1cmQ5LzUAL3lsb3JyZDkvNQAvb3JyZDkvNQAvcGFpcmVkOS81AC9zZXQzOS81AC9zZXQxOS81AC9wYXN0ZWwxOS81AC9yZGd5OC81AC9idXB1OC81AC9yZHB1OC81AC9wdWJ1OC81AC95bGduYnU4LzUAL2duYnU4LzUAL3JkeWxidTgvNQAvcmRidTgvNQAvYWNjZW50OC81AC9ncmV5czgvNQAvZ3JlZW5zOC81AC9ibHVlczgvNQAvcHVycGxlczgvNQAvb3JhbmdlczgvNQAvcmVkczgvNQAvcHVvcjgvNQAveWxvcmJyOC81AC9wdWJ1Z244LzUAL2J1Z244LzUAL3ByZ244LzUAL3JkeWxnbjgvNQAveWxnbjgvNQAvc3BlY3RyYWw4LzUAL3BpeWc4LzUAL2JyYmc4LzUAL3B1cmQ4LzUAL3lsb3JyZDgvNQAvb3JyZDgvNQAvcGFpcmVkOC81AC9zZXQzOC81AC9zZXQyOC81AC9wYXN0ZWwyOC81AC9kYXJrMjgvNQAvc2V0MTgvNQAvcGFzdGVsMTgvNQAvcmRneTcvNQAvYnVwdTcvNQAvcmRwdTcvNQAvcHVidTcvNQAveWxnbmJ1Ny81AC9nbmJ1Ny81AC9yZHlsYnU3LzUAL3JkYnU3LzUAL2FjY2VudDcvNQAvZ3JleXM3LzUAL2dyZWVuczcvNQAvYmx1ZXM3LzUAL3B1cnBsZXM3LzUAL29yYW5nZXM3LzUAL3JlZHM3LzUAL3B1b3I3LzUAL3lsb3JicjcvNQAvcHVidWduNy81AC9idWduNy81AC9wcmduNy81AC9yZHlsZ243LzUAL3lsZ243LzUAL3NwZWN0cmFsNy81AC9waXlnNy81AC9icmJnNy81AC9wdXJkNy81AC95bG9ycmQ3LzUAL29ycmQ3LzUAL3BhaXJlZDcvNQAvc2V0MzcvNQAvc2V0MjcvNQAvcGFzdGVsMjcvNQAvZGFyazI3LzUAL3NldDE3LzUAL3Bhc3RlbDE3LzUAL3JkZ3k2LzUAL2J1cHU2LzUAL3JkcHU2LzUAL3B1YnU2LzUAL3lsZ25idTYvNQAvZ25idTYvNQAvcmR5bGJ1Ni81AC9yZGJ1Ni81AC9hY2NlbnQ2LzUAL2dyZXlzNi81AC9ncmVlbnM2LzUAL2JsdWVzNi81AC9wdXJwbGVzNi81AC9vcmFuZ2VzNi81AC9yZWRzNi81AC9wdW9yNi81AC95bG9yYnI2LzUAL3B1YnVnbjYvNQAvYnVnbjYvNQAvcHJnbjYvNQAvcmR5bGduNi81AC95bGduNi81AC9zcGVjdHJhbDYvNQAvcGl5ZzYvNQAvYnJiZzYvNQAvcHVyZDYvNQAveWxvcnJkNi81AC9vcnJkNi81AC9wYWlyZWQ2LzUAL3NldDM2LzUAL3NldDI2LzUAL3Bhc3RlbDI2LzUAL2RhcmsyNi81AC9zZXQxNi81AC9wYXN0ZWwxNi81AC9yZGd5NS81AC9idXB1NS81AC9yZHB1NS81AC9wdWJ1NS81AC95bGduYnU1LzUAL2duYnU1LzUAL3JkeWxidTUvNQAvcmRidTUvNQAvYWNjZW50NS81AC9ncmV5czUvNQAvZ3JlZW5zNS81AC9ibHVlczUvNQAvcHVycGxlczUvNQAvb3JhbmdlczUvNQAvcmVkczUvNQAvcHVvcjUvNQAveWxvcmJyNS81AC9wdWJ1Z241LzUAL2J1Z241LzUAL3ByZ241LzUAL3JkeWxnbjUvNQAveWxnbjUvNQAvc3BlY3RyYWw1LzUAL3BpeWc1LzUAL2JyYmc1LzUAL3B1cmQ1LzUAL3lsb3JyZDUvNQAvb3JyZDUvNQAvcGFpcmVkNS81AC9zZXQzNS81AC9zZXQyNS81AC9wYXN0ZWwyNS81AC9kYXJrMjUvNQAvc2V0MTUvNQAvcGFzdGVsMTUvNQAvcGFpcmVkMTIvNQAvc2V0MzEyLzUAL3JkZ3kxMS81AC9yZHlsYnUxMS81AC9yZGJ1MTEvNQAvcHVvcjExLzUAL3ByZ24xMS81AC9yZHlsZ24xMS81AC9zcGVjdHJhbDExLzUAL3BpeWcxMS81AC9icmJnMTEvNQAvcGFpcmVkMTEvNQAvc2V0MzExLzUAL3JkZ3kxMC81AC9yZHlsYnUxMC81AC9yZGJ1MTAvNQAvcHVvcjEwLzUAL3ByZ24xMC81AC9yZHlsZ24xMC81AC9zcGVjdHJhbDEwLzUAL3BpeWcxMC81AC9icmJnMTAvNQAvcGFpcmVkMTAvNQAvc2V0MzEwLzUAYmlnLTUAQklHLTUAIC1kYXNoIDUAaXZvcnk0AGdyZXk0AGRhcmtzbGF0ZWdyYXk0AFx4NABzbm93NABsaWdodHllbGxvdzQAaG9uZXlkZXc0AHdoZWF0NAB0b21hdG80AHJvc3licm93bjQAbWFyb29uNABsaWdodHNhbG1vbjQAbGVtb25jaGlmZm9uNABzcHJpbmdncmVlbjQAZGFya29saXZlZ3JlZW40AHBhbGVncmVlbjQAZGFya3NlYWdyZWVuNABsaWdodGN5YW40AHRhbjQAcGx1bTQAc2Vhc2hlbGw0AGNvcmFsNABob3RwaW5rNABsaWdodHBpbms0AGRlZXBwaW5rNABjb3Juc2lsazQAZmlyZWJyaWNrNABraGFraTQAbGF2ZW5kZXJibHVzaDQAcGVhY2hwdWZmNABiaXNxdWU0AGxpZ2h0c2t5Ymx1ZTQAZGVlcHNreWJsdWU0AGxpZ2h0Ymx1ZTQAY2FkZXRibHVlNABkb2RnZXJibHVlNABsaWdodHN0ZWVsYmx1ZTQAcm95YWxibHVlNABzbGF0ZWJsdWU0AG5hdmFqb3doaXRlNABhbnRpcXVld2hpdGU0AGNob2NvbGF0ZTQAY2hhcnRyZXVzZTQAbWlzdHlyb3NlNABwYWxldHVycXVvaXNlNABhenVyZTQAdGhlcmU0AGFxdWFtYXJpbmU0AHRoaXN0bGU0AG1lZGl1bXB1cnBsZTQAZGFya29yYW5nZTQAbGlnaHRnb2xkZW5yb2Q0AGRhcmtnb2xkZW5yb2Q0AGJ1cmx5d29vZDQAZ29sZDQAbWVkaXVtb3JjaGlkNABkYXJrb3JjaGlkNABwYWxldmlvbGV0cmVkNABpbmRpYW5yZWQ0AG9yYW5nZXJlZDQAb2xpdmVkcmFiNABtYWdlbnRhNABzaWVubmE0AFx4RjQAXHhFNABceEQ0AFx4QzQAXHhCNABceEE0AGdyZXk5NABncmF5OTQAXHg5NABncmV5ODQAZ3JheTg0AFx4ODQAZ3JleTc0AGdyYXk3NABncmV5NjQAZ3JheTY0AGdyZXk1NABncmF5NTQAZ3JleTQ0AGdyYXk0NABncmV5MzQAZ3JheTM0AGZyYWMzNABncmV5MjQAZ3JheTI0AGdyZXkxNABncmF5MTQAXHgxNABmcmFjMTQAL3JkZ3k5LzQAL2J1cHU5LzQAL3JkcHU5LzQAL3B1YnU5LzQAL3lsZ25idTkvNAAvZ25idTkvNAAvcmR5bGJ1OS80AC9yZGJ1OS80AC9ncmV5czkvNAAvZ3JlZW5zOS80AC9ibHVlczkvNAAvcHVycGxlczkvNAAvb3JhbmdlczkvNAAvcmVkczkvNAAvcHVvcjkvNAAveWxvcmJyOS80AC9wdWJ1Z245LzQAL2J1Z245LzQAL3ByZ245LzQAL3JkeWxnbjkvNAAveWxnbjkvNAAvc3BlY3RyYWw5LzQAL3BpeWc5LzQAL2JyYmc5LzQAL3B1cmQ5LzQAL3lsb3JyZDkvNAAvb3JyZDkvNAAvcGFpcmVkOS80AC9zZXQzOS80AC9zZXQxOS80AC9wYXN0ZWwxOS80AC9yZGd5OC80AC9idXB1OC80AC9yZHB1OC80AC9wdWJ1OC80AC95bGduYnU4LzQAL2duYnU4LzQAL3JkeWxidTgvNAAvcmRidTgvNAAvYWNjZW50OC80AC9ncmV5czgvNAAvZ3JlZW5zOC80AC9ibHVlczgvNAAvcHVycGxlczgvNAAvb3JhbmdlczgvNAAvcmVkczgvNAAvcHVvcjgvNAAveWxvcmJyOC80AC9wdWJ1Z244LzQAL2J1Z244LzQAL3ByZ244LzQAL3JkeWxnbjgvNAAveWxnbjgvNAAvc3BlY3RyYWw4LzQAL3BpeWc4LzQAL2JyYmc4LzQAL3B1cmQ4LzQAL3lsb3JyZDgvNAAvb3JyZDgvNAAvcGFpcmVkOC80AC9zZXQzOC80AC9zZXQyOC80AC9wYXN0ZWwyOC80AC9kYXJrMjgvNAAvc2V0MTgvNAAvcGFzdGVsMTgvNAAvcmRneTcvNAAvYnVwdTcvNAAvcmRwdTcvNAAvcHVidTcvNAAveWxnbmJ1Ny80AC9nbmJ1Ny80AC9yZHlsYnU3LzQAL3JkYnU3LzQAL2FjY2VudDcvNAAvZ3JleXM3LzQAL2dyZWVuczcvNAAvYmx1ZXM3LzQAL3B1cnBsZXM3LzQAL29yYW5nZXM3LzQAL3JlZHM3LzQAL3B1b3I3LzQAL3lsb3JicjcvNAAvcHVidWduNy80AC9idWduNy80AC9wcmduNy80AC9yZHlsZ243LzQAL3lsZ243LzQAL3NwZWN0cmFsNy80AC9waXlnNy80AC9icmJnNy80AC9wdXJkNy80AC95bG9ycmQ3LzQAL29ycmQ3LzQAL3BhaXJlZDcvNAAvc2V0MzcvNAAvc2V0MjcvNAAvcGFzdGVsMjcvNAAvZGFyazI3LzQAL3NldDE3LzQAL3Bhc3RlbDE3LzQAL3JkZ3k2LzQAL2J1cHU2LzQAL3JkcHU2LzQAL3B1YnU2LzQAL3lsZ25idTYvNAAvZ25idTYvNAAvcmR5bGJ1Ni80AC9yZGJ1Ni80AC9hY2NlbnQ2LzQAL2dyZXlzNi80AC9ncmVlbnM2LzQAL2JsdWVzNi80AC9wdXJwbGVzNi80AC9vcmFuZ2VzNi80AC9yZWRzNi80AC9wdW9yNi80AC95bG9yYnI2LzQAL3B1YnVnbjYvNAAvYnVnbjYvNAAvcHJnbjYvNAAvcmR5bGduNi80AC95bGduNi80AC9zcGVjdHJhbDYvNAAvcGl5ZzYvNAAvYnJiZzYvNAAvcHVyZDYvNAAveWxvcnJkNi80AC9vcnJkNi80AC9wYWlyZWQ2LzQAL3NldDM2LzQAL3NldDI2LzQAL3Bhc3RlbDI2LzQAL2RhcmsyNi80AC9zZXQxNi80AC9wYXN0ZWwxNi80AC9yZGd5NS80AC9idXB1NS80AC9yZHB1NS80AC9wdWJ1NS80AC95bGduYnU1LzQAL2duYnU1LzQAL3JkeWxidTUvNAAvcmRidTUvNAAvYWNjZW50NS80AC9ncmV5czUvNAAvZ3JlZW5zNS80AC9ibHVlczUvNAAvcHVycGxlczUvNAAvb3JhbmdlczUvNAAvcmVkczUvNAAvcHVvcjUvNAAveWxvcmJyNS80AC9wdWJ1Z241LzQAL2J1Z241LzQAL3ByZ241LzQAL3JkeWxnbjUvNAAveWxnbjUvNAAvc3BlY3RyYWw1LzQAL3BpeWc1LzQAL2JyYmc1LzQAL3B1cmQ1LzQAL3lsb3JyZDUvNAAvb3JyZDUvNAAvcGFpcmVkNS80AC9zZXQzNS80AC9zZXQyNS80AC9wYXN0ZWwyNS80AC9kYXJrMjUvNAAvc2V0MTUvNAAvcGFzdGVsMTUvNAAvcmRneTQvNAAvYnVwdTQvNAAvcmRwdTQvNAAvcHVidTQvNAAveWxnbmJ1NC80AC9nbmJ1NC80AC9yZHlsYnU0LzQAL3JkYnU0LzQAL2FjY2VudDQvNAAvZ3JleXM0LzQAL2dyZWVuczQvNAAvYmx1ZXM0LzQAL3B1cnBsZXM0LzQAL29yYW5nZXM0LzQAL3JlZHM0LzQAL3B1b3I0LzQAL3lsb3JicjQvNAAvcHVidWduNC80AC9idWduNC80AC9wcmduNC80AC9yZHlsZ240LzQAL3lsZ240LzQAL3NwZWN0cmFsNC80AC9waXlnNC80AC9icmJnNC80AC9wdXJkNC80AC95bG9ycmQ0LzQAL29ycmQ0LzQAL3BhaXJlZDQvNAAvc2V0MzQvNAAvc2V0MjQvNAAvcGFzdGVsMjQvNAAvZGFyazI0LzQAL3NldDE0LzQAL3Bhc3RlbDE0LzQAL3BhaXJlZDEyLzQAL3NldDMxMi80AC9yZGd5MTEvNAAvcmR5bGJ1MTEvNAAvcmRidTExLzQAL3B1b3IxMS80AC9wcmduMTEvNAAvcmR5bGduMTEvNAAvc3BlY3RyYWwxMS80AC9waXlnMTEvNAAvYnJiZzExLzQAL3BhaXJlZDExLzQAL3NldDMxMS80AC9yZGd5MTAvNAAvcmR5bGJ1MTAvNAAvcmRidTEwLzQAL3B1b3IxMC80AC9wcmduMTAvNAAvcmR5bGduMTAvNAAvc3BlY3RyYWwxMC80AC9waXlnMTAvNAAvYnJiZzEwLzQAL3BhaXJlZDEwLzQAL3NldDMxMC80ADEuNABuID49IDQAc2lkZXMgPT0gNABpdm9yeTMAU3BhcnNlTWF0cml4X211bHRpcGx5MwBncmV5MwBkYXJrc2xhdGVncmF5MwBceDMAc25vdzMAbGlnaHR5ZWxsb3czAGhvbmV5ZGV3MwB3aGVhdDMAc3VwMwB0b21hdG8zAHJvc3licm93bjMAbWFyb29uMwBsaWdodHNhbG1vbjMAbGVtb25jaGlmZm9uMwBzcHJpbmdncmVlbjMAZGFya29saXZlZ3JlZW4zAHBhbGVncmVlbjMAZGFya3NlYWdyZWVuMwBsaWdodGN5YW4zAHRhbjMAcGx1bTMAc2Vhc2hlbGwzAGNvcmFsMwBob3RwaW5rMwBsaWdodHBpbmszAGRlZXBwaW5rMwBjb3Juc2lsazMAZmlyZWJyaWNrMwBraGFraTMAbGF2ZW5kZXJibHVzaDMAcGVhY2hwdWZmMwBiaXNxdWUzAGxpZ2h0c2t5Ymx1ZTMAZGVlcHNreWJsdWUzAGxpZ2h0Ymx1ZTMAY2FkZXRibHVlMwBkb2RnZXJibHVlMwBsaWdodHN0ZWVsYmx1ZTMAcm95YWxibHVlMwBzbGF0ZWJsdWUzAG5hdmFqb3doaXRlMwBhbnRpcXVld2hpdGUzAGNob2NvbGF0ZTMAY2hhcnRyZXVzZTMAbWlzdHlyb3NlMwBwYWxldHVycXVvaXNlMwBhenVyZTMAYXF1YW1hcmluZTMAdGhpc3RsZTMAbWVkaXVtcHVycGxlMwBkYXJrb3JhbmdlMwBsaWdodGdvbGRlbnJvZDMAZGFya2dvbGRlbnJvZDMAYnVybHl3b29kMwBnb2xkMwBtZWRpdW1vcmNoaWQzAGRhcmtvcmNoaWQzAHBhbGV2aW9sZXRyZWQzAGluZGlhbnJlZDMAb3JhbmdlcmVkMwBvbGl2ZWRyYWIzAG1hZ2VudGEzAHNpZW5uYTMAXHhGMwBceEUzAFx4RDMAXHhDMwBceEIzAFx4QTMAZ3JleTkzAGdyYXk5MwBceDkzAGdyZXk4MwBncmF5ODMAXHg4MwBncmV5NzMAZ3JheTczAGdyZXk2MwBncmF5NjMAZ3JleTUzAGdyYXk1MwBncmV5NDMAZ3JheTQzAGdyZXkzMwBncmF5MzMAZ3JleTIzAGdyYXkyMwBncmV5MTMAZ3JheTEzAFx4MTMAL3JkZ3k5LzMAL2J1cHU5LzMAL3JkcHU5LzMAL3B1YnU5LzMAL3lsZ25idTkvMwAvZ25idTkvMwAvcmR5bGJ1OS8zAC9yZGJ1OS8zAC9ncmV5czkvMwAvZ3JlZW5zOS8zAC9ibHVlczkvMwAvcHVycGxlczkvMwAvb3JhbmdlczkvMwAvcmVkczkvMwAvcHVvcjkvMwAveWxvcmJyOS8zAC9wdWJ1Z245LzMAL2J1Z245LzMAL3ByZ245LzMAL3JkeWxnbjkvMwAveWxnbjkvMwAvc3BlY3RyYWw5LzMAL3BpeWc5LzMAL2JyYmc5LzMAL3B1cmQ5LzMAL3lsb3JyZDkvMwAvb3JyZDkvMwAvcGFpcmVkOS8zAC9zZXQzOS8zAC9zZXQxOS8zAC9wYXN0ZWwxOS8zAC9yZGd5OC8zAC9idXB1OC8zAC9yZHB1OC8zAC9wdWJ1OC8zAC95bGduYnU4LzMAL2duYnU4LzMAL3JkeWxidTgvMwAvcmRidTgvMwAvYWNjZW50OC8zAC9ncmV5czgvMwAvZ3JlZW5zOC8zAC9ibHVlczgvMwAvcHVycGxlczgvMwAvb3JhbmdlczgvMwAvcmVkczgvMwAvcHVvcjgvMwAveWxvcmJyOC8zAC9wdWJ1Z244LzMAL2J1Z244LzMAL3ByZ244LzMAL3JkeWxnbjgvMwAveWxnbjgvMwAvc3BlY3RyYWw4LzMAL3BpeWc4LzMAL2JyYmc4LzMAL3B1cmQ4LzMAL3lsb3JyZDgvMwAvb3JyZDgvMwAvcGFpcmVkOC8zAC9zZXQzOC8zAC9zZXQyOC8zAC9wYXN0ZWwyOC8zAC9kYXJrMjgvMwAvc2V0MTgvMwAvcGFzdGVsMTgvMwAvcmRneTcvMwAvYnVwdTcvMwAvcmRwdTcvMwAvcHVidTcvMwAveWxnbmJ1Ny8zAC9nbmJ1Ny8zAC9yZHlsYnU3LzMAL3JkYnU3LzMAL2FjY2VudDcvMwAvZ3JleXM3LzMAL2dyZWVuczcvMwAvYmx1ZXM3LzMAL3B1cnBsZXM3LzMAL29yYW5nZXM3LzMAL3JlZHM3LzMAL3B1b3I3LzMAL3lsb3JicjcvMwAvcHVidWduNy8zAC9idWduNy8zAC9wcmduNy8zAC9yZHlsZ243LzMAL3lsZ243LzMAL3NwZWN0cmFsNy8zAC9waXlnNy8zAC9icmJnNy8zAC9wdXJkNy8zAC95bG9ycmQ3LzMAL29ycmQ3LzMAL3BhaXJlZDcvMwAvc2V0MzcvMwAvc2V0MjcvMwAvcGFzdGVsMjcvMwAvZGFyazI3LzMAL3NldDE3LzMAL3Bhc3RlbDE3LzMAL3JkZ3k2LzMAL2J1cHU2LzMAL3JkcHU2LzMAL3B1YnU2LzMAL3lsZ25idTYvMwAvZ25idTYvMwAvcmR5bGJ1Ni8zAC9yZGJ1Ni8zAC9hY2NlbnQ2LzMAL2dyZXlzNi8zAC9ncmVlbnM2LzMAL2JsdWVzNi8zAC9wdXJwbGVzNi8zAC9vcmFuZ2VzNi8zAC9yZWRzNi8zAC9wdW9yNi8zAC95bG9yYnI2LzMAL3B1YnVnbjYvMwAvYnVnbjYvMwAvcHJnbjYvMwAvcmR5bGduNi8zAC95bGduNi8zAC9zcGVjdHJhbDYvMwAvcGl5ZzYvMwAvYnJiZzYvMwAvcHVyZDYvMwAveWxvcnJkNi8zAC9vcnJkNi8zAC9wYWlyZWQ2LzMAL3NldDM2LzMAL3NldDI2LzMAL3Bhc3RlbDI2LzMAL2RhcmsyNi8zAC9zZXQxNi8zAC9wYXN0ZWwxNi8zAC9yZGd5NS8zAC9idXB1NS8zAC9yZHB1NS8zAC9wdWJ1NS8zAC95bGduYnU1LzMAL2duYnU1LzMAL3JkeWxidTUvMwAvcmRidTUvMwAvYWNjZW50NS8zAC9ncmV5czUvMwAvZ3JlZW5zNS8zAC9ibHVlczUvMwAvcHVycGxlczUvMwAvb3JhbmdlczUvMwAvcmVkczUvMwAvcHVvcjUvMwAveWxvcmJyNS8zAC9wdWJ1Z241LzMAL2J1Z241LzMAL3ByZ241LzMAL3JkeWxnbjUvMwAveWxnbjUvMwAvc3BlY3RyYWw1LzMAL3BpeWc1LzMAL2JyYmc1LzMAL3B1cmQ1LzMAL3lsb3JyZDUvMwAvb3JyZDUvMwAvcGFpcmVkNS8zAC9zZXQzNS8zAC9zZXQyNS8zAC9wYXN0ZWwyNS8zAC9kYXJrMjUvMwAvc2V0MTUvMwAvcGFzdGVsMTUvMwAvcmRneTQvMwAvYnVwdTQvMwAvcmRwdTQvMwAvcHVidTQvMwAveWxnbmJ1NC8zAC9nbmJ1NC8zAC9yZHlsYnU0LzMAL3JkYnU0LzMAL2FjY2VudDQvMwAvZ3JleXM0LzMAL2dyZWVuczQvMwAvYmx1ZXM0LzMAL3B1cnBsZXM0LzMAL29yYW5nZXM0LzMAL3JlZHM0LzMAL3B1b3I0LzMAL3lsb3JicjQvMwAvcHVidWduNC8zAC9idWduNC8zAC9wcmduNC8zAC9yZHlsZ240LzMAL3lsZ240LzMAL3NwZWN0cmFsNC8zAC9waXlnNC8zAC9icmJnNC8zAC9wdXJkNC8zAC95bG9ycmQ0LzMAL29ycmQ0LzMAL3BhaXJlZDQvMwAvc2V0MzQvMwAvc2V0MjQvMwAvcGFzdGVsMjQvMwAvZGFyazI0LzMAL3NldDE0LzMAL3Bhc3RlbDE0LzMAL3JkZ3kzLzMAL2J1cHUzLzMAL3JkcHUzLzMAL3B1YnUzLzMAL3lsZ25idTMvMwAvZ25idTMvMwAvcmR5bGJ1My8zAC9yZGJ1My8zAC9hY2NlbnQzLzMAL2dyZXlzMy8zAC9ncmVlbnMzLzMAL2JsdWVzMy8zAC9wdXJwbGVzMy8zAC9vcmFuZ2VzMy8zAC9yZWRzMy8zAC9wdW9yMy8zAC95bG9yYnIzLzMAL3B1YnVnbjMvMwAvYnVnbjMvMwAvcHJnbjMvMwAvcmR5bGduMy8zAC95bGduMy8zAC9zcGVjdHJhbDMvMwAvcGl5ZzMvMwAvYnJiZzMvMwAvcHVyZDMvMwAveWxvcnJkMy8zAC9vcnJkMy8zAC9wYWlyZWQzLzMAL3NldDMzLzMAL3NldDIzLzMAL3Bhc3RlbDIzLzMAL2RhcmsyMy8zAC9zZXQxMy8zAC9wYXN0ZWwxMy8zAC9wYWlyZWQxMi8zAC9zZXQzMTIvMwAvcmRneTExLzMAL3JkeWxidTExLzMAL3JkYnUxMS8zAC9wdW9yMTEvMwAvcHJnbjExLzMAL3JkeWxnbjExLzMAL3NwZWN0cmFsMTEvMwAvcGl5ZzExLzMAL2JyYmcxMS8zAC9wYWlyZWQxMS8zAC9zZXQzMTEvMwAvcmRneTEwLzMAL3JkeWxidTEwLzMAL3JkYnUxMC8zAC9wdW9yMTAvMwAvcHJnbjEwLzMAL3JkeWxnbjEwLzMAL3NwZWN0cmFsMTAvMwAvcGl5ZzEwLzMAL2JyYmcxMC8zAC9wYWlyZWQxMC8zAC9zZXQzMTAvMwBpdm9yeTIAZ3JleTIAZGFya3NsYXRlZ3JheTIAXHgyAHNub3cyAGxpZ2h0eWVsbG93MgBob25leWRldzIAUlRyZWVJbnNlcnQyAHdoZWF0MgBzdXAyAG5vcDIAdG9tYXRvMgByb3N5YnJvd24yAG1hcm9vbjIAbGlnaHRzYWxtb24yAGxlbW9uY2hpZmZvbjIAc3ByaW5nZ3JlZW4yAGRhcmtvbGl2ZWdyZWVuMgBwYWxlZ3JlZW4yAGRhcmtzZWFncmVlbjIAbGlnaHRjeWFuMgB0YW4yAHBsdW0yAHNlYXNoZWxsMgBjb3JhbDIAaG90cGluazIAbGlnaHRwaW5rMgBkZWVwcGluazIAY29ybnNpbGsyAGZpcmVicmljazIAa2hha2kyAGxhdmVuZGVyYmx1c2gyAHBlYWNocHVmZjIAYnJvbnplMgBiaXNxdWUyAGxpZ2h0c2t5Ymx1ZTIAZGVlcHNreWJsdWUyAGxpZ2h0Ymx1ZTIAY2FkZXRibHVlMgBkb2RnZXJibHVlMgBsaWdodHN0ZWVsYmx1ZTIAcm95YWxibHVlMgBzbGF0ZWJsdWUyAG5hdmFqb3doaXRlMgBhbnRpcXVld2hpdGUyAGNob2NvbGF0ZTIAY2hhcnRyZXVzZTIAbWlzdHlyb3NlMgBwYWxldHVycXVvaXNlMgBhenVyZTIAYXF1YW1hcmluZTIAdGhpc3RsZTIAbWVkaXVtcHVycGxlMgBkYXJrb3JhbmdlMgBsaWdodGdvbGRlbnJvZDIAZGFya2dvbGRlbnJvZDIAYnVybHl3b29kMgBnb2xkMgBtZWRpdW1vcmNoaWQyAGRhcmtvcmNoaWQyAHBhbGV2aW9sZXRyZWQyAGluZGlhbnJlZDIAb3JhbmdlcmVkMgBvbGl2ZWRyYWIyAG1hZ2VudGEyAHNpZW5uYTIAXHhGMgBceEUyAFx4RDIAXHhDMgBceEIyAFx4QTIAZ3JleTkyAGdyYXk5MgBceDkyAGdyZXk4MgBncmF5ODIAXHg4MgBncmV5NzIAZ3JheTcyAGdyZXk2MgBncmF5NjIAZ3JleTUyAGdyYXk1MgBncmV5NDIAZ3JheTQyAGdyZXkzMgBncmF5MzIAZ3JleTIyAGdyYXkyMgBncmV5MTIAZ3JheTEyAFx4MTIAZnJhYzEyAC9wYWlyZWQxMi8xMgAvc2V0MzEyLzEyAC9yZGd5OS8yAC9idXB1OS8yAC9yZHB1OS8yAC9wdWJ1OS8yAC95bGduYnU5LzIAL2duYnU5LzIAL3JkeWxidTkvMgAvcmRidTkvMgAvZ3JleXM5LzIAL2dyZWVuczkvMgAvYmx1ZXM5LzIAL3B1cnBsZXM5LzIAL29yYW5nZXM5LzIAL3JlZHM5LzIAL3B1b3I5LzIAL3lsb3JicjkvMgAvcHVidWduOS8yAC9idWduOS8yAC9wcmduOS8yAC9yZHlsZ245LzIAL3lsZ245LzIAL3NwZWN0cmFsOS8yAC9waXlnOS8yAC9icmJnOS8yAC9wdXJkOS8yAC95bG9ycmQ5LzIAL29ycmQ5LzIAL3BhaXJlZDkvMgAvc2V0MzkvMgAvc2V0MTkvMgAvcGFzdGVsMTkvMgAvcmRneTgvMgAvYnVwdTgvMgAvcmRwdTgvMgAvcHVidTgvMgAveWxnbmJ1OC8yAC9nbmJ1OC8yAC9yZHlsYnU4LzIAL3JkYnU4LzIAL2FjY2VudDgvMgAvZ3JleXM4LzIAL2dyZWVuczgvMgAvYmx1ZXM4LzIAL3B1cnBsZXM4LzIAL29yYW5nZXM4LzIAL3JlZHM4LzIAL3B1b3I4LzIAL3lsb3JicjgvMgAvcHVidWduOC8yAC9idWduOC8yAC9wcmduOC8yAC9yZHlsZ244LzIAL3lsZ244LzIAL3NwZWN0cmFsOC8yAC9waXlnOC8yAC9icmJnOC8yAC9wdXJkOC8yAC95bG9ycmQ4LzIAL29ycmQ4LzIAL3BhaXJlZDgvMgAvc2V0MzgvMgAvc2V0MjgvMgAvcGFzdGVsMjgvMgAvZGFyazI4LzIAL3NldDE4LzIAL3Bhc3RlbDE4LzIAL3JkZ3k3LzIAL2J1cHU3LzIAL3JkcHU3LzIAL3B1YnU3LzIAL3lsZ25idTcvMgAvZ25idTcvMgAvcmR5bGJ1Ny8yAC9yZGJ1Ny8yAC9hY2NlbnQ3LzIAL2dyZXlzNy8yAC9ncmVlbnM3LzIAL2JsdWVzNy8yAC9wdXJwbGVzNy8yAC9vcmFuZ2VzNy8yAC9yZWRzNy8yAC9wdW9yNy8yAC95bG9yYnI3LzIAL3B1YnVnbjcvMgAvYnVnbjcvMgAvcHJnbjcvMgAvcmR5bGduNy8yAC95bGduNy8yAC9zcGVjdHJhbDcvMgAvcGl5ZzcvMgAvYnJiZzcvMgAvcHVyZDcvMgAveWxvcnJkNy8yAC9vcnJkNy8yAC9wYWlyZWQ3LzIAL3NldDM3LzIAL3NldDI3LzIAL3Bhc3RlbDI3LzIAL2RhcmsyNy8yAC9zZXQxNy8yAC9wYXN0ZWwxNy8yAC9yZGd5Ni8yAC9idXB1Ni8yAC9yZHB1Ni8yAC9wdWJ1Ni8yAC95bGduYnU2LzIAL2duYnU2LzIAL3JkeWxidTYvMgAvcmRidTYvMgAvYWNjZW50Ni8yAC9ncmV5czYvMgAvZ3JlZW5zNi8yAC9ibHVlczYvMgAvcHVycGxlczYvMgAvb3JhbmdlczYvMgAvcmVkczYvMgAvcHVvcjYvMgAveWxvcmJyNi8yAC9wdWJ1Z242LzIAL2J1Z242LzIAL3ByZ242LzIAL3JkeWxnbjYvMgAveWxnbjYvMgAvc3BlY3RyYWw2LzIAL3BpeWc2LzIAL2JyYmc2LzIAL3B1cmQ2LzIAL3lsb3JyZDYvMgAvb3JyZDYvMgAvcGFpcmVkNi8yAC9zZXQzNi8yAC9zZXQyNi8yAC9wYXN0ZWwyNi8yAC9kYXJrMjYvMgAvc2V0MTYvMgAvcGFzdGVsMTYvMgAvcmRneTUvMgAvYnVwdTUvMgAvcmRwdTUvMgAvcHVidTUvMgAveWxnbmJ1NS8yAC9nbmJ1NS8yAC9yZHlsYnU1LzIAL3JkYnU1LzIAL2FjY2VudDUvMgAvZ3JleXM1LzIAL2dyZWVuczUvMgAvYmx1ZXM1LzIAL3B1cnBsZXM1LzIAL29yYW5nZXM1LzIAL3JlZHM1LzIAL3B1b3I1LzIAL3lsb3JicjUvMgAvcHVidWduNS8yAC9idWduNS8yAC9wcmduNS8yAC9yZHlsZ241LzIAL3lsZ241LzIAL3NwZWN0cmFsNS8yAC9waXlnNS8yAC9icmJnNS8yAC9wdXJkNS8yAC95bG9ycmQ1LzIAL29ycmQ1LzIAL3BhaXJlZDUvMgAvc2V0MzUvMgAvc2V0MjUvMgAvcGFzdGVsMjUvMgAvZGFyazI1LzIAL3NldDE1LzIAL3Bhc3RlbDE1LzIAL3JkZ3k0LzIAL2J1cHU0LzIAL3JkcHU0LzIAL3B1YnU0LzIAL3lsZ25idTQvMgAvZ25idTQvMgAvcmR5bGJ1NC8yAC9yZGJ1NC8yAC9hY2NlbnQ0LzIAL2dyZXlzNC8yAC9ncmVlbnM0LzIAL2JsdWVzNC8yAC9wdXJwbGVzNC8yAC9vcmFuZ2VzNC8yAC9yZWRzNC8yAC9wdW9yNC8yAC95bG9yYnI0LzIAL3B1YnVnbjQvMgAvYnVnbjQvMgAvcHJnbjQvMgAvcmR5bGduNC8yAC95bGduNC8yAC9zcGVjdHJhbDQvMgAvcGl5ZzQvMgAvYnJiZzQvMgAvcHVyZDQvMgAveWxvcnJkNC8yAC9vcnJkNC8yAC9wYWlyZWQ0LzIAL3NldDM0LzIAL3NldDI0LzIAL3Bhc3RlbDI0LzIAL2RhcmsyNC8yAC9zZXQxNC8yAC9wYXN0ZWwxNC8yAC9yZGd5My8yAC9idXB1My8yAC9yZHB1My8yAC9wdWJ1My8yAC95bGduYnUzLzIAL2duYnUzLzIAL3JkeWxidTMvMgAvcmRidTMvMgAvYWNjZW50My8yAC9ncmV5czMvMgAvZ3JlZW5zMy8yAC9ibHVlczMvMgAvcHVycGxlczMvMgAvb3JhbmdlczMvMgAvcmVkczMvMgAvcHVvcjMvMgAveWxvcmJyMy8yAC9wdWJ1Z24zLzIAL2J1Z24zLzIAL3ByZ24zLzIAL3JkeWxnbjMvMgAveWxnbjMvMgAvc3BlY3RyYWwzLzIAL3BpeWczLzIAL2JyYmczLzIAL3B1cmQzLzIAL3lsb3JyZDMvMgAvb3JyZDMvMgAvcGFpcmVkMy8yAC9zZXQzMy8yAC9zZXQyMy8yAC9wYXN0ZWwyMy8yAC9kYXJrMjMvMgAvc2V0MTMvMgAvcGFzdGVsMTMvMgAvcGFpcmVkMTIvMgAvc2V0MzEyLzIAL3JkZ3kxMS8yAC9yZHlsYnUxMS8yAC9yZGJ1MTEvMgAvcHVvcjExLzIAL3ByZ24xMS8yAC9yZHlsZ24xMS8yAC9zcGVjdHJhbDExLzIAL3BpeWcxMS8yAC9icmJnMTEvMgAvcGFpcmVkMTEvMgAvc2V0MzExLzIAL3JkZ3kxMC8yAC9yZHlsYnUxMC8yAC9yZGJ1MTAvMgAvcHVvcjEwLzIAL3ByZ24xMC8yAC9yZHlsZ24xMC8yAC9zcGVjdHJhbDEwLzIAL3BpeWcxMC8yAC9icmJnMTAvMgAvcGFpcmVkMTAvMgAvc2V0MzEwLzIAMS4yACAtZGFzaCAyAHN6ID49IDIAbGVuID49IDIAZGltID09IDIATkRfb3V0KHYpLnNpemUgPT0gMgBpdm9yeTEAZ3JleTEAZGFya3NsYXRlZ3JheTEAXHgxAHNub3cxAGxpZ2h0eWVsbG93MQBob25leWRldzEAbnNsaW1pdDEAd2hlYXQxAHN1cDEAbm9wMQB0b21hdG8xAHJvc3licm93bjEAbWFyb29uMQBsaWdodHNhbG1vbjEAbGVtb25jaGlmZm9uMQBsYXRpbjEAYWdvcGVuMQBzcHJpbmdncmVlbjEAZGFya29saXZlZ3JlZW4xAHBhbGVncmVlbjEAZGFya3NlYWdyZWVuMQBsaWdodGN5YW4xAHRhbjEAcGx1bTEAc2Vhc2hlbGwxAGNvcmFsMQBob3RwaW5rMQBsaWdodHBpbmsxAGRlZXBwaW5rMQBjb3Juc2lsazEAZmlyZWJyaWNrMQBqMCA8PSBpMSAmJiBpMSA8PSBqMQBraGFraTEAbGF2ZW5kZXJibHVzaDEAcGVhY2hwdWZmMQBiaXNxdWUxAGxpZ2h0c2t5Ymx1ZTEAZGVlcHNreWJsdWUxAGxpZ2h0Ymx1ZTEAY2FkZXRibHVlMQBkb2RnZXJibHVlMQBsaWdodHN0ZWVsYmx1ZTEAcm95YWxibHVlMQBzbGF0ZWJsdWUxAG5hdmFqb3doaXRlMQBhbnRpcXVld2hpdGUxAGNob2NvbGF0ZTEAY2hhcnRyZXVzZTEAbWlzdHlyb3NlMQBTcGFyc2VNYXRyaXhfbXVsdGlwbHlfZGVuc2UxAHBhbGV0dXJxdW9pc2UxAGF6dXJlMQBhcXVhbWFyaW5lMQB0aGlzdGxlMQBtZWRpdW1wdXJwbGUxAGRhcmtvcmFuZ2UxAGFyZ19lMCAmJiBhcmdfZTEAbGlnaHRnb2xkZW5yb2QxAGRhcmtnb2xkZW5yb2QxAGJ1cmx5d29vZDEAZ29sZDEAbWVkaXVtb3JjaGlkMQBkYXJrb3JjaGlkMQBwYWxldmlvbGV0cmVkMQBpbmRpYW5yZWQxAG9yYW5nZXJlZDEAb2xpdmVkcmFiMQBtYWdlbnRhMQBzaWVubmExAFx4RjEAXHhFMQBceEQxAFx4QzEAXHhCMQBceEExAGdyZXk5MQBncmF5OTEAXHg5MQBncmV5ODEAZ3JheTgxAFx4ODEAZ3JleTcxAGdyYXk3MQBncmV5NjEAZ3JheTYxAGdyZXk1MQBncmF5NTEAZ3JleTQxAGdyYXk0MQBncmV5MzEAZ3JheTMxAGdyZXkyMQBncmF5MjEAZ3JleTExAGdyYXkxMQBceDExAC9wYWlyZWQxMi8xMQAvc2V0MzEyLzExAC9yZGd5MTEvMTEAL3JkeWxidTExLzExAC9yZGJ1MTEvMTEAL3B1b3IxMS8xMQAvcHJnbjExLzExAC9yZHlsZ24xMS8xMQAvc3BlY3RyYWwxMS8xMQAvcGl5ZzExLzExAC9icmJnMTEvMTEAL3BhaXJlZDExLzExAC9zZXQzMTEvMTEAY3NbaV0tPnNsYWNrKCk+LTAuMDAwMDAwMQAvcmRneTkvMQAvYnVwdTkvMQAvcmRwdTkvMQAvcHVidTkvMQAveWxnbmJ1OS8xAC9nbmJ1OS8xAC9yZHlsYnU5LzEAL3JkYnU5LzEAL2dyZXlzOS8xAC9ncmVlbnM5LzEAL2JsdWVzOS8xAC9wdXJwbGVzOS8xAC9vcmFuZ2VzOS8xAC9yZWRzOS8xAC9wdW9yOS8xAC95bG9yYnI5LzEAL3B1YnVnbjkvMQAvYnVnbjkvMQAvcHJnbjkvMQAvcmR5bGduOS8xAC95bGduOS8xAC9zcGVjdHJhbDkvMQAvcGl5ZzkvMQAvYnJiZzkvMQAvcHVyZDkvMQAveWxvcnJkOS8xAC9vcnJkOS8xAC9wYWlyZWQ5LzEAL3NldDM5LzEAL3NldDE5LzEAL3Bhc3RlbDE5LzEAL3JkZ3k4LzEAL2J1cHU4LzEAL3JkcHU4LzEAL3B1YnU4LzEAL3lsZ25idTgvMQAvZ25idTgvMQAvcmR5bGJ1OC8xAC9yZGJ1OC8xAC9hY2NlbnQ4LzEAL2dyZXlzOC8xAC9ncmVlbnM4LzEAL2JsdWVzOC8xAC9wdXJwbGVzOC8xAC9vcmFuZ2VzOC8xAC9yZWRzOC8xAC9wdW9yOC8xAC95bG9yYnI4LzEAL3B1YnVnbjgvMQAvYnVnbjgvMQAvcHJnbjgvMQAvcmR5bGduOC8xAC95bGduOC8xAC9zcGVjdHJhbDgvMQAvcGl5ZzgvMQAvYnJiZzgvMQAvcHVyZDgvMQAveWxvcnJkOC8xAC9vcnJkOC8xAC9wYWlyZWQ4LzEAL3NldDM4LzEAL3NldDI4LzEAL3Bhc3RlbDI4LzEAL2RhcmsyOC8xAC9zZXQxOC8xAC9wYXN0ZWwxOC8xAC9yZGd5Ny8xAC9idXB1Ny8xAC9yZHB1Ny8xAC9wdWJ1Ny8xAC95bGduYnU3LzEAL2duYnU3LzEAL3JkeWxidTcvMQAvcmRidTcvMQAvYWNjZW50Ny8xAC9ncmV5czcvMQAvZ3JlZW5zNy8xAC9ibHVlczcvMQAvcHVycGxlczcvMQAvb3JhbmdlczcvMQAvcmVkczcvMQAvcHVvcjcvMQAveWxvcmJyNy8xAC9wdWJ1Z243LzEAL2J1Z243LzEAL3ByZ243LzEAL3JkeWxnbjcvMQAveWxnbjcvMQAvc3BlY3RyYWw3LzEAL3BpeWc3LzEAL2JyYmc3LzEAL3B1cmQ3LzEAL3lsb3JyZDcvMQAvb3JyZDcvMQAvcGFpcmVkNy8xAC9zZXQzNy8xAC9zZXQyNy8xAC9wYXN0ZWwyNy8xAC9kYXJrMjcvMQAvc2V0MTcvMQAvcGFzdGVsMTcvMQAvcmRneTYvMQAvYnVwdTYvMQAvcmRwdTYvMQAvcHVidTYvMQAveWxnbmJ1Ni8xAC9nbmJ1Ni8xAC9yZHlsYnU2LzEAL3JkYnU2LzEAL2FjY2VudDYvMQAvZ3JleXM2LzEAL2dyZWVuczYvMQAvYmx1ZXM2LzEAL3B1cnBsZXM2LzEAL29yYW5nZXM2LzEAL3JlZHM2LzEAL3B1b3I2LzEAL3lsb3JicjYvMQAvcHVidWduNi8xAC9idWduNi8xAC9wcmduNi8xAC9yZHlsZ242LzEAL3lsZ242LzEAL3NwZWN0cmFsNi8xAC9waXlnNi8xAC9icmJnNi8xAC9wdXJkNi8xAC95bG9ycmQ2LzEAL29ycmQ2LzEAL3BhaXJlZDYvMQAvc2V0MzYvMQAvc2V0MjYvMQAvcGFzdGVsMjYvMQAvZGFyazI2LzEAL3NldDE2LzEAL3Bhc3RlbDE2LzEAL3JkZ3k1LzEAL2J1cHU1LzEAL3JkcHU1LzEAL3B1YnU1LzEAL3lsZ25idTUvMQAvZ25idTUvMQAvcmR5bGJ1NS8xAC9yZGJ1NS8xAC9hY2NlbnQ1LzEAL2dyZXlzNS8xAC9ncmVlbnM1LzEAL2JsdWVzNS8xAC9wdXJwbGVzNS8xAC9vcmFuZ2VzNS8xAC9yZWRzNS8xAC9wdW9yNS8xAC95bG9yYnI1LzEAL3B1YnVnbjUvMQAvYnVnbjUvMQAvcHJnbjUvMQAvcmR5bGduNS8xAC95bGduNS8xAC9zcGVjdHJhbDUvMQAvcGl5ZzUvMQAvYnJiZzUvMQAvcHVyZDUvMQAveWxvcnJkNS8xAC9vcnJkNS8xAC9wYWlyZWQ1LzEAL3NldDM1LzEAL3NldDI1LzEAL3Bhc3RlbDI1LzEAL2RhcmsyNS8xAC9zZXQxNS8xAC9wYXN0ZWwxNS8xAC9yZGd5NC8xAC9idXB1NC8xAC9yZHB1NC8xAC9wdWJ1NC8xAC95bGduYnU0LzEAL2duYnU0LzEAL3JkeWxidTQvMQAvcmRidTQvMQAvYWNjZW50NC8xAC9ncmV5czQvMQAvZ3JlZW5zNC8xAC9ibHVlczQvMQAvcHVycGxlczQvMQAvb3JhbmdlczQvMQAvcmVkczQvMQAvcHVvcjQvMQAveWxvcmJyNC8xAC9wdWJ1Z240LzEAL2J1Z240LzEAL3ByZ240LzEAL3JkeWxnbjQvMQAveWxnbjQvMQAvc3BlY3RyYWw0LzEAL3BpeWc0LzEAL2JyYmc0LzEAL3B1cmQ0LzEAL3lsb3JyZDQvMQAvb3JyZDQvMQAvcGFpcmVkNC8xAC9zZXQzNC8xAC9zZXQyNC8xAC9wYXN0ZWwyNC8xAC9kYXJrMjQvMQAvc2V0MTQvMQAvcGFzdGVsMTQvMQAvcmRneTMvMQAvYnVwdTMvMQAvcmRwdTMvMQAvcHVidTMvMQAveWxnbmJ1My8xAC9nbmJ1My8xAC9yZHlsYnUzLzEAL3JkYnUzLzEAL2FjY2VudDMvMQAvZ3JleXMzLzEAL2dyZWVuczMvMQAvYmx1ZXMzLzEAL3B1cnBsZXMzLzEAL29yYW5nZXMzLzEAL3JlZHMzLzEAL3B1b3IzLzEAL3lsb3JicjMvMQAvcHVidWduMy8xAC9idWduMy8xAC9wcmduMy8xAC9yZHlsZ24zLzEAL3lsZ24zLzEAL3NwZWN0cmFsMy8xAC9waXlnMy8xAC9icmJnMy8xAC9wdXJkMy8xAC95bG9ycmQzLzEAL29ycmQzLzEAL3BhaXJlZDMvMQAvc2V0MzMvMQAvc2V0MjMvMQAvcGFzdGVsMjMvMQAvZGFyazIzLzEAL3NldDEzLzEAL3Bhc3RlbDEzLzEAL3BhaXJlZDEyLzEAL3NldDMxMi8xAC9yZGd5MTEvMQAvcmR5bGJ1MTEvMQAvcmRidTExLzEAL3B1b3IxMS8xAC9wcmduMTEvMQAvcmR5bGduMTEvMQAvc3BlY3RyYWwxMS8xAC9waXlnMTEvMQAvYnJiZzExLzEAL3BhaXJlZDExLzEAL3NldDMxMS8xAC9yZGd5MTAvMQAvcmR5bGJ1MTAvMQAvcmRidTEwLzEAL3B1b3IxMC8xAC9wcmduMTAvMQAvcmR5bGduMTAvMQAvc3BlY3RyYWwxMC8xAC9waXlnMTAvMQAvYnJiZzEwLzEAL3BhaXJlZDEwLzEAL3NldDMxMC8xAGxhdGluLTEASVNPXzg4NTktMQBJU084ODU5LTEASVNPLTg4NTktMQByMC0+aGVhcF9pbmRleCA+IC0xIHx8IHIxLT5oZWFwX2luZGV4ID4gLTEAbiA+IDEAaSA+PSAxAHEtPm4gPT0gMQBydHAtPnNwbGl0LlBhcnRpdGlvbnNbMF0ucGFydGl0aW9uW2ldID09IDAgfHwgcnRwLT5zcGxpdC5QYXJ0aXRpb25zWzBdLnBhcnRpdGlvbltpXSA9PSAxAGJ6LnNpemUgJSAzID09IDEAVHJlZV9lZGdlLnNpemUgPT0gTl9ub2RlcyAtIDEAZHRzaXplKGctPm5faWQpID09IG9zaXplICsgMQBuLT5jb3VudCArICgqbm4pLT5jb3VudCA9PSBOT0RFQ0FSRCArIDEAcnRwLT5zcGxpdC5QYXJ0aXRpb25zWzBdLmNvdW50WzBdICsgcnRwLT5zcGxpdC5QYXJ0aXRpb25zWzBdLmNvdW50WzFdID09IE5PREVDQVJEICsgMQBncmV5MABncmF5MABqc29uMAAjZjBmMGYwACNlMGUwZTAAeGItPnUucy5sb2NhdGVkID4gQUdYQlVGX0lOTElORV9TSVpFXzAAXDAAVDAAXHhGMABceEUwAFx4RDAAXHhDMABceEIwAFx4QTAAZ3JleTkwAGdyYXk5MABceDkwAGdyZXk4MABncmF5ODAAXHg4MAAjODA4MDgwAGdyZXk3MABncmF5NzAAY2N3cm90ID09IDAgfHwgY2N3cm90ID09IDkwIHx8IGNjd3JvdCA9PSAxODAgfHwgY2N3cm90ID09IDI3MABjd3JvdCA9PSAwIHx8IGN3cm90ID09IDkwIHx8IGN3cm90ID09IDE4MCB8fCBjd3JvdCA9PSAyNzAAZ3JleTYwAGdyYXk2MABncmV5NTAAZ3JheTUwAGdyZXk0MABncmF5NDAAci53aWR0aCgpPDFlNDAAZ3JleTMwAGdyYXkzMAAjMzAzMDMwAGdyZXkyMABncmF5MjAAZ3JleTEwAGdyYXkxMABceDEwACMxMDEwMTAAL3BhaXJlZDEyLzEwAC9zZXQzMTIvMTAAL3JkZ3kxMS8xMAAvcmR5bGJ1MTEvMTAAL3JkYnUxMS8xMAAvcHVvcjExLzEwAC9wcmduMTEvMTAAL3JkeWxnbjExLzEwAC9zcGVjdHJhbDExLzEwAC9waXlnMTEvMTAAL2JyYmcxMS8xMAAvcGFpcmVkMTEvMTAAL3NldDMxMS8xMAAvcmRneTEwLzEwAC9yZHlsYnUxMC8xMAAvcmRidTEwLzEwAC9wdW9yMTAvMTAAL3ByZ24xMC8xMAAvcmR5bGduMTAvMTAAL3NwZWN0cmFsMTAvMTAAL3BpeWcxMC8xMAAvYnJiZzEwLzEwAC9wYWlyZWQxMC8xMAAvc2V0MzEwLzEwADEyMDAAZ3JleTEwMABncmF5MTAwAElTTy1JUi0xMDAAMTAwMDAAJSFQUy1BZG9iZS0zLjAAOS4wLjAAbnogPiAwAGRpc3QgPiAwAHBhdGhjb3VudCA+IDAAd2d0ID4gMABuc2l0ZXMgPiAwAChydiA9PSAwKSB8fCAoTkRfb3JkZXIocnYpLU5EX29yZGVyKHYpKSpkaXIgPiAwAGxlbiA+IDAAcXQxLT5uID4gMCAmJiBxdDItPm4gPiAwAHdpZHRoID4gMABsaXN0LT5zaXplID4gMABzcGwtPnNpemUgPiAwAGJ6LnNpemUgPiAwAGdyYXBoLT53ZWlnaHRzW3hdID4gMABncmFwaC0+d2VpZ2h0c1tuX2VkZ2VzXSA+IDAAbSA+IDAgJiYgbiA+IDAgJiYgbnogPj0gMAByLT5oZWFwX2luZGV4ID49IDAAdCA+PSAwAG5Ob2RlR3JvdXBzID49IDAAbm5vZGVzID49IDAAbl9vYnMgPj0gMABwb2x5cC0+cG4gPj0gMABvYnNbcG9seV9pXS0+cG4gPj0gMABuLT5sZXZlbCA+PSAwAG9yaWdpbmFsID49IDAAUGFjayA+PSAwAGlpIDwgMTw8ZGltICYmIGlpID49IDAAd2lkdGggPj0gMABqZGlhZyA+PSAwAGlkaWFnID49IDAAcGJzX25baV0gPj0gMABvYmotPnVybF9ic3BsaW5lbWFwX25baV0gPj0gMABwYnNfblswXSA+PSAwAFYgPj0gMABhZ25ub2RlcyhncmFwaCkgPj0gMABvYmpwMS0+c3oueCA9PSAwICYmIG9ianAxLT5zei55ID09IDAAY19jbnQgPT0gMAByYW5rX3Jlc3VsdCA9PSAwAGdldHRpbWVvZmRheV9yZXMgPT0gMABqID09IDAATkRfaW4ocmlnaHQpLnNpemUgKyBORF9vdXQocmlnaHQpLnNpemUgPT0gMABkdHNpemUoZGVzdCkgPT0gMABkdHNpemUoZy0+Z19kaWN0KSA9PSAwAGR0c2l6ZShnLT5uX3NlcSkgPT0gMABkdHNpemUoZy0+ZV9zZXEpID09IDAAR0RfbWlucmFuayhnKSA9PSAwAGR0c2l6ZShnLT5uX2lkKSA9PSAwAGR0c2l6ZShnLT5lX2lkKSA9PSAwAGNvc3ggIT0gMCB8fCBzaW54ICE9IDAAcmVzdWx0ID09IChpbnQpKHNpemUgLSAxKSB8fCByZXN1bHQgPCAwAG1hc2tbaWldIDwgMABORF9oZWFwaW5kZXgodikgPCAwAFwvAFgxMS8AJS4qcy4Ac3BlY2lmaWVkIHJvb3Qgbm9kZSAiJXMiIHdhcyBub3QgZm91bmQuAEdyYXBoICVzIGhhcyBhcnJheSBwYWNraW5nIHdpdGggdXNlciB2YWx1ZXMgYnV0IG5vICJzb3J0diIgYXR0cmlidXRlcyBhcmUgZGVmaW5lZC4AMS4AJSFQUy1BZG9iZS0AJVBERi0APCEtLQAgLAB3KwAqAHN0cmVxKGFwdHItPnUubmFtZSxLZXkpAE5EX29yZGVyKHYpIDwgTkRfb3JkZXIodykAdSA9PSBVRl9maW5kKHUpACFwb2ludHNfaXNfZW1wdHkocGxpc3QpAG5wIDwgbm9kZWxpc3Rfc2l6ZShsaXN0KQBvbmUgPCBub2RlbGlzdF9zaXplKGxpc3QpACEocS0+cXRzKQAhaW50c19pc19lbXB0eSgmbGVhdmVzKQBkdHNpemUoZy0+bl9pZCkgPT0gZHRzaXplKGctPm5fc2VxKQBORF9yYW5rKGZyb20pIDwgTkRfcmFuayh0bykAbm90IHdlbGwtZm9ybWVkIChpbnZhbGlkIHRva2VuKQBhZ3N1YnJlcChnLG4pAG4gIT0gTkRfbmV4dChuKQBmaW5kX2Zhc3Rfbm9kZShnLCBuKQAobnVsbCkAKCFqY24pICYmICghdmFsKQAhKHEtPmwpAHN5bS0+aWQgPj0gMCAmJiBzeW0tPmlkIDwgdG9wZGljdHNpemUob2JqKQAhKCpmbGFnKQBTcGFyc2VNYXRyaXhfaXNfc3ltbWV0cmljKEEsIHRydWUpAHZhbHVlICYmIHN0cmxlbih2YWx1ZSkAU3BhcnNlTWF0cml4X2lzX3N5bW1ldHJpYyhBLCBmYWxzZSkARURfbGFiZWwoZmUpACFUUkVFX0VER0UoZSkAIWNvbnN0cmFpbmluZ19mbGF0X2VkZ2UoZywgZSkAcl8lZCkAbF8lZCkAbW92ZSB0byAoJWQsICVkKQA7IHNwbGluZSB0byAoJWQsICVkKQA7IGxpbmUgdG8gKCVkLCAlZCkAKGxpYikAIVNwYXJzZU1hdHJpeF9oYXNfZGlhZ29uYWwoQSkAU3BhcnNlTWF0cml4X2tub3duX3N0cnVjdXJhbF9zeW1tZXRyaWMoQSkAIHNjYW5uaW5nIGEgSFRNTCBzdHJpbmcgKG1pc3NpbmcgJz4nPyBiYWQgbmVzdGluZz8gbG9uZ2VyIHRoYW4gJWQ/KQAgc2Nhbm5pbmcgYSBxdW90ZWQgc3RyaW5nIChtaXNzaW5nIGVuZHF1b3RlPyBsb25nZXIgdGhhbiAlZD8pACBzY2FubmluZyBhIC8qLi4uKi8gY29tbWVudCAobWlzc2luZyAnKi8/IGxvbmdlciB0aGFuICVkPykAZmFsbGJhY2soNCkAYWd0YWlsKGUpID09IFVGX2ZpbmQoYWd0YWlsKGUpKQBhZ2hlYWQoZSkgPT0gVUZfZmluZChhZ2hlYWQoZSkpAG91dCBvZiBkeW5hbWljIG1lbW9yeSBpbiB5eV9nZXRfbmV4dF9idWZmZXIoKQBvdXQgb2YgZHluYW1pYyBtZW1vcnkgaW4geXlfY3JlYXRlX2J1ZmZlcigpAG91dCBvZiBkeW5hbWljIG1lbW9yeSBpbiB5eWVuc3VyZV9idWZmZXJfc3RhY2soKQBzZXRsaW5ld2lkdGgoACkgcm90YXRlKCVkKSB0cmFuc2xhdGUoACB0cmFuc2Zvcm09InNjYWxlKABOT1RBVElPTigAICgAIG5lYXIgJyVzJwAlbGYsJWxmLCVsZiwnJVteJ10nACYAJQAkAHVybCgjADx0ZXh0UGF0aCB4bGluazpocmVmPSIjADxhcmVhIHNoYXBlPSJwb2x5IgAgZmlsbD0iIyUwMnglMDJ4JTAyeCIAYm94ZXMuc2l6ZSA8PSAoc2l6ZV90KUlOVF9NQVggJiYgImludGVnZXIgb3ZlcmZsb3ciAChzZXEgJiBTRVFfTUFTSykgPT0gc2VxICYmICJzZXF1ZW5jZSBJRCBvdmVyZmxvdyIAZ3Zfc29ydF9jb21wYXIgPT0gTlVMTCAmJiBndl9zb3J0X2FyZyA9PSBOVUxMICYmICJ1bnN1cHBvcnRlZCByZWN1cnNpdmUgY2FsbCB0byBndl9zb3J0IgBndl9zb3J0X2NvbXBhciAhPSBOVUxMICYmICJubyBjb21wYXJhdG9yIHNldCBpbiBndl9zb3J0IgBvcC0+b3AudS5wb2x5Z29uLmNudCA8PSBJTlRfTUFYICYmICJwb2x5Z29uIGNvdW50IGV4Y2VlZHMgZ3ZyZW5kZXJfcG9seWdvbiBzdXBwb3J0IgBvcC0+b3AudS5iZXppZXIuY250IDw9IElOVF9NQVggJiYgInBvbHlnb24gY291bnQgZXhjZWVkcyBndnJlbmRlcl9iZWl6ZXJjdXJ2ZSBzdXBwb3J0IgBvcC0+b3AudS5wb2x5bGluZS5jbnQgPD0gSU5UX01BWCAmJiAicG9seWdvbiBjb3VudCBleGNlZWRzIGd2cmVuZGVyX3BvbHlsaW5lIHN1cHBvcnQiACB0ZXh0LWFuY2hvcj0ic3RhcnQiAGZ1bGxfbGVuZ3RoX3dpdGhvdXRfc2hhZnQgPiAwICYmICJub24tcG9zaXRpdmUgZnVsbCBsZW5ndGggd2l0aG91dCBzaGFmdCIAPGFyZWEgc2hhcGU9InJlY3QiAHNpemUgPiAwICYmICJhdHRlbXB0IHRvIGFsbG9jYXRlIGFycmF5IG9mIDAtc2l6ZWQgZWxlbWVudHMiAGluZGV4IDwgc2VsZi0+c2l6ZV9iaXRzICYmICJvdXQgb2YgYm91bmRzIGFjY2VzcyIAaW5kZXggPCBzZWxmLnNpemVfYml0cyAmJiAib3V0IG9mIGJvdW5kcyBhY2Nlc3MiACpzMSAhPSAqczIgJiYgImR1cGxpY2F0ZSBzZXBhcmF0b3IgY2hhcmFjdGVycyIAR0RfbWlucmFuayhzdWJnKSA8PSBHRF9tYXhyYW5rKHN1YmcpICYmICJjb3JydXB0ZWQgcmFuayBib3VuZHMiAGluZGV4IDwgbGlzdC0+c2l6ZSAmJiAiaW5kZXggb3V0IG9mIGJvdW5kcyIAICgrJTZkIGJ5dGVzICVzfCVkLCB4bWxwYXJzZS5jOiVkKSAlKnMiACBmb250LWZhbWlseT0iJXMiACBmb250LXdlaWdodD0iJXMiACBmaWxsPSIlcyIAIGZvbnQtc3RyZXRjaD0iJXMiACBmb250LXN0eWxlPSIlcyIAYmFkIGVkZ2UgbGVuICIlcyIAIGJhc2VsaW5lLXNoaWZ0PSJzdXBlciIAYWd4Ymxlbih4YikgPD0gc2l6ZW9mKHhiLT51LnN0b3JlKSAmJiAiYWd4YnVmIGNvcnJ1cHRpb24iAGZ1bGxfbGVuZ3RoID4gMCAmJiAibm9uLXBvc2l0aXZlIGZ1bGwgbGVuZ3RoIgBmdWxsX2Jhc2Vfd2lkdGggPiAwICYmICJub24tcG9zaXRpdmUgZnVsbCBiYXNlIHdpZHRoIgBub21pbmFsX2Jhc2Vfd2lkdGggPiAwICYmICJub24tcG9zaXRpdmUgbm9taW5hbCBiYXNlIHdpZHRoIgAiIHdpZHRoPSIlZ3B4IiBoZWlnaHQ9IiVncHgiIHByZXNlcnZlQXNwZWN0UmF0aW89InhNaW5ZTWluIG1lZXQiIHg9IiVnIiB5PSIlZyIAIiB3aWR0aD0iJWdweCIgaGVpZ2h0PSIlZ3B4IiBwcmVzZXJ2ZUFzcGVjdFJhdGlvPSJ4TWlkWU1pZCBtZWV0IiB4PSIlZyIgeT0iJWciACBmb250LXNpemU9IiUuMmYiACB2aWV3Qm94PSIlLjJmICUuMmYgJS4yZiAlLjJmIgAgZmlsbC1vcGFjaXR5PSIlZiIAKHhiLT51LnMubG9jYXRlZCA9PSBBR1hCVUZfT05fSEVBUCB8fCB4Yi0+dS5zLmxvY2F0ZWQgPT0gQUdYQlVGX09OX1NUQUNLIHx8IHhiLT51LnMubG9jYXRlZCA8PSBzaXplb2YoeGItPnUuc3RvcmUpKSAmJiAiY29ycnVwdGVkIGFneGJ1ZiB0eXBlIgAgdGV4dC1hbmNob3I9Im1pZGRsZSIAPGFyZWEgc2hhcGU9ImNpcmNsZSIAb2xkX25tZW1iIDwgU0laRV9NQVggLyBzaXplICYmICJjbGFpbWVkIHByZXZpb3VzIGV4dGVudCBpcyB0b28gbGFyZ2UiAHRoZXRhID49IDAgJiYgdGhldGEgPD0gTV9QSSAmJiAidGhldGEgb3V0IG9mIHJhbmdlIgAgdGV4dC1hbmNob3I9ImVuZCIAIGZvbnQtd2VpZ2h0PSJib2xkIgAgZm9udC1zdHlsZT0iaXRhbGljIgAgYmFzZWxpbmUtc2hpZnQ9InN1YiIAXCIAbGxlbiA8PSAoc2l6ZV90KUlOVF9NQVggJiYgIlhNTCB0b2tlbiB0b28gbG9uZyBmb3IgZXhwYXQgQVBJIgAiIHJ5PSIAX3AiIHN0YXJ0T2Zmc2V0PSI1MCUiPjx0c3BhbiB4PSIwIiBkeT0iACIgY3k9IgAiIHk9IgAiIHJ4PSIAIGN4PSIAIHg9IgAgdGFyZ2V0PSIAIHBvaW50cz0iACBjb29yZHM9IgAgdGV4dC1kZWNvcmF0aW9uPSIAIGZpbGw9IgAiIHN0cm9rZS13aWR0aD0iADxpbWFnZSB4bGluazpocmVmPSIAPD94bWwtc3R5bGVzaGVldCBocmVmPSIAIiBuYW1lPSIAIHhsaW5rOnRpdGxlPSIAIHRpdGxlPSIAIiBzdHJva2U9IgA8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSIAPGRlZnM+CjxyYWRpYWxHcmFkaWVudCBpZD0iADxtYXAgaWQ9IgA8ZyBpZD0iACBkPSIAIiB5Mj0iACIgeDI9IgAiIHkxPSIAeDE9IgAgdHJhbnNmb3JtPSJyb3RhdGUoJWQgJWcgJWcpIgBhZ3hibGVuKCZTYnVmKSA9PSAwICYmICJwZW5kaW5nIHN0cmluZyBkYXRhIHRoYXQgd2FzIG5vdCBjb25zdW1lZCAobWlzc2luZyAiICJlbmRzdHIoKS9lbmRodG1sc3RyKCk/KSIAIGFsdD0iIgBDeWNsZSBFcnJvciEAUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEAPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIgogImh0dHA6Ly93d3cudzMub3JnL0dyYXBoaWNzL1NWRy8xLjEvRFREL3N2ZzExLmR0ZCI+CjwhLS0gR2VuZXJhdGVkIGJ5IAB0ICV1IAAgY3JlYXRlIHRleHQgAHhMYXlvdXQgAGRlZmF1bHQgAHN0cmljdCAAJXMlenUgLSVzIAAgLXNtb290aCBiZXppZXIgACBtb3ZldG8gACB2ZXJzaW9uIAAgY3JlYXRlIHBvbHlnb24gACAtdGV4dCB7JXN9IC1maWxsIAAgY3JlYXRlIG92YWwgACAtd2lkdGggAG5ld3BhdGggAGdyYXBoIABzLCUuNWcsJS41ZyAAJS41ZywlLjVnLCUuNWcsJS41ZyAAZSwlLjVnLCUuNWcgACVnICVnIAAlLjAzbGYgACUuM2YgACAtb3V0bGluZSAAIGNyZWF0ZSBsaW5lIABub2RlIAAlZCAlZCAlZCAlZCAlZCAlZCAlLjFmICUuNGYgJWQgJS4xZiAlLjFmICVkICVkIAAlYyAlZCAAVG90YWwgc2l6ZSA+IDEgaW4gIiVzIiBjb2xvciBzcGVjIABbIC9SZWN0IFsgAFQgAFMgAE9QRU4gAEkgAEYgAEUgAEMgACAtPiAAUmFuayBzZXBhcmF0aW9uID0gAG5ldHdvcmsgc2ltcGxleDogAFVuc2F0aXNmaWVkIGNvbnN0cmFpbnQ6IABDYWxjdWxhdGluZyBzaG9ydGVzdCBwYXRoczogACVzOiAAU29sdmluZyBtb2RlbDogAFNldHRpbmcgdXAgc3ByaW5nIG1vZGVsOiAAY29udmVydCBncmFwaDogACBUaXRsZTogACJ0ZXh0IjogAHsiZnJhYyI6ICUuMDNmLCAiY29sb3IiOiAAIm5hbWUiOiAAInN0eWxlIjogACJmYWNlIjogADIgADwhLS0gACAtLSAAJSAAX3AiIABsXyVkIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgAA0gICAgICAgICAgICAgICAgaXRlciA9ICVkLCBzdGVwID0gJWYgRm5vcm0gPSAlZiBueiA9ICVkICBLID0gJWYgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgAAogICAgADoJIAAgICAgJXN9CgB0cnlpbmcgdG8gYWRkIHRvIHJlY3QgeyVmICsvLSAlZiwgJWYgKy8tICVmfQoAI2RlZmF1bHQgeyBmaW5pc2ggeyBhbWJpZW50IDAuMSBkaWZmdXNlIDAuOSB9IH0KAHBpZ21lbnQgeyBjb2xvciAlcyB9CgBsaWdodF9zb3VyY2UgeyA8MTUwMCwzMDAwLC0yNTAwPiBjb2xvciBXaGl0ZSB9CgBnbG9iYWxfc2V0dGluZ3MgeyBhc3N1bWVkX2dhbW1hIDEuMCB9CgAgICAgdGV4dHVyZSBJbWFnZVRleHR1cmUgeyB1cmwgIiVzIiB9CgAgICAgfQoALy9za3kKcGxhbmUgeyA8MCwgMSwgMD4sIDEgaG9sbG93CiAgICB0ZXh0dXJlIHsKICAgICAgICBwaWdtZW50IHsgYm96byB0dXJidWxlbmNlIDAuOTUKICAgICAgICAgICAgY29sb3JfbWFwIHsKICAgICAgICAgICAgICAgIFswLjAwIHJnYiA8MC4wNSwgMC4yMCwgMC41MD5dCiAgICAgICAgICAgICAgICBbMC41MCByZ2IgPDAuMDUsIDAuMjAsIDAuNTA+XQogICAgICAgICAgICAgICAgWzAuNzUgcmdiIDwxLjAwLCAxLjAwLCAxLjAwPl0KICAgICAgICAgICAgICAgIFswLjc1IHJnYiA8MC4yNSwgMC4yNSwgMC4yNT5dCiAgICAgICAgICAgICAgICBbMS4wMCByZ2IgPDAuNTAsIDAuNTAsIDAuNTA+XQogICAgICAgICAgICB9CiAgICAgICAgICAgIHNjYWxlIDwxLjAwLCAxLjAwLCAxLjUwPiAqIDIuNTAKICAgICAgICAgICAgdHJhbnNsYXRlIDwwLjAwLCAwLjAwLCAwLjAwPgogICAgICAgIH0KICAgICAgICBmaW5pc2ggeyBhbWJpZW50IDEgZGlmZnVzZSAwIH0KICAgIH0KICAgIHNjYWxlIDEwMDAwCn0KLy9taXN0CmZvZyB7IGZvZ190eXBlIDIKICAgIGRpc3RhbmNlIDUwCiAgICBjb2xvciByZ2IgPDEuMDAsIDEuMDAsIDEuMDA+ICogMC43NQogICAgZm9nX29mZnNldCAwLjEwCiAgICBmb2dfYWx0IDEuNTAKICAgIHR1cmJ1bGVuY2UgMS43NQp9Ci8vZ25kCnBsYW5lIHsgPDAuMDAsIDEuMDAsIDAuMDA+LCAwCiAgICB0ZXh0dXJlIHsKICAgICAgICBwaWdtZW50eyBjb2xvciByZ2IgPDAuMjUsIDAuNDUsIDAuMDA+IH0KICAgICAgICBub3JtYWwgeyBidW1wcyAwLjc1IHNjYWxlIDAuMDEgfQogICAgICAgIGZpbmlzaCB7IHBob25nIDAuMTAgfQogICAgfQp9CgBjYW1lcmEgeyBsb2NhdGlvbiA8JS4zZiAsICUuM2YgLCAtNTAwLjAwMD4KICAgICAgICAgbG9va19hdCAgPCUuM2YgLCAlLjNmICwgMC4wMDA+CiAgICAgICAgIHJpZ2h0IHggKiBpbWFnZV93aWR0aCAvIGltYWdlX2hlaWdodAogICAgICAgICBhbmdsZSAlLjNmCn0KACAgICBtYXRlcmlhbCBNYXRlcmlhbCB7CgBTaGFwZSB7CgAgIGFwcGVhcmFuY2UgQXBwZWFyYW5jZSB7CgAvdXNlcl9zaGFwZV8lZCB7CgBncmFwaCBHIHsKAGFycm93aGVhZCA9IDcgJXMgbm90IHVzZWQgYnkgZ3JhcGh2aXoKAGJveHJhZCA9IDAgJXMgbm8gcm91bmRlZCBjb3JuZXJzIGluIGdyYXBodml6CgBvdXQgb2YgbWVtb3J5CgAlczogY291bGQgbm90IGFsbG9jYXRlIG1lbW9yeQoAR3JhcGh2aXogYnVpbHQgd2l0aG91dCBhbnkgdHJpYW5ndWxhdGlvbiBsaWJyYXJ5CgByZW1vdmVfb3ZlcmxhcDogR3JhcGh2aXogbm90IGJ1aWx0IHdpdGggdHJpYW5ndWxhdGlvbiBsaWJyYXJ5CgAlcyBmaWxsIGhhcyBubyBtZWFuaW5nIGluIERXQiAyLCBncGljIGNhbiB1c2UgZmlsbCBvciBmaWxsZWQsIDEwdGggRWRpdGlvbiB1c2VzIGZpbGwgb25seQoAYm94cmFkPTIuMCAlcyB3aWxsIGJlIHJlc2V0IHRvIDAuMCBieSBncGljIG9ubHkKAGluIGNoZWNrcGF0aCwgc3RhcnQgcG9ydCBub3QgaW4gZmlyc3QgYm94CgBpbiBjaGVja3BhdGgsIGVuZCBwb3J0IG5vdCBpbiBsYXN0IGJveAoAJWQgJWQgIyUwMnglMDJ4JTAyeAoASGVhcCBvdmVyZmxvdwoAdGV4dCB7CiAgICB0dGYgIiVzIiwKICAgICIlcyIsICUuM2YsICUuM2YKICAgICAgICBub19zaGFkb3cKAHRvdGFsIGFkZGVkIHNvIGZhciA9ICV6dQoAcm9vdCA9ICVzIG1heCBzdGVwcyB0byByb290ID0gJWxsdQoALnBzICUuMGYqXG4oU0Z1LyUuMGZ1CgAgIG1hcmdpbiAldQoAICVzIGFsaWduZWR0ZXh0CgBsYXllcnMgbm90IHN1cHBvcnRlZCBpbiAlcyBvdXRwdXQKAGFkZF90cmVlX2VkZ2U6IGVtcHR5IG91dGVkZ2UgbGlzdAoAYWRkX3RyZWVfZWRnZTogZW1wdHkgaW5lZGdlIGxpc3QKAE5vIGxpYnogc3VwcG9ydAoAJXMgLlBTIHcvbyBhcmdzIGNhdXNlcyBHTlUgcGljIHRvIHNjYWxlIGRyYXdpbmcgdG8gZml0IDguNXgxMSBwYXBlcjsgRFdCIGRvZXMgbm90CgAlcyBHTlUgcGljIHN1cHBvcnRzIGEgbGluZXRoaWNrIHZhcmlhYmxlIHRvIHNldCBsaW5lIHRoaWNrbmVzczsgRFdCIGFuZCAxMHRoIEVkLiBkbyBub3QKACVzIEdOVSBwaWMgc3VwcG9ydHMgYSBib3hyYWQgdmFyaWFibGUgdG8gZHJhdyBib3hlcyB3aXRoIHJvdW5kZWQgY29ybmVyczsgRFdCIGFuZCAxMHRoIEVkLiBkbyBub3QKACAvJXMgc2V0X2ZvbnQKACVzJS4qcyBpcyBub3QgYSB0cm9mZiBmb250CgB1bmV4cGVjdGVkIGNhc2UgaW4gbG9jYXRlX2VuZHBvaW50CgBjZWxsIHNpemUgdG9vIHNtYWxsIGZvciBjb250ZW50CgB0YWJsZSBzaXplIHRvbyBzbWFsbCBmb3IgY29udGVudAoAJSVFbmREb2N1bWVudAoAVW5jbG9zZWQgY29tbWVudAoATGFiZWwgY2xvc2VkIGJlZm9yZSBlbmQgb2YgSFRNTCBlbGVtZW50CgBQb3J0cmFpdAoAZml4ZWQgY2VsbCBzaXplIHdpdGggdW5zcGVjaWZpZWQgd2lkdGggb3IgaGVpZ2h0CgBmaXhlZCB0YWJsZSBzaXplIHdpdGggdW5zcGVjaWZpZWQgd2lkdGggb3IgaGVpZ2h0CgBwb3MgYXR0cmlidXRlIGZvciBlZGdlICglcywlcykgZG9lc24ndCBoYXZlIDNuKzEgcG9pbnRzCgAgIGdlbmVyYXRlZCAlZCBjb25zdHJhaW50cwoAc3BsaW5lcyBhbmQgY2x1c3RlciBlZGdlcyBub3Qgc3VwcG9ydGVkIC0gdXNpbmcgbGluZSBzZWdtZW50cwoAb2JqZWN0cwoAV2FybmluZzogbm9kZSAlcywgcG9zaXRpb24gJXMsIGV4cGVjdGVkIHR3byBmbG9hdHMKAGRvdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBhc3BlY3QgYXR0cmlidXRlIGZvciBkaXNjb25uZWN0ZWQgZ3JhcGhzIG9yIGdyYXBocyB3aXRoIGNsdXN0ZXJzCgBjYW5ub3QgYWxsb2NhdGUgcHMKAHNjYWxlPTEuMCAlcyByZXF1aXJlZCBmb3IgY29tcGFyaXNvbnMKAFNldHRpbmcgaW5pdGlhbCBwb3NpdGlvbnMKACVzIERXQiAyIGNvbXBhdGliaWxpdHkgZGVmaW5pdGlvbnMKAGFycmF5IHBhY2tpbmc6ICVzICVkIHJvd3MgJWQgY29sdW1ucwoAc3ludGF4IGFtYmlndWl0eSAtIGJhZGx5IGRlbGltaXRlZCBudW1iZXIgJyVzJyBpbiBsaW5lICVkIG9mICVzIHNwbGl0cyBpbnRvIHR3byB0b2tlbnMKAGVkZ2UgbGFiZWxzIHdpdGggc3BsaW5lcz1jdXJ2ZWQgbm90IHN1cHBvcnRlZCBpbiBkb3QgLSB1c2UgeGxhYmVscwoAZmxhdCBlZGdlIGJldHdlZW4gYWRqYWNlbnQgbm9kZXMgb25lIG9mIHdoaWNoIGhhcyBhIHJlY29yZCBzaGFwZSAtIHJlcGxhY2UgcmVjb3JkcyB3aXRoIEhUTUwtbGlrZSBsYWJlbHMKAG91dCBvZiBtZW1vcnkgd2hlbiB0cnlpbmcgdG8gYWxsb2NhdGUgJXp1IGJ5dGVzCgBpbnRlZ2VyIG92ZXJmbG93IHdoZW4gdHJ5aW5nIHRvIGFsbG9jYXRlICV6dSAqICV6dSBieXRlcwoAdXBkYXRlOiBtaXNtYXRjaGVkIGxjYSBpbiB0cmVldXBkYXRlcwoAZ3JhcGggJXMsIGNvb3JkICVzLCBleHBlY3RlZCBmb3VyIGRvdWJsZXMKAG5vZGUgJXMsIHBvc2l0aW9uICVzLCBleHBlY3RlZCB0d28gZG91YmxlcwoARm91bmQgJWQgRGlHLUNvTGEgYm91bmRhcmllcwoASW5jaGVzCgAoJTR6dSkgJTd6dSBub2RlcyAlN3p1IGVkZ2VzCgBjb21wb3VuZEVkZ2VzOiBjb3VsZCBub3QgY29uc3RydWN0IG9ic3RhY2xlcyAtIGZhbGxpbmcgYmFjayB0byBzdHJhaWdodCBsaW5lIGVkZ2VzCgB0aGUgYm91bmRpbmcgYm94ZXMgb2Ygc29tZSBub2RlcyB0b3VjaCAtIGZhbGxpbmcgYmFjayB0byBzdHJhaWdodCBsaW5lIGVkZ2VzCgBjb21wb3VuZEVkZ2VzOiBub2RlcyB0b3VjaCAtIGZhbGxpbmcgYmFjayB0byBzdHJhaWdodCBsaW5lIGVkZ2VzCgBzb21lIG5vZGVzIHdpdGggbWFyZ2luICglLjAyZiwlLjAyZikgdG91Y2ggLSBmYWxsaW5nIGJhY2sgdG8gc3RyYWlnaHQgbGluZSBlZGdlcwoAbWVyZ2UyOiBncmFwaCAlcywgcmFuayAlZCBoYXMgb25seSAlZCA8ICVkIG5vZGVzCgBTY2FubmluZyBncmFwaCAlcywgJWQgbm9kZXMKAFdhcm5pbmc6IG5vIGhhcmQtY29kZWQgbWV0cmljcyBmb3IgJyVzJy4gIEZhbGxpbmcgYmFjayB0byAnVGltZXMnIG1ldHJpY3MKAGluIGVkZ2UgJXMlcyVzCgBVc2luZyAlczogJXM6JXMKAEZvcm1hdDogIiVzIiBub3QgcmVjb2duaXplZC4gVXNlIG9uZSBvZjolcwoATGF5b3V0IHR5cGU6ICIlcyIgbm90IHJlY29nbml6ZWQuIFVzZSBvbmUgb2Y6JXMKAGxheW91dCAlcwoALmZ0ICVzCgBiYWQgbGFiZWwgZm9ybWF0ICVzCgBpbiByb3V0ZXNwbGluZXMsIGVkZ2UgaXMgYSBsb29wIGF0ICVzCgAgICAgICAgJTdkIG5vZGVzICU3ZCBlZGdlcyAlN3p1IGNvbXBvbmVudHMgJXMKAGluIGxhYmVsIG9mIGVkZ2UgJXMgJXMgJXMKACAgRWRnZSAlcyAlcyAlcwoAb3J0aG8gJXMgJXMKAHBvbHlsaW5lICVzICVzCgBzcGxpbmUgJXMgJXMKAHJlY3RhbmdsZSAoJWQsJWQpICglZCwlZCkgJXMgJXMKAGluIGNsdXN0ZXIgJXMKACVzIHdhcyBhbHJlYWR5IGluIGEgcmFua3NldCwgZGVsZXRlZCBmcm9tIGNsdXN0ZXIgJXMKACVzIC0+ICVzOiB0YWlsIG5vdCBpbnNpZGUgdGFpbCBjbHVzdGVyICVzCgAlcyAtPiAlczogaGVhZCBpcyBpbnNpZGUgdGFpbCBjbHVzdGVyICVzCgBoZWFkIGNsdXN0ZXIgJXMgaW5zaWRlIHRhaWwgY2x1c3RlciAlcwoAaGVhZCBub2RlICVzIGluc2lkZSB0YWlsIGNsdXN0ZXIgJXMKACVzIC0+ICVzOiBoZWFkIG5vdCBpbnNpZGUgaGVhZCBjbHVzdGVyICVzCgAlcyAtPiAlczogdGFpbCBpcyBpbnNpZGUgaGVhZCBjbHVzdGVyICVzCgB0YWlsIGNsdXN0ZXIgJXMgaW5zaWRlIGhlYWQgY2x1c3RlciAlcwoAdGFpbCBub2RlICVzIGluc2lkZSBoZWFkIGNsdXN0ZXIgJXMKAFVuaGFuZGxlZCBhZGp1c3Qgb3B0aW9uICVzCgByZXBvc2l0aW9uICVzCgBubyBwb3NpdGlvbiBmb3IgZWRnZSB3aXRoIHhsYWJlbCAlcwoAbm8gcG9zaXRpb24gZm9yIGVkZ2Ugd2l0aCB0YWlsIGxhYmVsICVzCgBubyBwb3NpdGlvbiBmb3IgZWRnZSB3aXRoIGxhYmVsICVzCgBubyBwb3NpdGlvbiBmb3IgZWRnZSB3aXRoIGhlYWQgbGFiZWwgJXMKAC8vKioqIGJlZ2luX2dyYXBoICVzCgBNYXguIGl0ZXJhdGlvbnMgKCVkKSByZWFjaGVkIG9uIGdyYXBoICVzCgBDb3VsZCBub3QgcGFyc2UgIl9iYWNrZ3JvdW5kIiBhdHRyaWJ1dGUgaW4gZ3JhcGggJXMKAGluIGxhYmVsIG9mIGdyYXBoICVzCgBDcmVhdGluZyBlZGdlcyB1c2luZyAlcwoAQWRqdXN0aW5nICVzIHVzaW5nICVzCgAlcyB3aGlsZSBvcGVuaW5nICVzCgBkZXJpdmUgZ3JhcGggX2RnXyVkIG9mICVzCgAgXSAgJWQgdHJ1ZSAlcwoAIF0gICVkIGZhbHNlICVzCgBtYWtlUG9seTogdW5rbm93biBzaGFwZSB0eXBlICVzCgBtYWtlQWRkUG9seTogdW5rbm93biBzaGFwZSB0eXBlICVzCgB1c2luZyAlcyBmb3IgdW5rbm93biBzaGFwZSAlcwoAICBvY3RyZWUgc2NoZW1lICVzCgBjYW4ndCBvcGVuIGxpYnJhcnkgZmlsZSAlcwoAY2FuJ3QgZmluZCBsaWJyYXJ5IGZpbGUgJXMKAEJvdW5kaW5nQm94IG5vdCBmb3VuZCBpbiBlcHNmIGZpbGUgJXMKAGNvdWxkbid0IG9wZW4gZXBzZiBmaWxlICVzCgBjb3VsZG4ndCByZWFkIGZyb20gZXBzZiBmaWxlICVzCgBpbiBub2RlICVzCgBzaGFwZWZpbGUgbm90IHNldCBvciBub3QgZm91bmQgZm9yIGVwc2Ygbm9kZSAlcwoAaW4gbGFiZWwgb2Ygbm9kZSAlcwoAZW5kICVzCgByYW5raW5nOiBmYWlsdXJlIHRvIGNyZWF0ZSBzdHJvbmcgY29uc3RyYWludCBlZGdlIGJldHdlZW4gbm9kZXMgJXMgYW5kICVzCgBvb3BzLCBpbnRlcm5hbCBlcnJvcjogdW5oYW5kbGVkIGNvbG9yIHR5cGU9JWQgJXMKACVkICVkICVkICVkICVkICVkICVkICVkICVkICUuMWYgJWQgJWQgJWQgJWQgJWQgJWQKICVkICVzCgByb290ID0gJXMKAC8vKioqIHRleHRzcGFuOiAlcywgZm9udHNpemUgPSAlLjNmLCBmb250bmFtZSA9ICVzCgB0cmllcyA9ICVkLCBtb2RlID0gJXMKAC8vKioqIGNvbW1lbnQ6ICVzCgBmb250bmFtZTogIiVzIiByZXNvbHZlZCB0bzogJXMKACUlJSVQYWdlT3JpZW50YXRpb246ICVzCgBkZWxhdW5heV90cmlhbmd1bGF0aW9uOiAlcwoAZGVsYXVuYXlfdHJpOiAlcwoAZ3ZwcmludGY6ICVzCgBuZXN0aW5nIG5vdCBhbGxvd2VkIGluIHN0eWxlOiAlcwoAdW5tYXRjaGVkICcpJyBpbiBzdHlsZTogJXMKAHVubWF0Y2hlZCAnKCcgaW4gc3R5bGU6ICVzCgAlJSUlVGl0bGU6ICVzCgAlcyBUaXRsZTogJXMKACMgVGl0bGU6ICVzCgAvLyoqKiBiZWdpbl9ub2RlOiAlcwoAcmVhbGxvYyBmYWlsZWQ6ICVzCgBsaWIvcGF0aHBsYW4vJXM6JWQ6ICVzCgBncmlkKCVkLCVkKTogJXMKAENvdWxkIG5vdCBvcGVuICIlcyIgZm9yIHdyaXRpbmcgOiAlcwoAc3RhcnQgcG9ydDogKCUuNWcsICUuNWcpLCB0YW5nZW50IGFuZ2xlOiAlLjVnLCAlcwoAZW5kIHBvcnQ6ICglLjVnLCAlLjVnKSwgdGFuZ2VudCBhbmdsZTogJS41ZywgJXMKACBbJXp1XSAlcCBzZXQgJWQgKCUuMDJmLCUuMDJmKSAoJS4wMmYsJS4wMmYpICVzCgAlJSAlcwoAIyAlcwoAICBtb2RlICAgJXMKAGNvbmp1Z2F0ZV9ncmFkaWVudDogdW5leHBlY3RlZCBsZW5ndGggMCB2ZWN0b3IKACVzIHRvIGNoYW5nZSBkcmF3aW5nIHNpemUsIG11bHRpcGx5IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9uIHRoZSAuUFMgbGluZSBhYm92ZSBhbmQgdGhlIG51bWJlciBvbiB0aGUgdHdvIGxpbmVzIGJlbG93IChyb3VuZGVkIHRvIHRoZSBuZWFyZXN0IGludGVnZXIpIGJ5IGEgc2NhbGUgZmFjdG9yCgBhZGRfc2VnbWVudDogZXJyb3IKACUuNWcgJS41ZyAlLjVnICVzY29sb3IKADAgMCAwIGVkZ2Vjb2xvcgoAMC44IDAuOCAwLjggc2V0cmdiY29sb3IKADAgMCAxIHNldHJnYmNvbG9yCgAxIDAgMCBzZXRyZ2Jjb2xvcgoAMCAwIDAgc2V0cmdiY29sb3IKACVkICVkIHNldGxheWVyCgAvLyoqKiBlbmRfbGF5ZXIKAFVURi04IGlucHV0IHVzZXMgbm9uLUxhdGluMSBjaGFyYWN0ZXJzIHdoaWNoIGNhbm5vdCBiZSBoYW5kbGVkIGJ5IHRoaXMgUG9zdFNjcmlwdCBkcml2ZXIKAExldHRlcgoALy8qKiogYmVnaW5fY2x1c3RlcgoALy8qKiogZW5kX2NsdXN0ZXIKAHJlbW92aW5nIGVtcHR5IGNsdXN0ZXIKAENlbnRlcgoAV2FybmluZzogbm8gdmFsdWUgZm9yIHdpZHRoIG9mIG5vbi1BU0NJSSBjaGFyYWN0ZXIgJXUuIEZhbGxpbmcgYmFjayB0byB3aWR0aCBvZiBzcGFjZSBjaGFyYWN0ZXIKAGJhc2UgcmVmZXJlcgoAJSVQYWdlVHJhaWxlcgoAJSVUcmFpbGVyCgAvLyoqKiBiZXppZXIKACIlcyIgd2FzIG5vdCBmb3VuZCBhcyBhIGZpbGUgb3IgYXMgYSBzaGFwZSBsaWJyYXJ5IG1lbWJlcgoAc3RvcAoAIGN1cnZldG8KAG5ld3BhdGggJWQgJWQgbW92ZXRvCgAlZCAlZCBsaW5ldG8KACBsYXlvdXQ9bmVhdG8KAG5vZGUgJXMgaW4gZ3JhcGggJXMgaGFzIG5vIHBvc2l0aW9uCgAlcyBtYXhwc2h0IGFuZCBtYXhwc3dpZCBoYXZlIG5vIG1lYW5pbmcgaW4gRFdCIDIuMCwgc2V0IHBhZ2UgYm91bmRhcmllcyBpbiBncGljIGFuZCBpbiAxMHRoIEVkaXRpb24KACVzIGFycm93aGVhZCBoYXMgbm8gbWVhbmluZyBpbiBEV0IgMiwgYXJyb3doZWFkID0gNyBtYWtlcyBmaWxsZWQgYXJyb3doZWFkcyBpbiBncGljIGFuZCBpbiAxMHRoIEVkaXRpb24KACVzIGFycm93aGVhZCBpcyB1bmRlZmluZWQgaW4gRFdCIDIsIGluaXRpYWxseSAxIGluIGdwaWMsIDIgaW4gMTB0aCBFZGl0aW9uCgBtYWpvcml6YXRpb24KAC8vKioqIHBvbHlnb24KAHNmZHAgb25seSBzdXBwb3J0cyBzdGFydD1yYW5kb20KAG5vZGUgcG9zaXRpb25zIGFyZSBpZ25vcmVkIHVubGVzcyBzdGFydD1yYW5kb20KAGNsb3NlcGF0aCBmaWxsCgAgZWxsaXBzZV9wYXRoIGZpbGwKACVmICVmICVmICVmIGNlbGwKACAgJWQgJWQgY2VsbAoAZ3JhcGggJXMgaXMgZGlzY29ubmVjdGVkLiBIZW5jZSwgdGhlIGNpcmN1aXQgbW9kZWwKAGdyYXBoIGlzIGRpc2Nvbm5lY3RlZC4gSGVuY2UsIHRoZSBjaXJjdWl0IG1vZGVsCgBlZGdlcyBpbiBncmFwaCAlcyBoYXZlIG5vIGxlbiBhdHRyaWJ1dGUuIEhlbmNlLCB0aGUgbWRzIG1vZGVsCgBjaXJjdWl0IG1vZGVsIG5vdCB5ZXQgc3VwcG9ydGVkIGluIEdtb2RlPXNnZCwgcmV2ZXJ0aW5nIHRvIHNob3J0cGF0aCBtb2RlbAoAbWRzIG1vZGVsIG5vdCB5ZXQgc3VwcG9ydGVkIGluIEdtb2RlPXNnZCwgcmV2ZXJ0aW5nIHRvIHNob3J0cGF0aCBtb2RlbAoAbm9kZSAnJXMnLCBncmFwaCAnJXMnIHNpemUgdG9vIHNtYWxsIGZvciBsYWJlbAoAJXMgRFdCIDIgZG9lc24ndCB1c2UgZmlsbCBhbmQgZG9lc24ndCBkZWZpbmUgZmlsbHZhbAoAWyB7Q2F0YWxvZ30gPDwgL1VSSSA8PCAvQmFzZSAlcyA+PiA+PgovUFVUIHBkZm1hcmsKAFsgL0Nyb3BCb3ggWyVkICVkICVkICVkXSAvUEFHRVMgcGRmbWFyawoAICAvQm9yZGVyIFsgMCAwIDAgXQogIC9BY3Rpb24gPDwgL1N1YnR5cGUgL1VSSSAvVVJJICVzID4+CiAgL1N1YnR5cGUgL0xpbmsKL0FOTiBwZGZtYXJrCgB0cm91YmxlIGluIGluaXRfcmFuawoAbGluZXRoaWNrID0gMDsgb2xkbGluZXRoaWNrID0gbGluZXRoaWNrCgAgc2V0bGluZXdpZHRoCgBnc2F2ZQolZCAlZCAlZCAlZCBib3hwcmltIGNsaXAgbmV3cGF0aAoAZ3NhdmUgJWcgJWcgdHJhbnNsYXRlIG5ld3BhdGgKAC8vKioqIGVuZF9ncmFwaAoAbGF5b3V0IGF0dHJpYnV0ZSBpcyBpbnZhbGlkIGV4Y2VwdCBvbiB0aGUgcm9vdCBncmFwaAoAaW4gY2hlY2twYXRoLCBib3hlcyAlZCBhbmQgJWQgZG9uJ3QgdG91Y2gKAG1lcmdlX29uZXdheSBnbGl0Y2gKACVzIGRvbid0IGNoYW5nZSBhbnl0aGluZyBiZWxvdyB0aGlzIGxpbmUgaW4gdGhpcyBkcmF3aW5nCgBOb2RlIG5vdCBhZGphY2VudCB0byBjZWxsIC0tIEFib3J0aW5nCgBpbmNvbXBhcmFibGUgc2VnbWVudHMgISEgLS0gQWJvcnRpbmcKAEFsdGVybmF0aXZlbHksIGNvbnNpZGVyIHJ1bm5pbmcgbmVhdG8gdXNpbmcgLUdwYWNrPXRydWUgb3IgZGVjb21wb3NpbmcKAGxhYmVsX3NjaGVtZSA9ICVkID4gNCA6IGlnbm9yaW5nCgBndnJlbmRlcl9zZXRfc3R5bGU6IHVuc3VwcG9ydGVkIHN0eWxlICVzIC0gaWdub3JpbmcKAEFycm93IHR5cGUgIiVzIiB1bmtub3duIC0gaWdub3JpbmcKAGZkcCBkb2VzIG5vdCBzdXBwb3J0IHN0YXJ0PXNlbGYgLSBpZ25vcmluZwoAJXMgYXR0cmlidXRlIHZhbHVlIG11c3QgYmUgMSBvciAyIC0gaWdub3JpbmcKAE1vcmUgdGhhbiAyIGNvbG9ycyBzcGVjaWZpZWQgZm9yIGEgZ3JhZGllbnQgLSBpZ25vcmluZyByZW1haW5pbmcKAGFzIHJlcXVpcmVkIGJ5IHRoZSAtbiBmbGFnCgBiYlslc10gJS41ZyAlLjVnICUuNWcgJS41ZwoAY29tYmlBUiA9ICVsZgoAL3BhdGhib3ggewogICAgL1kgZXhjaCAlLjVnIHN1YiBkZWYKICAgIC9YIGV4Y2ggJS41ZyBzdWIgZGVmCiAgICAveSBleGNoICUuNWcgc3ViIGRlZgogICAgL3ggZXhjaCAlLjVnIHN1YiBkZWYKICAgIG5ld3BhdGggeCB5IG1vdmV0bwogICAgWCB5IGxpbmV0bwogICAgWCBZIGxpbmV0bwogICAgeCBZIGxpbmV0bwogICAgY2xvc2VwYXRoIHN0cm9rZQogfSBkZWYKL2RiZ3N0YXJ0IHsgZ3NhdmUgJS41ZyAlLjVnIHRyYW5zbGF0ZSB9IGRlZgovYXJyb3dsZW5ndGggMTAgZGVmCi9hcnJvd3dpZHRoIGFycm93bGVuZ3RoIDIgZGl2IGRlZgovYXJyb3doZWFkIHsKICAgIGdzYXZlCiAgICByb3RhdGUKICAgIGN1cnJlbnRwb2ludAogICAgbmV3cGF0aAogICAgbW92ZXRvCiAgICBhcnJvd2xlbmd0aCBhcnJvd3dpZHRoIDIgZGl2IHJsaW5ldG8KICAgIDAgYXJyb3d3aWR0aCBuZWcgcmxpbmV0bwogICAgY2xvc2VwYXRoIGZpbGwKICAgIGdyZXN0b3JlCn0gYmluZCBkZWYKL21ha2VhcnJvdyB7CiAgICBjdXJyZW50cG9pbnQgZXhjaCBwb3Agc3ViIGV4Y2ggY3VycmVudHBvaW50IHBvcCBzdWIgYXRhbgogICAgYXJyb3doZWFkCn0gYmluZCBkZWYKL3BvaW50IHsgICAgbmV3cGF0aCAgICAyIDAgMzYwIGFyYyBmaWxsfSBkZWYvbWFrZXZlYyB7CiAgICAvWSBleGNoIGRlZgogICAgL1ggZXhjaCBkZWYKICAgIC95IGV4Y2ggZGVmCiAgICAveCBleGNoIGRlZgogICAgbmV3cGF0aCB4IHkgbW92ZXRvCiAgICBYIFkgbGluZXRvIHN0cm9rZQogICAgWCBZIG1vdmV0bwogICAgeCB5IG1ha2VhcnJvdwp9IGRlZgoAL3BhdGhib3ggewogICAgL1ggZXhjaCBuZWcgJS41ZyBzdWIgZGVmCiAgICAvWSBleGNoICUuNWcgc3ViIGRlZgogICAgL3ggZXhjaCBuZWcgJS41ZyBzdWIgZGVmCiAgICAveSBleGNoICUuNWcgc3ViIGRlZgogICAgbmV3cGF0aCB4IHkgbW92ZXRvCiAgICBYIHkgbGluZXRvCiAgICBYIFkgbGluZXRvCiAgICB4IFkgbGluZXRvCiAgICBjbG9zZXBhdGggc3Ryb2tlCn0gZGVmCgAlIVBTLUFkb2JlLTIuMAovbm9kZSB7CiAgL1kgZXhjaCBkZWYKICAvWCBleGNoIGRlZgogIC95IGV4Y2ggZGVmCiAgL3ggZXhjaCBkZWYKICBuZXdwYXRoCiAgeCB5IG1vdmV0bwogIHggWSBsaW5ldG8KICBYIFkgbGluZXRvCiAgWCB5IGxpbmV0bwogIGNsb3NlcGF0aCBmaWxsCn0gZGVmCi9jZWxsIHsKICAvWSBleGNoIGRlZgogIC9YIGV4Y2ggZGVmCiAgL3kgZXhjaCBkZWYKICAveCBleGNoIGRlZgogIG5ld3BhdGgKICB4IHkgbW92ZXRvCiAgeCBZIGxpbmV0bwogIFggWSBsaW5ldG8KICBYIHkgbGluZXRvCiAgY2xvc2VwYXRoIHN0cm9rZQp9IGRlZgoAfSBiaW5kIGRlZgoALlBTICUuNWYgJS41ZgoAb3ZlcmxhcDogJXMgdmFsdWUgJWQgc2NhbGluZyAlLjA0ZgoAICBiZWF1dGlmeV9sZWF2ZXMgJWQgbm9kZSB3ZWlnaHRzICVkIHJvdGF0aW9uICUuMDNmCgAgIHJlcHVsc2l2ZSBhbmQgYXR0cmFjdGl2ZSBleHBvbmVudHM6ICUuMDNmICUuMDNmCgAgIEsgOiAlLjAzZiBDIDogJS4wM2YKACVzICUuM2YKAAppbnRlcnNlY3Rpb24gYXQgJS4zZiAlLjNmCgAgICAgc2NhbGUgJS4zZgoAdG9ydXMgeyAlLjNmLCAlLjNmCgAgICAgPCU5LjNmLCAlOS4zZiwgJTkuM2Y+LCAlLjNmCgAgaW4gJXMgLSBzZXR0aW5nIHRvICUuMDJmCgAubnIgU0YgJS4wZgpzY2FsZXRoaWNrbmVzcyA9ICUuMGYKACVzIHNhdmUgcG9pbnQgc2l6ZSBhbmQgZm9udAoubnIgLlMgXG4oLnMKLm5yIERGIFxuKC5mCgBzaG93cGFnZQolJSUlVHJhaWxlcgolJSUlQm91bmRpbmdCb3g6ICUuZiAlLmYgJS5mICUuZgoAYWRkaW5nICV6dSBpdGVtcywgdG90YWwgYXJlYSA9ICVmLCB3ID0gJWYsIGFyZWEvdz0lZgoAZ2FwPSVmLCVmCgAgIGFzcGVjdCAlZgoAYSAlZiBiICVmIGMgJWYgZCAlZiByICVmCgBtb2RlbCAlZCBzbWFydF9pbml0ICVkIHN0cmVzc3d0ICVkIGl0ZXJhdGlvbnMgJWQgdG9sICVmCgBTb2x2aW5nIG1vZGVsICVkIGl0ZXJhdGlvbnMgJWQgdG9sICVmCgAlcyBjb29yZCAlLjVnICUuNWcgaHQgJWYgd2lkdGggJWYKAHJlYyAlZiAlZiAlZiAlZgoAJXMgOiAlZiAlZiAlZiAlZgoAJXMgOiAlZiAlZgoAbWF4cHNodCA9ICVmCm1heHBzd2lkID0gJWYKAG1kc01vZGVsOiBkZWx0YSA9ICVmCgAgcjEgJWYgcjIgJWYKAFBhY2tpbmc6IGNvbXB1dGUgZ3JpZCBzaXplCgBnc2F2ZQoAJSVFbmRDb21tZW50cwpzYXZlCgBVbnJlY29nbml6ZWQgY2hhcmFjdGVyICclYycgKCVkKSBpbiBzaWRlcyBhdHRyaWJ1dGUKAEltYWdlcyB1bnN1cHBvcnRlZCBpbiAiYmFja2dyb3VuZCIgYXR0cmlidXRlCgAlcyBHTlUgcGljIHZzLiAxMHRoIEVkaXRpb24gZFwoZSd0ZW50ZQoAcmVzZXQgJXMgc2V0IHRvIGtub3duIHN0YXRlCgAlZyAlZyBzZXRfc2NhbGUgJWQgcm90YXRlICVnICVnIHRyYW5zbGF0ZQoAJWYgJWYgdHJhbnNsYXRlCgAlZCAlZCB0cmFuc2xhdGUKAC8vKioqIGVsbGlwc2UKAFVucmVjb2duaXplZCBvdmVybGFwIHZhbHVlICIlcyIgLSB1c2luZyBmYWxzZQoAc3VycHJpc2UKAG1lbW9yeSBhbGxvY2F0aW9uIGZhaWx1cmUKACVzOiB2c25wcmludGYgZmFpbHVyZQoAZW5kcGFnZQpzaG93cGFnZQpncmVzdG9yZQoAZW5kCnJlc3RvcmUKAGxheW91dCB3YXMgbm90IGRvbmUKAExheW91dCB3YXMgbm90IGRvbmUKAC8vKioqIHBvbHlsaW5lCgB0cnlpbmcgdG8gZGVsZXRlIGEgbm9uLWxpbmUKACMgZW5kIG9mIEZJRyBmaWxlCgBTaW5nbGUKAHJlbmRlcmVyIGZvciAlcyBpcyB1bmF2YWlsYWJsZQoAZHluYW1pYyBsb2FkaW5nIG5vdCBhdmFpbGFibGUKACVkICVkIGxpbmV0byBzdHJva2UKAGNsb3NlcGF0aCBzdHJva2UKACBlbGxpcHNlX3BhdGggc3Ryb2tlCgAvLyoqKiBiZWdpbl9lZGdlCgAvLyoqKiBlbmRfZWRnZQoAbG9zdCAlcyAlcyBlZGdlCgBvdmVyZmxvdyB3aGVuIGNhbGN1bGF0aW5nIHZpcnR1YWwgd2VpZ2h0IG9mIGVkZ2UKAGFkZF90cmVlX2VkZ2U6IG1pc3NpbmcgdHJlZSBlZGdlCgBpbiByb3V0ZXNwbGluZXMsIGNhbm5vdCBmaW5kIE5PUk1BTCBlZGdlCgBzaG93cGFnZQoAJWQgJWQgJWQgYmVnaW5wYWdlCgAvLyoqKiBiZWdpbl9wYWdlCgAvLyoqKiBlbmRfcGFnZQoARmlsZW5hbWUgIiVzIiBpcyB1bnNhZmUKAGxhYmVsOiBhcmVhIHRvbyBsYXJnZSBmb3IgcnRyZWUKAC8vKioqIGVuZF9ub2RlCgBVc2luZyBkZWZhdWx0IGNhbGN1bGF0aW9uIGZvciByb290IG5vZGUKAGNvbnRhaW5fbm9kZXMgY2x1c3QgJXMgcmFuayAlZCBtaXNzaW5nIG5vZGUKACVmICVmICVmICVmIG5vZGUKADw8IC9QYWdlU2l6ZSBbJWQgJWRdID4+IHNldHBhZ2VkZXZpY2UKAGluIGNoZWNrcGF0aCwgYm94ICVkIGhhcyBMTCBjb29yZCA+IFVSIGNvb3JkCgBpbiBjaGVja3BhdGgsIGJveCAwIGhhcyBMTCBjb29yZCA+IFVSIGNvb3JkCgBjbHVzdGVyIG5hbWVkICVzIG5vdCBmb3VuZAoAbm9kZSAlcywgcG9ydCAlcyB1bnJlY29nbml6ZWQKACVzJXMgdW5zdXBwb3J0ZWQKAGNsdXN0ZXIgY3ljbGUgJXMgLS0gJXMgbm90IHN1cHBvcnRlZAoAJXMgLT4gJXM6IHNwbGluZSBzaXplID4gMSBub3Qgc3VwcG9ydGVkCgBsYXlvdXQgYWJvcnRlZAoAcGFnZWRpcj0lcyBpZ25vcmVkCgBUd28gY2x1c3RlcnMgbmFtZWQgJXMgLSB0aGUgc2Vjb25kIHdpbGwgYmUgaWdub3JlZAoASWxsZWdhbCBhdHRyaWJ1dGUgJXMgaW4gJXMgLSBpZ25vcmVkCgBVbmtub3duIHZhbHVlICVzIGZvciBhdHRyaWJ1dGUgIm1vZGVsIiBpbiBncmFwaCAlcyAtIGlnbm9yZWQKAElsbGVnYWwgdmFsdWUgJXMgZm9yIGF0dHJpYnV0ZSAibW9kZSIgaW4gZ3JhcGggJXMgLSBpZ25vcmVkCgBzdGFydD0wIG5vdCBzdXBwb3J0ZWQgd2l0aCBtb2RlPXNlbGYgLSBpZ25vcmVkCgBPdmVybGFwIHZhbHVlICIlcyIgdW5zdXBwb3J0ZWQgLSBpZ25vcmVkCgBVbmtub3duIHZhbHVlICVzIGZvciBST1dTIC0gaWdub3JlZAoAVW5rbm93biB2YWx1ZSAlcyBmb3IgQ09MVU1OUyAtIGlnbm9yZWQKAElsbGVnYWwgdmFsdWUgJXMgZm9yIFZBTElHTiAtIGlnbm9yZWQKAElsbGVnYWwgdmFsdWUgJXMgZm9yIEFMSUdOIC0gaWdub3JlZAoASWxsZWdhbCB2YWx1ZSAlcyBmb3IgRklYRURTSVpFIC0gaWdub3JlZAoASWxsZWdhbCB2YWx1ZSAlLipzIGZvciBTVFlMRSAtIGlnbm9yZWQKAElsbGVnYWwgdmFsdWUgJXMgZm9yIEJBTElHTiBpbiBURCAtIGlnbm9yZWQKAElsbGVnYWwgdmFsdWUgJXMgZm9yIEFMSUdOIGluIFREIC0gaWdub3JlZAoAUk9XU1BBTiB2YWx1ZSBjYW5ub3QgYmUgMCAtIGlnbm9yZWQKAENPTFNQQU4gdmFsdWUgY2Fubm90IGJlIDAgLSBpZ25vcmVkCgBub2RlICVzLCBwb3J0ICVzLCB1bnJlY29nbml6ZWQgY29tcGFzcyBwb2ludCAnJXMnIC0gaWdub3JlZAoAVW5rbm93biAic3BsaW5lcyIgdmFsdWU6ICIlcyIgLSBpZ25vcmVkCgBpbiByb3V0ZXNwbGluZXMsIFBzaG9ydGVzdHBhdGggZmFpbGVkCgBpbiByb3V0ZXNwbGluZXMsIFByb3V0ZXNwbGluZSBmYWlsZWQKACUuNWcgJS41ZyB0cmFuc2xhdGUgbmV3cGF0aCB1c2VyX3NoYXBlXyVkCgBEdW1teT0lZAoAbnNpemVzY2FsZT0lZixpdGVyYXRpb25zPSVkCgBuZXh0I2l0ZXI9JWQKAGN0cmwtPm92ZXJsYXA9JWQKACVzICVkIG5vZGVzICVkIGVkZ2VzIG1heGl0ZXI9JWQgYmFsYW5jZT0lZAoALy8qKiogYmVnaW5fbGF5ZXI6ICVzLCAlZC8lZAoAZGVnZW5lcmF0ZSBjb25jZW50cmF0ZWQgcmFuayAlcywlZAoAY2lyY2xlICVzICVkLCVkLCVkCgByZWN0ICVzICVkLCVkICVkLCVkCgBtaW5jcm9zczogcGFzcyAlZCBpdGVyICVkIHRyeWluZyAlZCBjdXJfY3Jvc3MgJWQgYmVzdF9jcm9zcyAlZAoAICBtYXggbGV2ZWxzICVkCgAJJXMgJWQKACAgQmFybmVzLUh1dHQgY29uc3RhbnQgJS4wM2YgdG9sZXJhbmNlICAlLjAzZiBtYXhpdGVyICVkCgBndndyaXRlX25vX3ogcHJvYmxlbSAlZAoAICBxdWFkdHJlZSBzaXplICVkIG1heF9sZXZlbCAlZAoAcmVidWlsZF92bGlzdHM6IGxlYWQgaXMgbnVsbCBmb3IgcmFuayAlZAoAcmVidWlsZF92bGlzdHM6IHJhbmsgbGVhZCAlcyBub3QgaW4gb3JkZXIgJWQgb2YgcmFuayAlZAoAICBzbW9vdGhpbmcgJXMgb3ZlcmxhcCAlZCBpbml0aWFsX3NjYWxpbmcgJS4wM2YgZG9fc2hyaW5raW5nICVkCgAgIGNvb2xpbmcgJS4w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bmssIGxpbmUgJWQ6ICVzICVzIHJhbmsgJWQgaSA9ICVkIGFuID0gMAoAY29uY2VudHJhdGU9dHJ1ZSBtYXkgbm90IHdvcmsgY29ycmVjdGx5LgoATm8gbGlieiBzdXBwb3J0LgoAdHdvcGk6IHVzZSBvZiB3ZWlnaHQ9MCBjcmVhdGVzIGRpc2Nvbm5lY3RlZCBjb21wb25lbnQuCgB0aGUgZ3JhcGggaW50byBjb25uZWN0ZWQgY29tcG9uZW50cy4KAE9ydGhvZ29uYWwgZWRnZXMgZG8gbm90IGN1cnJlbnRseSBoYW5kbGUgZWRnZSBsYWJlbHMuIFRyeSB1c2luZyB4bGFiZWxzLgoAZ3ZSZW5kZXJKb2JzICVzOiAlLjJmIHNlY3MuCgBtaW5jcm9zcyAlczogJWQgY3Jvc3NpbmdzLCAlLjJmIHNlY3MuCgAlcyBpcyBub3QgYSBrbm93biBjb2xvci4KAEdvaW5nIHRvIGFwcGx5IGFub3RoZXIgZXhwYW5zaW9uLgoAaXMgaW5hcHByb3ByaWF0ZS4gUmV2ZXJ0aW5nIHRvIHRoZSBzaG9ydGVzdCBwYXRoIG1vZGVsLgoAaXMgdW5kZWZpbmVkLiBSZXZlcnRpbmcgdG8gdGhlIHNob3J0ZXN0IHBhdGggbW9kZWwuCgBVbmFibGUgdG8gcmVjbGFpbSBib3ggc3BhY2UgaW4gc3BsaW5lIHJvdXRpbmcgZm9yIGVkZ2UgIiVzIiAtPiAiJXMiLiBTb21ldGhpbmcgaXMgcHJvYmFibHkgc2VyaW91c2x5IHdyb25nLgoARXJyb3IgZHVyaW5nIGNvbnZlcnNpb24gdG8gIlVURi04Ii4gUXVpdGluZy4KAG9yZGVyaW5nICclcycgbm90IHJlY29nbml6ZWQuCgBncmFkaWVudCBwZW4gY29sb3JzIG5vdCB5ZXQgc3VwcG9ydGVkLgoAICBpbml0Q01halZQU0MgZG9uZTogJWQgZ2xvYmFsIGNvbnN0cmFpbnRzIGdlbmVyYXRlZC4KAFRoZSBjaGFyYWN0ZXIgJyVjJyBhcHBlYXJzIGluIGJvdGggdGhlIGxheWVyc2VwIGFuZCBsYXllcmxpc3RzZXAgYXR0cmlidXRlcyAtIGxheWVybGlzdHNlcCBpZ25vcmVkLgoAdGhlIGFzcGVjdCBhdHRyaWJ1dGUgaGFzIGJlZW4gZGlzYWJsZWQgZHVlIHRvIGltcGxlbWVudGF0aW9uIGZsYXdzIC0gYXR0cmlidXRlIGlnbm9yZWQuCgBUaGUgbGF5ZXJzZWxlY3QgYXR0cmlidXRlICIlcyIgZG9lcyBub3QgbWF0Y2ggYW55IGxheWVyIHNwZWNpZmVkIGJ5IHRoZSBsYXllcnMgYXR0cmlidXRlIC0gaWdub3JlZC4KACV6dSBvdXQgb2YgJXp1IGxhYmVscyBwb3NpdGlvbmVkLgoAJXp1IG91dCBvZiAlenUgZXh0ZXJpb3IgbGFiZWxzIHBvc2l0aW9uZWQuCgAgIGdlbmVyYXRlIGVkZ2UgY29uc3RyYWludHMuLi4KAEdlbmVyYXRpbmcgTm9uLW92ZXJsYXAgQ29uc3RyYWludHMuLi4KAEdlbmVyYXRpbmcgRWRnZSBDb25zdHJhaW50cy4uLgoAR2VuZXJhdGluZyBEaUctQ29MYSBFZGdlIENvbnN0cmFpbnRzLi4uCgBSZW1vdmluZyBvdmVybGFwcyBhcyBwb3N0cHJvY2Vzcy4uLgoALi4uICVzIC4uLgoARWRnZSBsZW5ndGggJWYgbGFyZ2VyIHRoYW4gbWF4aW11bSAlZCBhbGxvd2VkLgpDaGVjayBmb3Igb3ZlcndpZGUgbm9kZShzKS4KAG9yZGVyaW5nICclcycgbm90IHJlY29nbml6ZWQgZm9yIG5vZGUgJyVzJy4KACJkaXJlY3RlZCI6ICVzLAoAIndpZHRoIjogJS4wM2YsCgAic2l6ZSI6ICUuMDNmLAoAcG9seWdvbiB7ICVkLAoAInRhaWwiOiAlZCwKACJfZ3ZpZCI6ICVkLAoAc3BoZXJlX3N3ZWVwIHsKICAgICVzCiAgICAlZCwKACJwdCI6IFslLjAzZiwlLjAzZl0sCgAicDEiOiBbJS4wM2YsJS4wM2ZdLAoAInAwIjogWyUuMDNmLCUuMDNmXSwKACJwMSI6IFslLjAzZiwlLjAzZiwlLjAzZl0sCgAicDAiOiBbJS4wM2YsJS4wM2YsJS4wM2ZdLAoAIm9wIjogInQiLAoAImdyYWQiOiAibGluZWFyIiwKACJncmFkIjogInJhZGlhbCIsCgAiZ3JhZCI6ICJub25lIiwKAAklcyBpZiB5b3UgdXNlIGdwaWMgYW5kIGl0IGJhcmZzIG9uIGVuY291bnRlcmluZyAic29saWQiLAoAIm9wIjogIiVjIiwKACJhbGlnbiI6ICIlYyIsCgAib3AiOiAiVCIsCgAib3AiOiAiUyIsCgAib3AiOiAiTCIsCgAib3AiOiAiRiIsCgBleHBhdDogRW50cm9weTogJXMgLS0+IDB4JTAqbHggKCVsdSBieXRlcykKAHN5bnRheCBlcnJvciBpbiBwb3MgYXR0cmlidXRlIGZvciBlZGdlICglcywlcykKAGdldHNwbGluZXBvaW50czogbm8gc3BsaW5lIHBvaW50cyBhdmFpbGFibGUgZm9yIGVkZ2UgKCVzLCVzKQoAbWFrZVNwbGluZTogZmFpbGVkIHRvIG1ha2Ugc3BsaW5lIGVkZ2UgKCVzLCVzKQoAIyBHZW5lcmF0ZWQgYnkgJXMgdmVyc2lvbiAlcyAoJXMpCgAlJSUlQ3JlYXRvcjogJXMgdmVyc2lvbiAlcyAoJXMpCgAlcyBDcmVhdG9yOiAlcyB2ZXJzaW9uICVzICglcykKAHNlZ21lbnQgWyglLjVnLCAlLjVnKSwoJS41ZywlLjVnKV0gZG9lcyBub3QgaW50ZXJzZWN0IGJveCBsbD0oJS41ZywlLjVnKSx1cj0oJS41ZywlLjVnKQoAJWQgKCUuNWcsICUuNWcpLCAoJS41ZywgJS41ZykKAHBhY2sgdmFsdWUgJWQgaXMgc21hbGxlciB0aGFuIGVzZXAgKCUuMDNmLCUuMDNmKQoAc2VwIHZhbHVlICglLjAzZiwlLjAzZikgaXMgc21hbGxlciB0aGFuIGVzZXAgKCUuMDNmLCUuMDNmKQoAc2NhbGUgPSAoJS4wM2YsJS4wM2YpCgBzZWcjJWQgOiAoJS4zZiwgJS4zZikgKCUuM2YsICUuM2YpCgAlenUgb2JqcyAlenUgeGxhYmVscyBmb3JjZT0lZCBiYj0oJS4wMmYsJS4wMmYpICglLjAyZiwlLjAyZikKAEVkZ2Ugc2VwYXJhdGlvbjogYWRkPSVkICglZiwlZikKAE5vZGUgc2VwYXJhdGlvbjogYWRkPSVkICglZiwlZikKAGNoYW5uZWwgJWQgKCVmLCVmKQoAcm9vdCAlZCAoJWYpICVkICglZikKACVmIC0gJWYgJWYgJWYgJWYgPSAlZiAoJWYgJWYgJWYgJWYpCgAlJUJvdW5kaW5nQm94OiAoYXRlbmQpCgAlJVBhZ2VzOiAoYXRlbmQpCgBleHBhdDogRW50aXRpZXMoJXApOiBDb3VudCAlOWQsIGRlcHRoICUyZC8lMmQgJSpzJXMlczsgJXMgbGVuZ3RoICVkICh4bWxwYXJzZS5jOiVkKQoAY2MgKCVkIGNlbGxzKSBhdCAoJWQsJWQpCgBjYyAoJWQgY2VsbHMpIGF0ICglZCwlZCkgKCVkLCVkKQoAbGlicGFjazogZGlzYyA9ICVmICggPCAwKQoAY2FudmFzIHNpemUgKCVkLCVkKSBleGNlZWRzIFBERiBsaW1pdCAoJWQpCgkoc3VnZ2VzdCBzZXR0aW5nIGEgYm91bmRpbmcgYm94IHNpemUsIHNlZSBkb3QoMSkpCgBlcnJvciBpbiBjb2x4bGF0ZSgpCgB0cnVuY2F0aW5nIHN0eWxlICclcycKAElsbGVnYWwgdmFsdWUgaW4gIiVzIiBjb2xvciBhdHRyaWJ1dGU7IGZsb2F0IGV4cGVjdGVkIGFmdGVyICc7JwoAZGVmaW5lIGF0dHJzMCAlJSAlJTsgZGVmaW5lIHVuZmlsbGVkICUlICUlOyBkZWZpbmUgcm91bmRlZCAlJSAlJTsgZGVmaW5lIGRpYWdvbmFscyAlJSAlJQoAPHN2ZyB3aWR0aD0iJWRwdCIgaGVpZ2h0PSIlZHB0IgoAJGMgY3JlYXRlIGltYWdlICUuMmYgJS4yZiAtaW1hZ2UgInBob3RvXyVzIgoATm8gb3IgaW1wcm9wZXIgaW1hZ2UgZmlsZT0iJXMiCgBmaWxlIGxvYWRpbmcgaXMgZGlzYWJsZWQgYmVjYXVzZSB0aGUgZW52aXJvbm1lbnQgY29udGFpbnMgU0VSVkVSX05BTUU9IiVzIgoAQ291bGQgbm90IHBhcnNlIHhkb3QgIiVzIgoATm8gbG9hZGltYWdlIHBsdWdpbiBmb3IgIiVzIgoAIFslenVdICglLjAyZiwlLjAyZikgKCUuMDJmLCUuMDJmKSAlcCAiJXMiCgBmb250bmFtZTogdW5hYmxlIHRvIHJlc29sdmUgIiVzIgoARHVwbGljYXRlIGNsdXN0ZXIgbmFtZSAiJXMiCgB1bnJlY29nbml6ZWQgYXBpIG5hbWUg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ABAAUAATAG0AewAUAJgADwCmAMMArv+u/67/rv+u/67/rv+u/67/rv+u/67/rv+u/67/rv+u/67/rv+u/67/rv+u/67/FwCu/3cArv8HAC4Arv8mAK7/FwARACMArv8NAK7/rv+u/67/OgCu/67/NQCu/67/rv8oAK7/BwCu/zsARQCu/0gArv+u/67/rv+u/wBB8fcEC8EGAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiMkJSYnKAAAAAAAAAAAAgICAgICEAxZAQAfUAgDBxITFFcWFwgLaQwfCgUMDikRKw8tEC8wIDIGNDUbHB0eCwwhIiMkJSYnKAwYGRcEChscGiAqCiEiIyQlJicoDAoOUwosWDFYWFhYWFgMGxwPLlgzISIjJCUmJygbHP9T//8hIiMkJSYnKAz//wX///8JFP//////DBsc/xAVFiEiIyQlJicoGxz/////ISIjJCUmJygM/xITFBEWF////////wwbHP///xIhIiMkJSYnKBsc/////yEiIyQlJicoDP///////xP///////8MGxz/////ISIjJCUmJygbHP////8hIiMkJSYnKBITFBUWFxgZ////////////IyQlJicbEhMUFhciNmgBHzhWISACGxsbXhsbNzlwNtLCTwQ8IkciPyJEIiJYImUiIgUGX2A5BAcICQoLDA0OBGZnXWptBQZvWDtxBwgJCgsMDQ4Ecjxbcz5hRhsSExQWFwQFBj9BYkkHCAkKCwwNDgUGAFwAAAcICQoLDA0OBAAATwAAAFNCAAAAAAAEBQYARFRVBwgJCgsMDQ4FBgAAAAAHCAkKCwwNDgQAKiwuRzEzAAAAAAAABAUGAAAASgcICQoLDA0OBQYAAAAABwgJCgsMDQ4EAAAAAAAATAAAAAAAAAQFBgAAAAAHCAkKCwwNDgUGAAAAAAcICQoLDA0OKSstLzAyNDUAQbv+BAsuKSstMDIABC8AJCMAEhQWGhweIBgABQcvLy8ALy8AAAkIKAAAASICBgAAAAAACABB9v4ECz4lAyYTCikVCyoXDi0ZERsMKx0NLB8PIRAAMwAwAC9DADEALwA1LidCMkEAOjgAPDRFADYAQAAAPwBENzs5PQBBwf8EC0UCAwMBAQIBAQEDAwMDAwMDAwEBAQEBAQEBAQEBAQEBAQECAQECAAYBAwMDAwMBAAECAwAEAQIDAAQABAAEAAMCAQIBAgEAQZGABQtFKSoqKissLC0tLS0tLS0tLS0uLzAxMjM0NTY3ODk6Ozw9Pj4/P0FAQkJCQkJCQ0NERERGRUdHR0lISkhLSExITU1OTk9PAEHggAULjgGu/67//P/oAPb///8aAAAAJwABADIArv+u/wIAJAADAC8Arv+u/67/rv+u//7/lACu/wkAGwCu/7z/rv+u/6//rv+u/67/rv+u/67/rv8AAP8DDxARIzokPSVAFUMmRSdIGEsZTRooHE4dHlBRUllabGtuY2RXaQAIAAAACAAAAAAAAAA+AQAAPwEAAD0BAEGOggULCfC/AAAAAAAAAQBBoIIFC8MCaW52aXMAAGZpbGxlZAAAALQZAABNTwAAIjUAAGALAAAMAAAABAAAAAYAAAACAAAAAwAAAAEAAAAJAAAACAAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAAAfAAAAIAAAACEAAAAiAAAAIwAAACQAAAAlAAAAJgAAACkAAAAqAAAAKwAAACwAAAAtAAAALgAAAC8AAAAwAAAAMwAAADQAAAA1AAAANgAAADcAAAA4AAAAOQAAADoAAAA9AAAAPgAAAD8AAABAAAAAQQAAAEIAAABDAAAARAAAAEcAAABIAAAASQAAAEoAAABLAAAATAAAAE0AAABOAAAAUQAAAFIAAABTAAAAVAAAAFUAAABWAAAAVwAAAFgAAAC8kwIAQe6EBQuFCKBA/////////////////////////////////////////////////////////////////////////////////////wACqgJEAwAEAASqBjkGcQGqAqoCAASDBAACqgIAAjkCAAQABAAEAAQABAAEAAQABAAEAAQ5AjkCgwSDBIMEjQNeB8cFVgVWBccF4wRzBMcFxwWqAh0DxwXjBB0HxwXHBXMExwVWBXME4wTHBccFjQfHBccF4wSqAjkCqgLBAwAEqgKNAwAEjQMABI0DqgIABAAEOQI5AgAEOQI5BgAEAAQABAAEqgIdAzkCAAQABMcFAAQABI0D1wOaAdcDVAT///////////////////////////////////////////////////////////////////////////////////////8AAqoCcQQABAAEAAiqBjkCqgKqAgAEjwQAAqoCAAI5AgAEAAQABAAEAAQABAAEAAQABAAEqgKqAo8EjwSPBAAEcQfHBVYFxwXHBVYF4wQ5BjkGHQMABDkGVgWNB8cFOQbjBDkGxwVzBFYFxwXHBQAIxwXHBVYFqgI5AqoCpgQABKoCAARzBI0DcwSNA6oCAARzBDkCqgJzBDkCqgZzBAAEcwRzBI0DHQOqAnMEAATHBQAEAASNAycDwwEnAykE////////////////////////////////////////////////////////////////////////////////////////AAKqAlwDAAQABKoGOQa2AaoCqgIABGYFAAKqAgACOQIABAAEAAQABAAEAAQABAAEAAQABKoCqgJmBWYFZgUABFwH4wTjBFYFxwXjBOMExwXHBaoCjQNWBXMEqgZWBccF4wTHBeMEAARzBMcF4wSqBuMEcwRzBB0DOQIdA2ADAASqAgAEAASNAwAEjQM5AgAEAAQ5AjkCjQM5AscFAAQABAAEAAQdAx0DOQIABI0DVgWNA40DHQMzAzMCMwNUBP///////////////////////////////////////////////////////////////////////////////////////wACHQNxBAAEAASqBjkGOQKqAqoCAASPBAACqgIAAjkCAAQABAAEAAQABAAEAAQABAAEAASqAqoCjwSPBI8EAASoBlYFVgVWBccFVgVWBccFOQYdAwAEVgXjBB0HxwXHBeMExwVWBXME4wTHBVYFHQdWBeME4wSqAjkCqgKPBAAEqgIABAAEjQMABI0DqgIABHMEOQI5AgAEOQI5BnMEAAQABAAEHQMdAzkCcwSNA1YFAASNAx0DyQLDAckCjwT//+STAgBB/owFC4UIoED/////////////////////////////////////////////////////////////////////////////////////OQI5AtcCcwRzBB0HVgWHAaoCqgIdA6wEOQKqAjkCOQJzBHMEcwRzBHMEcwRzBHMEcwRzBDkCOQKsBKwErARzBB8IVgVWBccFxwVWBeMEOQbHBTkCAARWBXMEqgbHBTkGVgU5BscFVgXjBMcFVgWNB1YFVgXjBDkCOQI5AsEDcwSqAnMEcwQABHMEcwQ5AnMEcwTHAccBAATHAaoGcwRzBHMEcwSqAgAEOQJzBAAExwUABAAEAASsAhQCrAKsBP///////////////////////////////////////////////////////////////////////////////////////zkCqgLLA3MEcwQdB8cF5wGqAqoCHQOsBDkCqgI5AjkCcwRzBHMEcwRzBHMEcwRzBHMEcwSqAqoCrASsBKwE4wTNB8cFxwXHBccFVgXjBDkGxwU5AnMExwXjBKoGxwU5BlYFOQbHBVYF4wTHBVYFjQdWBVYF4wSqAjkCqgKsBHMEqgJzBOMEcwTjBHMEqgLjBOMEOQI5AnMEOQIdB+ME4wTjBOMEHQNzBKoC4wRzBDkGcwRzBAAEHQM9Ah0DrAT///////////////////////////////////////////////////////////////////////////////////////85AjkC1wJzBHMEHQdWBYcBqgKqAh0DrAQ5AqoCOQI5AnMEcwRzBHMEcwRzBHMEcwRzBHMEOQI5AqwErASsBHMEHwhWBVYFxwXHBVYF4wQ5BscFOQIABFYFcwSqBscFOQZWBTkGxwVWBeMExwVWBY0HVgVWBeMEOQI5AjkCwQNzBKoCcwRzBAAEcwRzBDkCcwRzBMcBxwEABMcBqgZzBHMEcwRzBKoCAAQ5AnMEAATHBQAEAAQABKwCFAKsAqwE////////////////////////////////////////////////////////////////////////////////////////OQKqAssDcwRzBB0HxwXnAaoCqgIdA6wEOQKqAjkCOQJzBHMEcwRzBHMEcwRzBHMEcwRzBKoCqgKsBKwErATjBM0HxwXHBccFxwVWBeMEOQbHBTkCcwTHBeMEqgbHBTkGVgU5BscFVgXjBMcFVgWNB1YFVgXjBKoCOQKqAqwEcwSqAnME4wRzBOMEcwSqAuME4wQ5AjkCcwQ5Ah0H4wTjBOME4wQdA3MEqgLjBHMEOQZzBHMEAAQdAz0CHQOsBP//GJQCAEGOlQULhQigQP/////////////////////////////////////////////////////////////////////////////////////NBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0E////////////////////////////////////////////////////////////////////////////////////////zQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBP///////////////////////////////////////////////////////////////////////////////////////80EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQT////////////////////////////////////////////////////////////////////////////////////////NBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0EzQTNBM0E//9AlAIAQZ2dBQuGCECPQAAA////////////////////////////////AgH///////////////////////////////////////////////8CAeQAiAFYAlgCogO1At0APQE9AcIBWALkAKgB5AAbAVgCWAJYAlgCWAJYAlgCWAJYAlgC5ADkAFgCWAJYArsBsgPZAqQCoQLmAkcCJALWAvkCAQFEAXECHwJXA+QC/wJ5Av8CnQJnAloC2AKxAk0EigJUAk0COwEbATsBWAL0AfQBEgJHAs8BRwIUAk0BSgI4AugA7AD0ASgBWAM4AiwCRwJHAmYB4QFeATECAwJJAw0CAgLPAWABCQFgAVgC//8AAP///////////////////////////////w8B////////////////////////////////////////////////DwH4AMABWAJYArED1gLzAGYBZgHFAVgC+ACyAfgAOQFYAlgCWAJYAlgCWAJYAlgCWAJYAvgA+ABYAlgCWALLAbYD6AKwAqgC+gJVAjIC4AIFAxoBYgGZAjICZAPsAhEDjAIRA64CdwJtAuICyQJZBKACagJdAmIBOQFiAVgC9AH0ASMCWALYAVgCHgJsAVwCSQL/AAMBGAI/AW0DSQJAAlgCWAKIAegBgAFDAg8CVQMiAg4C2gGHASABhwFYAv//AAD///////////////////////////////8CAf///////////////////////////////////////////////wIB5ACIAVgCWAKiA7UC3QA9AT0BwgFYAuQAqAHkABsBWAJYAlgCWAJYAlgCWAJYAlgCWALkAOQAWAJYAlgCuwGyA9kCpAKhAuYCRwIkAtYC+QIBAUQBcQIfAlgD4wL/AnkC/wKdAmcCWgLYArACTQSKAlQCTQI7ARsBOwFYAvQB9AESAkcCzwFHAhQCTQFKAjgC6ADsAPQBKAFYAzgCLAJHAkcCZgHhAV4BMQIDAkkDDQICAs8BYAEJAWABWAL//wAA////////////////////////////////DwH///////////////////////////////////////////////8PAfgAwAFYAlgCsQPWAvMAZgFmAcUBWAL4ALIB+AA5AVgCWAJYAlgCWAJYAlgCWAJYAlgC+AD4AFgCWAJYAssBtgPoArACqAL6AlUCMgLgAgUDGgFiAZgCMgJlA+sCEQOMAhEDrgJ3Am0C4gLJAlkEoAJqAl0CYgE5AWIBWAL0AfQBIwJYAtgBWAIeAmwBXAJJAv8AAwEYAj8BbQNJAkACWAJYAogB6AGAAUMCDwJVAyICDgLaAYcBIAGHAVgC//9IlAIAQa6lBQuFCKBA/////////////////////////////////////////////////////////////////////////////////////4sCNQOuA7QGFwWaBz0GMwIfAx8DAAS0BosC4wKLArICFwUXBRcFFwUXBRcFFwUXBRcFFwWyArICtAa0BrQGPwQACHkFfQWWBSkGDgWaBDMGBAZcAlwCPwV1BOcG/AVMBtMETAaPBRQF4wTbBXkF6Qd7BeMEewUfA7ICHwO0BgAEAATnBBQFZgQUBewE0QIUBRIFOQI5AqIEOQLLBxIF5QQUBRQFSgMrBCMDEgW8BIsGvAS8BDMEFwWyAhcFtAb////////////////////////////////////////////////////////////////////////////////////////JAqYDKwS0BpEFBAj6BnMCqAOoAy8EtAYKA1IDCgPsApEFkQWRBZEFkQWRBZEFkQWRBZEFMwMzA7QGtAa0BqQEAAgxBhkG3wWkBncFdwWRBrIG+gL6AjMGGQX2B7IGzQbdBc0GKQbDBXUFfwYxBtMIKwbLBc0FqAPsAqgDtAYABAAEZgW6Bb4EugVtBXsDugWyBb4CvgJSBb4CVgiyBX8FugW6BfIDwwTTA7IFNwVkBykFNwWoBLIF7AKyBbQG////////////////////////////////////////////////////////////////////////////////////////iwI1A64DtAYXBZoHPQYzAh8DHwMABLQGiwLjAosCsgIXBRcFFwUXBRcFFwUXBRcFFwUXBbICsgK0BrQGtAY/BAAIeQV9BZYFKQYOBZoEMwYEBlwCXAI/BXUE5wb8BUwG0wRMBo8FFAXjBNsFeQXpB3sF4wR7BR8DsgIfA7QGAAQABOcEFAVmBBQF7ATRAhQFEgU5AjkCogQ5AssHEgXlBBQFFAVKAysEIwMSBbwEiwa8BLwEMwQXBbICFwW0Bv///////////////////////////////////////////////////////////////////////////////////////8kCpgMrBJEFkQUECPoGcwKoA6gDLwS0BgoDUgMKA+wCkQWRBZEFkQWRBZEFkQWRBZEFkQUzAzMDtAa0BrQGpAQACDEGGQbfBaQGdwV3BZEGsgb6AvoCMwYZBfYHsgbNBt0FzQYpBsMFdQV/BjEG0wgrBssFzQWoA+wCqAO0BgAEAARmBboFvgS6BW0FewO6BbIFvgK+AlIFvgJWCLIFfwW6BboF8gPDBNMDsgU3BWQHKQU3BagEsgXsArIFtAb//1CUAgBBvq0FC4UIoEBmBP///////////////////////////////wAA////////////////////////////////////////////////ZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBP//ZgT///////////////////////////////8AAP///////////////////////////////////////////////2YEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgT//2YE////////////////////////////////AAD///////////////////////////////////////////////9mBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYE////////////////////////////////////////////////////////////////////////////////////////ZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBGYEZgRmBP//XJQCAEHOtQULhQigQP////////////////////////////////////////////////////////////////////////////////////9pAvACmQIyBDIEzQSmBUcB8ALwAvACMgTwAvAC8AIyBDIEMgQyBDIEMgQyBDIEMgQyBDIE8ALwAjIEMgQyBPACKga4BIcEyQToBEkEMwRpBTwFOgLQA5sEDQStBRsFZAV2BGgFqATZA6UEMAWzBNEGdASQBGcE8ALYAvACMgQyBDIENAR1BPYDdQRdBPUCBARfBEgC7wIJBFwCpAZfBEsEdQR1BBwDPQMsA18E6wP0BQIE8gPMA/ACMgTwAjIE////////////////////////////////////////////////////////////////////////////////////////aQLwAu8CsASwBHkFpgXWAfAC8AJ1A7AE8ALwAvACHwOwBLAEsASwBLAEsASwBLAEsASwBPAC8AKwBLAEsASBAyoGEQXDBOUEJAWNBKsEXwV4BToCQwTwBGwE9gVXBaAFsgSsBeMEFwTlBGwF+QQSB84E6AR7BDcD2AI3A7AEsASwBEMEpwQYBKUEmQT1AgQEvgRjAu8CYgRcAuAGuQSHBKkErARrA3IDLAO6BDgERQZrBEUEOgR4A7AEeAOwBP///////////////////////////////////////////////////////////////////////////////////////2kC8AKZAjIE2QPNBKYFRwHwAvAC8AIyBPAC8ALwAjIEMgQyBDIEMgQyBDIEMgQyBDIEMgTwAvACMgQyBDIE8AIqBuMEhwTJBOgESQQzBGkFPAU6AtADmwQNBBcGGwVkBVkEZAWoBNkDpQQwBbME0QZ0BJAEZwTwAtgC8AIyBDIEMgQ0BHUErgN1BEwENgMEBHUEdALvAgkEkAKkBl8ESwR1BHUEVQM9A1wDdATrA/QFAgTyA8wD8AIyBPACMgT///////////////////////////////////////////////////////////////////////////////////////9pAvACIAOwBLAE3AWmBWkC8ALwAnUDsATwAvAC8AItA7AEsASwBLAEsASwBLAEsASwBLAE8ALwArAEsASwBC0DKgbpBLgE5wQPBb8ErwRpBW0FOgL9AzMFOgRKBkgFngWrBCgG/QQDBHsFSwV3BWkHQQV4BeQE4gPSA+IDsASwBLAEvgS/BPEDvwRqBEgDSAR/BJ0CGgNRBI8CpAZ/BI8EygTKBJMDrAOBA3UEawQwBpsEgwRDBOIDsATiA7AE//9olAIAQd69BQuFCKBA/////////////////////////////////////////////////////////////////////////////////////9ACJgOsA4wGFgWcCNAFJgKiA6IDFgWMBukCogPpAqIDFgUWBRYFFgUWBRYFFgUWBRYFFgWiA6IDjAaMBowGXQQACHgFfAWWBSoGDwWZBDQGAwZeA6MDiwV0BL4G/AVMBtMETAaQBXgF7gTbBXgF6Qd7BewEewWiA6IDogOMBhYFFgXOBPwEKwT8BMQE0AL8BBAFMgLBArwEMgLIBxAF2wT8BPwEagMrBCcDEAW8BIwGvAS8BDQEFAWiAxQFjAb///////////////////////////////////////////////////////////////////////////////////////+8AjgDswTwBrAFLQrmBqgCWQRZBLAF8AbkAtcD5AKEBbAFsAWwBbAFsAWwBbAFsAWwBbAFOAM4A/AG8AbwBu8Etgc2BhgGygWkBncFNAV9BrMGXgRxBCsGGQWVB8YGzQbdBc0GQgavBXQFfwYcBgcJHAblBYkFWQSEBVkE8AawBbAFWAWYBbUEmAVQBWEDmAWzBbwCOQNeBbwCdwizBX4FmAWYBfoDvwSlA7MFMwXWB1oFNQXGBLAFWQSwBfAG////////////////////////////////////////////////////////////////////////////////////////0AImA6wDjAYWBZwI0AUmAqIDogMWBYwG6QKiA+kCogMWBRYFFgUWBRYFFgUWBRYFFgUWBaIDogOMBowGjAZdBAAIdgV8BZYFIAYPBZkENAYDBl4DowOLBXQEvgb8BUwG0wRMBpAFeAXuBNsFdgXsB3sF7AR7BaIDogOiA4wGFgUWBc4E/AQrBPwExATQAvkEEAUyAsECsgQyAskHEAXbBPwE/ARqAysEJwMQBboEjAa8BLoENAQUBaIDFAWMBv///////////////////////////////////////////////////////////////////////////////////////7wCOAOzBPAGsAUtCuYGqAJZBFkEsAXwBuQC1wPkAoQFsAWwBbAFsAWwBbAFsAWwBbAFsAU4AzgD8AbwBvAG7wS2BzYGGAbKBaQGdwU0BX0GswZeBHEEKwYZBZUHxgbNBt0FzQZCBq8FdAV/BhwGBwkcBuUFiQVZBIQFWQTwBrAFsAVYBZgFtQSYBVAFYQOYBbMFvAI5A14FvAJ3CLMFfAWYBZgF+gO/BKUDswUxBdYHWgU1BcYEsAVZBLAF8Ab//3CUAgBB7sUFC4UIoED/////////////////////////////////////////////////////////////////////////////////////FAIjAjUDKwWTBJYG1wXFAV4CXgJqBJME9gGTAiEC8AKTBJMEkwSTBJMEkwSTBJMEkwSTBCECIQKTBJMEkwRvAzEHEAUvBQwF1QVzBCEE0wXnBTsCIwLpBCcEOQcIBjsG0QQ7BvIEZARtBNMFwwRoB54EewSRBKIC8AKiAlYElgOeBHME5wTPA+cEfQS2AmIE6QQGAgYCMwQGAnEH6QTVBOcE5wREA9ED0wLpBAIEOQYxBAgEvgMIA2gECAOTBP///////////////////////////////////////////////////////////////////////////////////////xQCSgLHAysFkQQ1BwAGIQK2ArYCXASRBFICkwJIAk4DkQSRBJEEkQSRBJEEkQSRBJEEkQRIAlICkQSRBJEE0QMtB4UFYAUZBewFewRkBMsFHwamAqYCUAWFBIsHgQZeBgYFXgZIBWgEogQMBjMFvAdWBf4EogSmAk4DpgJCBEoD2wTVBBAFHQQQBboEGQOFBEIFcQJxAvYEcQLbB0IF9AQQBRAFogP6A3kDQgWNBNkGoASNBOcDJwNoBCcDkQT///////////////////////////////////////////////////////////////////////////////////////8UAhICFwMrBWgEWAZcBbwBSAJIAmoEaATsAX8CBgLNAmgEaARoBGgEaARoBGgEaARoBGgEBgIGAmgEaARoBGoDxwZxBMkErgRUBRcExwNqBW0FLwIjAnUEywOyBp4FwwWHBMMFjQQEBPwDaAViBNEGJwQGBD8ESgLNAkoCIwQnA28EhQSeBJoDngTyA4ECAgSeBAgCCALnAwgC+gaeBH0EngSeBCsDbQOYAp4EsgO8BdMDsgONA8sCaATLAmgE////////////////////////////////////////////////////////////////////////////////////////FAJKAqADKwVoBNkGqgUKArYCtgJcBGgEOQKTAkgCXgNoBGgEaARoBGgEaARoBGgEaARoBEgCSAJoBGgEaASsA9kGBgX2BOUEagVWBD8EhQWaBZMCpgLnBCUECgcKBtcFpATXBd8EPQQ/BIcFuAQnB9kEgwRKBKYCXgOmAjkEMwNvBMEEwwTdA8EEdQT8AlQE1QRgAmACiwRgAj0H1QSuBMMEwQReA8kDSAPVBBkETgY/BCcEpAPXAmgE1wJoBP//eJQCAEH+zQULhQigQP/////////////////////////////////////////////////////////////////////////////////////uAaYCSwMlBeEEigavBbkBAAMAA8cDJQUoAv4CKALAA+kEcAN4BGoEhQQ6BIcEBQTFBIcEgAKAAiUFJQUlBdQDbgdeBTsFIwX+BToFywTNBYUGHgMkBI4F1ARrByMG9AXhBPQFnQV9BPMEDQZVBc4HrwXsBNAEAAPAAwADJQUlBQAECAR7BKIDmATeA5oCEwSoBFgCVgJJBEoCDAe6BFAEkgR6BEcDdQPDApoE+QPmBQoE8AONA3EDAANxAyUF////////////////////////////////////////////////////////////////////////////////////////CAIDAxQEoAUgBQkHZQYnApMDkwPbA6AFoAIIA6ACxgOcBesDAwX/BDIFywQvBW8EaQUvBfAC8AKgBaAFoAVjBLwHEQYPBrkFrAbFBV8FdQZOB5EDwwSJBnwFMAi3Bo8GnAWPBmEGMQV5BasGGQYDCXgG2wWEBZMDxgOTA6AFoAUABMQEKgVABE4FkwQlA50EcAXUAsUCDgXBAiAIhQUWBUMFMAUpBBoELgNqBYkE6Aa0BH8ENAQABBoDAASgBf///////////////////////////////////////////////////////////////////////////////////////+4BpgJLAyUF4QSKBq8FuQEAAwADxwMlBSgC/gIoAsAD6QRwA3gEagSFBDoEhwT5A8UEhwQSAxIDJQUlBSUF1ANuB14FOwUjBf4FOgXLBM0FhQYeAyQEjgXUBGsHIwbYBeEE2AWdBX0E8wQNBlUFzgevBewE0AQAA8ADAAMlBSUFAASVBG4EoQOaBMYDoQKVBIAEYQJUAjkESAIJB7gETASgBHEEsQNzA8cCmgROBJQGAgR6BI0DcQMAA3EDJQX///////////////////////////////////////////////////////////////////////////////////////8IAgMDFASgBSAFCQdlBicCkwOTA9sDoAWgAggDoALGA5wF6wMDBf8EMgXLBC8FiARpBS8F8ALwAqAFoAWgBWMEvAcRBhMGuQWsBsUFXwV1Bk4HmwPDBIkGfAVECKMGjwamBY8GYQY5BXkFqwYZBgMJawbbBYQFkwPGA5MDoAWgBQAESAUxBUkETQV1BAwDMgVnBe0C6wIhBdYCBAiFBRYFTQUzBUUEIwRWA3sF5gR4B6sEWwUjBAAEGgMABKAF//+AlAIAQY7WBQukCKBA/////////////////////////////////////////////////////////////////////////////////////88BmwI1A/wDDgS4BXUFxAFtAm0C/AP8A/8BcwIFAhcDDgQOBA4EDgQOBA4EDgQOBA4EDgQkAiQC/AP8A/wDtQMnB6EEWgREBOwE6AOtAwwF/AQEAo0CKARdA9cGKgVMBSIEYgVYBK0D5gMiBYoEHgcnBOYDvwN0AhcDdAL8A/wDVALVAzQEYgM0BPsDcQLEAzQE1gHqAaMD1gFkBjQEOAQ0BDQEygIhA64CNASdA7gFdwOfAykDhAKvA4QC/AP//wAA////////////////////////////////AAD////////////////////////////////////////////////PAZsCggP8Aw4E1QWjBd4BfgJ+AvwD/AMQAnMCIwJwAw4EDgQOBA4EDgQOBA4EDgQOBA4ENQI1AvwD/AP8A7UDMAfZBHwEPAQLBecDrAMZBQwFIgKmAmAEYgP+BkUFaQVCBH0FgQTIA/YDOQW7BEAHaAQoBNMDmQJwA5kC/AP8A2cC8wNLBFkDSwQHBIgCywNLBPcBCwLXA/cBggZLBE0ESwRLBNgCMQPGAksEyQP2Ba0DygMuA8ACzQPAAvwD////////////////////////////////////////////////////////////////////////////////////////zwGbAjUD/AMOBLgFdQXEAW0CbQL8A/wD/wFzAgUCGgMOBA4EDgQOBA4EDgQOBA4EDgQOBCQCJAL8A/wD/AO1AycHoQRaBC4E7AToA60DDAX8BAQCjQIoBF0D1wYoBTwFIgRQBVgEngPmAyIFigQfBycE5gO/A3QCEwN0AvwD/ANUAh0EHQRUAx0E0gNxAh0EHQTWAeoBowPWAVQGHQQbBB0EHQS+Ah0DrgIdBJEDuAV3A5QDKQOEAq8DhAL8A////////////////////////////////////////////////////////////////////////////////////////88BmwKCA/wDDgTVBaMF3gF+An4C/AP8AxACcwIjAnkDDgQOBA4EDgQOBA4EDgQOBA4EDgQ1AjUC/AP8A/wDtQMwB9kEfAQmBAsF5wOsAxkFDAUiAqYCYARiA/4GQAVZBUIEawWBBLkD9gM5BbsEQQdoBCgE0wOZAmYDmQL8A/wDZwI5BDkESwM5BO4DiAI5BDgE9wELAtcD9wFuBjgEOAQ5BDkE0QInA8YCOATBA/YFrQPDAy4DwALNA8AC/AP//y5oAAAdZAAAQWMAADRkAAAyYwAAbAEAAG0BAABuAQAAbgEAQcDeBQvRBRHu7hMIA+7+7u7uAe7u7gHu7gn+7hIVF+4SAe7u7u4KDe7u7u7u7u7u7gHu7hYIAQEZDhju7hsYGu7uHe7u7u4BFfvu7u7uEB7u7u4AAAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhYRAgICAgICAgICAgICAhIQAhMCAgICAgICAgICAgICAgICAgICAgICAgICAgICAhQCFQICAgICAgICAgICAgICAgICAgICAgICAgICAgICDgIPAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgECAwQFBgcICQoLDA0AAAALAwQFDwcDDA0GDA0ODA0aFQABAAMHDgYPCAwNEhMJKhAREBYvMA0yERMuMhQSFBJBEywTQkAqQhn//ywAAAAAIgwNDiMPCRARChARzBARLUX8AQb2Dwf2JAIQES8wKDZJSiYxOzw9Nio5Oj4/L9hARDA3JUdDNUgrAAA4AAAAAAADCQAAAAEOAgsMCCMkJTM4OgANEBIbFhwSJy8iFzAeOQYHMgUPERQYKQATKQAAAAAANBUoHR4AISYxHy47GSwAGwAgGiorNwA1Ni0AAAAAAAICAQADAwEAAQABAQEAAgEBAAICAwEBAAAFAAEDAQMFAwEBAQECAAEABAIAAgMBAAMCAQABAQABAQEDAAAAAAAXGBgYGRobGxwcHR0eHh8fICAhISIjIyUmJCQnJygoKCkpKioqKyssLC0uLi8wMTMyNDQ0NTU1NjY3NwAAAADu7vzu7u7u7u4fIO757+7u7gzu7u4GD+7u8u7u7u7u9e4AQaDkBQsh/wMIBCEFCxITJxQVFikyQRcYGRosMzRCRhscHS4eSx8gAEHR5AULtgMBAQEBAQEBAQIDAQECAQEBAQEBAQEBAQEBAQEBAQEBAgEEBQEBAQEBAQYBAQcICQoKCgoKCgoKCgoBAQsBDAENDg8QERITFBUWExMTExcYGRMaGxwdExMTExMBHgEBEwEfICEiIxMkJSYTExMTJygpEyorLC0TExMTEwEBAQEBExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMuExMTLxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTMBMTExMTExMTExMTExMTExMAAAAAAAAEAAQAHAAcACEAIQAkACIACgACABYACQAiACIAIgAVAB0AAQAUABQAFAAUABQAFAAUAAgABAAFABwAGwAXABwAIQAgAB8AHgAJABMAAAAVABIAFQADAAcAFQAVABQAFAAUABQAFAAUABQAFAAIAAQABQAFAAYAHAAaABgAGQAhAAcAFQAUABQAFAAUABQAFAALABQADQAUAAwAFAAUABQADgAUABQA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AAAFcwAAhm4AAIhrAACzagAAa2oAAGlqAABfagAAiWkAAIdpAACFaQAAWGkAABxpAADgaAAAUWgAAIhnAAAzZwAAt2YAAJNmAABxZgAAb2YAAGxmAABrZAAAW2QAACpkAAAoZAAAF2QAABVkAABzYwAAV2MAAL5iAAC8YgAAumIAALhiAADpYAAAwGAAAL5gAACjYAAAoWAAAH9fAAB9XwAAMF8AAC5fAADfXQAAYl0AAHVXAABNTwAAokIAABJBAABAPgAAADsAAF06AABLOgAAFjkAANU1AAAiNQAAEi8AAOYtAACFHQAARx0AALQZAADIEgAAzQsAAIoLAABgCwAAmwkAAKgIAAB8BAAARwQAAD4EAAAyBAAACgQAAIBnAABET0NUWVBFAFNZU1RFTQBQVUJMSUMARU5USVRZAEFUVExJU1QARUxFTUVOVABOT1RBVElPTgBJTkNMVURFAElHTk9SRQBOREFUQQBBsIAGC7kBUIABAFaAAQBZgAEAX4ABAO5/AQBmgAEAb4ABAHeAAQBDREFUQQBJRABJRFJFRgBJRFJFRlMARU5USVRJRVMATk1UT0tFTgBOTVRPS0VOUwBJTVBMSUVEAFJFUVVJUkVEAEZJWEVEAEVNUFRZAEFOWQBQQ0RBVEEA3wEAAOABAADhAQAA4gEAAOMBAADkAQAA5QEAAOYBAADnAQAA6AEAAOkBAADqAQAA6wEAAOwBAADtAQAA7gEAAAEAQfmBBgsFFQoAAAkAQZCCBgvgARUQDBMcHgMNHyAhIiMbGhEZGRkZGRkZGRkZFhICDgsPHBgYGBgYGBYWFhYWFhYWFhYWFhYWFhYWFhYWFBwEHBYcGBgYGBgYFhYWFhYWFhYWFhYWFhYWFhYWFhYcJBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBYcHBwcHBwcHBwcFhwaHBwWHBwcHBwWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhwWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWHBYWFhYWFhYWAEHAhAYLef//////////////////////////////////////////AAAAAAAAAAT+//+H/v//BwAAAAAAAAAA//9/////f//////////zf/79//////9///////////8P4P////8x/P///wAAAAAAAAD//////////////wEA+AMAQdCFBgtBQNf///v/////f39U/f8PAP7f///////////+3/////8DAP///////58Z////zz8DAAAAAAAA/v///38C/v///38AQZqGBguzAf///wcHAAAAAAD+//8H/gcAAAAA/v//////////fP9/LwBgAAAA4P///////yMAAAD/AwAAAOCf+f///cUDAAAAsAMAAwDgh/n///1tAwAAAF4AABwA4K/7///97SMAAAAAAQAAAOCf+f///c0jAAAAsAMAAADgxz3WGMe/AwAAAAAAAAAA4N/9///97wMAAAAAAwAAAODf/f///e8DAAAAQAMAAADg3/3///3/AwAAAAADAEHghwYLGf7/////fw0APwAAAAAAAACWJfD+rmwNIB8AQYiIBgsG//7///8DAEG0iAYLcv////8/AP////9/AO3aBwAAAABQAVAxgqtiLAAAAABAAMmA9QcAAAAACAEC/////////////////////////w///////////////wP//z8//////z8//6r///8/////////31/cH88P/x/cHwAAAABATABBsIkGCwEHAEHAiQYLJoAAAAD+AwAA/v///////////x8A/v////////////8H4P////8fAEGAigYLFf//////////////////////////PwBBoIoGCxX//////////////////////////w8AQcWKBgvJAmD/B/7//4f+//8HAAAAAAAAgAD//3////9//////wAAAAAAAAD//////////////wEA+AMAAwAAAAAA//////////8/AAAAAwAAAMDX///7/////39/VP3/DwD+3////////////t//////ewD///////+fGf///88/AwAAAAAAAP7///9/Av7///9/AP7/+///uxYA////BwcAAAAAAP7//wf//wcA/wP///////////98/3/v//89/wPu////////8/8/Hv/P/wAA7p/5///9xdOfOYCwz/8DAOSH+f///W3ThzkAXsD/HwDur/v///3t8787AADB/wAA7p/5///9zfOPOcCww/8AAOzHPdYYx7/Dxz2AAID/AADu3/3///3vw989YADD/wAA7N/9///978PfPWBAw/8AAOzf/f///f/Dzz2AAMP/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bmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MAU3RhbGUgZmlsZSBoYW5kbGUAUmVtb3RlIEkvTyBlcnJvcgBRdW90YSBleGNlZWRlZABObyBtZWRpdW0gZm91bmQAV3JvbmcgbWVkaXVtIHR5cGUATXVsdGlob3AgYXR0ZW1wdGVkAFJlcXVpcmVkIGtleSBub3QgYXZhaWxhYmxlAEtleSBoYXMgZXhwaXJlZABLZXkgaGFzIGJlZW4gcmV2b2tlZABLZXkgd2FzIHJlamVjdGVkIGJ5IHNlcnZpY2UAAAAAAKUCWwDwAbUFjAUlAYMGHQOUBP8AxwMxAwsGvAGPAX8DygQrANoGrwBCA04D3AEOBBUAoQYNAZQCCwI4BmQCvAL/Al0D5wQLB88CywXvBdsF4QIeBkUChQCCAmwDbwTxAPMDGAXZANoDTAZUAnsBnQO9BAAAUQAVArsAswNtAP8BhQQvBfkEOABlAUYBnwC3BqgBcwJTAQBBuO8GCwwhBAAAAAAAAAAALwIAQdjvBgsGNQRHBFYEAEHu7wYLAqAEAEGC8AYLIkYFYAVuBWEGAADPAQAAAAAAAAAAyQbpBvkGHgc5B0kHXgcAQbDwBgtj0XSeAFedvSqAcFIP//8+JwoAAABkAAAA6AMAABAnAACghgEAQEIPAICWmAAA4fUFGAAAADUAAABxAAAAa////877//+Sv///AAAAAAAAAAAvdG1wL3RtcGZpbGVfWFhYWFhYAEGg8QYLQRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEHx8QYLIQ4AAAAAAAAAABkACg0ZGRkADQAAAgAJDgAAAAkADgAADgBBq/IGCwEMAEG38gYLFRMAAAAAEwAAAAAJDAAAAAAADAAADABB5fIGCwEQAEHx8gYLFQ8AAAAEDwAAAAAJEAAAAAAAEAAAEABBn/MGCwESAEGr8wYLHhEAAAAAEQAAAAAJEgAAAAAAEgAAEgAAGgAAABoaGgBB4vMGCw4aAAAAGhoaAAAAAAAACQBBk/QGCwEUAEGf9AYLFRcAAAAAFwAAAAAJFAAAAAAAFAAAFABBzfQGCwEWAEHZ9AYLJxUAAAAAFQAAAAAJFgAAAAAAFgAAFgAAMDEyMzQ1Njc4OUFCQ0RFRgBBpPUGCwIjAgBBzPUGCwj//////////wBBkPYGC/sI/////////////////////////////////////////////////////////////////wABAgMEBQYHCAn/////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP///////8KCwwNDg8QERITFBUWFxgZGhscHR4fICEiI/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////8AAQIEBwMGBQAAAAAAAAACAADAAwAAwAQAAMAFAADABgAAwAcAAMAIAADACQAAwAoAAMALAADADAAAwA0AAMAOAADADwAAwBAAAMARAADAEgAAwBMAAMAUAADAFQAAwBYAAMAXAADAGAAAwBkAAMAaAADAGwAAwBwAAMAdAADAHgAAwB8AAMAAAACzAQAAwwIAAMMDAADDBAAAwwUAAMMGAADDBwAAwwgA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";
  function G() {
    const A2 = atob(o), I2 = new Uint8Array(A2.length);
    for (let g2 = 0; g2 < A2.length; g2++)
      I2[g2] = A2.charCodeAt(g2);
    return I2.buffer;
  }
  function y() {
    return A({ wasm: G() }).then((A2) => new i(A2));
  }

  // node_modules/@babel/runtime/helpers/esm/extends.js
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i3 = 1; i3 < arguments.length; i3++) {
        var source = arguments[i3];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }

  // node_modules/mathjs/lib/esm/core/config.js
  var DEFAULT_CONFIG = {
    // minimum relative difference between two compared values,
    // used by all comparison functions
    epsilon: 1e-12,
    // type of default matrix output. Choose 'matrix' (default) or 'array'
    matrix: "Matrix",
    // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
    number: "number",
    // number of significant digits in BigNumbers
    precision: 64,
    // predictable output type of functions. When true, output type depends only
    // on the input types. When false (default), output type can vary depending
    // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
    // predictable is false, and returns `NaN` when true.
    predictable: false,
    // random seed for seeded pseudo random number generation
    // null = randomly seed
    randomSeed: null
  };

  // node_modules/mathjs/lib/esm/utils/is.js
  function isNumber(x) {
    return typeof x === "number";
  }
  function isBigNumber(x) {
    if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
      return false;
    }
    if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
      return true;
    }
    if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
      return true;
    }
    return false;
  }
  function isComplex(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
  }
  function isFraction(x) {
    return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
  }
  function isUnit(x) {
    return x && x.constructor.prototype.isUnit === true || false;
  }
  function isString(x) {
    return typeof x === "string";
  }
  var isArray = Array.isArray;
  function isMatrix(x) {
    return x && x.constructor.prototype.isMatrix === true || false;
  }
  function isCollection(x) {
    return Array.isArray(x) || isMatrix(x);
  }
  function isDenseMatrix(x) {
    return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isSparseMatrix(x) {
    return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
  }
  function isRange(x) {
    return x && x.constructor.prototype.isRange === true || false;
  }
  function isIndex(x) {
    return x && x.constructor.prototype.isIndex === true || false;
  }
  function isBoolean(x) {
    return typeof x === "boolean";
  }
  function isResultSet(x) {
    return x && x.constructor.prototype.isResultSet === true || false;
  }
  function isHelp(x) {
    return x && x.constructor.prototype.isHelp === true || false;
  }
  function isFunction(x) {
    return typeof x === "function";
  }
  function isDate(x) {
    return x instanceof Date;
  }
  function isRegExp(x) {
    return x instanceof RegExp;
  }
  function isObject(x) {
    return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
  }
  function isNull(x) {
    return x === null;
  }
  function isUndefined(x) {
    return x === void 0;
  }
  function isAccessorNode(x) {
    return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isArrayNode(x) {
    return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isAssignmentNode(x) {
    return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isBlockNode(x) {
    return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConditionalNode(x) {
    return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isConstantNode(x) {
    return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
  }
  function rule2Node(node) {
    return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
  }
  function isFunctionAssignmentNode(x) {
    return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isFunctionNode(x) {
    return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isIndexNode(x) {
    return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isNode(x) {
    return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isObjectNode(x) {
    return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isOperatorNode(x) {
    return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isParenthesisNode(x) {
    return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRangeNode(x) {
    return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isRelationalNode(x) {
    return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isSymbolNode(x) {
    return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
  }
  function isChain(x) {
    return x && x.constructor.prototype.isChain === true || false;
  }
  function typeOf(x) {
    var t = typeof x;
    if (t === "object") {
      if (x === null)
        return "null";
      if (isBigNumber(x))
        return "BigNumber";
      if (x.constructor && x.constructor.name)
        return x.constructor.name;
      return "Object";
    }
    return t;
  }

  // node_modules/mathjs/lib/esm/utils/object.js
  function clone(x) {
    var type = typeof x;
    if (type === "number" || type === "string" || type === "boolean" || x === null || x === void 0) {
      return x;
    }
    if (typeof x.clone === "function") {
      return x.clone();
    }
    if (Array.isArray(x)) {
      return x.map(function(value) {
        return clone(value);
      });
    }
    if (x instanceof Date)
      return new Date(x.valueOf());
    if (isBigNumber(x))
      return x;
    if (isObject(x)) {
      return mapObject(x, clone);
    }
    throw new TypeError("Cannot clone: unknown type of value (value: ".concat(x, ")"));
  }
  function mapObject(object, callback) {
    var clone5 = {};
    for (var key in object) {
      if (hasOwnProperty(object, key)) {
        clone5[key] = callback(object[key]);
      }
    }
    return clone5;
  }
  function extend(a, b) {
    for (var prop in b) {
      if (hasOwnProperty(b, prop)) {
        a[prop] = b[prop];
      }
    }
    return a;
  }
  function deepStrictEqual(a, b) {
    var prop, i3, len;
    if (Array.isArray(a)) {
      if (!Array.isArray(b)) {
        return false;
      }
      if (a.length !== b.length) {
        return false;
      }
      for (i3 = 0, len = a.length; i3 < len; i3++) {
        if (!deepStrictEqual(a[i3], b[i3])) {
          return false;
        }
      }
      return true;
    } else if (typeof a === "function") {
      return a === b;
    } else if (a instanceof Object) {
      if (Array.isArray(b) || !(b instanceof Object)) {
        return false;
      }
      for (prop in a) {
        if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
          return false;
        }
      }
      for (prop in b) {
        if (!(prop in a)) {
          return false;
        }
      }
      return true;
    } else {
      return a === b;
    }
  }
  function lazy(object, prop, valueResolver) {
    var _uninitialized = true;
    var _value;
    Object.defineProperty(object, prop, {
      get: function get() {
        if (_uninitialized) {
          _value = valueResolver();
          _uninitialized = false;
        }
        return _value;
      },
      set: function set(value) {
        _value = value;
        _uninitialized = false;
      },
      configurable: true,
      enumerable: true
    });
  }
  function hasOwnProperty(object, property) {
    return object && Object.hasOwnProperty.call(object, property);
  }
  function pickShallow(object, properties2) {
    var copy = {};
    for (var i3 = 0; i3 < properties2.length; i3++) {
      var key = properties2[i3];
      var value = object[key];
      if (value !== void 0) {
        copy[key] = value;
      }
    }
    return copy;
  }

  // node_modules/mathjs/lib/esm/core/function/config.js
  var MATRIX_OPTIONS = ["Matrix", "Array"];
  var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];

  // node_modules/mathjs/lib/esm/entry/configReadonly.js
  var config = function config2(options) {
    if (options) {
      throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
    }
    return Object.freeze(DEFAULT_CONFIG);
  };
  _extends(config, DEFAULT_CONFIG, {
    MATRIX_OPTIONS,
    NUMBER_OPTIONS
  });

  // node_modules/mathjs/lib/esm/core/function/typed.js
  var import_typed_function = __toESM(require_typed_function(), 1);

  // node_modules/mathjs/lib/esm/utils/number.js
  function isInteger(value) {
    if (typeof value === "boolean") {
      return true;
    }
    return isFinite(value) ? value === Math.round(value) : false;
  }
  var sign = Math.sign || function(x) {
    if (x > 0) {
      return 1;
    } else if (x < 0) {
      return -1;
    } else {
      return 0;
    }
  };
  var log2 = Math.log2 || function log22(x) {
    return Math.log(x) / Math.LN2;
  };
  var log10 = Math.log10 || function log102(x) {
    return Math.log(x) / Math.LN10;
  };
  var log1p = Math.log1p || function(x) {
    return Math.log(x + 1);
  };
  var cbrt = Math.cbrt || function cbrt2(x) {
    if (x === 0) {
      return x;
    }
    var negate = x < 0;
    var result;
    if (negate) {
      x = -x;
    }
    if (isFinite(x)) {
      result = Math.exp(Math.log(x) / 3);
      result = (x / (result * result) + 2 * result) / 3;
    } else {
      result = x;
    }
    return negate ? -result : result;
  };
  var expm1 = Math.expm1 || function expm12(x) {
    return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
  };
  function formatNumberToBase(n, base, size2) {
    var prefixes = {
      2: "0b",
      8: "0o",
      16: "0x"
    };
    var prefix = prefixes[base];
    var suffix = "";
    if (size2) {
      if (size2 < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size2)) {
        throw new Error("size must be an integer");
      }
      if (n > 2 ** (size2 - 1) - 1 || n < -(2 ** (size2 - 1))) {
        throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
      }
      if (!isInteger(n)) {
        throw new Error("Value must be an integer");
      }
      if (n < 0) {
        n = n + 2 ** size2;
      }
      suffix = "i".concat(size2);
    }
    var sign4 = "";
    if (n < 0) {
      n = -n;
      sign4 = "-";
    }
    return "".concat(sign4).concat(prefix).concat(n.toString(base)).concat(suffix);
  }
  function format(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (value === Infinity) {
      return "Infinity";
    } else if (value === -Infinity) {
      return "-Infinity";
    } else if (isNaN(value)) {
      return "NaN";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options) {
      if (options.notation) {
        notation = options.notation;
      }
      if (isNumber(options)) {
        precision = options;
      } else if (isNumber(options.precision)) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed(value, precision);
      case "exponential":
        return toExponential(value, precision);
      case "engineering":
        return toEngineering(value, precision);
      case "bin":
        return formatNumberToBase(value, 2, wordSize);
      case "oct":
        return formatNumberToBase(value, 8, wordSize);
      case "hex":
        return formatNumberToBase(value, 16, wordSize);
      case "auto":
        return toPrecision(value, precision, options && options).replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e3 = arguments[4];
          return digits2 !== "." ? digits2 + e3 : e3;
        });
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function splitNumber(value) {
    var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
    if (!match) {
      throw new SyntaxError("Invalid number " + value);
    }
    var sign4 = match[1];
    var digits2 = match[2];
    var exponent = parseFloat(match[4] || "0");
    var dot2 = digits2.indexOf(".");
    exponent += dot2 !== -1 ? dot2 - 1 : digits2.length - 1;
    var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros3) {
      exponent -= zeros3.length;
      return "";
    }).replace(/0*$/, "").split("").map(function(d) {
      return parseInt(d);
    });
    if (coefficients.length === 0) {
      coefficients.push(0);
      exponent++;
    }
    return {
      sign: sign4,
      coefficients,
      exponent
    };
  }
  function toEngineering(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = roundDigits(split, precision);
    var e3 = rounded.exponent;
    var c = rounded.coefficients;
    var newExp = e3 % 3 === 0 ? e3 : e3 < 0 ? e3 - 3 - e3 % 3 : e3 - e3 % 3;
    if (isNumber(precision)) {
      while (precision > c.length || e3 - newExp + 1 > c.length) {
        c.push(0);
      }
    } else {
      var missingZeros = Math.abs(e3 - newExp) - (c.length - 1);
      for (var i3 = 0; i3 < missingZeros; i3++) {
        c.push(0);
      }
    }
    var expDiff = Math.abs(e3 - newExp);
    var decimalIdx = 1;
    while (expDiff > 0) {
      decimalIdx++;
      expDiff--;
    }
    var decimals = c.slice(decimalIdx).join("");
    var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
    var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e3 >= 0 ? "+" : "") + newExp.toString();
    return rounded.sign + str;
  }
  function toFixed(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var splitValue = splitNumber(value);
    var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
    var c = rounded.coefficients;
    var p = rounded.exponent + 1;
    var pp = p + (precision || 0);
    if (c.length < pp) {
      c = c.concat(zeros(pp - c.length));
    }
    if (p < 0) {
      c = zeros(-p + 1).concat(c);
      p = 1;
    }
    if (p < c.length) {
      c.splice(p, 0, p === 0 ? "0." : ".");
    }
    return rounded.sign + c.join("");
  }
  function toExponential(value, precision) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    var c = rounded.coefficients;
    var e3 = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros(precision - c.length));
    }
    var first = c.shift();
    return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e3 >= 0 ? "+" : "") + e3;
  }
  function toPrecision(value, precision, options) {
    if (isNaN(value) || !isFinite(value)) {
      return String(value);
    }
    var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
    var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
    var split = splitNumber(value);
    var rounded = precision ? roundDigits(split, precision) : split;
    if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
      return toExponential(value, precision);
    } else {
      var c = rounded.coefficients;
      var e3 = rounded.exponent;
      if (c.length < precision) {
        c = c.concat(zeros(precision - c.length));
      }
      c = c.concat(zeros(e3 - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
      c = zeros(-e3).concat(c);
      var dot2 = e3 > 0 ? e3 : 0;
      if (dot2 < c.length - 1) {
        c.splice(dot2 + 1, 0, ".");
      }
      return rounded.sign + c.join("");
    }
  }
  function roundDigits(split, precision) {
    var rounded = {
      sign: split.sign,
      coefficients: split.coefficients,
      exponent: split.exponent
    };
    var c = rounded.coefficients;
    while (precision <= 0) {
      c.unshift(0);
      rounded.exponent++;
      precision++;
    }
    if (c.length > precision) {
      var removed = c.splice(precision, c.length - precision);
      if (removed[0] >= 5) {
        var i3 = precision - 1;
        c[i3]++;
        while (c[i3] === 10) {
          c.pop();
          if (i3 === 0) {
            c.unshift(0);
            rounded.exponent++;
            i3++;
          }
          i3--;
          c[i3]++;
        }
      }
    }
    return rounded;
  }
  function zeros(length) {
    var arr = [];
    for (var i3 = 0; i3 < length; i3++) {
      arr.push(0);
    }
    return arr;
  }
  function digits(value) {
    return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
  }
  var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
  function nearlyEqual(x, y2, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x === y2;
    }
    if (x === y2) {
      return true;
    }
    if (isNaN(x) || isNaN(y2)) {
      return false;
    }
    if (isFinite(x) && isFinite(y2)) {
      var diff2 = Math.abs(x - y2);
      if (diff2 <= DBL_EPSILON) {
        return true;
      } else {
        return diff2 <= Math.max(Math.abs(x), Math.abs(y2)) * epsilon;
      }
    }
    return false;
  }
  var acosh = Math.acosh || function(x) {
    return Math.log(Math.sqrt(x * x - 1) + x);
  };
  var asinh = Math.asinh || function(x) {
    return Math.log(Math.sqrt(x * x + 1) + x);
  };
  var atanh = Math.atanh || function(x) {
    return Math.log((1 + x) / (1 - x)) / 2;
  };
  var cosh = Math.cosh || function(x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
  };
  var sinh = Math.sinh || function(x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
  };
  var tanh = Math.tanh || function(x) {
    var e3 = Math.exp(2 * x);
    return (e3 - 1) / (e3 + 1);
  };
  function copysign(x, y2) {
    var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
    var signy = y2 > 0 ? true : y2 < 0 ? false : 1 / y2 === Infinity;
    return signx ^ signy ? -x : x;
  }

  // node_modules/mathjs/lib/esm/utils/bignumber/formatter.js
  function formatBigNumberToBase(n, base, size2) {
    var BigNumberCtor = n.constructor;
    var big2 = new BigNumberCtor(2);
    var suffix = "";
    if (size2) {
      if (size2 < 1) {
        throw new Error("size must be in greater than 0");
      }
      if (!isInteger(size2)) {
        throw new Error("size must be an integer");
      }
      if (n.greaterThan(big2.pow(size2 - 1).sub(1)) || n.lessThan(big2.pow(size2 - 1).mul(-1))) {
        throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
      }
      if (!n.isInteger()) {
        throw new Error("Value must be an integer");
      }
      if (n.lessThan(0)) {
        n = n.add(big2.pow(size2));
      }
      suffix = "i".concat(size2);
    }
    switch (base) {
      case 2:
        return "".concat(n.toBinary()).concat(suffix);
      case 8:
        return "".concat(n.toOctal()).concat(suffix);
      case 16:
        return "".concat(n.toHexadecimal()).concat(suffix);
      default:
        throw new Error("Base ".concat(base, " not supported "));
    }
  }
  function format2(value, options) {
    if (typeof options === "function") {
      return options(value);
    }
    if (!value.isFinite()) {
      return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
    }
    var notation = "auto";
    var precision;
    var wordSize;
    if (options !== void 0) {
      if (options.notation) {
        notation = options.notation;
      }
      if (typeof options === "number") {
        precision = options;
      } else if (options.precision !== void 0) {
        precision = options.precision;
      }
      if (options.wordSize) {
        wordSize = options.wordSize;
        if (typeof wordSize !== "number") {
          throw new Error('Option "wordSize" must be a number');
        }
      }
    }
    switch (notation) {
      case "fixed":
        return toFixed2(value, precision);
      case "exponential":
        return toExponential2(value, precision);
      case "engineering":
        return toEngineering2(value, precision);
      case "bin":
        return formatBigNumberToBase(value, 2, wordSize);
      case "oct":
        return formatBigNumberToBase(value, 8, wordSize);
      case "hex":
        return formatBigNumberToBase(value, 16, wordSize);
      case "auto": {
        var lowerExp = options && options.lowerExp !== void 0 ? options.lowerExp : -3;
        var upperExp = options && options.upperExp !== void 0 ? options.upperExp : 5;
        if (value.isZero())
          return "0";
        var str;
        var rounded = value.toSignificantDigits(precision);
        var exp3 = rounded.e;
        if (exp3 >= lowerExp && exp3 < upperExp) {
          str = rounded.toFixed();
        } else {
          str = toExponential2(value, precision);
        }
        return str.replace(/((\.\d*?)(0+))($|e)/, function() {
          var digits2 = arguments[2];
          var e3 = arguments[4];
          return digits2 !== "." ? digits2 + e3 : e3;
        });
      }
      default:
        throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
    }
  }
  function toEngineering2(value, precision) {
    var e3 = value.e;
    var newExp = e3 % 3 === 0 ? e3 : e3 < 0 ? e3 - 3 - e3 % 3 : e3 - e3 % 3;
    var valueWithoutExp = value.mul(Math.pow(10, -newExp));
    var valueStr = valueWithoutExp.toPrecision(precision);
    if (valueStr.indexOf("e") !== -1) {
      var BigNumber2 = value.constructor;
      valueStr = new BigNumber2(valueStr).toFixed();
    }
    return valueStr + "e" + (e3 >= 0 ? "+" : "") + newExp.toString();
  }
  function toExponential2(value, precision) {
    if (precision !== void 0) {
      return value.toExponential(precision - 1);
    } else {
      return value.toExponential();
    }
  }
  function toFixed2(value, precision) {
    return value.toFixed(precision);
  }

  // node_modules/mathjs/lib/esm/utils/string.js
  function endsWith(text, search) {
    var start = text.length - search.length;
    var end = text.length;
    return text.substring(start, end) === search;
  }
  function format3(value, options) {
    var result = _format(value, options);
    if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
      return result.substring(0, options.truncate - 3) + "...";
    }
    return result;
  }
  function _format(value, options) {
    if (typeof value === "number") {
      return format(value, options);
    }
    if (isBigNumber(value)) {
      return format2(value, options);
    }
    if (looksLikeFraction(value)) {
      if (!options || options.fraction !== "decimal") {
        return value.s * value.n + "/" + value.d;
      } else {
        return value.toString();
      }
    }
    if (Array.isArray(value)) {
      return formatArray(value, options);
    }
    if (isString(value)) {
      return stringify(value);
    }
    if (typeof value === "function") {
      return value.syntax ? String(value.syntax) : "function";
    }
    if (value && typeof value === "object") {
      if (typeof value.format === "function") {
        return value.format(options);
      } else if (value && value.toString(options) !== {}.toString()) {
        return value.toString(options);
      } else {
        var entries = Object.keys(value).map((key) => {
          return stringify(key) + ": " + format3(value[key], options);
        });
        return "{" + entries.join(", ") + "}";
      }
    }
    return String(value);
  }
  function stringify(value) {
    var text = String(value);
    var escaped = "";
    var i3 = 0;
    while (i3 < text.length) {
      var c = text.charAt(i3);
      escaped += c in controlCharacters ? controlCharacters[c] : c;
      i3++;
    }
    return '"' + escaped + '"';
  }
  var controlCharacters = {
    '"': '\\"',
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "	": "\\t"
  };
  function escape(value) {
    var text = String(value);
    text = text.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    return text;
  }
  function formatArray(array, options) {
    if (Array.isArray(array)) {
      var str = "[";
      var len = array.length;
      for (var i3 = 0; i3 < len; i3++) {
        if (i3 !== 0) {
          str += ", ";
        }
        str += formatArray(array[i3], options);
      }
      str += "]";
      return str;
    } else {
      return format3(array, options);
    }
  }
  function looksLikeFraction(value) {
    return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
  }
  function compareText(x, y2) {
    if (!isString(x)) {
      throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(x) + ", index: 0)");
    }
    if (!isString(y2)) {
      throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf(y2) + ", index: 1)");
    }
    return x === y2 ? 0 : x > y2 ? 1 : -1;
  }

  // node_modules/mathjs/lib/esm/error/DimensionError.js
  function DimensionError(actual, expected, relation) {
    if (!(this instanceof DimensionError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.actual = actual;
    this.expected = expected;
    this.relation = relation;
    this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
    this.stack = new Error().stack;
  }
  DimensionError.prototype = new RangeError();
  DimensionError.prototype.constructor = RangeError;
  DimensionError.prototype.name = "DimensionError";
  DimensionError.prototype.isDimensionError = true;

  // node_modules/mathjs/lib/esm/error/IndexError.js
  function IndexError(index2, min3, max3) {
    if (!(this instanceof IndexError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.index = index2;
    if (arguments.length < 3) {
      this.min = 0;
      this.max = min3;
    } else {
      this.min = min3;
      this.max = max3;
    }
    if (this.min !== void 0 && this.index < this.min) {
      this.message = "Index out of range (" + this.index + " < " + this.min + ")";
    } else if (this.max !== void 0 && this.index >= this.max) {
      this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
    } else {
      this.message = "Index out of range (" + this.index + ")";
    }
    this.stack = new Error().stack;
  }
  IndexError.prototype = new RangeError();
  IndexError.prototype.constructor = RangeError;
  IndexError.prototype.name = "IndexError";
  IndexError.prototype.isIndexError = true;

  // node_modules/mathjs/lib/esm/utils/array.js
  function arraySize(x) {
    var s = [];
    while (Array.isArray(x)) {
      s.push(x.length);
      x = x[0];
    }
    return s;
  }
  function _validate(array, size2, dim) {
    var i3;
    var len = array.length;
    if (len !== size2[dim]) {
      throw new DimensionError(len, size2[dim]);
    }
    if (dim < size2.length - 1) {
      var dimNext = dim + 1;
      for (i3 = 0; i3 < len; i3++) {
        var child = array[i3];
        if (!Array.isArray(child)) {
          throw new DimensionError(size2.length - 1, size2.length, "<");
        }
        _validate(array[i3], size2, dimNext);
      }
    } else {
      for (i3 = 0; i3 < len; i3++) {
        if (Array.isArray(array[i3])) {
          throw new DimensionError(size2.length + 1, size2.length, ">");
        }
      }
    }
  }
  function validate(array, size2) {
    var isScalar = size2.length === 0;
    if (isScalar) {
      if (Array.isArray(array)) {
        throw new DimensionError(array.length, 0);
      }
    } else {
      _validate(array, size2, 0);
    }
  }
  function validateIndexSourceSize(value, index2) {
    var valueSize = value.isMatrix ? value._size : arraySize(value);
    var sourceSize = index2._sourceSize;
    sourceSize.forEach((sourceDim, i3) => {
      if (sourceDim !== null && sourceDim !== valueSize[i3]) {
        throw new DimensionError(sourceDim, valueSize[i3]);
      }
    });
  }
  function validateIndex(index2, length) {
    if (index2 !== void 0) {
      if (!isNumber(index2) || !isInteger(index2)) {
        throw new TypeError("Index must be an integer (value: " + index2 + ")");
      }
      if (index2 < 0 || typeof length === "number" && index2 >= length) {
        throw new IndexError(index2, length);
      }
    }
  }
  function isEmptyIndex(index2) {
    for (var i3 = 0; i3 < index2._dimensions.length; ++i3) {
      var dimension = index2._dimensions[i3];
      if (dimension._data && isArray(dimension._data)) {
        if (dimension._size[0] === 0) {
          return true;
        }
      } else if (dimension.isRange) {
        if (dimension.start === dimension.end) {
          return true;
        }
      } else if (isString(dimension)) {
        if (dimension.length === 0) {
          return true;
        }
      }
    }
    return false;
  }
  function resize(array, size2, defaultValue) {
    if (!Array.isArray(size2)) {
      throw new TypeError("Array expected");
    }
    if (size2.length === 0) {
      throw new Error("Resizing to scalar is not supported");
    }
    size2.forEach(function(value) {
      if (!isNumber(value) || !isInteger(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
      }
    });
    if (isNumber(array) || isBigNumber(array)) {
      array = [array];
    }
    var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
    _resize(array, size2, 0, _defaultValue);
    return array;
  }
  function _resize(array, size2, dim, defaultValue) {
    var i3;
    var elem;
    var oldLen = array.length;
    var newLen = size2[dim];
    var minLen = Math.min(oldLen, newLen);
    array.length = newLen;
    if (dim < size2.length - 1) {
      var dimNext = dim + 1;
      for (i3 = 0; i3 < minLen; i3++) {
        elem = array[i3];
        if (!Array.isArray(elem)) {
          elem = [elem];
          array[i3] = elem;
        }
        _resize(elem, size2, dimNext, defaultValue);
      }
      for (i3 = minLen; i3 < newLen; i3++) {
        elem = [];
        array[i3] = elem;
        _resize(elem, size2, dimNext, defaultValue);
      }
    } else {
      for (i3 = 0; i3 < minLen; i3++) {
        while (Array.isArray(array[i3])) {
          array[i3] = array[i3][0];
        }
      }
      for (i3 = minLen; i3 < newLen; i3++) {
        array[i3] = defaultValue;
      }
    }
  }
  function reshape(array, sizes) {
    var flatArray = flatten(array);
    var currentLength = flatArray.length;
    if (!Array.isArray(array) || !Array.isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length === 0) {
      throw new DimensionError(0, currentLength, "!=");
    }
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = product(sizes);
    if (currentLength !== newLength) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    try {
      return _reshape(flatArray, sizes);
    } catch (e3) {
      if (e3 instanceof DimensionError) {
        throw new DimensionError(newLength, currentLength, "!=");
      }
      throw e3;
    }
  }
  function processSizesWildcard(sizes, currentLength) {
    var newLength = product(sizes);
    var processedSizes = sizes.slice();
    var WILDCARD = -1;
    var wildCardIndex = sizes.indexOf(WILDCARD);
    var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
    if (isMoreThanOneWildcard) {
      throw new Error("More than one wildcard in sizes");
    }
    var hasWildcard = wildCardIndex >= 0;
    var canReplaceWildcard = currentLength % newLength === 0;
    if (hasWildcard) {
      if (canReplaceWildcard) {
        processedSizes[wildCardIndex] = -currentLength / newLength;
      } else {
        throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
      }
    }
    return processedSizes;
  }
  function product(array) {
    return array.reduce((prev, curr) => prev * curr, 1);
  }
  function _reshape(array, sizes) {
    var tmpArray = array;
    var tmpArray2;
    for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
      var size2 = sizes[sizeIndex];
      tmpArray2 = [];
      var length = tmpArray.length / size2;
      for (var i3 = 0; i3 < length; i3++) {
        tmpArray2.push(tmpArray.slice(i3 * size2, (i3 + 1) * size2));
      }
      tmpArray = tmpArray2;
    }
    return tmpArray;
  }
  function squeeze(array, size2) {
    var s = size2 || arraySize(array);
    while (Array.isArray(array) && array.length === 1) {
      array = array[0];
      s.shift();
    }
    var dims = s.length;
    while (s[dims - 1] === 1) {
      dims--;
    }
    if (dims < s.length) {
      array = _squeeze(array, dims, 0);
      s.length = dims;
    }
    return array;
  }
  function _squeeze(array, dims, dim) {
    var i3, ii;
    if (dim < dims) {
      var next = dim + 1;
      for (i3 = 0, ii = array.length; i3 < ii; i3++) {
        array[i3] = _squeeze(array[i3], dims, next);
      }
    } else {
      while (Array.isArray(array)) {
        array = array[0];
      }
    }
    return array;
  }
  function unsqueeze(array, dims, outer, size2) {
    var s = size2 || arraySize(array);
    if (outer) {
      for (var i3 = 0; i3 < outer; i3++) {
        array = [array];
        s.unshift(1);
      }
    }
    array = _unsqueeze(array, dims, 0);
    while (s.length < dims) {
      s.push(1);
    }
    return array;
  }
  function _unsqueeze(array, dims, dim) {
    var i3, ii;
    if (Array.isArray(array)) {
      var next = dim + 1;
      for (i3 = 0, ii = array.length; i3 < ii; i3++) {
        array[i3] = _unsqueeze(array[i3], dims, next);
      }
    } else {
      for (var d = dim; d < dims; d++) {
        array = [array];
      }
    }
    return array;
  }
  function flatten(array) {
    if (!Array.isArray(array)) {
      return array;
    }
    var flat = [];
    array.forEach(function callback(value) {
      if (Array.isArray(value)) {
        value.forEach(callback);
      } else {
        flat.push(value);
      }
    });
    return flat;
  }
  function map(array, callback) {
    return Array.prototype.map.call(array, callback);
  }
  function forEach(array, callback) {
    Array.prototype.forEach.call(array, callback);
  }
  function filter(array, callback) {
    if (arraySize(array).length !== 1) {
      throw new Error("Only one dimensional matrices supported");
    }
    return Array.prototype.filter.call(array, callback);
  }
  function filterRegExp(array, regexp) {
    if (arraySize(array).length !== 1) {
      throw new Error("Only one dimensional matrices supported");
    }
    return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
  }
  function join(array, separator) {
    return Array.prototype.join.call(array, separator);
  }
  function identify(a) {
    if (!Array.isArray(a)) {
      throw new TypeError("Array input expected");
    }
    if (a.length === 0) {
      return a;
    }
    var b = [];
    var count2 = 0;
    b[0] = {
      value: a[0],
      identifier: 0
    };
    for (var i3 = 1; i3 < a.length; i3++) {
      if (a[i3] === a[i3 - 1]) {
        count2++;
      } else {
        count2 = 0;
      }
      b.push({
        value: a[i3],
        identifier: count2
      });
    }
    return b;
  }
  function generalize(a) {
    if (!Array.isArray(a)) {
      throw new TypeError("Array input expected");
    }
    if (a.length === 0) {
      return a;
    }
    var b = [];
    for (var i3 = 0; i3 < a.length; i3++) {
      b.push(a[i3].value);
    }
    return b;
  }
  function getArrayDataType(array, typeOf3) {
    var type;
    var length = 0;
    for (var i3 = 0; i3 < array.length; i3++) {
      var item = array[i3];
      var _isArray = Array.isArray(item);
      if (i3 === 0 && _isArray) {
        length = item.length;
      }
      if (_isArray && item.length !== length) {
        return void 0;
      }
      var itemType = _isArray ? getArrayDataType(item, typeOf3) : typeOf3(item);
      if (type === void 0) {
        type = itemType;
      } else if (type !== itemType) {
        return "mixed";
      } else {
      }
    }
    return type;
  }
  function concatRecursive(a, b, concatDim, dim) {
    if (dim < concatDim) {
      if (a.length !== b.length) {
        throw new DimensionError(a.length, b.length);
      }
      var c = [];
      for (var i3 = 0; i3 < a.length; i3++) {
        c[i3] = concatRecursive(a[i3], b[i3], concatDim, dim + 1);
      }
      return c;
    } else {
      return a.concat(b);
    }
  }
  function concat() {
    var arrays = Array.prototype.slice.call(arguments, 0, -1);
    var concatDim = Array.prototype.slice.call(arguments, -1);
    if (arrays.length === 1) {
      return arrays[0];
    }
    if (arrays.length > 1) {
      return arrays.slice(1).reduce(function(A2, B2) {
        return concatRecursive(A2, B2, concatDim, 0);
      }, arrays[0]);
    } else {
      throw new Error("Wrong number of arguments in function concat");
    }
  }
  function broadcastSizes() {
    for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {
      sizes[_key] = arguments[_key];
    }
    var dimensions = sizes.map((s) => s.length);
    var N = Math.max(...dimensions);
    var sizeMax = new Array(N).fill(null);
    for (var i3 = 0; i3 < sizes.length; i3++) {
      var size2 = sizes[i3];
      var dim = dimensions[i3];
      for (var j = 0; j < dim; j++) {
        var n = N - dim + j;
        if (size2[j] > sizeMax[n]) {
          sizeMax[n] = size2[j];
        }
      }
    }
    for (var _i = 0; _i < sizes.length; _i++) {
      checkBroadcastingRules(sizes[_i], sizeMax);
    }
    return sizeMax;
  }
  function checkBroadcastingRules(size2, toSize) {
    var N = toSize.length;
    var dim = size2.length;
    for (var j = 0; j < dim; j++) {
      var n = N - dim + j;
      if (size2[j] < toSize[n] && size2[j] > 1 || size2[j] > toSize[n]) {
        throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(size2, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size2[j], " to size ").concat(toSize[n]));
      }
    }
  }
  function broadcastTo(array, toSize) {
    var Asize = arraySize(array);
    if (deepStrictEqual(Asize, toSize)) {
      return array;
    }
    checkBroadcastingRules(Asize, toSize);
    var broadcastedSize = broadcastSizes(Asize, toSize);
    var N = broadcastedSize.length;
    var paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];
    var A2 = clone2(array);
    if (Asize.length < N) {
      A2 = reshape(A2, paddedSize);
      Asize = arraySize(A2);
    }
    for (var dim = 0; dim < N; dim++) {
      if (Asize[dim] < broadcastedSize[dim]) {
        A2 = stretch(A2, broadcastedSize[dim], dim);
        Asize = arraySize(A2);
      }
    }
    return A2;
  }
  function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
    return concat(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
  }
  function clone2(array) {
    return _extends([], array);
  }

  // node_modules/mathjs/lib/esm/utils/factory.js
  function factory(name310, dependencies310, create, meta) {
    function assertAndCreate(scope) {
      var deps = pickShallow(scope, dependencies310.map(stripOptionalNotation));
      assertDependencies(name310, dependencies310, scope);
      return create(deps);
    }
    assertAndCreate.isFactory = true;
    assertAndCreate.fn = name310;
    assertAndCreate.dependencies = dependencies310.slice().sort();
    if (meta) {
      assertAndCreate.meta = meta;
    }
    return assertAndCreate;
  }
  function assertDependencies(name310, dependencies310, scope) {
    var allDefined = dependencies310.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
    if (!allDefined) {
      var missingDependencies = dependencies310.filter((dependency) => scope[dependency] === void 0);
      throw new Error('Cannot create function "'.concat(name310, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
    }
  }
  function isOptionalDependency(dependency) {
    return dependency && dependency[0] === "?";
  }
  function stripOptionalNotation(dependency) {
    return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
  }

  // node_modules/mathjs/lib/esm/utils/customs.js
  function getSafeProperty(object, prop) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      return object[prop];
    }
    if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
      throw new Error('Cannot access method "' + prop + '" as a property');
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function setSafeProperty(object, prop, value) {
    if (isPlainObject(object) && isSafeProperty(object, prop)) {
      object[prop] = value;
      return value;
    }
    throw new Error('No access to property "' + prop + '"');
  }
  function hasSafeProperty(object, prop) {
    return prop in object;
  }
  function isSafeProperty(object, prop) {
    if (!object || typeof object !== "object") {
      return false;
    }
    if (hasOwnProperty(safeNativeProperties, prop)) {
      return true;
    }
    if (prop in Object.prototype) {
      return false;
    }
    if (prop in Function.prototype) {
      return false;
    }
    return true;
  }
  function getSafeMethod(object, method) {
    if (!isSafeMethod(object, method)) {
      throw new Error('No access to method "' + method + '"');
    }
    return object[method];
  }
  function isSafeMethod(object, method) {
    if (object === null || object === void 0 || typeof object[method] !== "function") {
      return false;
    }
    if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
      return false;
    }
    if (hasOwnProperty(safeNativeMethods, method)) {
      return true;
    }
    if (method in Object.prototype) {
      return false;
    }
    if (method in Function.prototype) {
      return false;
    }
    return true;
  }
  function isPlainObject(object) {
    return typeof object === "object" && object && object.constructor === Object;
  }
  var safeNativeProperties = {
    length: true,
    name: true
  };
  var safeNativeMethods = {
    toString: true,
    valueOf: true,
    toLocaleString: true
  };

  // node_modules/mathjs/lib/esm/utils/map.js
  var ObjectWrappingMap = class {
    constructor(object) {
      this.wrappedObject = object;
    }
    keys() {
      return Object.keys(this.wrappedObject);
    }
    get(key) {
      return getSafeProperty(this.wrappedObject, key);
    }
    set(key, value) {
      setSafeProperty(this.wrappedObject, key, value);
      return this;
    }
    has(key) {
      return hasSafeProperty(this.wrappedObject, key);
    }
  };
  function createEmptyMap() {
    return /* @__PURE__ */ new Map();
  }
  function createMap(mapOrObject) {
    if (!mapOrObject) {
      return createEmptyMap();
    }
    if (isMap(mapOrObject)) {
      return mapOrObject;
    }
    if (isObject(mapOrObject)) {
      return new ObjectWrappingMap(mapOrObject);
    }
    throw new Error("createMap can create maps from objects or Maps");
  }
  function toObject(map3) {
    if (map3 instanceof ObjectWrappingMap) {
      return map3.wrappedObject;
    }
    var object = {};
    for (var key of map3.keys()) {
      var value = map3.get(key);
      setSafeProperty(object, key, value);
    }
    return object;
  }
  function isMap(object) {
    if (!object) {
      return false;
    }
    return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
  }
  function assign(map3) {
    for (var _len = arguments.length, objects = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      objects[_key - 1] = arguments[_key];
    }
    for (var args of objects) {
      if (!args) {
        continue;
      }
      if (isMap(args)) {
        for (var key of args.keys()) {
          map3.set(key, args.get(key));
        }
      } else if (isObject(args)) {
        for (var _key2 of Object.keys(args)) {
          map3.set(_key2, args[_key2]);
        }
      }
    }
    return map3;
  }

  // node_modules/mathjs/lib/esm/core/function/typed.js
  var _createTyped2 = function _createTyped() {
    _createTyped2 = import_typed_function.default.create;
    return import_typed_function.default;
  };
  var dependencies = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
  var createTyped = /* @__PURE__ */ factory("typed", dependencies, function createTyped2(_ref) {
    var {
      BigNumber: BigNumber2,
      Complex: Complex3,
      DenseMatrix: DenseMatrix2,
      Fraction: Fraction3
    } = _ref;
    var typed3 = _createTyped2();
    typed3.clear();
    typed3.addTypes([
      {
        name: "number",
        test: isNumber
      },
      {
        name: "Complex",
        test: isComplex
      },
      {
        name: "BigNumber",
        test: isBigNumber
      },
      {
        name: "Fraction",
        test: isFraction
      },
      {
        name: "Unit",
        test: isUnit
      },
      // The following type matches a valid variable name, i.e., an alphanumeric
      // string starting with an alphabetic character. It is used (at least)
      // in the definition of the derivative() function, as the argument telling
      // what to differentiate over must (currently) be a variable.
      {
        name: "identifier",
        test: (s) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s)
      },
      {
        name: "string",
        test: isString
      },
      {
        name: "Chain",
        test: isChain
      },
      {
        name: "Array",
        test: isArray
      },
      {
        name: "Matrix",
        test: isMatrix
      },
      {
        name: "DenseMatrix",
        test: isDenseMatrix
      },
      {
        name: "SparseMatrix",
        test: isSparseMatrix
      },
      {
        name: "Range",
        test: isRange
      },
      {
        name: "Index",
        test: isIndex
      },
      {
        name: "boolean",
        test: isBoolean
      },
      {
        name: "ResultSet",
        test: isResultSet
      },
      {
        name: "Help",
        test: isHelp
      },
      {
        name: "function",
        test: isFunction
      },
      {
        name: "Date",
        test: isDate
      },
      {
        name: "RegExp",
        test: isRegExp
      },
      {
        name: "null",
        test: isNull
      },
      {
        name: "undefined",
        test: isUndefined
      },
      {
        name: "AccessorNode",
        test: isAccessorNode
      },
      {
        name: "ArrayNode",
        test: isArrayNode
      },
      {
        name: "AssignmentNode",
        test: isAssignmentNode
      },
      {
        name: "BlockNode",
        test: isBlockNode
      },
      {
        name: "ConditionalNode",
        test: isConditionalNode
      },
      {
        name: "ConstantNode",
        test: isConstantNode
      },
      {
        name: "FunctionNode",
        test: isFunctionNode
      },
      {
        name: "FunctionAssignmentNode",
        test: isFunctionAssignmentNode
      },
      {
        name: "IndexNode",
        test: isIndexNode
      },
      {
        name: "Node",
        test: isNode
      },
      {
        name: "ObjectNode",
        test: isObjectNode
      },
      {
        name: "OperatorNode",
        test: isOperatorNode
      },
      {
        name: "ParenthesisNode",
        test: isParenthesisNode
      },
      {
        name: "RangeNode",
        test: isRangeNode
      },
      {
        name: "RelationalNode",
        test: isRelationalNode
      },
      {
        name: "SymbolNode",
        test: isSymbolNode
      },
      {
        name: "Map",
        test: isMap
      },
      {
        name: "Object",
        test: isObject
      }
      // order 'Object' last, it matches on other classes too
    ]);
    typed3.addConversions([{
      from: "number",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber2) {
          throwNoBignumber(x);
        }
        if (digits(x) > 15) {
          throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
        }
        return new BigNumber2(x);
      }
    }, {
      from: "number",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        return new Complex3(x, 0);
      }
    }, {
      from: "BigNumber",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        return new Complex3(x.toNumber(), 0);
      }
    }, {
      from: "Fraction",
      to: "BigNumber",
      convert: function convert(x) {
        throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
      }
    }, {
      from: "Fraction",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        return new Complex3(x.valueOf(), 0);
      }
    }, {
      from: "number",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction3) {
          throwNoFraction(x);
        }
        var f = new Fraction3(x);
        if (f.valueOf() !== x) {
          throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
        }
        return f;
      }
    }, {
      // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
      //  from: 'Fraction',
      //  to: 'number',
      //  convert: function (x) {
      //    return x.valueOf()
      //  }
      // }, {
      from: "string",
      to: "number",
      convert: function convert(x) {
        var n = Number(x);
        if (isNaN(n)) {
          throw new Error('Cannot convert "' + x + '" to a number');
        }
        return n;
      }
    }, {
      from: "string",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber2) {
          throwNoBignumber(x);
        }
        try {
          return new BigNumber2(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to BigNumber');
        }
      }
    }, {
      from: "string",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction3) {
          throwNoFraction(x);
        }
        try {
          return new Fraction3(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Fraction');
        }
      }
    }, {
      from: "string",
      to: "Complex",
      convert: function convert(x) {
        if (!Complex3) {
          throwNoComplex(x);
        }
        try {
          return new Complex3(x);
        } catch (err) {
          throw new Error('Cannot convert "' + x + '" to Complex');
        }
      }
    }, {
      from: "boolean",
      to: "number",
      convert: function convert(x) {
        return +x;
      }
    }, {
      from: "boolean",
      to: "BigNumber",
      convert: function convert(x) {
        if (!BigNumber2) {
          throwNoBignumber(x);
        }
        return new BigNumber2(+x);
      }
    }, {
      from: "boolean",
      to: "Fraction",
      convert: function convert(x) {
        if (!Fraction3) {
          throwNoFraction(x);
        }
        return new Fraction3(+x);
      }
    }, {
      from: "boolean",
      to: "string",
      convert: function convert(x) {
        return String(x);
      }
    }, {
      from: "Array",
      to: "Matrix",
      convert: function convert(array) {
        if (!DenseMatrix2) {
          throwNoMatrix();
        }
        return new DenseMatrix2(array);
      }
    }, {
      from: "Matrix",
      to: "Array",
      convert: function convert(matrix2) {
        return matrix2.valueOf();
      }
    }]);
    typed3.onMismatch = (name310, args, signatures) => {
      var usualError = typed3.createError(name310, args, signatures);
      if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
      signatures.some((sig) => !sig.params.includes(","))) {
        var err = new TypeError("Function '".concat(name310, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name310, ")'."));
        err.data = usualError.data;
        throw err;
      }
      throw usualError;
    };
    typed3.onMismatch = (name310, args, signatures) => {
      var usualError = typed3.createError(name310, args, signatures);
      if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
      signatures.some((sig) => !sig.params.includes(","))) {
        var err = new TypeError("Function '".concat(name310, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name310, ")'."));
        err.data = usualError.data;
        throw err;
      }
      throw usualError;
    };
    return typed3;
  });
  function throwNoBignumber(x) {
    throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
  }
  function throwNoComplex(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
  }
  function throwNoMatrix() {
    throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
  }
  function throwNoFraction(x) {
    throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
  }

  // node_modules/mathjs/lib/esm/type/resultset/ResultSet.js
  var name = "ResultSet";
  var dependencies2 = [];
  var createResultSet = /* @__PURE__ */ factory(name, dependencies2, () => {
    function ResultSet2(entries) {
      if (!(this instanceof ResultSet2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this.entries = entries || [];
    }
    ResultSet2.prototype.type = "ResultSet";
    ResultSet2.prototype.isResultSet = true;
    ResultSet2.prototype.valueOf = function() {
      return this.entries;
    };
    ResultSet2.prototype.toString = function() {
      return "[" + this.entries.join(", ") + "]";
    };
    ResultSet2.prototype.toJSON = function() {
      return {
        mathjs: "ResultSet",
        entries: this.entries
      };
    };
    ResultSet2.fromJSON = function(json) {
      return new ResultSet2(json.entries);
    };
    return ResultSet2;
  }, {
    isClass: true
  });

  // node_modules/decimal.js/decimal.mjs
  var EXP_LIMIT = 9e15;
  var MAX_DIGITS = 1e9;
  var NUMERALS = "0123456789abcdef";
  var LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058";
  var PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789";
  var DEFAULTS = {
    // These values must be integers within the stated ranges (inclusive).
    // Most of these values can be changed at run-time using the `Decimal.config` method.
    // The maximum number of significant digits of the result of a calculation or base conversion.
    // E.g. `Decimal.config({ precision: 20 });`
    precision: 20,
    // 1 to MAX_DIGITS
    // The rounding mode used when rounding to `precision`.
    //
    // ROUND_UP         0 Away from zero.
    // ROUND_DOWN       1 Towards zero.
    // ROUND_CEIL       2 Towards +Infinity.
    // ROUND_FLOOR      3 Towards -Infinity.
    // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
    // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
    // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
    // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
    // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
    //
    // E.g.
    // `Decimal.rounding = 4;`
    // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
    rounding: 4,
    // 0 to 8
    // The modulo mode used when calculating the modulus: a mod n.
    // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
    // The remainder (r) is calculated as: r = a - n * q.
    //
    // UP         0 The remainder is positive if the dividend is negative, else is negative.
    // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
    // FLOOR      3 The remainder has the same sign as the divisor (Python %).
    // HALF_EVEN  6 The IEEE 754 remainder function.
    // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
    //
    // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
    // division (9) are commonly used for the modulus operation. The other rounding modes can also
    // be used, but they may not give useful results.
    modulo: 1,
    // 0 to 9
    // The exponent value at and beneath which `toString` returns exponential notation.
    // JavaScript numbers: -7
    toExpNeg: -7,
    // 0 to -EXP_LIMIT
    // The exponent value at and above which `toString` returns exponential notation.
    // JavaScript numbers: 21
    toExpPos: 21,
    // 0 to EXP_LIMIT
    // The minimum exponent value, beneath which underflow to zero occurs.
    // JavaScript numbers: -324  (5e-324)
    minE: -EXP_LIMIT,
    // -1 to -EXP_LIMIT
    // The maximum exponent value, above which overflow to Infinity occurs.
    // JavaScript numbers: 308  (1.7976931348623157e+308)
    maxE: EXP_LIMIT,
    // 1 to EXP_LIMIT
    // Whether to use cryptographically-secure random number generation, if available.
    crypto: false
    // true/false
  };
  var inexact;
  var quadrant;
  var external = true;
  var decimalError = "[DecimalError] ";
  var invalidArgument = decimalError + "Invalid argument: ";
  var precisionLimitExceeded = decimalError + "Precision limit exceeded";
  var cryptoUnavailable = decimalError + "crypto unavailable";
  var tag = "[object Decimal]";
  var mathfloor = Math.floor;
  var mathpow = Math.pow;
  var isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i;
  var isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i;
  var isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i;
  var isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i;
  var BASE = 1e7;
  var LOG_BASE = 7;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var LN10_PRECISION = LN10.length - 1;
  var PI_PRECISION = PI.length - 1;
  var P = { toStringTag: tag };
  P.absoluteValue = P.abs = function() {
    var x = new this.constructor(this);
    if (x.s < 0)
      x.s = 1;
    return finalise(x);
  };
  P.ceil = function() {
    return finalise(new this.constructor(this), this.e + 1, 2);
  };
  P.clampedTo = P.clamp = function(min3, max3) {
    var k, x = this, Ctor = x.constructor;
    min3 = new Ctor(min3);
    max3 = new Ctor(max3);
    if (!min3.s || !max3.s)
      return new Ctor(NaN);
    if (min3.gt(max3))
      throw Error(invalidArgument + max3);
    k = x.cmp(min3);
    return k < 0 ? min3 : x.cmp(max3) > 0 ? max3 : new Ctor(x);
  };
  P.comparedTo = P.cmp = function(y2) {
    var i3, j, xdL, ydL, x = this, xd = x.d, yd = (y2 = new x.constructor(y2)).d, xs = x.s, ys = y2.s;
    if (!xd || !yd) {
      return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
    }
    if (!xd[0] || !yd[0])
      return xd[0] ? xs : yd[0] ? -ys : 0;
    if (xs !== ys)
      return xs;
    if (x.e !== y2.e)
      return x.e > y2.e ^ xs < 0 ? 1 : -1;
    xdL = xd.length;
    ydL = yd.length;
    for (i3 = 0, j = xdL < ydL ? xdL : ydL; i3 < j; ++i3) {
      if (xd[i3] !== yd[i3])
        return xd[i3] > yd[i3] ^ xs < 0 ? 1 : -1;
    }
    return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
  };
  P.cosine = P.cos = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.d)
      return new Ctor(NaN);
    if (!x.d[0])
      return new Ctor(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
  };
  P.cubeRoot = P.cbrt = function() {
    var e3, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    external = false;
    s = x.s * mathpow(x.s * x, 1 / 3);
    if (!s || Math.abs(s) == 1 / 0) {
      n = digitsToString(x.d);
      e3 = x.e;
      if (s = (e3 - n.length + 1) % 3)
        n += s == 1 || s == -2 ? "0" : "00";
      s = mathpow(n, 1 / 3);
      e3 = mathfloor((e3 + 1) / 3) - (e3 % 3 == (e3 < 0 ? -1 : 2));
      if (s == 1 / 0) {
        n = "5e" + e3;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e3;
      }
      r = new Ctor(n);
      r.s = x.s;
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e3 = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      t3 = t.times(t).times(t);
      t3plusx = t3.plus(x);
      r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e3 + 1, 0);
            if (t.times(t).times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e3 + 1, 1);
            m = !r.times(r).times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e3, Ctor.rounding, m);
  };
  P.decimalPlaces = P.dp = function() {
    var w2, d = this.d, n = NaN;
    if (d) {
      w2 = d.length - 1;
      n = (w2 - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
      w2 = d[w2];
      if (w2)
        for (; w2 % 10 == 0; w2 /= 10)
          n--;
      if (n < 0)
        n = 0;
    }
    return n;
  };
  P.dividedBy = P.div = function(y2) {
    return divide(this, new this.constructor(y2));
  };
  P.dividedToIntegerBy = P.divToInt = function(y2) {
    var x = this, Ctor = x.constructor;
    return finalise(divide(x, new Ctor(y2), 0, 1, 1), Ctor.precision, Ctor.rounding);
  };
  P.equals = P.eq = function(y2) {
    return this.cmp(y2) === 0;
  };
  P.floor = function() {
    return finalise(new this.constructor(this), this.e + 1, 3);
  };
  P.greaterThan = P.gt = function(y2) {
    return this.cmp(y2) > 0;
  };
  P.greaterThanOrEqualTo = P.gte = function(y2) {
    var k = this.cmp(y2);
    return k == 1 || k === 0;
  };
  P.hyperbolicCosine = P.cosh = function() {
    var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
    if (!x.isFinite())
      return new Ctor(x.s ? 1 / 0 : NaN);
    if (x.isZero())
      return one;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      n = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      n = "2.3283064365386962890625e-10";
    }
    x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
    var cosh2_x, i3 = k, d8 = new Ctor(8);
    for (; i3--; ) {
      cosh2_x = x.times(x);
      x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
    }
    return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.hyperbolicSine = P.sinh = function() {
    var k, pr, rm, len, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
    Ctor.rounding = 1;
    len = x.d.length;
    if (len < 3) {
      x = taylorSeries(Ctor, 2, x, x, true);
    } else {
      k = 1.4 * Math.sqrt(len);
      k = k > 16 ? 16 : k | 0;
      x = x.times(1 / tinyPow(5, k));
      x = taylorSeries(Ctor, 2, x, x, true);
      var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
      for (; k--; ) {
        sinh2_x = x.times(x);
        x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
      }
    }
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(x, pr, rm, true);
  };
  P.hyperbolicTangent = P.tanh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(x.s);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 7;
    Ctor.rounding = 1;
    return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
  };
  P.inverseCosine = P.acos = function() {
    var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
    if (k !== -1) {
      return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
    }
    if (x.isZero())
      return getPi(Ctor, pr + 4, rm).times(0.5);
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.asin();
    halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return halfPi.minus(x);
  };
  P.inverseHyperbolicCosine = P.acosh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (x.lte(1))
      return new Ctor(x.eq(1) ? 0 : NaN);
    if (!x.isFinite())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).minus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicSine = P.asinh = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite() || x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
    Ctor.rounding = 1;
    external = false;
    x = x.times(x).plus(1).sqrt().plus(x);
    external = true;
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.ln();
  };
  P.inverseHyperbolicTangent = P.atanh = function() {
    var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.e >= 0)
      return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    xsd = x.sd();
    if (Math.max(xsd, pr) < 2 * -x.e - 1)
      return finalise(new Ctor(x), pr, rm, true);
    Ctor.precision = wpr = xsd - x.e;
    x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
    Ctor.precision = pr + 4;
    Ctor.rounding = 1;
    x = x.ln();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(0.5);
  };
  P.inverseSine = P.asin = function() {
    var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
    if (x.isZero())
      return new Ctor(x);
    k = x.abs().cmp(1);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (k !== -1) {
      if (k === 0) {
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        halfPi.s = x.s;
        return halfPi;
      }
      return new Ctor(NaN);
    }
    Ctor.precision = pr + 6;
    Ctor.rounding = 1;
    x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return x.times(2);
  };
  P.inverseTangent = P.atan = function() {
    var i3, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
    if (!x.isFinite()) {
      if (!x.s)
        return new Ctor(NaN);
      if (pr + 4 <= PI_PRECISION) {
        r = getPi(Ctor, pr + 4, rm).times(0.5);
        r.s = x.s;
        return r;
      }
    } else if (x.isZero()) {
      return new Ctor(x);
    } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.25);
      r.s = x.s;
      return r;
    }
    Ctor.precision = wpr = pr + 10;
    Ctor.rounding = 1;
    k = Math.min(28, wpr / LOG_BASE + 2 | 0);
    for (i3 = k; i3; --i3)
      x = x.div(x.times(x).plus(1).sqrt().plus(1));
    external = false;
    j = Math.ceil(wpr / LOG_BASE);
    n = 1;
    x2 = x.times(x);
    r = new Ctor(x);
    px = x;
    for (; i3 !== -1; ) {
      px = px.times(x2);
      t = r.minus(px.div(n += 2));
      px = px.times(x2);
      r = t.plus(px.div(n += 2));
      if (r.d[j] !== void 0)
        for (i3 = j; r.d[i3] === t.d[i3] && i3--; )
          ;
    }
    if (k)
      r = r.times(2 << k - 1);
    external = true;
    return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
  };
  P.isFinite = function() {
    return !!this.d;
  };
  P.isInteger = P.isInt = function() {
    return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
  };
  P.isNaN = function() {
    return !this.s;
  };
  P.isNegative = P.isNeg = function() {
    return this.s < 0;
  };
  P.isPositive = P.isPos = function() {
    return this.s > 0;
  };
  P.isZero = function() {
    return !!this.d && this.d[0] === 0;
  };
  P.lessThan = P.lt = function(y2) {
    return this.cmp(y2) < 0;
  };
  P.lessThanOrEqualTo = P.lte = function(y2) {
    return this.cmp(y2) < 1;
  };
  P.logarithm = P.log = function(base) {
    var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
    if (base == null) {
      base = new Ctor(10);
      isBase10 = true;
    } else {
      base = new Ctor(base);
      d = base.d;
      if (base.s < 0 || !d || !d[0] || base.eq(1))
        return new Ctor(NaN);
      isBase10 = base.eq(10);
    }
    d = arg2.d;
    if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {
      return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);
    }
    if (isBase10) {
      if (d.length > 1) {
        inf = true;
      } else {
        for (k = d[0]; k % 10 === 0; )
          k /= 10;
        inf = k !== 1;
      }
    }
    external = false;
    sd = pr + guard;
    num = naturalLogarithm(arg2, sd);
    denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
    r = divide(num, denominator, sd, 1);
    if (checkRoundingDigits(r.d, k = pr, rm)) {
      do {
        sd += 10;
        num = naturalLogarithm(arg2, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (!inf) {
          if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
            r = finalise(r, pr + 1, 0);
          }
          break;
        }
      } while (checkRoundingDigits(r.d, k += 10, rm));
    }
    external = true;
    return finalise(r, pr, rm);
  };
  P.minus = P.sub = function(y2) {
    var d, e3, i3, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
    y2 = new Ctor(y2);
    if (!x.d || !y2.d) {
      if (!x.s || !y2.s)
        y2 = new Ctor(NaN);
      else if (x.d)
        y2.s = -y2.s;
      else
        y2 = new Ctor(y2.d || x.s !== y2.s ? x : NaN);
      return y2;
    }
    if (x.s != y2.s) {
      y2.s = -y2.s;
      return x.plus(y2);
    }
    xd = x.d;
    yd = y2.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (yd[0])
        y2.s = -y2.s;
      else if (xd[0])
        y2 = new Ctor(x);
      else
        return new Ctor(rm === 3 ? -0 : 0);
      return external ? finalise(y2, pr, rm) : y2;
    }
    e3 = mathfloor(y2.e / LOG_BASE);
    xe = mathfloor(x.e / LOG_BASE);
    xd = xd.slice();
    k = xe - e3;
    if (k) {
      xLTy = k < 0;
      if (xLTy) {
        d = xd;
        k = -k;
        len = yd.length;
      } else {
        d = yd;
        e3 = xe;
        len = xd.length;
      }
      i3 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
      if (k > i3) {
        k = i3;
        d.length = 1;
      }
      d.reverse();
      for (i3 = k; i3--; )
        d.push(0);
      d.reverse();
    } else {
      i3 = xd.length;
      len = yd.length;
      xLTy = i3 < len;
      if (xLTy)
        len = i3;
      for (i3 = 0; i3 < len; i3++) {
        if (xd[i3] != yd[i3]) {
          xLTy = xd[i3] < yd[i3];
          break;
        }
      }
      k = 0;
    }
    if (xLTy) {
      d = xd;
      xd = yd;
      yd = d;
      y2.s = -y2.s;
    }
    len = xd.length;
    for (i3 = yd.length - len; i3 > 0; --i3)
      xd[len++] = 0;
    for (i3 = yd.length; i3 > k; ) {
      if (xd[--i3] < yd[i3]) {
        for (j = i3; j && xd[--j] === 0; )
          xd[j] = BASE - 1;
        --xd[j];
        xd[i3] += BASE;
      }
      xd[i3] -= yd[i3];
    }
    for (; xd[--len] === 0; )
      xd.pop();
    for (; xd[0] === 0; xd.shift())
      --e3;
    if (!xd[0])
      return new Ctor(rm === 3 ? -0 : 0);
    y2.d = xd;
    y2.e = getBase10Exponent(xd, e3);
    return external ? finalise(y2, pr, rm) : y2;
  };
  P.modulo = P.mod = function(y2) {
    var q, x = this, Ctor = x.constructor;
    y2 = new Ctor(y2);
    if (!x.d || !y2.s || y2.d && !y2.d[0])
      return new Ctor(NaN);
    if (!y2.d || x.d && !x.d[0]) {
      return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
    }
    external = false;
    if (Ctor.modulo == 9) {
      q = divide(x, y2.abs(), 0, 3, 1);
      q.s *= y2.s;
    } else {
      q = divide(x, y2, 0, Ctor.modulo, 1);
    }
    q = q.times(y2);
    external = true;
    return x.minus(q);
  };
  P.naturalExponential = P.exp = function() {
    return naturalExponential(this);
  };
  P.naturalLogarithm = P.ln = function() {
    return naturalLogarithm(this);
  };
  P.negated = P.neg = function() {
    var x = new this.constructor(this);
    x.s = -x.s;
    return finalise(x);
  };
  P.plus = P.add = function(y2) {
    var carry, d, e3, i3, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
    y2 = new Ctor(y2);
    if (!x.d || !y2.d) {
      if (!x.s || !y2.s)
        y2 = new Ctor(NaN);
      else if (!x.d)
        y2 = new Ctor(y2.d || x.s === y2.s ? x : NaN);
      return y2;
    }
    if (x.s != y2.s) {
      y2.s = -y2.s;
      return x.minus(y2);
    }
    xd = x.d;
    yd = y2.d;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (!xd[0] || !yd[0]) {
      if (!yd[0])
        y2 = new Ctor(x);
      return external ? finalise(y2, pr, rm) : y2;
    }
    k = mathfloor(x.e / LOG_BASE);
    e3 = mathfloor(y2.e / LOG_BASE);
    xd = xd.slice();
    i3 = k - e3;
    if (i3) {
      if (i3 < 0) {
        d = xd;
        i3 = -i3;
        len = yd.length;
      } else {
        d = yd;
        e3 = k;
        len = xd.length;
      }
      k = Math.ceil(pr / LOG_BASE);
      len = k > len ? k + 1 : len + 1;
      if (i3 > len) {
        i3 = len;
        d.length = 1;
      }
      d.reverse();
      for (; i3--; )
        d.push(0);
      d.reverse();
    }
    len = xd.length;
    i3 = yd.length;
    if (len - i3 < 0) {
      i3 = len;
      d = yd;
      yd = xd;
      xd = d;
    }
    for (carry = 0; i3; ) {
      carry = (xd[--i3] = xd[i3] + yd[i3] + carry) / BASE | 0;
      xd[i3] %= BASE;
    }
    if (carry) {
      xd.unshift(carry);
      ++e3;
    }
    for (len = xd.length; xd[--len] == 0; )
      xd.pop();
    y2.d = xd;
    y2.e = getBase10Exponent(xd, e3);
    return external ? finalise(y2, pr, rm) : y2;
  };
  P.precision = P.sd = function(z) {
    var k, x = this;
    if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
      throw Error(invalidArgument + z);
    if (x.d) {
      k = getPrecision(x.d);
      if (z && x.e + 1 > k)
        k = x.e + 1;
    } else {
      k = NaN;
    }
    return k;
  };
  P.round = function() {
    var x = this, Ctor = x.constructor;
    return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
  };
  P.sine = P.sin = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
    Ctor.rounding = 1;
    x = sine(Ctor, toLessThanHalfPi(Ctor, x));
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
  };
  P.squareRoot = P.sqrt = function() {
    var m, n, sd, r, rep, t, x = this, d = x.d, e3 = x.e, s = x.s, Ctor = x.constructor;
    if (s !== 1 || !d || !d[0]) {
      return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
    }
    external = false;
    s = Math.sqrt(+x);
    if (s == 0 || s == 1 / 0) {
      n = digitsToString(d);
      if ((n.length + e3) % 2 == 0)
        n += "0";
      s = Math.sqrt(n);
      e3 = mathfloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
      if (s == 1 / 0) {
        n = "5e" + e3;
      } else {
        n = s.toExponential();
        n = n.slice(0, n.indexOf("e") + 1) + e3;
      }
      r = new Ctor(n);
    } else {
      r = new Ctor(s.toString());
    }
    sd = (e3 = Ctor.precision) + 3;
    for (; ; ) {
      t = r;
      r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
      if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
        n = n.slice(sd - 3, sd + 1);
        if (n == "9999" || !rep && n == "4999") {
          if (!rep) {
            finalise(t, e3 + 1, 0);
            if (t.times(t).eq(x)) {
              r = t;
              break;
            }
          }
          sd += 4;
          rep = 1;
        } else {
          if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
            finalise(r, e3 + 1, 1);
            m = !r.times(r).eq(x);
          }
          break;
        }
      }
    }
    external = true;
    return finalise(r, e3, Ctor.rounding, m);
  };
  P.tangent = P.tan = function() {
    var pr, rm, x = this, Ctor = x.constructor;
    if (!x.isFinite())
      return new Ctor(NaN);
    if (x.isZero())
      return new Ctor(x);
    pr = Ctor.precision;
    rm = Ctor.rounding;
    Ctor.precision = pr + 10;
    Ctor.rounding = 1;
    x = x.sin();
    x.s = 1;
    x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
    Ctor.precision = pr;
    Ctor.rounding = rm;
    return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
  };
  P.times = P.mul = function(y2) {
    var carry, e3, i3, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y2 = new Ctor(y2)).d;
    y2.s *= x.s;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(!y2.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y2.s / 0 : y2.s * 0);
    }
    e3 = mathfloor(x.e / LOG_BASE) + mathfloor(y2.e / LOG_BASE);
    xdL = xd.length;
    ydL = yd.length;
    if (xdL < ydL) {
      r = xd;
      xd = yd;
      yd = r;
      rL = xdL;
      xdL = ydL;
      ydL = rL;
    }
    r = [];
    rL = xdL + ydL;
    for (i3 = rL; i3--; )
      r.push(0);
    for (i3 = ydL; --i3 >= 0; ) {
      carry = 0;
      for (k = xdL + i3; k > i3; ) {
        t = r[k] + yd[i3] * xd[k - i3 - 1] + carry;
        r[k--] = t % BASE | 0;
        carry = t / BASE | 0;
      }
      r[k] = (r[k] + carry) % BASE | 0;
    }
    for (; !r[--rL]; )
      r.pop();
    if (carry)
      ++e3;
    else
      r.shift();
    y2.d = r;
    y2.e = getBase10Exponent(r, e3);
    return external ? finalise(y2, Ctor.precision, Ctor.rounding) : y2;
  };
  P.toBinary = function(sd, rm) {
    return toStringBinary(this, 2, sd, rm);
  };
  P.toDecimalPlaces = P.toDP = function(dp, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (dp === void 0)
      return x;
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    return finalise(x, dp + x.e + 1, rm);
  };
  P.toExponential = function(dp, rm) {
    var str, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x, true);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), dp + 1, rm);
      str = finiteToString(x, true, dp + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFixed = function(dp, rm) {
    var str, y2, x = this, Ctor = x.constructor;
    if (dp === void 0) {
      str = finiteToString(x);
    } else {
      checkInt32(dp, 0, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      y2 = finalise(new Ctor(x), dp + x.e + 1, rm);
      str = finiteToString(y2, false, dp + y2.e + 1);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toFraction = function(maxD) {
    var d, d0, d1, d2, e3, k, n, n0, n16, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
    if (!xd)
      return new Ctor(x);
    n16 = d0 = new Ctor(1);
    d1 = n0 = new Ctor(0);
    d = new Ctor(d1);
    e3 = d.e = getPrecision(xd) - x.e - 1;
    k = e3 % LOG_BASE;
    d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
    if (maxD == null) {
      maxD = e3 > 0 ? d : n16;
    } else {
      n = new Ctor(maxD);
      if (!n.isInt() || n.lt(n16))
        throw Error(invalidArgument + n);
      maxD = n.gt(d) ? e3 > 0 ? d : n16 : n;
    }
    external = false;
    n = new Ctor(digitsToString(xd));
    pr = Ctor.precision;
    Ctor.precision = e3 = xd.length * LOG_BASE * 2;
    for (; ; ) {
      q = divide(n, d, 0, 1, 1);
      d2 = d0.plus(q.times(d1));
      if (d2.cmp(maxD) == 1)
        break;
      d0 = d1;
      d1 = d2;
      d2 = n16;
      n16 = n0.plus(q.times(d2));
      n0 = d2;
      d2 = d;
      d = n.minus(q.times(d2));
      n = d2;
    }
    d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
    n0 = n0.plus(d2.times(n16));
    d0 = d0.plus(d2.times(d1));
    n0.s = n16.s = x.s;
    r = divide(n16, d1, e3, 1).minus(x).abs().cmp(divide(n0, d0, e3, 1).minus(x).abs()) < 1 ? [n16, d1] : [n0, d0];
    Ctor.precision = pr;
    external = true;
    return r;
  };
  P.toHexadecimal = P.toHex = function(sd, rm) {
    return toStringBinary(this, 16, sd, rm);
  };
  P.toNearest = function(y2, rm) {
    var x = this, Ctor = x.constructor;
    x = new Ctor(x);
    if (y2 == null) {
      if (!x.d)
        return x;
      y2 = new Ctor(1);
      rm = Ctor.rounding;
    } else {
      y2 = new Ctor(y2);
      if (rm === void 0) {
        rm = Ctor.rounding;
      } else {
        checkInt32(rm, 0, 8);
      }
      if (!x.d)
        return y2.s ? x : y2;
      if (!y2.d) {
        if (y2.s)
          y2.s = x.s;
        return y2;
      }
    }
    if (y2.d[0]) {
      external = false;
      x = divide(x, y2, 0, rm, 1).times(y2);
      external = true;
      finalise(x);
    } else {
      y2.s = x.s;
      x = y2;
    }
    return x;
  };
  P.toNumber = function() {
    return +this;
  };
  P.toOctal = function(sd, rm) {
    return toStringBinary(this, 8, sd, rm);
  };
  P.toPower = P.pow = function(y2) {
    var e3, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y2 = new Ctor(y2));
    if (!x.d || !y2.d || !x.d[0] || !y2.d[0])
      return new Ctor(mathpow(+x, yn));
    x = new Ctor(x);
    if (x.eq(1))
      return x;
    pr = Ctor.precision;
    rm = Ctor.rounding;
    if (y2.eq(1))
      return finalise(x, pr, rm);
    e3 = mathfloor(y2.e / LOG_BASE);
    if (e3 >= y2.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
      r = intPow(Ctor, x, k, pr);
      return y2.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
    }
    s = x.s;
    if (s < 0) {
      if (e3 < y2.d.length - 1)
        return new Ctor(NaN);
      if ((y2.d[e3] & 1) == 0)
        s = 1;
      if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
        x.s = s;
        return x;
      }
    }
    k = mathpow(+x, yn);
    e3 = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
    if (e3 > Ctor.maxE + 1 || e3 < Ctor.minE - 1)
      return new Ctor(e3 > 0 ? s / 0 : 0);
    external = false;
    Ctor.rounding = x.s = 1;
    k = Math.min(12, (e3 + "").length);
    r = naturalExponential(y2.times(naturalLogarithm(x, pr + k)), pr);
    if (r.d) {
      r = finalise(r, pr + 5, 1);
      if (checkRoundingDigits(r.d, pr, rm)) {
        e3 = pr + 10;
        r = finalise(naturalExponential(y2.times(naturalLogarithm(x, e3 + k)), e3), e3 + 5, 1);
        if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
      }
    }
    r.s = s;
    external = true;
    Ctor.rounding = rm;
    return finalise(r, pr, rm);
  };
  P.toPrecision = function(sd, rm) {
    var str, x = this, Ctor = x.constructor;
    if (sd === void 0) {
      str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
      x = finalise(new Ctor(x), sd, rm);
      str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
    }
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.toSignificantDigits = P.toSD = function(sd, rm) {
    var x = this, Ctor = x.constructor;
    if (sd === void 0) {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    } else {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
    }
    return finalise(new Ctor(x), sd, rm);
  };
  P.toString = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() && !x.isZero() ? "-" + str : str;
  };
  P.truncated = P.trunc = function() {
    return finalise(new this.constructor(this), this.e + 1, 1);
  };
  P.valueOf = P.toJSON = function() {
    var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
    return x.isNeg() ? "-" + str : str;
  };
  function digitsToString(d) {
    var i3, k, ws, indexOfLastWord = d.length - 1, str = "", w2 = d[0];
    if (indexOfLastWord > 0) {
      str += w2;
      for (i3 = 1; i3 < indexOfLastWord; i3++) {
        ws = d[i3] + "";
        k = LOG_BASE - ws.length;
        if (k)
          str += getZeroString(k);
        str += ws;
      }
      w2 = d[i3];
      ws = w2 + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
    } else if (w2 === 0) {
      return "0";
    }
    for (; w2 % 10 === 0; )
      w2 /= 10;
    return str + w2;
  }
  function checkInt32(i3, min3, max3) {
    if (i3 !== ~~i3 || i3 < min3 || i3 > max3) {
      throw Error(invalidArgument + i3);
    }
  }
  function checkRoundingDigits(d, i3, rm, repeating) {
    var di, k, r, rd;
    for (k = d[0]; k >= 10; k /= 10)
      --i3;
    if (--i3 < 0) {
      i3 += LOG_BASE;
      di = 0;
    } else {
      di = Math.ceil((i3 + 1) / LOG_BASE);
      i3 %= LOG_BASE;
    }
    k = mathpow(10, LOG_BASE - i3);
    rd = d[di] % k | 0;
    if (repeating == null) {
      if (i3 < 3) {
        if (i3 == 0)
          rd = rd / 100 | 0;
        else if (i3 == 1)
          rd = rd / 10 | 0;
        r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
      } else {
        r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i3 - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
      }
    } else {
      if (i3 < 4) {
        if (i3 == 0)
          rd = rd / 1e3 | 0;
        else if (i3 == 1)
          rd = rd / 100 | 0;
        else if (i3 == 2)
          rd = rd / 10 | 0;
        r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
      } else {
        r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i3 - 3) - 1;
      }
    }
    return r;
  }
  function convertBase(str, baseIn, baseOut) {
    var j, arr = [0], arrL, i3 = 0, strL = str.length;
    for (; i3 < strL; ) {
      for (arrL = arr.length; arrL--; )
        arr[arrL] *= baseIn;
      arr[0] += NUMERALS.indexOf(str.charAt(i3++));
      for (j = 0; j < arr.length; j++) {
        if (arr[j] > baseOut - 1) {
          if (arr[j + 1] === void 0)
            arr[j + 1] = 0;
          arr[j + 1] += arr[j] / baseOut | 0;
          arr[j] %= baseOut;
        }
      }
    }
    return arr.reverse();
  }
  function cosine(Ctor, x) {
    var k, len, y2;
    if (x.isZero())
      return x;
    len = x.d.length;
    if (len < 32) {
      k = Math.ceil(len / 3);
      y2 = (1 / tinyPow(4, k)).toString();
    } else {
      k = 16;
      y2 = "2.3283064365386962890625e-10";
    }
    Ctor.precision += k;
    x = taylorSeries(Ctor, 1, x.times(y2), new Ctor(1));
    for (var i3 = k; i3--; ) {
      var cos2x = x.times(x);
      x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
    }
    Ctor.precision -= k;
    return x;
  }
  var divide = /* @__PURE__ */ function() {
    function multiplyInteger(x, k, base) {
      var temp, carry = 0, i3 = x.length;
      for (x = x.slice(); i3--; ) {
        temp = x[i3] * k + carry;
        x[i3] = temp % base | 0;
        carry = temp / base | 0;
      }
      if (carry)
        x.unshift(carry);
      return x;
    }
    function compare2(a, b, aL, bL) {
      var i3, r;
      if (aL != bL) {
        r = aL > bL ? 1 : -1;
      } else {
        for (i3 = r = 0; i3 < aL; i3++) {
          if (a[i3] != b[i3]) {
            r = a[i3] > b[i3] ? 1 : -1;
            break;
          }
        }
      }
      return r;
    }
    function subtract2(a, b, aL, base) {
      var i3 = 0;
      for (; aL--; ) {
        a[aL] -= i3;
        i3 = a[aL] < b[aL] ? 1 : 0;
        a[aL] = i3 * base + a[aL] - b[aL];
      }
      for (; !a[0] && a.length > 1; )
        a.shift();
    }
    return function(x, y2, pr, rm, dp, base) {
      var cmp, e3, i3, k, logBase, more, prod2, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign4 = x.s == y2.s ? 1 : -1, xd = x.d, yd = y2.d;
      if (!xd || !xd[0] || !yd || !yd[0]) {
        return new Ctor(
          // Return NaN if either NaN, or both Infinity or 0.
          !x.s || !y2.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
            xd && xd[0] == 0 || !yd ? sign4 * 0 : sign4 / 0
          )
        );
      }
      if (base) {
        logBase = 1;
        e3 = x.e - y2.e;
      } else {
        base = BASE;
        logBase = LOG_BASE;
        e3 = mathfloor(x.e / logBase) - mathfloor(y2.e / logBase);
      }
      yL = yd.length;
      xL = xd.length;
      q = new Ctor(sign4);
      qd = q.d = [];
      for (i3 = 0; yd[i3] == (xd[i3] || 0); i3++)
        ;
      if (yd[i3] > (xd[i3] || 0))
        e3--;
      if (pr == null) {
        sd = pr = Ctor.precision;
        rm = Ctor.rounding;
      } else if (dp) {
        sd = pr + (x.e - y2.e) + 1;
      } else {
        sd = pr;
      }
      if (sd < 0) {
        qd.push(1);
        more = true;
      } else {
        sd = sd / logBase + 2 | 0;
        i3 = 0;
        if (yL == 1) {
          k = 0;
          yd = yd[0];
          sd++;
          for (; (i3 < xL || k) && sd--; i3++) {
            t = k * base + (xd[i3] || 0);
            qd[i3] = t / yd | 0;
            k = t % yd | 0;
          }
          more = k || i3 < xL;
        } else {
          k = base / (yd[0] + 1) | 0;
          if (k > 1) {
            yd = multiplyInteger(yd, k, base);
            xd = multiplyInteger(xd, k, base);
            yL = yd.length;
            xL = xd.length;
          }
          xi = yL;
          rem = xd.slice(0, yL);
          remL = rem.length;
          for (; remL < yL; )
            rem[remL++] = 0;
          yz = yd.slice();
          yz.unshift(0);
          yd0 = yd[0];
          if (yd[1] >= base / 2)
            ++yd0;
          do {
            k = 0;
            cmp = compare2(yd, rem, yL, remL);
            if (cmp < 0) {
              rem0 = rem[0];
              if (yL != remL)
                rem0 = rem0 * base + (rem[1] || 0);
              k = rem0 / yd0 | 0;
              if (k > 1) {
                if (k >= base)
                  k = base - 1;
                prod2 = multiplyInteger(yd, k, base);
                prodL = prod2.length;
                remL = rem.length;
                cmp = compare2(prod2, rem, prodL, remL);
                if (cmp == 1) {
                  k--;
                  subtract2(prod2, yL < prodL ? yz : yd, prodL, base);
                }
              } else {
                if (k == 0)
                  cmp = k = 1;
                prod2 = yd.slice();
              }
              prodL = prod2.length;
              if (prodL < remL)
                prod2.unshift(0);
              subtract2(rem, prod2, remL, base);
              if (cmp == -1) {
                remL = rem.length;
                cmp = compare2(yd, rem, yL, remL);
                if (cmp < 1) {
                  k++;
                  subtract2(rem, yL < remL ? yz : yd, remL, base);
                }
              }
              remL = rem.length;
            } else if (cmp === 0) {
              k++;
              rem = [0];
            }
            qd[i3++] = k;
            if (cmp && rem[0]) {
              rem[remL++] = xd[xi] || 0;
            } else {
              rem = [xd[xi]];
              remL = 1;
            }
          } while ((xi++ < xL || rem[0] !== void 0) && sd--);
          more = rem[0] !== void 0;
        }
        if (!qd[0])
          qd.shift();
      }
      if (logBase == 1) {
        q.e = e3;
        inexact = more;
      } else {
        for (i3 = 1, k = qd[0]; k >= 10; k /= 10)
          i3++;
        q.e = i3 + e3 * logBase - 1;
        finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
      }
      return q;
    };
  }();
  function finalise(x, sd, rm, isTruncated) {
    var digits2, i3, j, k, rd, roundUp, w2, xd, xdi, Ctor = x.constructor;
    out:
      if (sd != null) {
        xd = x.d;
        if (!xd)
          return x;
        for (digits2 = 1, k = xd[0]; k >= 10; k /= 10)
          digits2++;
        i3 = sd - digits2;
        if (i3 < 0) {
          i3 += LOG_BASE;
          j = sd;
          w2 = xd[xdi = 0];
          rd = w2 / mathpow(10, digits2 - j - 1) % 10 | 0;
        } else {
          xdi = Math.ceil((i3 + 1) / LOG_BASE);
          k = xd.length;
          if (xdi >= k) {
            if (isTruncated) {
              for (; k++ <= xdi; )
                xd.push(0);
              w2 = rd = 0;
              digits2 = 1;
              i3 %= LOG_BASE;
              j = i3 - LOG_BASE + 1;
            } else {
              break out;
            }
          } else {
            w2 = k = xd[xdi];
            for (digits2 = 1; k >= 10; k /= 10)
              digits2++;
            i3 %= LOG_BASE;
            j = i3 - LOG_BASE + digits2;
            rd = j < 0 ? 0 : w2 / mathpow(10, digits2 - j - 1) % 10 | 0;
          }
        }
        isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w2 : w2 % mathpow(10, digits2 - j - 1));
        roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (i3 > 0 ? j > 0 ? w2 / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
        if (sd < 1 || !xd[0]) {
          xd.length = 0;
          if (roundUp) {
            sd -= x.e + 1;
            xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
            x.e = -sd || 0;
          } else {
            xd[0] = x.e = 0;
          }
          return x;
        }
        if (i3 == 0) {
          xd.length = xdi;
          k = 1;
          xdi--;
        } else {
          xd.length = xdi + 1;
          k = mathpow(10, LOG_BASE - i3);
          xd[xdi] = j > 0 ? (w2 / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
        }
        if (roundUp) {
          for (; ; ) {
            if (xdi == 0) {
              for (i3 = 1, j = xd[0]; j >= 10; j /= 10)
                i3++;
              j = xd[0] += k;
              for (k = 1; j >= 10; j /= 10)
                k++;
              if (i3 != k) {
                x.e++;
                if (xd[0] == BASE)
                  xd[0] = 1;
              }
              break;
            } else {
              xd[xdi] += k;
              if (xd[xdi] != BASE)
                break;
              xd[xdi--] = 0;
              k = 1;
            }
          }
        }
        for (i3 = xd.length; xd[--i3] === 0; )
          xd.pop();
      }
    if (external) {
      if (x.e > Ctor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < Ctor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
    return x;
  }
  function finiteToString(x, isExp, sd) {
    if (!x.isFinite())
      return nonFiniteToString(x);
    var k, e3 = x.e, str = digitsToString(x.d), len = str.length;
    if (isExp) {
      if (sd && (k = sd - len) > 0) {
        str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
      } else if (len > 1) {
        str = str.charAt(0) + "." + str.slice(1);
      }
      str = str + (x.e < 0 ? "e" : "e+") + x.e;
    } else if (e3 < 0) {
      str = "0." + getZeroString(-e3 - 1) + str;
      if (sd && (k = sd - len) > 0)
        str += getZeroString(k);
    } else if (e3 >= len) {
      str += getZeroString(e3 + 1 - len);
      if (sd && (k = sd - e3 - 1) > 0)
        str = str + "." + getZeroString(k);
    } else {
      if ((k = e3 + 1) < len)
        str = str.slice(0, k) + "." + str.slice(k);
      if (sd && (k = sd - len) > 0) {
        if (e3 + 1 === len)
          str += ".";
        str += getZeroString(k);
      }
    }
    return str;
  }
  function getBase10Exponent(digits2, e3) {
    var w2 = digits2[0];
    for (e3 *= LOG_BASE; w2 >= 10; w2 /= 10)
      e3++;
    return e3;
  }
  function getLn10(Ctor, sd, pr) {
    if (sd > LN10_PRECISION) {
      external = true;
      if (pr)
        Ctor.precision = pr;
      throw Error(precisionLimitExceeded);
    }
    return finalise(new Ctor(LN10), sd, 1, true);
  }
  function getPi(Ctor, sd, rm) {
    if (sd > PI_PRECISION)
      throw Error(precisionLimitExceeded);
    return finalise(new Ctor(PI), sd, rm, true);
  }
  function getPrecision(digits2) {
    var w2 = digits2.length - 1, len = w2 * LOG_BASE + 1;
    w2 = digits2[w2];
    if (w2) {
      for (; w2 % 10 == 0; w2 /= 10)
        len--;
      for (w2 = digits2[0]; w2 >= 10; w2 /= 10)
        len++;
    }
    return len;
  }
  function getZeroString(k) {
    var zs = "";
    for (; k--; )
      zs += "0";
    return zs;
  }
  function intPow(Ctor, x, n, pr) {
    var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (n % 2) {
        r = r.times(x);
        if (truncate(r.d, k))
          isTruncated = true;
      }
      n = mathfloor(n / 2);
      if (n === 0) {
        n = r.d.length - 1;
        if (isTruncated && r.d[n] === 0)
          ++r.d[n];
        break;
      }
      x = x.times(x);
      truncate(x.d, k);
    }
    external = true;
    return r;
  }
  function isOdd(n) {
    return n.d[n.d.length - 1] & 1;
  }
  function maxOrMin(Ctor, args, ltgt) {
    var y2, x = new Ctor(args[0]), i3 = 0;
    for (; ++i3 < args.length; ) {
      y2 = new Ctor(args[i3]);
      if (!y2.s) {
        x = y2;
        break;
      } else if (x[ltgt](y2)) {
        x = y2;
      }
    }
    return x;
  }
  function naturalExponential(x, sd) {
    var denominator, guard, j, pow3, sum3, t, wpr, rep = 0, i3 = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (!x.d || !x.d[0] || x.e > 17) {
      return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    t = new Ctor(0.03125);
    while (x.e > -2) {
      x = x.times(t);
      k += 5;
    }
    guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
    wpr += guard;
    denominator = pow3 = sum3 = new Ctor(1);
    Ctor.precision = wpr;
    for (; ; ) {
      pow3 = finalise(pow3.times(x), wpr, 1);
      denominator = denominator.times(++i3);
      t = sum3.plus(divide(pow3, denominator, wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
        j = k;
        while (j--)
          sum3 = finalise(sum3.times(sum3), wpr, 1);
        if (sd == null) {
          if (rep < 3 && checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += 10;
            denominator = pow3 = t = new Ctor(1);
            i3 = 0;
            rep++;
          } else {
            return finalise(sum3, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum3;
        }
      }
      sum3 = t;
    }
  }
  function naturalLogarithm(y2, sd) {
    var c, c0, denominator, e3, numerator, rep, sum3, t, wpr, x1, x2, n = 1, guard = 10, x = y2, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
    if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
      return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
    }
    if (sd == null) {
      external = false;
      wpr = pr;
    } else {
      wpr = sd;
    }
    Ctor.precision = wpr += guard;
    c = digitsToString(xd);
    c0 = c.charAt(0);
    if (Math.abs(e3 = x.e) < 15e14) {
      while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
        x = x.times(y2);
        c = digitsToString(x.d);
        c0 = c.charAt(0);
        n++;
      }
      e3 = x.e;
      if (c0 > 1) {
        x = new Ctor("0." + c);
        e3++;
      } else {
        x = new Ctor(c0 + "." + c.slice(1));
      }
    } else {
      t = getLn10(Ctor, wpr + 2, pr).times(e3 + "");
      x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
      Ctor.precision = pr;
      return sd == null ? finalise(x, pr, rm, external = true) : x;
    }
    x1 = x;
    sum3 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
    x2 = finalise(x.times(x), wpr, 1);
    denominator = 3;
    for (; ; ) {
      numerator = finalise(numerator.times(x2), wpr, 1);
      t = sum3.plus(divide(numerator, new Ctor(denominator), wpr, 1));
      if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum3.d).slice(0, wpr)) {
        sum3 = sum3.times(2);
        if (e3 !== 0)
          sum3 = sum3.plus(getLn10(Ctor, wpr + 2, pr).times(e3 + ""));
        sum3 = divide(sum3, new Ctor(n), wpr, 1);
        if (sd == null) {
          if (checkRoundingDigits(sum3.d, wpr - guard, rm, rep)) {
            Ctor.precision = wpr += guard;
            t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
            x2 = finalise(x.times(x), wpr, 1);
            denominator = rep = 1;
          } else {
            return finalise(sum3, Ctor.precision = pr, rm, external = true);
          }
        } else {
          Ctor.precision = pr;
          return sum3;
        }
      }
      sum3 = t;
      denominator += 2;
    }
  }
  function nonFiniteToString(x) {
    return String(x.s * x.s / 0);
  }
  function parseDecimal(x, str) {
    var e3, i3, len;
    if ((e3 = str.indexOf(".")) > -1)
      str = str.replace(".", "");
    if ((i3 = str.search(/e/i)) > 0) {
      if (e3 < 0)
        e3 = i3;
      e3 += +str.slice(i3 + 1);
      str = str.substring(0, i3);
    } else if (e3 < 0) {
      e3 = str.length;
    }
    for (i3 = 0; str.charCodeAt(i3) === 48; i3++)
      ;
    for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
      ;
    str = str.slice(i3, len);
    if (str) {
      len -= i3;
      x.e = e3 = e3 - i3 - 1;
      x.d = [];
      i3 = (e3 + 1) % LOG_BASE;
      if (e3 < 0)
        i3 += LOG_BASE;
      if (i3 < len) {
        if (i3)
          x.d.push(+str.slice(0, i3));
        for (len -= LOG_BASE; i3 < len; )
          x.d.push(+str.slice(i3, i3 += LOG_BASE));
        str = str.slice(i3);
        i3 = LOG_BASE - str.length;
      } else {
        i3 -= len;
      }
      for (; i3--; )
        str += "0";
      x.d.push(+str);
      if (external) {
        if (x.e > x.constructor.maxE) {
          x.d = null;
          x.e = NaN;
        } else if (x.e < x.constructor.minE) {
          x.e = 0;
          x.d = [0];
        }
      }
    } else {
      x.e = 0;
      x.d = [0];
    }
    return x;
  }
  function parseOther(x, str) {
    var base, Ctor, divisor, i3, isFloat, len, p, xd, xe;
    if (str.indexOf("_") > -1) {
      str = str.replace(/(\d)_(?=\d)/g, "$1");
      if (isDecimal.test(str))
        return parseDecimal(x, str);
    } else if (str === "Infinity" || str === "NaN") {
      if (!+str)
        x.s = NaN;
      x.e = NaN;
      x.d = null;
      return x;
    }
    if (isHex.test(str)) {
      base = 16;
      str = str.toLowerCase();
    } else if (isBinary.test(str)) {
      base = 2;
    } else if (isOctal.test(str)) {
      base = 8;
    } else {
      throw Error(invalidArgument + str);
    }
    i3 = str.search(/p/i);
    if (i3 > 0) {
      p = +str.slice(i3 + 1);
      str = str.substring(2, i3);
    } else {
      str = str.slice(2);
    }
    i3 = str.indexOf(".");
    isFloat = i3 >= 0;
    Ctor = x.constructor;
    if (isFloat) {
      str = str.replace(".", "");
      len = str.length;
      i3 = len - i3;
      divisor = intPow(Ctor, new Ctor(base), i3, i3 * 2);
    }
    xd = convertBase(str, base, BASE);
    xe = xd.length - 1;
    for (i3 = xe; xd[i3] === 0; --i3)
      xd.pop();
    if (i3 < 0)
      return new Ctor(x.s * 0);
    x.e = getBase10Exponent(xd, xe);
    x.d = xd;
    external = false;
    if (isFloat)
      x = divide(x, divisor, len * 4);
    if (p)
      x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
    external = true;
    return x;
  }
  function sine(Ctor, x) {
    var k, len = x.d.length;
    if (len < 3) {
      return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
    }
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x);
    var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sin2_x = x.times(x);
      x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
    }
    return x;
  }
  function taylorSeries(Ctor, n, x, y2, isHyperbolic) {
    var j, t, u, x2, i3 = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
    external = false;
    x2 = x.times(x);
    u = new Ctor(y2);
    for (; ; ) {
      t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
      u = isHyperbolic ? y2.plus(t) : y2.minus(t);
      y2 = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
      t = u.plus(y2);
      if (t.d[k] !== void 0) {
        for (j = k; t.d[j] === u.d[j] && j--; )
          ;
        if (j == -1)
          break;
      }
      j = u;
      u = y2;
      y2 = t;
      t = j;
      i3++;
    }
    external = true;
    t.d.length = k + 1;
    return t;
  }
  function tinyPow(b, e3) {
    var n = b;
    while (--e3)
      n *= b;
    return n;
  }
  function toLessThanHalfPi(Ctor, x) {
    var t, isNeg = x.s < 0, pi3 = getPi(Ctor, Ctor.precision, 1), halfPi = pi3.times(0.5);
    x = x.abs();
    if (x.lte(halfPi)) {
      quadrant = isNeg ? 4 : 1;
      return x;
    }
    t = x.divToInt(pi3);
    if (t.isZero()) {
      quadrant = isNeg ? 3 : 2;
    } else {
      x = x.minus(t.times(pi3));
      if (x.lte(halfPi)) {
        quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
        return x;
      }
      quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
    }
    return x.minus(pi3).abs();
  }
  function toStringBinary(x, baseOut, sd, rm) {
    var base, e3, i3, k, len, roundUp, str, xd, y2, Ctor = x.constructor, isExp = sd !== void 0;
    if (isExp) {
      checkInt32(sd, 1, MAX_DIGITS);
      if (rm === void 0)
        rm = Ctor.rounding;
      else
        checkInt32(rm, 0, 8);
    } else {
      sd = Ctor.precision;
      rm = Ctor.rounding;
    }
    if (!x.isFinite()) {
      str = nonFiniteToString(x);
    } else {
      str = finiteToString(x);
      i3 = str.indexOf(".");
      if (isExp) {
        base = 2;
        if (baseOut == 16) {
          sd = sd * 4 - 3;
        } else if (baseOut == 8) {
          sd = sd * 3 - 2;
        }
      } else {
        base = baseOut;
      }
      if (i3 >= 0) {
        str = str.replace(".", "");
        y2 = new Ctor(1);
        y2.e = str.length - i3;
        y2.d = convertBase(finiteToString(y2), 10, base);
        y2.e = y2.d.length;
      }
      xd = convertBase(str, 10, base);
      e3 = len = xd.length;
      for (; xd[--len] == 0; )
        xd.pop();
      if (!xd[0]) {
        str = isExp ? "0p+0" : "0";
      } else {
        if (i3 < 0) {
          e3--;
        } else {
          x = new Ctor(x);
          x.d = xd;
          x.e = e3;
          x = divide(x, y2, sd, rm, 0, base);
          xd = x.d;
          e3 = x.e;
          roundUp = inexact;
        }
        i3 = xd[sd];
        k = base / 2;
        roundUp = roundUp || xd[sd + 1] !== void 0;
        roundUp = rm < 4 ? (i3 !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i3 > k || i3 === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
        xd.length = sd;
        if (roundUp) {
          for (; ++xd[--sd] > base - 1; ) {
            xd[sd] = 0;
            if (!sd) {
              ++e3;
              xd.unshift(1);
            }
          }
        }
        for (len = xd.length; !xd[len - 1]; --len)
          ;
        for (i3 = 0, str = ""; i3 < len; i3++)
          str += NUMERALS.charAt(xd[i3]);
        if (isExp) {
          if (len > 1) {
            if (baseOut == 16 || baseOut == 8) {
              i3 = baseOut == 16 ? 4 : 3;
              for (--len; len % i3; len++)
                str += "0";
              xd = convertBase(str, base, baseOut);
              for (len = xd.length; !xd[len - 1]; --len)
                ;
              for (i3 = 1, str = "1."; i3 < len; i3++)
                str += NUMERALS.charAt(xd[i3]);
            } else {
              str = str.charAt(0) + "." + str.slice(1);
            }
          }
          str = str + (e3 < 0 ? "p" : "p+") + e3;
        } else if (e3 < 0) {
          for (; ++e3; )
            str = "0" + str;
          str = "0." + str;
        } else {
          if (++e3 > len)
            for (e3 -= len; e3--; )
              str += "0";
          else if (e3 < len)
            str = str.slice(0, e3) + "." + str.slice(e3);
        }
      }
      str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
    }
    return x.s < 0 ? "-" + str : str;
  }
  function truncate(arr, len) {
    if (arr.length > len) {
      arr.length = len;
      return true;
    }
  }
  function abs(x) {
    return new this(x).abs();
  }
  function acos(x) {
    return new this(x).acos();
  }
  function acosh2(x) {
    return new this(x).acosh();
  }
  function add(x, y2) {
    return new this(x).plus(y2);
  }
  function asin(x) {
    return new this(x).asin();
  }
  function asinh2(x) {
    return new this(x).asinh();
  }
  function atan(x) {
    return new this(x).atan();
  }
  function atanh2(x) {
    return new this(x).atanh();
  }
  function atan2(y2, x) {
    y2 = new this(y2);
    x = new this(x);
    var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
    if (!y2.s || !x.s) {
      r = new this(NaN);
    } else if (!y2.d && !x.d) {
      r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
      r.s = y2.s;
    } else if (!x.d || y2.isZero()) {
      r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
      r.s = y2.s;
    } else if (!y2.d || x.isZero()) {
      r = getPi(this, wpr, 1).times(0.5);
      r.s = y2.s;
    } else if (x.s < 0) {
      this.precision = wpr;
      this.rounding = 1;
      r = this.atan(divide(y2, x, wpr, 1));
      x = getPi(this, wpr, 1);
      this.precision = pr;
      this.rounding = rm;
      r = y2.s < 0 ? r.minus(x) : r.plus(x);
    } else {
      r = this.atan(divide(y2, x, wpr, 1));
    }
    return r;
  }
  function cbrt3(x) {
    return new this(x).cbrt();
  }
  function ceil(x) {
    return finalise(x = new this(x), x.e + 1, 2);
  }
  function clamp(x, min3, max3) {
    return new this(x).clamp(min3, max3);
  }
  function config3(obj) {
    if (!obj || typeof obj !== "object")
      throw Error(decimalError + "Object expected");
    var i3, p, v, useDefaults = obj.defaults === true, ps = [
      "precision",
      1,
      MAX_DIGITS,
      "rounding",
      0,
      8,
      "toExpNeg",
      -EXP_LIMIT,
      0,
      "toExpPos",
      0,
      EXP_LIMIT,
      "maxE",
      0,
      EXP_LIMIT,
      "minE",
      -EXP_LIMIT,
      0,
      "modulo",
      0,
      9
    ];
    for (i3 = 0; i3 < ps.length; i3 += 3) {
      if (p = ps[i3], useDefaults)
        this[p] = DEFAULTS[p];
      if ((v = obj[p]) !== void 0) {
        if (mathfloor(v) === v && v >= ps[i3 + 1] && v <= ps[i3 + 2])
          this[p] = v;
        else
          throw Error(invalidArgument + p + ": " + v);
      }
    }
    if (p = "crypto", useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (v === true || v === false || v === 0 || v === 1) {
        if (v) {
          if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
            this[p] = true;
          } else {
            throw Error(cryptoUnavailable);
          }
        } else {
          this[p] = false;
        }
      } else {
        throw Error(invalidArgument + p + ": " + v);
      }
    }
    return this;
  }
  function cos(x) {
    return new this(x).cos();
  }
  function cosh2(x) {
    return new this(x).cosh();
  }
  function clone3(obj) {
    var i3, p, ps;
    function Decimal2(v) {
      var e3, i4, t, x = this;
      if (!(x instanceof Decimal2))
        return new Decimal2(v);
      x.constructor = Decimal2;
      if (isDecimalInstance(v)) {
        x.s = v.s;
        if (external) {
          if (!v.d || v.e > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (v.e < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = v.e;
            x.d = v.d.slice();
          }
        } else {
          x.e = v.e;
          x.d = v.d ? v.d.slice() : v.d;
        }
        return;
      }
      t = typeof v;
      if (t === "number") {
        if (v === 0) {
          x.s = 1 / v < 0 ? -1 : 1;
          x.e = 0;
          x.d = [0];
          return;
        }
        if (v < 0) {
          v = -v;
          x.s = -1;
        } else {
          x.s = 1;
        }
        if (v === ~~v && v < 1e7) {
          for (e3 = 0, i4 = v; i4 >= 10; i4 /= 10)
            e3++;
          if (external) {
            if (e3 > Decimal2.maxE) {
              x.e = NaN;
              x.d = null;
            } else if (e3 < Decimal2.minE) {
              x.e = 0;
              x.d = [0];
            } else {
              x.e = e3;
              x.d = [v];
            }
          } else {
            x.e = e3;
            x.d = [v];
          }
          return;
        } else if (v * 0 !== 0) {
          if (!v)
            x.s = NaN;
          x.e = NaN;
          x.d = null;
          return;
        }
        return parseDecimal(x, v.toString());
      } else if (t !== "string") {
        throw Error(invalidArgument + v);
      }
      if ((i4 = v.charCodeAt(0)) === 45) {
        v = v.slice(1);
        x.s = -1;
      } else {
        if (i4 === 43)
          v = v.slice(1);
        x.s = 1;
      }
      return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
    }
    Decimal2.prototype = P;
    Decimal2.ROUND_UP = 0;
    Decimal2.ROUND_DOWN = 1;
    Decimal2.ROUND_CEIL = 2;
    Decimal2.ROUND_FLOOR = 3;
    Decimal2.ROUND_HALF_UP = 4;
    Decimal2.ROUND_HALF_DOWN = 5;
    Decimal2.ROUND_HALF_EVEN = 6;
    Decimal2.ROUND_HALF_CEIL = 7;
    Decimal2.ROUND_HALF_FLOOR = 8;
    Decimal2.EUCLID = 9;
    Decimal2.config = Decimal2.set = config3;
    Decimal2.clone = clone3;
    Decimal2.isDecimal = isDecimalInstance;
    Decimal2.abs = abs;
    Decimal2.acos = acos;
    Decimal2.acosh = acosh2;
    Decimal2.add = add;
    Decimal2.asin = asin;
    Decimal2.asinh = asinh2;
    Decimal2.atan = atan;
    Decimal2.atanh = atanh2;
    Decimal2.atan2 = atan2;
    Decimal2.cbrt = cbrt3;
    Decimal2.ceil = ceil;
    Decimal2.clamp = clamp;
    Decimal2.cos = cos;
    Decimal2.cosh = cosh2;
    Decimal2.div = div;
    Decimal2.exp = exp;
    Decimal2.floor = floor;
    Decimal2.hypot = hypot;
    Decimal2.ln = ln;
    Decimal2.log = log;
    Decimal2.log10 = log103;
    Decimal2.log2 = log23;
    Decimal2.max = max;
    Decimal2.min = min;
    Decimal2.mod = mod;
    Decimal2.mul = mul;
    Decimal2.pow = pow;
    Decimal2.random = random;
    Decimal2.round = round;
    Decimal2.sign = sign2;
    Decimal2.sin = sin;
    Decimal2.sinh = sinh2;
    Decimal2.sqrt = sqrt;
    Decimal2.sub = sub;
    Decimal2.sum = sum;
    Decimal2.tan = tan;
    Decimal2.tanh = tanh2;
    Decimal2.trunc = trunc;
    if (obj === void 0)
      obj = {};
    if (obj) {
      if (obj.defaults !== true) {
        ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
        for (i3 = 0; i3 < ps.length; )
          if (!obj.hasOwnProperty(p = ps[i3++]))
            obj[p] = this[p];
      }
    }
    Decimal2.config(obj);
    return Decimal2;
  }
  function div(x, y2) {
    return new this(x).div(y2);
  }
  function exp(x) {
    return new this(x).exp();
  }
  function floor(x) {
    return finalise(x = new this(x), x.e + 1, 3);
  }
  function hypot() {
    var i3, n, t = new this(0);
    external = false;
    for (i3 = 0; i3 < arguments.length; ) {
      n = new this(arguments[i3++]);
      if (!n.d) {
        if (n.s) {
          external = true;
          return new this(1 / 0);
        }
        t = n;
      } else if (t.d) {
        t = t.plus(n.times(n));
      }
    }
    external = true;
    return t.sqrt();
  }
  function isDecimalInstance(obj) {
    return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
  }
  function ln(x) {
    return new this(x).ln();
  }
  function log(x, y2) {
    return new this(x).log(y2);
  }
  function log23(x) {
    return new this(x).log(2);
  }
  function log103(x) {
    return new this(x).log(10);
  }
  function max() {
    return maxOrMin(this, arguments, "lt");
  }
  function min() {
    return maxOrMin(this, arguments, "gt");
  }
  function mod(x, y2) {
    return new this(x).mod(y2);
  }
  function mul(x, y2) {
    return new this(x).mul(y2);
  }
  function pow(x, y2) {
    return new this(x).pow(y2);
  }
  function random(sd) {
    var d, e3, k, n, i3 = 0, r = new this(1), rd = [];
    if (sd === void 0)
      sd = this.precision;
    else
      checkInt32(sd, 1, MAX_DIGITS);
    k = Math.ceil(sd / LOG_BASE);
    if (!this.crypto) {
      for (; i3 < k; )
        rd[i3++] = Math.random() * 1e7 | 0;
    } else if (crypto.getRandomValues) {
      d = crypto.getRandomValues(new Uint32Array(k));
      for (; i3 < k; ) {
        n = d[i3];
        if (n >= 429e7) {
          d[i3] = crypto.getRandomValues(new Uint32Array(1))[0];
        } else {
          rd[i3++] = n % 1e7;
        }
      }
    } else if (crypto.randomBytes) {
      d = crypto.randomBytes(k *= 4);
      for (; i3 < k; ) {
        n = d[i3] + (d[i3 + 1] << 8) + (d[i3 + 2] << 16) + ((d[i3 + 3] & 127) << 24);
        if (n >= 214e7) {
          crypto.randomBytes(4).copy(d, i3);
        } else {
          rd.push(n % 1e7);
          i3 += 4;
        }
      }
      i3 = k / 4;
    } else {
      throw Error(cryptoUnavailable);
    }
    k = rd[--i3];
    sd %= LOG_BASE;
    if (k && sd) {
      n = mathpow(10, LOG_BASE - sd);
      rd[i3] = (k / n | 0) * n;
    }
    for (; rd[i3] === 0; i3--)
      rd.pop();
    if (i3 < 0) {
      e3 = 0;
      rd = [0];
    } else {
      e3 = -1;
      for (; rd[0] === 0; e3 -= LOG_BASE)
        rd.shift();
      for (k = 1, n = rd[0]; n >= 10; n /= 10)
        k++;
      if (k < LOG_BASE)
        e3 -= LOG_BASE - k;
    }
    r.e = e3;
    r.d = rd;
    return r;
  }
  function round(x) {
    return finalise(x = new this(x), x.e + 1, this.rounding);
  }
  function sign2(x) {
    x = new this(x);
    return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
  }
  function sin(x) {
    return new this(x).sin();
  }
  function sinh2(x) {
    return new this(x).sinh();
  }
  function sqrt(x) {
    return new this(x).sqrt();
  }
  function sub(x, y2) {
    return new this(x).sub(y2);
  }
  function sum() {
    var i3 = 0, args = arguments, x = new this(args[i3]);
    external = false;
    for (; x.s && ++i3 < args.length; )
      x = x.plus(args[i3]);
    external = true;
    return finalise(x, this.precision, this.rounding);
  }
  function tan(x) {
    return new this(x).tan();
  }
  function tanh2(x) {
    return new this(x).tanh();
  }
  function trunc(x) {
    return finalise(x = new this(x), x.e + 1, 1);
  }
  P[Symbol.for("nodejs.util.inspect.custom")] = P.toString;
  P[Symbol.toStringTag] = "Decimal";
  var Decimal = P.constructor = clone3(DEFAULTS);
  LN10 = new Decimal(LN10);
  PI = new Decimal(PI);
  var decimal_default = Decimal;

  // node_modules/mathjs/lib/esm/type/bignumber/BigNumber.js
  var name2 = "BigNumber";
  var dependencies3 = ["?on", "config"];
  var createBigNumberClass = /* @__PURE__ */ factory(name2, dependencies3, (_ref) => {
    var {
      on,
      config: config4
    } = _ref;
    var BigNumber2 = decimal_default.clone({
      precision: config4.precision,
      modulo: decimal_default.EUCLID
    });
    BigNumber2.prototype = Object.create(BigNumber2.prototype);
    BigNumber2.prototype.type = "BigNumber";
    BigNumber2.prototype.isBigNumber = true;
    BigNumber2.prototype.toJSON = function() {
      return {
        mathjs: "BigNumber",
        value: this.toString()
      };
    };
    BigNumber2.fromJSON = function(json) {
      return new BigNumber2(json.value);
    };
    if (on) {
      on("config", function(curr, prev) {
        if (curr.precision !== prev.precision) {
          BigNumber2.config({
            precision: curr.precision
          });
        }
      });
    }
    return BigNumber2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/complex/Complex.js
  var import_complex = __toESM(require_complex(), 1);
  var name3 = "Complex";
  var dependencies4 = [];
  var createComplexClass = /* @__PURE__ */ factory(name3, dependencies4, () => {
    Object.defineProperty(import_complex.default, "name", {
      value: "Complex"
    });
    import_complex.default.prototype.constructor = import_complex.default;
    import_complex.default.prototype.type = "Complex";
    import_complex.default.prototype.isComplex = true;
    import_complex.default.prototype.toJSON = function() {
      return {
        mathjs: "Complex",
        re: this.re,
        im: this.im
      };
    };
    import_complex.default.prototype.toPolar = function() {
      return {
        r: this.abs(),
        phi: this.arg()
      };
    };
    import_complex.default.prototype.format = function(options) {
      var str = "";
      var im2 = this.im;
      var re2 = this.re;
      var strRe = format(this.re, options);
      var strIm = format(this.im, options);
      var precision = isNumber(options) ? options : options ? options.precision : null;
      if (precision !== null) {
        var epsilon = Math.pow(10, -precision);
        if (Math.abs(re2 / im2) < epsilon) {
          re2 = 0;
        }
        if (Math.abs(im2 / re2) < epsilon) {
          im2 = 0;
        }
      }
      if (im2 === 0) {
        str = strRe;
      } else if (re2 === 0) {
        if (im2 === 1) {
          str = "i";
        } else if (im2 === -1) {
          str = "-i";
        } else {
          str = strIm + "i";
        }
      } else {
        if (im2 < 0) {
          if (im2 === -1) {
            str = strRe + " - i";
          } else {
            str = strRe + " - " + strIm.substring(1) + "i";
          }
        } else {
          if (im2 === 1) {
            str = strRe + " + i";
          } else {
            str = strRe + " + " + strIm + "i";
          }
        }
      }
      return str;
    };
    import_complex.default.fromPolar = function(args) {
      switch (arguments.length) {
        case 1: {
          var arg2 = arguments[0];
          if (typeof arg2 === "object") {
            return (0, import_complex.default)(arg2);
          } else {
            throw new TypeError("Input has to be an object with r and phi keys.");
          }
        }
        case 2: {
          var r = arguments[0];
          var phi3 = arguments[1];
          if (isNumber(r)) {
            if (isUnit(phi3) && phi3.hasBase("ANGLE")) {
              phi3 = phi3.toNumber("rad");
            }
            if (isNumber(phi3)) {
              return new import_complex.default({
                r,
                phi: phi3
              });
            }
            throw new TypeError("Phi is not a number nor an angle unit.");
          } else {
            throw new TypeError("Radius r is not a number.");
          }
        }
        default:
          throw new SyntaxError("Wrong number of arguments in function fromPolar");
      }
    };
    import_complex.default.prototype.valueOf = import_complex.default.prototype.toString;
    import_complex.default.fromJSON = function(json) {
      return new import_complex.default(json);
    };
    import_complex.default.compare = function(a, b) {
      if (a.re > b.re) {
        return 1;
      }
      if (a.re < b.re) {
        return -1;
      }
      if (a.im > b.im) {
        return 1;
      }
      if (a.im < b.im) {
        return -1;
      }
      return 0;
    };
    return import_complex.default;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/fraction/Fraction.js
  var import_fraction = __toESM(require_fraction(), 1);
  var name4 = "Fraction";
  var dependencies5 = [];
  var createFractionClass = /* @__PURE__ */ factory(name4, dependencies5, () => {
    Object.defineProperty(import_fraction.default, "name", {
      value: "Fraction"
    });
    import_fraction.default.prototype.constructor = import_fraction.default;
    import_fraction.default.prototype.type = "Fraction";
    import_fraction.default.prototype.isFraction = true;
    import_fraction.default.prototype.toJSON = function() {
      return {
        mathjs: "Fraction",
        n: this.s * this.n,
        d: this.d
      };
    };
    import_fraction.default.fromJSON = function(json) {
      return new import_fraction.default(json);
    };
    return import_fraction.default;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/Range.js
  var name5 = "Range";
  var dependencies6 = [];
  var createRangeClass = /* @__PURE__ */ factory(name5, dependencies6, () => {
    function Range2(start, end, step) {
      if (!(this instanceof Range2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      var hasStart = start !== null && start !== void 0;
      var hasEnd = end !== null && end !== void 0;
      var hasStep = step !== null && step !== void 0;
      if (hasStart) {
        if (isBigNumber(start)) {
          start = start.toNumber();
        } else if (typeof start !== "number") {
          throw new TypeError("Parameter start must be a number");
        }
      }
      if (hasEnd) {
        if (isBigNumber(end)) {
          end = end.toNumber();
        } else if (typeof end !== "number") {
          throw new TypeError("Parameter end must be a number");
        }
      }
      if (hasStep) {
        if (isBigNumber(step)) {
          step = step.toNumber();
        } else if (typeof step !== "number") {
          throw new TypeError("Parameter step must be a number");
        }
      }
      this.start = hasStart ? parseFloat(start) : 0;
      this.end = hasEnd ? parseFloat(end) : 0;
      this.step = hasStep ? parseFloat(step) : 1;
    }
    Range2.prototype.type = "Range";
    Range2.prototype.isRange = true;
    Range2.parse = function(str) {
      if (typeof str !== "string") {
        return null;
      }
      var args = str.split(":");
      var nums = args.map(function(arg2) {
        return parseFloat(arg2);
      });
      var invalid = nums.some(function(num) {
        return isNaN(num);
      });
      if (invalid) {
        return null;
      }
      switch (nums.length) {
        case 2:
          return new Range2(nums[0], nums[1]);
        case 3:
          return new Range2(nums[0], nums[2], nums[1]);
        default:
          return null;
      }
    };
    Range2.prototype.clone = function() {
      return new Range2(this.start, this.end, this.step);
    };
    Range2.prototype.size = function() {
      var len = 0;
      var start = this.start;
      var step = this.step;
      var end = this.end;
      var diff2 = end - start;
      if (sign(step) === sign(diff2)) {
        len = Math.ceil(diff2 / step);
      } else if (diff2 === 0) {
        len = 0;
      }
      if (isNaN(len)) {
        len = 0;
      }
      return [len];
    };
    Range2.prototype.min = function() {
      var size2 = this.size()[0];
      if (size2 > 0) {
        if (this.step > 0) {
          return this.start;
        } else {
          return this.start + (size2 - 1) * this.step;
        }
      } else {
        return void 0;
      }
    };
    Range2.prototype.max = function() {
      var size2 = this.size()[0];
      if (size2 > 0) {
        if (this.step > 0) {
          return this.start + (size2 - 1) * this.step;
        } else {
          return this.start;
        }
      } else {
        return void 0;
      }
    };
    Range2.prototype.forEach = function(callback) {
      var x = this.start;
      var step = this.step;
      var end = this.end;
      var i3 = 0;
      if (step > 0) {
        while (x < end) {
          callback(x, [i3], this);
          x += step;
          i3++;
        }
      } else if (step < 0) {
        while (x > end) {
          callback(x, [i3], this);
          x += step;
          i3++;
        }
      }
    };
    Range2.prototype.map = function(callback) {
      var array = [];
      this.forEach(function(value, index2, obj) {
        array[index2[0]] = callback(value, index2, obj);
      });
      return array;
    };
    Range2.prototype.toArray = function() {
      var array = [];
      this.forEach(function(value, index2) {
        array[index2[0]] = value;
      });
      return array;
    };
    Range2.prototype.valueOf = function() {
      return this.toArray();
    };
    Range2.prototype.format = function(options) {
      var str = format(this.start, options);
      if (this.step !== 1) {
        str += ":" + format(this.step, options);
      }
      str += ":" + format(this.end, options);
      return str;
    };
    Range2.prototype.toString = function() {
      return this.format();
    };
    Range2.prototype.toJSON = function() {
      return {
        mathjs: "Range",
        start: this.start,
        end: this.end,
        step: this.step
      };
    };
    Range2.fromJSON = function(json) {
      return new Range2(json.start, json.end, json.step);
    };
    return Range2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/Matrix.js
  var name6 = "Matrix";
  var dependencies7 = [];
  var createMatrixClass = /* @__PURE__ */ factory(name6, dependencies7, () => {
    function Matrix2() {
      if (!(this instanceof Matrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
    }
    Matrix2.prototype.type = "Matrix";
    Matrix2.prototype.isMatrix = true;
    Matrix2.prototype.storage = function() {
      throw new Error("Cannot invoke storage on a Matrix interface");
    };
    Matrix2.prototype.datatype = function() {
      throw new Error("Cannot invoke datatype on a Matrix interface");
    };
    Matrix2.prototype.create = function(data, datatype) {
      throw new Error("Cannot invoke create on a Matrix interface");
    };
    Matrix2.prototype.subset = function(index2, replacement, defaultValue) {
      throw new Error("Cannot invoke subset on a Matrix interface");
    };
    Matrix2.prototype.get = function(index2) {
      throw new Error("Cannot invoke get on a Matrix interface");
    };
    Matrix2.prototype.set = function(index2, value, defaultValue) {
      throw new Error("Cannot invoke set on a Matrix interface");
    };
    Matrix2.prototype.resize = function(size2, defaultValue) {
      throw new Error("Cannot invoke resize on a Matrix interface");
    };
    Matrix2.prototype.reshape = function(size2, defaultValue) {
      throw new Error("Cannot invoke reshape on a Matrix interface");
    };
    Matrix2.prototype.clone = function() {
      throw new Error("Cannot invoke clone on a Matrix interface");
    };
    Matrix2.prototype.size = function() {
      throw new Error("Cannot invoke size on a Matrix interface");
    };
    Matrix2.prototype.map = function(callback, skipZeros) {
      throw new Error("Cannot invoke map on a Matrix interface");
    };
    Matrix2.prototype.forEach = function(callback) {
      throw new Error("Cannot invoke forEach on a Matrix interface");
    };
    Matrix2.prototype[Symbol.iterator] = function() {
      throw new Error("Cannot iterate a Matrix interface");
    };
    Matrix2.prototype.toArray = function() {
      throw new Error("Cannot invoke toArray on a Matrix interface");
    };
    Matrix2.prototype.valueOf = function() {
      throw new Error("Cannot invoke valueOf on a Matrix interface");
    };
    Matrix2.prototype.format = function(options) {
      throw new Error("Cannot invoke format on a Matrix interface");
    };
    Matrix2.prototype.toString = function() {
      throw new Error("Cannot invoke toString on a Matrix interface");
    };
    return Matrix2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/utils/lruQueue.js
  function lruQueue(limit) {
    var size2 = 0;
    var base = 1;
    var queue = /* @__PURE__ */ Object.create(null);
    var map3 = /* @__PURE__ */ Object.create(null);
    var index2 = 0;
    var del = function del2(id) {
      var oldIndex = map3[id];
      if (!oldIndex)
        return;
      delete queue[oldIndex];
      delete map3[id];
      --size2;
      if (base !== oldIndex)
        return;
      if (!size2) {
        index2 = 0;
        base = 1;
        return;
      }
      while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
      }
    };
    limit = Math.abs(limit);
    return {
      hit: function hit(id) {
        var oldIndex = map3[id];
        var nuIndex = ++index2;
        queue[nuIndex] = id;
        map3[id] = nuIndex;
        if (!oldIndex) {
          ++size2;
          if (size2 <= limit)
            return void 0;
          id = queue[base];
          del(id);
          return id;
        }
        delete queue[oldIndex];
        if (base !== oldIndex)
          return void 0;
        while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
        }
        return void 0;
      },
      delete: del,
      clear: function clear() {
        size2 = index2 = 0;
        base = 1;
        queue = /* @__PURE__ */ Object.create(null);
        map3 = /* @__PURE__ */ Object.create(null);
      }
    };
  }

  // node_modules/mathjs/lib/esm/utils/function.js
  function memoize(fn) {
    var {
      hasher: hasher2,
      limit
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    limit = limit == null ? Number.POSITIVE_INFINITY : limit;
    hasher2 = hasher2 == null ? JSON.stringify : hasher2;
    return function memoize2() {
      if (typeof memoize2.cache !== "object") {
        memoize2.cache = {
          values: /* @__PURE__ */ new Map(),
          lru: lruQueue(limit || Number.POSITIVE_INFINITY)
        };
      }
      var args = [];
      for (var i3 = 0; i3 < arguments.length; i3++) {
        args[i3] = arguments[i3];
      }
      var hash = hasher2(args);
      if (memoize2.cache.values.has(hash)) {
        memoize2.cache.lru.hit(hash);
        return memoize2.cache.values.get(hash);
      }
      var newVal = fn.apply(fn, args);
      memoize2.cache.values.set(hash, newVal);
      memoize2.cache.values.delete(memoize2.cache.lru.hit(hash));
      return newVal;
    };
  }
  function maxArgumentCount(fn) {
    return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
      var count2 = (signature.match(/,/g) || []).length + 1;
      return Math.max(args, count2);
    }, -1);
  }

  // node_modules/mathjs/lib/esm/type/matrix/DenseMatrix.js
  var name7 = "DenseMatrix";
  var dependencies8 = ["Matrix"];
  var createDenseMatrixClass = /* @__PURE__ */ factory(name7, dependencies8, (_ref) => {
    var {
      Matrix: Matrix2
    } = _ref;
    function DenseMatrix2(data, datatype) {
      if (!(this instanceof DenseMatrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        if (data.type === "DenseMatrix") {
          this._data = clone(data._data);
          this._size = clone(data._size);
          this._datatype = datatype || data._datatype;
        } else {
          this._data = data.toArray();
          this._size = data.size();
          this._datatype = datatype || data._datatype;
        }
      } else if (data && isArray(data.data) && isArray(data.size)) {
        this._data = data.data;
        this._size = data.size;
        validate(this._data, this._size);
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        this._data = preprocess(data);
        this._size = arraySize(this._data);
        validate(this._data, this._size);
        this._datatype = datatype;
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
      }
    }
    DenseMatrix2.prototype = new Matrix2();
    DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
      return new DenseMatrix2(data, datatype);
    };
    Object.defineProperty(DenseMatrix2, "name", {
      value: "DenseMatrix"
    });
    DenseMatrix2.prototype.constructor = DenseMatrix2;
    DenseMatrix2.prototype.type = "DenseMatrix";
    DenseMatrix2.prototype.isDenseMatrix = true;
    DenseMatrix2.prototype.getDataType = function() {
      return getArrayDataType(this._data, typeOf);
    };
    DenseMatrix2.prototype.storage = function() {
      return "dense";
    };
    DenseMatrix2.prototype.datatype = function() {
      return this._datatype;
    };
    DenseMatrix2.prototype.create = function(data, datatype) {
      return new DenseMatrix2(data, datatype);
    };
    DenseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
      switch (arguments.length) {
        case 1:
          return _get(this, index2);
        case 2:
        case 3:
          return _set(this, index2, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    DenseMatrix2.prototype.get = function(index2) {
      if (!isArray(index2)) {
        throw new TypeError("Array expected");
      }
      if (index2.length !== this._size.length) {
        throw new DimensionError(index2.length, this._size.length);
      }
      for (var x = 0; x < index2.length; x++) {
        validateIndex(index2[x], this._size[x]);
      }
      var data = this._data;
      for (var i3 = 0, ii = index2.length; i3 < ii; i3++) {
        var indexI = index2[i3];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      return data;
    };
    DenseMatrix2.prototype.set = function(index2, value, defaultValue) {
      if (!isArray(index2)) {
        throw new TypeError("Array expected");
      }
      if (index2.length < this._size.length) {
        throw new DimensionError(index2.length, this._size.length, "<");
      }
      var i3, ii, indexI;
      var size2 = index2.map(function(i4) {
        return i4 + 1;
      });
      _fit(this, size2, defaultValue);
      var data = this._data;
      for (i3 = 0, ii = index2.length - 1; i3 < ii; i3++) {
        indexI = index2[i3];
        validateIndex(indexI, data.length);
        data = data[indexI];
      }
      indexI = index2[index2.length - 1];
      validateIndex(indexI, data.length);
      data[indexI] = value;
      return this;
    };
    function _get(matrix2, index2) {
      if (!isIndex(index2)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = index2.isScalar();
      if (isScalar) {
        return matrix2.get(index2.min());
      } else {
        var size2 = index2.size();
        if (size2.length !== matrix2._size.length) {
          throw new DimensionError(size2.length, matrix2._size.length);
        }
        var min3 = index2.min();
        var max3 = index2.max();
        for (var i3 = 0, ii = matrix2._size.length; i3 < ii; i3++) {
          validateIndex(min3[i3], matrix2._size[i3]);
          validateIndex(max3[i3], matrix2._size[i3]);
        }
        return new DenseMatrix2(_getSubmatrix(matrix2._data, index2, size2.length, 0), matrix2._datatype);
      }
    }
    function _getSubmatrix(data, index2, dims, dim) {
      var last = dim === dims - 1;
      var range2 = index2.dimension(dim);
      if (last) {
        return range2.map(function(i3) {
          validateIndex(i3, data.length);
          return data[i3];
        }).valueOf();
      } else {
        return range2.map(function(i3) {
          validateIndex(i3, data.length);
          var child = data[i3];
          return _getSubmatrix(child, index2, dims, dim + 1);
        }).valueOf();
      }
    }
    function _set(matrix2, index2, submatrix, defaultValue) {
      if (!index2 || index2.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index2.size();
      var isScalar = index2.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.valueOf();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix2.set(index2.min(), submatrix, defaultValue);
      } else {
        if (!deepStrictEqual(sSize, iSize)) {
          try {
            if (sSize.length === 0) {
              submatrix = broadcastTo([submatrix], iSize);
            } else {
              submatrix = broadcastTo(submatrix, iSize);
            }
            sSize = arraySize(submatrix);
          } catch (_unused) {
          }
        }
        if (iSize.length < matrix2._size.length) {
          throw new DimensionError(iSize.length, matrix2._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i3 = 0;
          var outer = 0;
          while (iSize[i3] === 1 && sSize[i3] === 1) {
            i3++;
          }
          while (iSize[i3] === 1) {
            outer++;
            i3++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        var size2 = index2.max().map(function(i4) {
          return i4 + 1;
        });
        _fit(matrix2, size2, defaultValue);
        var dims = iSize.length;
        var dim = 0;
        _setSubmatrix(matrix2._data, index2, submatrix, dims, dim);
      }
      return matrix2;
    }
    function _setSubmatrix(data, index2, submatrix, dims, dim) {
      var last = dim === dims - 1;
      var range2 = index2.dimension(dim);
      if (last) {
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          data[dataIndex] = submatrix[subIndex[0]];
        });
      } else {
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          _setSubmatrix(data[dataIndex], index2, submatrix[subIndex[0]], dims, dim + 1);
        });
      }
    }
    DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
      if (!isCollection(size2)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size2.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray, defaultValue);
    };
    function _resize2(matrix2, size2, defaultValue) {
      if (size2.length === 0) {
        var v = matrix2._data;
        while (isArray(v)) {
          v = v[0];
        }
        return v;
      }
      matrix2._size = size2.slice(0);
      matrix2._data = resize(matrix2._data, matrix2._size, defaultValue);
      return matrix2;
    }
    DenseMatrix2.prototype.reshape = function(size2, copy) {
      var m = copy ? this.clone() : this;
      m._data = reshape(m._data, size2);
      var currentLength = m._size.reduce((length, size3) => length * size3);
      m._size = processSizesWildcard(size2, currentLength);
      return m;
    };
    function _fit(matrix2, size2, defaultValue) {
      var newSize = matrix2._size.slice(0);
      var changed = false;
      while (newSize.length < size2.length) {
        newSize.push(0);
        changed = true;
      }
      for (var i3 = 0, ii = size2.length; i3 < ii; i3++) {
        if (size2[i3] > newSize[i3]) {
          newSize[i3] = size2[i3];
          changed = true;
        }
      }
      if (changed) {
        _resize2(matrix2, newSize, defaultValue);
      }
    }
    DenseMatrix2.prototype.clone = function() {
      var m = new DenseMatrix2({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    DenseMatrix2.prototype.size = function() {
      return this._size.slice(0);
    };
    DenseMatrix2.prototype.map = function(callback) {
      var me = this;
      var args = maxArgumentCount(callback);
      var recurse = function recurse2(value, index2) {
        if (isArray(value)) {
          return value.map(function(child, i3) {
            return recurse2(child, index2.concat(i3));
          });
        } else {
          if (args === 1) {
            return callback(value);
          } else if (args === 2) {
            return callback(value, index2);
          } else {
            return callback(value, index2, me);
          }
        }
      };
      var data = recurse(this._data, []);
      var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf) : void 0;
      return new DenseMatrix2(data, datatype);
    };
    DenseMatrix2.prototype.forEach = function(callback) {
      var me = this;
      var recurse = function recurse2(value, index2) {
        if (isArray(value)) {
          value.forEach(function(child, i3) {
            recurse2(child, index2.concat(i3));
          });
        } else {
          callback(value, index2, me);
        }
      };
      recurse(this._data, []);
    };
    DenseMatrix2.prototype[Symbol.iterator] = function* () {
      var recurse = function* recurse2(value, index2) {
        if (isArray(value)) {
          for (var i3 = 0; i3 < value.length; i3++) {
            yield* recurse2(value[i3], index2.concat(i3));
          }
        } else {
          yield {
            value,
            index: index2
          };
        }
      };
      yield* recurse(this._data, []);
    };
    DenseMatrix2.prototype.rows = function() {
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError("Rows can only be returned for a 2D matrix.");
      }
      var data = this._data;
      for (var row2 of data) {
        result.push(new DenseMatrix2([row2], this._datatype));
      }
      return result;
    };
    DenseMatrix2.prototype.columns = function() {
      var _this = this;
      var result = [];
      var s = this.size();
      if (s.length !== 2) {
        throw new TypeError("Rows can only be returned for a 2D matrix.");
      }
      var data = this._data;
      var _loop = function _loop2(i4) {
        var col = data.map((row2) => [row2[i4]]);
        result.push(new DenseMatrix2(col, _this._datatype));
      };
      for (var i3 = 0; i3 < s[1]; i3++) {
        _loop(i3);
      }
      return result;
    };
    DenseMatrix2.prototype.toArray = function() {
      return clone(this._data);
    };
    DenseMatrix2.prototype.valueOf = function() {
      return this._data;
    };
    DenseMatrix2.prototype.format = function(options) {
      return format3(this._data, options);
    };
    DenseMatrix2.prototype.toString = function() {
      return format3(this._data);
    };
    DenseMatrix2.prototype.toJSON = function() {
      return {
        mathjs: "DenseMatrix",
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    DenseMatrix2.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var data = [];
      for (var i3 = 0; i3 < n; i3++) {
        data[i3] = this._data[i3 + kSub][i3 + kSuper];
      }
      return new DenseMatrix2({
        data,
        size: [n],
        datatype: this._datatype
      });
    };
    DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
      if (!isArray(size2)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size2.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size2 = size2.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size2[0];
      var columns = size2[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i3) {
          return value[i3];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i3) {
          return value.get([i3]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      if (!defaultValue) {
        defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
      }
      var data = [];
      if (size2.length > 0) {
        data = resize(data, size2, defaultValue);
        for (var d = 0; d < n; d++) {
          data[d + kSub][d + kSuper] = _value(d);
        }
      }
      return new DenseMatrix2({
        data,
        size: [rows, columns]
      });
    };
    DenseMatrix2.fromJSON = function(json) {
      return new DenseMatrix2(json);
    };
    DenseMatrix2.prototype.swapRows = function(i3, j) {
      if (!isNumber(i3) || !isInteger(i3) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i3, this._size[0]);
      validateIndex(j, this._size[0]);
      DenseMatrix2._swapRows(i3, j, this._data);
      return this;
    };
    DenseMatrix2._swapRows = function(i3, j, data) {
      var vi = data[i3];
      data[i3] = data[j];
      data[j] = vi;
    };
    function preprocess(data) {
      if (isMatrix(data)) {
        return preprocess(data.valueOf());
      }
      if (isArray(data)) {
        return data.map(preprocess);
      }
      return data;
    }
    return DenseMatrix2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/function/utils/clone.js
  var name8 = "clone";
  var dependencies9 = ["typed"];
  var createClone = /* @__PURE__ */ factory(name8, dependencies9, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name8, {
      any: clone
    });
  });

  // node_modules/mathjs/lib/esm/utils/switch.js
  function _switch(mat) {
    var I2 = mat.length;
    var J = mat[0].length;
    var i3, j;
    var ret = [];
    for (j = 0; j < J; j++) {
      var tmp = [];
      for (i3 = 0; i3 < I2; i3++) {
        tmp.push(mat[i3][j]);
      }
      ret.push(tmp);
    }
    return ret;
  }

  // node_modules/mathjs/lib/esm/utils/collection.js
  function containsCollections(array) {
    for (var i3 = 0; i3 < array.length; i3++) {
      if (isCollection(array[i3])) {
        return true;
      }
    }
    return false;
  }
  function deepForEach(array, callback) {
    if (isMatrix(array)) {
      array = array.valueOf();
    }
    for (var i3 = 0, ii = array.length; i3 < ii; i3++) {
      var value = array[i3];
      if (Array.isArray(value)) {
        deepForEach(value, callback);
      } else {
        callback(value);
      }
    }
  }
  function deepMap(array, callback, skipZeros) {
    if (array && typeof array.map === "function") {
      return array.map(function(x) {
        return deepMap(x, callback, skipZeros);
      });
    } else {
      return callback(array);
    }
  }
  function reduce(mat, dim, callback) {
    var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
    if (dim < 0 || dim >= size2.length) {
      throw new IndexError(dim, size2.length);
    }
    if (isMatrix(mat)) {
      return mat.create(_reduce(mat.valueOf(), dim, callback));
    } else {
      return _reduce(mat, dim, callback);
    }
  }
  function _reduce(mat, dim, callback) {
    var i3, ret, val, tran;
    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        val = mat[0];
        for (i3 = 1; i3 < mat.length; i3++) {
          val = callback(val, mat[i3]);
        }
        return val;
      } else {
        tran = _switch(mat);
        ret = [];
        for (i3 = 0; i3 < tran.length; i3++) {
          ret[i3] = _reduce(tran[i3], dim - 1, callback);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i3 = 0; i3 < mat.length; i3++) {
        ret[i3] = _reduce(mat[i3], dim - 1, callback);
      }
      return ret;
    }
  }
  function scatter(a, j, w2, x, u, mark, cindex, f, inverse, update, value) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var k, k0, k1, i3;
    if (x) {
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i3 = aindex[k];
        if (w2[i3] !== mark) {
          w2[i3] = mark;
          cindex.push(i3);
          if (update) {
            x[i3] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
            u[i3] = mark;
          } else {
            x[i3] = avalues[k];
          }
        } else {
          x[i3] = inverse ? f(avalues[k], x[i3]) : f(x[i3], avalues[k]);
          u[i3] = mark;
        }
      }
    } else {
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i3 = aindex[k];
        if (w2[i3] !== mark) {
          w2[i3] = mark;
          cindex.push(i3);
        } else {
          u[i3] = mark;
        }
      }
    }
  }

  // node_modules/mathjs/lib/esm/function/utils/isInteger.js
  var name9 = "isInteger";
  var dependencies10 = ["typed"];
  var createIsInteger = /* @__PURE__ */ factory(name9, dependencies10, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name9, {
      number: isInteger,
      // TODO: what to do with isInteger(add(0.1, 0.2))  ?
      BigNumber: function BigNumber2(x) {
        return x.isInt();
      },
      Fraction: function Fraction3(x) {
        return x.d === 1 && isFinite(x.n);
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/plain/number/arithmetic.js
  var n1 = "number";
  var n2 = "number, number";
  function absNumber(a) {
    return Math.abs(a);
  }
  absNumber.signature = n1;
  function addNumber(a, b) {
    return a + b;
  }
  addNumber.signature = n2;
  function subtractNumber(a, b) {
    return a - b;
  }
  subtractNumber.signature = n2;
  function multiplyNumber(a, b) {
    return a * b;
  }
  multiplyNumber.signature = n2;
  function divideNumber(a, b) {
    return a / b;
  }
  divideNumber.signature = n2;
  function unaryMinusNumber(x) {
    return -x;
  }
  unaryMinusNumber.signature = n1;
  function unaryPlusNumber(x) {
    return x;
  }
  unaryPlusNumber.signature = n1;
  function cbrtNumber(x) {
    return cbrt(x);
  }
  cbrtNumber.signature = n1;
  function cubeNumber(x) {
    return x * x * x;
  }
  cubeNumber.signature = n1;
  function expNumber(x) {
    return Math.exp(x);
  }
  expNumber.signature = n1;
  function expm1Number(x) {
    return expm1(x);
  }
  expm1Number.signature = n1;
  function gcdNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = a % b;
      a = b;
      b = r;
    }
    return a < 0 ? -a : a;
  }
  gcdNumber.signature = n2;
  function lcmNumber(a, b) {
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a === 0 || b === 0) {
      return 0;
    }
    var t;
    var prod2 = a * b;
    while (b !== 0) {
      t = b;
      b = a % t;
      a = t;
    }
    return Math.abs(prod2 / a);
  }
  lcmNumber.signature = n2;
  function logNumber(x, y2) {
    if (y2) {
      return Math.log(x) / Math.log(y2);
    }
    return Math.log(x);
  }
  function log10Number(x) {
    return log10(x);
  }
  log10Number.signature = n1;
  function log2Number(x) {
    return log2(x);
  }
  log2Number.signature = n1;
  function log1pNumber(x) {
    return log1p(x);
  }
  log1pNumber.signature = n1;
  function modNumber(x, y2) {
    return y2 === 0 ? x : x - y2 * Math.floor(x / y2);
  }
  modNumber.signature = n2;
  function nthRootNumber(a) {
    var root = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
    var inv2 = root < 0;
    if (inv2) {
      root = -root;
    }
    if (root === 0) {
      throw new Error("Root must be non-zero");
    }
    if (a < 0 && Math.abs(root) % 2 !== 1) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a === 0) {
      return inv2 ? Infinity : 0;
    }
    if (!isFinite(a)) {
      return inv2 ? 0 : a;
    }
    var x = Math.pow(Math.abs(a), 1 / root);
    x = a < 0 ? -x : x;
    return inv2 ? 1 / x : x;
  }
  function signNumber(x) {
    return sign(x);
  }
  signNumber.signature = n1;
  function sqrtNumber(x) {
    return Math.sqrt(x);
  }
  sqrtNumber.signature = n1;
  function squareNumber(x) {
    return x * x;
  }
  squareNumber.signature = n1;
  function xgcdNumber(a, b) {
    var t;
    var q;
    var r;
    var x = 0;
    var lastx = 1;
    var y2 = 1;
    var lasty = 0;
    if (!isInteger(a) || !isInteger(b)) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (b) {
      q = Math.floor(a / b);
      r = a - q * b;
      t = x;
      x = lastx - q * x;
      lastx = t;
      t = y2;
      y2 = lasty - q * y2;
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a < 0) {
      res = [-a, -lastx, -lasty];
    } else {
      res = [a, a ? lastx : 0, lasty];
    }
    return res;
  }
  xgcdNumber.signature = n2;
  function powNumber(x, y2) {
    if (x * x < 1 && y2 === Infinity || x * x > 1 && y2 === -Infinity) {
      return 0;
    }
    return Math.pow(x, y2);
  }
  powNumber.signature = n2;
  function roundNumber(value) {
    var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    if (!isInteger(decimals) || decimals < 0 || decimals > 15) {
      throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
    }
    return parseFloat(toFixed(value, decimals));
  }
  function normNumber(x) {
    return Math.abs(x);
  }
  normNumber.signature = n1;

  // node_modules/mathjs/lib/esm/plain/number/bitwise.js
  var n12 = "number";
  var n22 = "number, number";
  function bitAndNumber(x, y2) {
    if (!isInteger(x) || !isInteger(y2)) {
      throw new Error("Integers expected in function bitAnd");
    }
    return x & y2;
  }
  bitAndNumber.signature = n22;
  function bitNotNumber(x) {
    if (!isInteger(x)) {
      throw new Error("Integer expected in function bitNot");
    }
    return ~x;
  }
  bitNotNumber.signature = n12;
  function bitOrNumber(x, y2) {
    if (!isInteger(x) || !isInteger(y2)) {
      throw new Error("Integers expected in function bitOr");
    }
    return x | y2;
  }
  bitOrNumber.signature = n22;
  function bitXorNumber(x, y2) {
    if (!isInteger(x) || !isInteger(y2)) {
      throw new Error("Integers expected in function bitXor");
    }
    return x ^ y2;
  }
  bitXorNumber.signature = n22;
  function leftShiftNumber(x, y2) {
    if (!isInteger(x) || !isInteger(y2)) {
      throw new Error("Integers expected in function leftShift");
    }
    return x << y2;
  }
  leftShiftNumber.signature = n22;
  function rightArithShiftNumber(x, y2) {
    if (!isInteger(x) || !isInteger(y2)) {
      throw new Error("Integers expected in function rightArithShift");
    }
    return x >> y2;
  }
  rightArithShiftNumber.signature = n22;
  function rightLogShiftNumber(x, y2) {
    if (!isInteger(x) || !isInteger(y2)) {
      throw new Error("Integers expected in function rightLogShift");
    }
    return x >>> y2;
  }
  rightLogShiftNumber.signature = n22;

  // node_modules/mathjs/lib/esm/utils/product.js
  function product2(i3, n) {
    if (n < i3) {
      return 1;
    }
    if (n === i3) {
      return n;
    }
    var half = n + i3 >> 1;
    return product2(i3, half) * product2(half + 1, n);
  }

  // node_modules/mathjs/lib/esm/plain/number/combinations.js
  function combinationsNumber(n, k) {
    if (!isInteger(n) || n < 0) {
      throw new TypeError("Positive integer value expected in function combinations");
    }
    if (!isInteger(k) || k < 0) {
      throw new TypeError("Positive integer value expected in function combinations");
    }
    if (k > n) {
      throw new TypeError("k must be less than or equal to n");
    }
    var nMinusk = n - k;
    var answer = 1;
    var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
    var nextdivisor = 2;
    var lastdivisor = k < nMinusk ? k : nMinusk;
    for (var nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
      answer *= nextnumerator;
      while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
        answer /= nextdivisor;
        ++nextdivisor;
      }
    }
    if (nextdivisor <= lastdivisor) {
      answer /= product2(nextdivisor, lastdivisor);
    }
    return answer;
  }
  combinationsNumber.signature = "number, number";

  // node_modules/mathjs/lib/esm/plain/number/constants.js
  var pi = Math.PI;
  var tau = 2 * Math.PI;
  var e = Math.E;
  var phi = 1.618033988749895;

  // node_modules/mathjs/lib/esm/plain/number/logical.js
  var n13 = "number";
  var n23 = "number, number";
  function notNumber(x) {
    return !x;
  }
  notNumber.signature = n13;
  function orNumber(x, y2) {
    return !!(x || y2);
  }
  orNumber.signature = n23;
  function xorNumber(x, y2) {
    return !!x !== !!y2;
  }
  xorNumber.signature = n23;
  function andNumber(x, y2) {
    return !!(x && y2);
  }
  andNumber.signature = n23;

  // node_modules/mathjs/lib/esm/plain/number/probability.js
  function gammaNumber(n) {
    var x;
    if (isInteger(n)) {
      if (n <= 0) {
        return isFinite(n) ? Infinity : NaN;
      }
      if (n > 171) {
        return Infinity;
      }
      return product2(1, n - 1);
    }
    if (n < 0.5) {
      return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
    }
    if (n >= 171.35) {
      return Infinity;
    }
    if (n > 85) {
      var twoN = n * n;
      var threeN = twoN * n;
      var fourN = threeN * n;
      var fiveN = fourN * n;
      return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
    }
    --n;
    x = gammaP[0];
    for (var i3 = 1; i3 < gammaP.length; ++i3) {
      x += gammaP[i3] / (n + i3);
    }
    var t = n + gammaG + 0.5;
    return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
  }
  gammaNumber.signature = "number";
  var gammaG = 4.7421875;
  var gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
  var lnSqrt2PI = 0.9189385332046728;
  var lgammaG = 5;
  var lgammaN = 7;
  var lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
  function lgammaNumber(n) {
    if (n < 0)
      return NaN;
    if (n === 0)
      return Infinity;
    if (!isFinite(n))
      return n;
    if (n < 0.5) {
      return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
    }
    n = n - 1;
    var base = n + lgammaG + 0.5;
    var sum3 = lgammaSeries[0];
    for (var i3 = lgammaN - 1; i3 >= 1; i3--) {
      sum3 += lgammaSeries[i3] / (n + i3);
    }
    return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum3);
  }
  lgammaNumber.signature = "number";

  // node_modules/mathjs/lib/esm/plain/number/trigonometry.js
  var n14 = "number";
  var n24 = "number, number";
  function acosNumber(x) {
    return Math.acos(x);
  }
  acosNumber.signature = n14;
  function acoshNumber(x) {
    return acosh(x);
  }
  acoshNumber.signature = n14;
  function acotNumber(x) {
    return Math.atan(1 / x);
  }
  acotNumber.signature = n14;
  function acothNumber(x) {
    return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
  }
  acothNumber.signature = n14;
  function acscNumber(x) {
    return Math.asin(1 / x);
  }
  acscNumber.signature = n14;
  function acschNumber(x) {
    var xInv = 1 / x;
    return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
  }
  acschNumber.signature = n14;
  function asecNumber(x) {
    return Math.acos(1 / x);
  }
  asecNumber.signature = n14;
  function asechNumber(x) {
    var xInv = 1 / x;
    var ret = Math.sqrt(xInv * xInv - 1);
    return Math.log(ret + xInv);
  }
  asechNumber.signature = n14;
  function asinNumber(x) {
    return Math.asin(x);
  }
  asinNumber.signature = n14;
  function asinhNumber(x) {
    return asinh(x);
  }
  asinhNumber.signature = n14;
  function atanNumber(x) {
    return Math.atan(x);
  }
  atanNumber.signature = n14;
  function atan2Number(y2, x) {
    return Math.atan2(y2, x);
  }
  atan2Number.signature = n24;
  function atanhNumber(x) {
    return atanh(x);
  }
  atanhNumber.signature = n14;
  function cosNumber(x) {
    return Math.cos(x);
  }
  cosNumber.signature = n14;
  function coshNumber(x) {
    return cosh(x);
  }
  coshNumber.signature = n14;
  function cotNumber(x) {
    return 1 / Math.tan(x);
  }
  cotNumber.signature = n14;
  function cothNumber(x) {
    var e3 = Math.exp(2 * x);
    return (e3 + 1) / (e3 - 1);
  }
  cothNumber.signature = n14;
  function cscNumber(x) {
    return 1 / Math.sin(x);
  }
  cscNumber.signature = n14;
  function cschNumber(x) {
    if (x === 0) {
      return Number.POSITIVE_INFINITY;
    } else {
      return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign(x);
    }
  }
  cschNumber.signature = n14;
  function secNumber(x) {
    return 1 / Math.cos(x);
  }
  secNumber.signature = n14;
  function sechNumber(x) {
    return 2 / (Math.exp(x) + Math.exp(-x));
  }
  sechNumber.signature = n14;
  function sinNumber(x) {
    return Math.sin(x);
  }
  sinNumber.signature = n14;
  function sinhNumber(x) {
    return sinh(x);
  }
  sinhNumber.signature = n14;
  function tanNumber(x) {
    return Math.tan(x);
  }
  tanNumber.signature = n14;
  function tanhNumber(x) {
    return tanh(x);
  }
  tanhNumber.signature = n14;

  // node_modules/mathjs/lib/esm/plain/number/utils.js
  var n15 = "number";
  function isIntegerNumber(x) {
    return isInteger(x);
  }
  isIntegerNumber.signature = n15;
  function isNegativeNumber(x) {
    return x < 0;
  }
  isNegativeNumber.signature = n15;
  function isPositiveNumber(x) {
    return x > 0;
  }
  isPositiveNumber.signature = n15;
  function isZeroNumber(x) {
    return x === 0;
  }
  isZeroNumber.signature = n15;
  function isNaNNumber(x) {
    return Number.isNaN(x);
  }
  isNaNNumber.signature = n15;

  // node_modules/mathjs/lib/esm/function/utils/isNegative.js
  var name10 = "isNegative";
  var dependencies11 = ["typed"];
  var createIsNegative = /* @__PURE__ */ factory(name10, dependencies11, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name10, {
      number: isNegativeNumber,
      BigNumber: function BigNumber2(x) {
        return x.isNeg() && !x.isZero() && !x.isNaN();
      },
      Fraction: function Fraction3(x) {
        return x.s < 0;
      },
      Unit: typed3.referToSelf((self2) => (x) => typed3.find(self2, x.valueType())(x.value)),
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isNumeric.js
  var name11 = "isNumeric";
  var dependencies12 = ["typed"];
  var createIsNumeric = /* @__PURE__ */ factory(name11, dependencies12, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name11, {
      "number | BigNumber | Fraction | boolean": () => true,
      "Complex | Unit | string | null | undefined | Node": () => false,
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/hasNumericValue.js
  var name12 = "hasNumericValue";
  var dependencies13 = ["typed", "isNumeric"];
  var createHasNumericValue = /* @__PURE__ */ factory(name12, dependencies13, (_ref) => {
    var {
      typed: typed3,
      isNumeric: isNumeric2
    } = _ref;
    return typed3(name12, {
      boolean: () => true,
      string: function string2(x) {
        return x.trim().length > 0 && !isNaN(Number(x));
      },
      any: function any(x) {
        return isNumeric2(x);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isPositive.js
  var name13 = "isPositive";
  var dependencies14 = ["typed"];
  var createIsPositive = /* @__PURE__ */ factory(name13, dependencies14, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name13, {
      number: isPositiveNumber,
      BigNumber: function BigNumber2(x) {
        return !x.isNeg() && !x.isZero() && !x.isNaN();
      },
      Fraction: function Fraction3(x) {
        return x.s > 0 && x.n > 0;
      },
      Unit: typed3.referToSelf((self2) => (x) => typed3.find(self2, x.valueType())(x.value)),
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isZero.js
  var name14 = "isZero";
  var dependencies15 = ["typed"];
  var createIsZero = /* @__PURE__ */ factory(name14, dependencies15, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name14, {
      number: isZeroNumber,
      BigNumber: function BigNumber2(x) {
        return x.isZero();
      },
      Complex: function Complex3(x) {
        return x.re === 0 && x.im === 0;
      },
      Fraction: function Fraction3(x) {
        return x.d === 1 && x.n === 0;
      },
      Unit: typed3.referToSelf((self2) => (x) => typed3.find(self2, x.valueType())(x.value)),
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/isNaN.js
  var name15 = "isNaN";
  var dependencies16 = ["typed"];
  var createIsNaN = /* @__PURE__ */ factory(name15, dependencies16, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name15, {
      number: isNaNNumber,
      BigNumber: function BigNumber2(x) {
        return x.isNaN();
      },
      Fraction: function Fraction3(x) {
        return false;
      },
      Complex: function Complex3(x) {
        return x.isNaN();
      },
      Unit: function Unit2(x) {
        return Number.isNaN(x.value);
      },
      "Array | Matrix": function ArrayMatrix(x) {
        return deepMap(x, Number.isNaN);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/typeOf.js
  var name16 = "typeOf";
  var dependencies17 = ["typed"];
  var createTypeOf = /* @__PURE__ */ factory(name16, dependencies17, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name16, {
      any: typeOf
    });
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/nearlyEqual.js
  function nearlyEqual2(x, y2, epsilon) {
    if (epsilon === null || epsilon === void 0) {
      return x.eq(y2);
    }
    if (x.eq(y2)) {
      return true;
    }
    if (x.isNaN() || y2.isNaN()) {
      return false;
    }
    if (x.isFinite() && y2.isFinite()) {
      var diff2 = x.minus(y2).abs();
      if (diff2.isZero()) {
        return true;
      } else {
        var max3 = x.constructor.max(x.abs(), y2.abs());
        return diff2.lte(max3.times(epsilon));
      }
    }
    return false;
  }

  // node_modules/mathjs/lib/esm/utils/complex.js
  function complexEquals(x, y2, epsilon) {
    return nearlyEqual(x.re, y2.re, epsilon) && nearlyEqual(x.im, y2.im, epsilon);
  }

  // node_modules/mathjs/lib/esm/function/relational/compareUnits.js
  var createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return {
      "Unit, Unit": typed3.referToSelf((self2) => (x, y2) => {
        if (!x.equalBase(y2)) {
          throw new Error("Cannot compare units with different base");
        }
        return typed3.find(self2, [x.valueType(), y2.valueType()])(x.value, y2.value);
      })
    };
  });

  // node_modules/mathjs/lib/esm/function/relational/equalScalar.js
  var name17 = "equalScalar";
  var dependencies18 = ["typed", "config"];
  var createEqualScalar = /* @__PURE__ */ factory(name17, dependencies18, (_ref) => {
    var {
      typed: typed3,
      config: config4
    } = _ref;
    var compareUnits = createCompareUnits({
      typed: typed3
    });
    return typed3(name17, {
      "boolean, boolean": function booleanBoolean(x, y2) {
        return x === y2;
      },
      "number, number": function numberNumber(x, y2) {
        return nearlyEqual(x, y2, config4.epsilon);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return x.eq(y2) || nearlyEqual2(x, y2, config4.epsilon);
      },
      "Fraction, Fraction": function FractionFraction(x, y2) {
        return x.equals(y2);
      },
      "Complex, Complex": function ComplexComplex(x, y2) {
        return complexEquals(x, y2, config4.epsilon);
      }
    }, compareUnits);
  });
  var createEqualScalarNumber = factory(name17, ["typed", "config"], (_ref2) => {
    var {
      typed: typed3,
      config: config4
    } = _ref2;
    return typed3(name17, {
      "number, number": function numberNumber(x, y2) {
        return nearlyEqual(x, y2, config4.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/SparseMatrix.js
  var name18 = "SparseMatrix";
  var dependencies19 = ["typed", "equalScalar", "Matrix"];
  var createSparseMatrixClass = /* @__PURE__ */ factory(name18, dependencies19, (_ref) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2,
      Matrix: Matrix2
    } = _ref;
    function SparseMatrix2(data, datatype) {
      if (!(this instanceof SparseMatrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data)) {
        _createFromMatrix(this, data, datatype);
      } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
        this._values = data.values;
        this._index = data.index;
        this._ptr = data.ptr;
        this._size = data.size;
        this._datatype = datatype || data.datatype;
      } else if (isArray(data)) {
        _createFromArray(this, data, datatype);
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._values = [];
        this._index = [];
        this._ptr = [0];
        this._size = [0, 0];
        this._datatype = datatype;
      }
    }
    function _createFromMatrix(matrix2, source, datatype) {
      if (source.type === "SparseMatrix") {
        matrix2._values = source._values ? clone(source._values) : void 0;
        matrix2._index = clone(source._index);
        matrix2._ptr = clone(source._ptr);
        matrix2._size = clone(source._size);
        matrix2._datatype = datatype || source._datatype;
      } else {
        _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
      }
    }
    function _createFromArray(matrix2, data, datatype) {
      matrix2._values = [];
      matrix2._index = [];
      matrix2._ptr = [];
      matrix2._datatype = datatype;
      var rows = data.length;
      var columns = 0;
      var eq = equalScalar2;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed3.find(equalScalar2, [datatype, datatype]) || equalScalar2;
        zero = typed3.convert(0, datatype);
      }
      if (rows > 0) {
        var j = 0;
        do {
          matrix2._ptr.push(matrix2._index.length);
          for (var i3 = 0; i3 < rows; i3++) {
            var row2 = data[i3];
            if (isArray(row2)) {
              if (j === 0 && columns < row2.length) {
                columns = row2.length;
              }
              if (j < row2.length) {
                var v = row2[j];
                if (!eq(v, zero)) {
                  matrix2._values.push(v);
                  matrix2._index.push(i3);
                }
              }
            } else {
              if (j === 0 && columns < 1) {
                columns = 1;
              }
              if (!eq(row2, zero)) {
                matrix2._values.push(row2);
                matrix2._index.push(i3);
              }
            }
          }
          j++;
        } while (j < columns);
      }
      matrix2._ptr.push(matrix2._index.length);
      matrix2._size = [rows, columns];
    }
    SparseMatrix2.prototype = new Matrix2();
    SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
      return new SparseMatrix2(data, datatype);
    };
    Object.defineProperty(SparseMatrix2, "name", {
      value: "SparseMatrix"
    });
    SparseMatrix2.prototype.constructor = SparseMatrix2;
    SparseMatrix2.prototype.type = "SparseMatrix";
    SparseMatrix2.prototype.isSparseMatrix = true;
    SparseMatrix2.prototype.getDataType = function() {
      return getArrayDataType(this._values, typeOf);
    };
    SparseMatrix2.prototype.storage = function() {
      return "sparse";
    };
    SparseMatrix2.prototype.datatype = function() {
      return this._datatype;
    };
    SparseMatrix2.prototype.create = function(data, datatype) {
      return new SparseMatrix2(data, datatype);
    };
    SparseMatrix2.prototype.density = function() {
      var rows = this._size[0];
      var columns = this._size[1];
      return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
    };
    SparseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
      if (!this._values) {
        throw new Error("Cannot invoke subset on a Pattern only matrix");
      }
      switch (arguments.length) {
        case 1:
          return _getsubset(this, index2);
        case 2:
        case 3:
          return _setsubset(this, index2, replacement, defaultValue);
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    function _getsubset(matrix2, idx) {
      if (!isIndex(idx)) {
        throw new TypeError("Invalid index");
      }
      var isScalar = idx.isScalar();
      if (isScalar) {
        return matrix2.get(idx.min());
      }
      var size2 = idx.size();
      if (size2.length !== matrix2._size.length) {
        throw new DimensionError(size2.length, matrix2._size.length);
      }
      var i3, ii, k, kk;
      var min3 = idx.min();
      var max3 = idx.max();
      for (i3 = 0, ii = matrix2._size.length; i3 < ii; i3++) {
        validateIndex(min3[i3], matrix2._size[i3]);
        validateIndex(max3[i3], matrix2._size[i3]);
      }
      var mvalues = matrix2._values;
      var mindex = matrix2._index;
      var mptr = matrix2._ptr;
      var rows = idx.dimension(0);
      var columns = idx.dimension(1);
      var w2 = [];
      var pv = [];
      rows.forEach(function(i4, r) {
        pv[i4] = r[0];
        w2[i4] = true;
      });
      var values = mvalues ? [] : void 0;
      var index2 = [];
      var ptr = [];
      columns.forEach(function(j) {
        ptr.push(index2.length);
        for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
          i3 = mindex[k];
          if (w2[i3] === true) {
            index2.push(pv[i3]);
            if (values) {
              values.push(mvalues[k]);
            }
          }
        }
      });
      ptr.push(index2.length);
      return new SparseMatrix2({
        values,
        index: index2,
        ptr,
        size: size2,
        datatype: matrix2._datatype
      });
    }
    function _setsubset(matrix2, index2, submatrix, defaultValue) {
      if (!index2 || index2.isIndex !== true) {
        throw new TypeError("Invalid index");
      }
      var iSize = index2.size();
      var isScalar = index2.isScalar();
      var sSize;
      if (isMatrix(submatrix)) {
        sSize = submatrix.size();
        submatrix = submatrix.toArray();
      } else {
        sSize = arraySize(submatrix);
      }
      if (isScalar) {
        if (sSize.length !== 0) {
          throw new TypeError("Scalar expected");
        }
        matrix2.set(index2.min(), submatrix, defaultValue);
      } else {
        if (iSize.length !== 1 && iSize.length !== 2) {
          throw new DimensionError(iSize.length, matrix2._size.length, "<");
        }
        if (sSize.length < iSize.length) {
          var i3 = 0;
          var outer = 0;
          while (iSize[i3] === 1 && sSize[i3] === 1) {
            i3++;
          }
          while (iSize[i3] === 1) {
            outer++;
            i3++;
          }
          submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
        }
        if (!deepStrictEqual(iSize, sSize)) {
          throw new DimensionError(iSize, sSize, ">");
        }
        if (iSize.length === 1) {
          var range2 = index2.dimension(0);
          range2.forEach(function(dataIndex, subIndex) {
            validateIndex(dataIndex);
            matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
          });
        } else {
          var firstDimensionRange = index2.dimension(0);
          var secondDimensionRange = index2.dimension(1);
          firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
            validateIndex(firstDataIndex);
            secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
              validateIndex(secondDataIndex);
              matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
            });
          });
        }
      }
      return matrix2;
    }
    SparseMatrix2.prototype.get = function(index2) {
      if (!isArray(index2)) {
        throw new TypeError("Array expected");
      }
      if (index2.length !== this._size.length) {
        throw new DimensionError(index2.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke get on a Pattern only matrix");
      }
      var i3 = index2[0];
      var j = index2[1];
      validateIndex(i3, this._size[0]);
      validateIndex(j, this._size[1]);
      var k = _getValueIndex(i3, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i3) {
        return this._values[k];
      }
      return 0;
    };
    SparseMatrix2.prototype.set = function(index2, v, defaultValue) {
      if (!isArray(index2)) {
        throw new TypeError("Array expected");
      }
      if (index2.length !== this._size.length) {
        throw new DimensionError(index2.length, this._size.length);
      }
      if (!this._values) {
        throw new Error("Cannot invoke set on a Pattern only matrix");
      }
      var i3 = index2[0];
      var j = index2[1];
      var rows = this._size[0];
      var columns = this._size[1];
      var eq = equalScalar2;
      var zero = 0;
      if (isString(this._datatype)) {
        eq = typed3.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
        zero = typed3.convert(0, this._datatype);
      }
      if (i3 > rows - 1 || j > columns - 1) {
        _resize2(this, Math.max(i3 + 1, rows), Math.max(j + 1, columns), defaultValue);
        rows = this._size[0];
        columns = this._size[1];
      }
      validateIndex(i3, rows);
      validateIndex(j, columns);
      var k = _getValueIndex(i3, this._ptr[j], this._ptr[j + 1], this._index);
      if (k < this._ptr[j + 1] && this._index[k] === i3) {
        if (!eq(v, zero)) {
          this._values[k] = v;
        } else {
          _remove(k, j, this._values, this._index, this._ptr);
        }
      } else {
        if (!eq(v, zero)) {
          _insert(k, i3, j, v, this._values, this._index, this._ptr);
        }
      }
      return this;
    };
    function _getValueIndex(i3, top, bottom, index2) {
      if (bottom - top === 0) {
        return bottom;
      }
      for (var r = top; r < bottom; r++) {
        if (index2[r] === i3) {
          return r;
        }
      }
      return top;
    }
    function _remove(k, j, values, index2, ptr) {
      values.splice(k, 1);
      index2.splice(k, 1);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]--;
      }
    }
    function _insert(k, i3, j, v, values, index2, ptr) {
      values.splice(k, 0, v);
      index2.splice(k, 0, i3);
      for (var x = j + 1; x < ptr.length; x++) {
        ptr[x]++;
      }
    }
    SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
      if (!isCollection(size2)) {
        throw new TypeError("Array or Matrix expected");
      }
      var sizeArray = size2.valueOf().map((value) => {
        return Array.isArray(value) && value.length === 1 ? value[0] : value;
      });
      if (sizeArray.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      sizeArray.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value < 0) {
          throw new TypeError("Invalid size, must contain positive integers (size: " + format3(sizeArray) + ")");
        }
      });
      var m = copy ? this.clone() : this;
      return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
    };
    function _resize2(matrix2, rows, columns, defaultValue) {
      var value = defaultValue || 0;
      var eq = equalScalar2;
      var zero = 0;
      if (isString(matrix2._datatype)) {
        eq = typed3.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
        zero = typed3.convert(0, matrix2._datatype);
        value = typed3.convert(value, matrix2._datatype);
      }
      var ins = !eq(value, zero);
      var r = matrix2._size[0];
      var c = matrix2._size[1];
      var i3, j, k;
      if (columns > c) {
        for (j = c; j < columns; j++) {
          matrix2._ptr[j] = matrix2._values.length;
          if (ins) {
            for (i3 = 0; i3 < r; i3++) {
              matrix2._values.push(value);
              matrix2._index.push(i3);
            }
          }
        }
        matrix2._ptr[columns] = matrix2._values.length;
      } else if (columns < c) {
        matrix2._ptr.splice(columns + 1, c - columns);
        matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
        matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
      }
      c = columns;
      if (rows > r) {
        if (ins) {
          var n = 0;
          for (j = 0; j < c; j++) {
            matrix2._ptr[j] = matrix2._ptr[j] + n;
            k = matrix2._ptr[j + 1] + n;
            var p = 0;
            for (i3 = r; i3 < rows; i3++, p++) {
              matrix2._values.splice(k + p, 0, value);
              matrix2._index.splice(k + p, 0, i3);
              n++;
            }
          }
          matrix2._ptr[c] = matrix2._values.length;
        }
      } else if (rows < r) {
        var d = 0;
        for (j = 0; j < c; j++) {
          matrix2._ptr[j] = matrix2._ptr[j] - d;
          var k0 = matrix2._ptr[j];
          var k1 = matrix2._ptr[j + 1] - d;
          for (k = k0; k < k1; k++) {
            i3 = matrix2._index[k];
            if (i3 > rows - 1) {
              matrix2._values.splice(k, 1);
              matrix2._index.splice(k, 1);
              d++;
            }
          }
        }
        matrix2._ptr[j] = matrix2._values.length;
      }
      matrix2._size[0] = rows;
      matrix2._size[1] = columns;
      return matrix2;
    }
    SparseMatrix2.prototype.reshape = function(sizes, copy) {
      if (!isArray(sizes)) {
        throw new TypeError("Array expected");
      }
      if (sizes.length !== 2) {
        throw new Error("Sparse matrices can only be reshaped in two dimensions");
      }
      sizes.forEach(function(value) {
        if (!isNumber(value) || !isInteger(value) || value <= -2 || value === 0) {
          throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format3(sizes) + ")");
        }
      });
      var currentLength = this._size[0] * this._size[1];
      sizes = processSizesWildcard(sizes, currentLength);
      var newLength = sizes[0] * sizes[1];
      if (currentLength !== newLength) {
        throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
      }
      var m = copy ? this.clone() : this;
      if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
        return m;
      }
      var colIndex = [];
      for (var i3 = 0; i3 < m._ptr.length; i3++) {
        for (var j = 0; j < m._ptr[i3 + 1] - m._ptr[i3]; j++) {
          colIndex.push(i3);
        }
      }
      var values = m._values.slice();
      var rowIndex = m._index.slice();
      for (var _i = 0; _i < m._index.length; _i++) {
        var r1 = rowIndex[_i];
        var c1 = colIndex[_i];
        var flat = r1 * m._size[1] + c1;
        colIndex[_i] = flat % sizes[1];
        rowIndex[_i] = Math.floor(flat / sizes[1]);
      }
      m._values.length = 0;
      m._index.length = 0;
      m._ptr.length = sizes[1] + 1;
      m._size = sizes.slice();
      for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
        m._ptr[_i2] = 0;
      }
      for (var h = 0; h < values.length; h++) {
        var _i3 = rowIndex[h];
        var _j = colIndex[h];
        var v = values[h];
        var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
        _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
      }
      return m;
    };
    SparseMatrix2.prototype.clone = function() {
      var m = new SparseMatrix2({
        values: this._values ? clone(this._values) : void 0,
        index: clone(this._index),
        ptr: clone(this._ptr),
        size: clone(this._size),
        datatype: this._datatype
      });
      return m;
    };
    SparseMatrix2.prototype.size = function() {
      return this._size.slice(0);
    };
    SparseMatrix2.prototype.map = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke map on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      var args = maxArgumentCount(callback);
      var invoke = function invoke2(v, i3, j) {
        if (args === 1)
          return callback(v);
        if (args === 2)
          return callback(v, [i3, j]);
        return callback(v, [i3, j], me);
      };
      return _map3(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
    };
    function _map3(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
      var values = [];
      var index2 = [];
      var ptr = [];
      var eq = equalScalar2;
      var zero = 0;
      if (isString(matrix2._datatype)) {
        eq = typed3.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
        zero = typed3.convert(0, matrix2._datatype);
      }
      var invoke = function invoke2(v, x, y2) {
        v = callback(v, x, y2);
        if (!eq(v, zero)) {
          values.push(v);
          index2.push(x);
        }
      };
      for (var j = minColumn; j <= maxColumn; j++) {
        ptr.push(values.length);
        var k0 = matrix2._ptr[j];
        var k1 = matrix2._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i3 = matrix2._index[k];
            if (i3 >= minRow && i3 <= maxRow) {
              invoke(matrix2._values[k], i3 - minRow, j - minColumn);
            }
          }
        } else {
          var _values = {};
          for (var _k = k0; _k < k1; _k++) {
            var _i4 = matrix2._index[_k];
            _values[_i4] = matrix2._values[_k];
          }
          for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
            var value = _i5 in _values ? _values[_i5] : 0;
            invoke(value, _i5 - minRow, j - minColumn);
          }
        }
      }
      ptr.push(values.length);
      return new SparseMatrix2({
        values,
        index: index2,
        ptr,
        size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
      });
    }
    SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
      if (!this._values) {
        throw new Error("Cannot invoke forEach on a Pattern only matrix");
      }
      var me = this;
      var rows = this._size[0];
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        if (skipZeros) {
          for (var k = k0; k < k1; k++) {
            var i3 = this._index[k];
            callback(this._values[k], [i3, j], me);
          }
        } else {
          var values = {};
          for (var _k2 = k0; _k2 < k1; _k2++) {
            var _i6 = this._index[_k2];
            values[_i6] = this._values[_k2];
          }
          for (var _i7 = 0; _i7 < rows; _i7++) {
            var value = _i7 in values ? values[_i7] : 0;
            callback(value, [_i7, j], me);
          }
        }
      }
    };
    SparseMatrix2.prototype[Symbol.iterator] = function* () {
      if (!this._values) {
        throw new Error("Cannot iterate a Pattern only matrix");
      }
      var columns = this._size[1];
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          var i3 = this._index[k];
          yield {
            value: this._values[k],
            index: [i3, j]
          };
        }
      }
    };
    SparseMatrix2.prototype.toArray = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, true);
    };
    SparseMatrix2.prototype.valueOf = function() {
      return _toArray(this._values, this._index, this._ptr, this._size, false);
    };
    function _toArray(values, index2, ptr, size2, copy) {
      var rows = size2[0];
      var columns = size2[1];
      var a = [];
      var i3, j;
      for (i3 = 0; i3 < rows; i3++) {
        a[i3] = [];
        for (j = 0; j < columns; j++) {
          a[i3][j] = 0;
        }
      }
      for (j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          i3 = index2[k];
          a[i3][j] = values ? copy ? clone(values[k]) : values[k] : 1;
        }
      }
      return a;
    }
    SparseMatrix2.prototype.format = function(options) {
      var rows = this._size[0];
      var columns = this._size[1];
      var density = this.density();
      var str = "Sparse Matrix [" + format3(rows, options) + " x " + format3(columns, options) + "] density: " + format3(density, options) + "\n";
      for (var j = 0; j < columns; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var k = k0; k < k1; k++) {
          var i3 = this._index[k];
          str += "\n    (" + format3(i3, options) + ", " + format3(j, options) + ") ==> " + (this._values ? format3(this._values[k], options) : "X");
        }
      }
      return str;
    };
    SparseMatrix2.prototype.toString = function() {
      return format3(this.toArray());
    };
    SparseMatrix2.prototype.toJSON = function() {
      return {
        mathjs: "SparseMatrix",
        values: this._values,
        index: this._index,
        ptr: this._ptr,
        size: this._size,
        datatype: this._datatype
      };
    };
    SparseMatrix2.prototype.diagonal = function(k) {
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = this._size[0];
      var columns = this._size[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var values = [];
      var index2 = [];
      var ptr = [];
      ptr[0] = 0;
      for (var j = kSuper; j < columns && values.length < n; j++) {
        var k0 = this._ptr[j];
        var k1 = this._ptr[j + 1];
        for (var x = k0; x < k1; x++) {
          var i3 = this._index[x];
          if (i3 === j - kSuper + kSub) {
            values.push(this._values[x]);
            index2[values.length - 1] = i3 - kSub;
            break;
          }
        }
      }
      ptr.push(values.length);
      return new SparseMatrix2({
        values,
        index: index2,
        ptr,
        size: [n, 1]
      });
    };
    SparseMatrix2.fromJSON = function(json) {
      return new SparseMatrix2(json);
    };
    SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
      if (!isArray(size2)) {
        throw new TypeError("Array expected, size parameter");
      }
      if (size2.length !== 2) {
        throw new Error("Only two dimensions matrix are supported");
      }
      size2 = size2.map(function(s) {
        if (isBigNumber(s)) {
          s = s.toNumber();
        }
        if (!isNumber(s) || !isInteger(s) || s < 1) {
          throw new Error("Size values must be positive integers");
        }
        return s;
      });
      if (k) {
        if (isBigNumber(k)) {
          k = k.toNumber();
        }
        if (!isNumber(k) || !isInteger(k)) {
          throw new TypeError("The parameter k must be an integer number");
        }
      } else {
        k = 0;
      }
      var eq = equalScalar2;
      var zero = 0;
      if (isString(datatype)) {
        eq = typed3.find(equalScalar2, [datatype, datatype]) || equalScalar2;
        zero = typed3.convert(0, datatype);
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      var rows = size2[0];
      var columns = size2[1];
      var n = Math.min(rows - kSub, columns - kSuper);
      var _value;
      if (isArray(value)) {
        if (value.length !== n) {
          throw new Error("Invalid value array length");
        }
        _value = function _value2(i4) {
          return value[i4];
        };
      } else if (isMatrix(value)) {
        var ms = value.size();
        if (ms.length !== 1 || ms[0] !== n) {
          throw new Error("Invalid matrix length");
        }
        _value = function _value2(i4) {
          return value.get([i4]);
        };
      } else {
        _value = function _value2() {
          return value;
        };
      }
      var values = [];
      var index2 = [];
      var ptr = [];
      for (var j = 0; j < columns; j++) {
        ptr.push(values.length);
        var i3 = j - kSuper;
        if (i3 >= 0 && i3 < n) {
          var v = _value(i3);
          if (!eq(v, zero)) {
            index2.push(i3 + kSub);
            values.push(v);
          }
        }
      }
      ptr.push(values.length);
      return new SparseMatrix2({
        values,
        index: index2,
        ptr,
        size: [rows, columns]
      });
    };
    SparseMatrix2.prototype.swapRows = function(i3, j) {
      if (!isNumber(i3) || !isInteger(i3) || !isNumber(j) || !isInteger(j)) {
        throw new Error("Row index must be positive integers");
      }
      if (this._size.length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(i3, this._size[0]);
      validateIndex(j, this._size[0]);
      SparseMatrix2._swapRows(i3, j, this._size[1], this._values, this._index, this._ptr);
      return this;
    };
    SparseMatrix2._forEachRow = function(j, values, index2, ptr, callback) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        callback(index2[k], values[k]);
      }
    };
    SparseMatrix2._swapRows = function(x, y2, columns, values, index2, ptr) {
      for (var j = 0; j < columns; j++) {
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        var kx = _getValueIndex(x, k0, k1, index2);
        var ky = _getValueIndex(y2, k0, k1, index2);
        if (kx < k1 && ky < k1 && index2[kx] === x && index2[ky] === y2) {
          if (values) {
            var v = values[kx];
            values[kx] = values[ky];
            values[ky] = v;
          }
          continue;
        }
        if (kx < k1 && index2[kx] === x && (ky >= k1 || index2[ky] !== y2)) {
          var vx = values ? values[kx] : void 0;
          index2.splice(ky, 0, y2);
          if (values) {
            values.splice(ky, 0, vx);
          }
          index2.splice(ky <= kx ? kx + 1 : kx, 1);
          if (values) {
            values.splice(ky <= kx ? kx + 1 : kx, 1);
          }
          continue;
        }
        if (ky < k1 && index2[ky] === y2 && (kx >= k1 || index2[kx] !== x)) {
          var vy = values ? values[ky] : void 0;
          index2.splice(kx, 0, x);
          if (values) {
            values.splice(kx, 0, vy);
          }
          index2.splice(kx <= ky ? ky + 1 : ky, 1);
          if (values) {
            values.splice(kx <= ky ? ky + 1 : ky, 1);
          }
        }
      }
    };
    return SparseMatrix2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/number.js
  var name19 = "number";
  var dependencies20 = ["typed"];
  function getNonDecimalNumberParts(input2) {
    var nonDecimalWithRadixMatch = input2.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
    if (nonDecimalWithRadixMatch) {
      var radix = {
        "0b": 2,
        "0o": 8,
        "0x": 16
      }[nonDecimalWithRadixMatch[1]];
      var integerPart = nonDecimalWithRadixMatch[2];
      var fractionalPart = nonDecimalWithRadixMatch[3];
      return {
        input: input2,
        radix,
        integerPart,
        fractionalPart
      };
    } else {
      return null;
    }
  }
  function makeNumberFromNonDecimalParts(parts) {
    var n = parseInt(parts.integerPart, parts.radix);
    var f = 0;
    for (var i3 = 0; i3 < parts.fractionalPart.length; i3++) {
      var digitValue = parseInt(parts.fractionalPart[i3], parts.radix);
      f += digitValue / Math.pow(parts.radix, i3 + 1);
    }
    var result = n + f;
    if (isNaN(result)) {
      throw new SyntaxError('String "' + parts.input + '" is not a valid number');
    }
    return result;
  }
  var createNumber = /* @__PURE__ */ factory(name19, dependencies20, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    var number2 = typed3("number", {
      "": function _() {
        return 0;
      },
      number: function number3(x) {
        return x;
      },
      string: function string2(x) {
        if (x === "NaN")
          return NaN;
        var nonDecimalNumberParts = getNonDecimalNumberParts(x);
        if (nonDecimalNumberParts) {
          return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
        }
        var size2 = 0;
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          size2 = Number(wordSizeSuffixMatch[2]);
          x = wordSizeSuffixMatch[1];
        }
        var num = Number(x);
        if (isNaN(num)) {
          throw new SyntaxError('String "' + x + '" is not a valid number');
        }
        if (wordSizeSuffixMatch) {
          if (num > 2 ** size2 - 1) {
            throw new SyntaxError('String "'.concat(x, '" is out of range'));
          }
          if (num >= 2 ** (size2 - 1)) {
            num = num - 2 ** size2;
          }
        }
        return num;
      },
      BigNumber: function BigNumber2(x) {
        return x.toNumber();
      },
      Fraction: function Fraction3(x) {
        return x.valueOf();
      },
      Unit: typed3.referToSelf((self2) => (x) => {
        var clone5 = x.clone();
        clone5.value = self2(x.value);
        return clone5;
      }),
      null: function _null2(x) {
        return 0;
      },
      "Unit, string | Unit": function UnitStringUnit(unit2, valuelessUnit) {
        return unit2.toNumber(valuelessUnit);
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
    number2.fromJSON = function(json) {
      return parseFloat(json.value);
    };
    return number2;
  });

  // node_modules/mathjs/lib/esm/type/string.js
  var name20 = "string";
  var dependencies21 = ["typed"];
  var createString = /* @__PURE__ */ factory(name20, dependencies21, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name20, {
      "": function _() {
        return "";
      },
      number: format,
      null: function _null2(x) {
        return "null";
      },
      boolean: function boolean2(x) {
        return x + "";
      },
      string: function string2(x) {
        return x;
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2)),
      any: function any(x) {
        return String(x);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/boolean.js
  var name21 = "boolean";
  var dependencies22 = ["typed"];
  var createBoolean = /* @__PURE__ */ factory(name21, dependencies22, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name21, {
      "": function _() {
        return false;
      },
      boolean: function boolean2(x) {
        return x;
      },
      number: function number2(x) {
        return !!x;
      },
      null: function _null2(x) {
        return false;
      },
      BigNumber: function BigNumber2(x) {
        return !x.isZero();
      },
      string: function string2(x) {
        var lcase = x.toLowerCase();
        if (lcase === "true") {
          return true;
        } else if (lcase === "false") {
          return false;
        }
        var num = Number(x);
        if (x !== "" && !isNaN(num)) {
          return !!num;
        }
        throw new Error('Cannot convert "' + x + '" to a boolean');
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/bignumber/function/bignumber.js
  var name22 = "bignumber";
  var dependencies23 = ["typed", "BigNumber"];
  var createBignumber = /* @__PURE__ */ factory(name22, dependencies23, (_ref) => {
    var {
      typed: typed3,
      BigNumber: BigNumber2
    } = _ref;
    return typed3("bignumber", {
      "": function _() {
        return new BigNumber2(0);
      },
      number: function number2(x) {
        return new BigNumber2(x + "");
      },
      string: function string2(x) {
        var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
        if (wordSizeSuffixMatch) {
          var size2 = wordSizeSuffixMatch[2];
          var n = BigNumber2(wordSizeSuffixMatch[1]);
          var twoPowSize = new BigNumber2(2).pow(Number(size2));
          if (n.gt(twoPowSize.sub(1))) {
            throw new SyntaxError('String "'.concat(x, '" is out of range'));
          }
          var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
          if (n.gte(twoPowSizeSubOne)) {
            return n.sub(twoPowSize);
          } else {
            return n;
          }
        }
        return new BigNumber2(x);
      },
      BigNumber: function BigNumber3(x) {
        return x;
      },
      Unit: typed3.referToSelf((self2) => (x) => {
        var clone5 = x.clone();
        clone5.value = self2(x.value);
        return clone5;
      }),
      Fraction: function Fraction3(x) {
        return new BigNumber2(x.n).div(x.d).times(x.s);
      },
      null: function _null2(x) {
        return new BigNumber2(0);
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/complex/function/complex.js
  var name23 = "complex";
  var dependencies24 = ["typed", "Complex"];
  var createComplex = /* @__PURE__ */ factory(name23, dependencies24, (_ref) => {
    var {
      typed: typed3,
      Complex: Complex3
    } = _ref;
    return typed3("complex", {
      "": function _() {
        return Complex3.ZERO;
      },
      number: function number2(x) {
        return new Complex3(x, 0);
      },
      "number, number": function numberNumber(re2, im2) {
        return new Complex3(re2, im2);
      },
      // TODO: this signature should be redundant
      "BigNumber, BigNumber": function BigNumberBigNumber(re2, im2) {
        return new Complex3(re2.toNumber(), im2.toNumber());
      },
      Fraction: function Fraction3(x) {
        return new Complex3(x.valueOf(), 0);
      },
      Complex: function Complex4(x) {
        return x.clone();
      },
      string: function string2(x) {
        return Complex3(x);
      },
      null: function _null2(x) {
        return Complex3(0);
      },
      Object: function Object2(x) {
        if ("re" in x && "im" in x) {
          return new Complex3(x.re, x.im);
        }
        if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
          return new Complex3(x);
        }
        throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/fraction/function/fraction.js
  var name24 = "fraction";
  var dependencies25 = ["typed", "Fraction"];
  var createFraction = /* @__PURE__ */ factory(name24, dependencies25, (_ref) => {
    var {
      typed: typed3,
      Fraction: Fraction3
    } = _ref;
    return typed3("fraction", {
      number: function number2(x) {
        if (!isFinite(x) || isNaN(x)) {
          throw new Error(x + " cannot be represented as a fraction");
        }
        return new Fraction3(x);
      },
      string: function string2(x) {
        return new Fraction3(x);
      },
      "number, number": function numberNumber(numerator, denominator) {
        return new Fraction3(numerator, denominator);
      },
      null: function _null2(x) {
        return new Fraction3(0);
      },
      BigNumber: function BigNumber2(x) {
        return new Fraction3(x.toString());
      },
      Fraction: function Fraction4(x) {
        return x;
      },
      Unit: typed3.referToSelf((self2) => (x) => {
        var clone5 = x.clone();
        clone5.value = self2(x.value);
        return clone5;
      }),
      Object: function Object2(x) {
        return new Fraction3(x);
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/matrix.js
  var name25 = "matrix";
  var dependencies26 = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
  var createMatrix = /* @__PURE__ */ factory(name25, dependencies26, (_ref) => {
    var {
      typed: typed3,
      Matrix: Matrix2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    return typed3(name25, {
      "": function _() {
        return _create([]);
      },
      string: function string2(format5) {
        return _create([], format5);
      },
      "string, string": function stringString(format5, datatype) {
        return _create([], format5, datatype);
      },
      Array: function Array2(data) {
        return _create(data);
      },
      Matrix: function Matrix3(data) {
        return _create(data, data.storage());
      },
      "Array | Matrix, string": _create,
      "Array | Matrix, string, string": _create
    });
    function _create(data, format5, datatype) {
      if (format5 === "dense" || format5 === "default" || format5 === void 0) {
        return new DenseMatrix2(data, datatype);
      }
      if (format5 === "sparse") {
        return new SparseMatrix2(data, datatype);
      }
      throw new TypeError("Unknown matrix type " + JSON.stringify(format5) + ".");
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/matrixFromFunction.js
  var name26 = "matrixFromFunction";
  var dependencies27 = ["typed", "matrix", "isZero"];
  var createMatrixFromFunction = /* @__PURE__ */ factory(name26, dependencies27, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      isZero: isZero2
    } = _ref;
    return typed3(name26, {
      "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size2, fn, format5, datatype) {
        return _create(size2, fn, format5, datatype);
      },
      "Array | Matrix, function, string": function ArrayMatrixFunctionString(size2, fn, format5) {
        return _create(size2, fn, format5);
      },
      "Matrix, function": function MatrixFunction(size2, fn) {
        return _create(size2, fn, "dense");
      },
      "Array, function": function ArrayFunction(size2, fn) {
        return _create(size2, fn, "dense").toArray();
      },
      "Array | Matrix, string, function": function ArrayMatrixStringFunction(size2, format5, fn) {
        return _create(size2, fn, format5);
      },
      "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size2, format5, datatype, fn) {
        return _create(size2, fn, format5, datatype);
      }
    });
    function _create(size2, fn, format5, datatype) {
      var m;
      if (datatype !== void 0) {
        m = matrix2(format5, datatype);
      } else {
        m = matrix2(format5);
      }
      m.resize(size2);
      m.forEach(function(_, index2) {
        var val = fn(index2);
        if (isZero2(val))
          return;
        m.set(index2, val);
      });
      return m;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/matrixFromRows.js
  var name27 = "matrixFromRows";
  var dependencies28 = ["typed", "matrix", "flatten", "size"];
  var createMatrixFromRows = /* @__PURE__ */ factory(name27, dependencies28, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      flatten: flatten3,
      size: size2
    } = _ref;
    return typed3(name27, {
      "...Array": function Array2(arr) {
        return _createArray(arr);
      },
      "...Matrix": function Matrix2(arr) {
        return matrix2(_createArray(arr.map((m) => m.toArray())));
      }
      // TODO implement this properly for SparseMatrix
    });
    function _createArray(arr) {
      if (arr.length === 0)
        throw new TypeError("At least one row is needed to construct a matrix.");
      var N = checkVectorTypeAndReturnLength(arr[0]);
      var result = [];
      for (var row2 of arr) {
        var rowLength = checkVectorTypeAndReturnLength(row2);
        if (rowLength !== N) {
          throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (rowLength | 0));
        }
        result.push(flatten3(row2));
      }
      return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
      var s = size2(vec);
      if (s.length === 1) {
        return s[0];
      } else if (s.length === 2) {
        if (s[0] === 1) {
          return s[1];
        } else if (s[1] === 1) {
          return s[0];
        } else {
          throw new TypeError("At least one of the arguments is not a vector.");
        }
      } else {
        throw new TypeError("Only one- or two-dimensional vectors are supported.");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/matrixFromColumns.js
  var name28 = "matrixFromColumns";
  var dependencies29 = ["typed", "matrix", "flatten", "size"];
  var createMatrixFromColumns = /* @__PURE__ */ factory(name28, dependencies29, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      flatten: flatten3,
      size: size2
    } = _ref;
    return typed3(name28, {
      "...Array": function Array2(arr) {
        return _createArray(arr);
      },
      "...Matrix": function Matrix2(arr) {
        return matrix2(_createArray(arr.map((m) => m.toArray())));
      }
      // TODO implement this properly for SparseMatrix
    });
    function _createArray(arr) {
      if (arr.length === 0)
        throw new TypeError("At least one column is needed to construct a matrix.");
      var N = checkVectorTypeAndReturnLength(arr[0]);
      var result = [];
      for (var i3 = 0; i3 < N; i3++) {
        result[i3] = [];
      }
      for (var col of arr) {
        var colLength = checkVectorTypeAndReturnLength(col);
        if (colLength !== N) {
          throw new TypeError("The vectors had different length: " + (N | 0) + " \u2260 " + (colLength | 0));
        }
        var f = flatten3(col);
        for (var _i = 0; _i < N; _i++) {
          result[_i].push(f[_i]);
        }
      }
      return result;
    }
    function checkVectorTypeAndReturnLength(vec) {
      var s = size2(vec);
      if (s.length === 1) {
        return s[0];
      } else if (s.length === 2) {
        if (s[0] === 1) {
          return s[1];
        } else if (s[1] === 1) {
          return s[0];
        } else {
          throw new TypeError("At least one of the arguments is not a vector.");
        }
      } else {
        throw new TypeError("Only one- or two-dimensional vectors are supported.");
      }
    }
  });

  // node_modules/mathjs/lib/esm/type/unit/function/splitUnit.js
  var name29 = "splitUnit";
  var dependencies30 = ["typed"];
  var createSplitUnit = /* @__PURE__ */ factory(name29, dependencies30, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name29, {
      "Unit, Array": function UnitArray(unit2, parts) {
        return unit2.splitUnit(parts);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/unaryMinus.js
  var name30 = "unaryMinus";
  var dependencies31 = ["typed"];
  var createUnaryMinus = /* @__PURE__ */ factory(name30, dependencies31, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name30, {
      number: unaryMinusNumber,
      "Complex | BigNumber | Fraction": (x) => x.neg(),
      Unit: typed3.referToSelf((self2) => (x) => {
        var res = x.clone();
        res.value = typed3.find(self2, res.valueType())(x.value);
        return res;
      }),
      // deep map collection, skip zeros since unaryMinus(0) = 0
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2, true))
      // TODO: add support for string
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/unaryPlus.js
  var name31 = "unaryPlus";
  var dependencies32 = ["typed", "config", "BigNumber"];
  var createUnaryPlus = /* @__PURE__ */ factory(name31, dependencies32, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      BigNumber: BigNumber2
    } = _ref;
    return typed3(name31, {
      number: unaryPlusNumber,
      Complex: function Complex3(x) {
        return x;
      },
      BigNumber: function BigNumber3(x) {
        return x;
      },
      Fraction: function Fraction3(x) {
        return x;
      },
      Unit: function Unit2(x) {
        return x.clone();
      },
      // deep map collection, skip zeros since unaryPlus(0) = 0
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2, true)),
      "boolean | string": function booleanString(x) {
        return config4.number === "BigNumber" ? new BigNumber2(+x) : +x;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/abs.js
  var name32 = "abs";
  var dependencies33 = ["typed"];
  var createAbs = /* @__PURE__ */ factory(name32, dependencies33, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name32, {
      number: absNumber,
      "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
      // deep map collection, skip zeros since abs(0) = 0
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2, true))
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/apply.js
  var name33 = "apply";
  var dependencies34 = ["typed", "isInteger"];
  var createApply = /* @__PURE__ */ factory(name33, dependencies34, (_ref) => {
    var {
      typed: typed3,
      isInteger: isInteger3
    } = _ref;
    return typed3(name33, {
      "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
        if (!isInteger3(dim)) {
          throw new TypeError("Integer number expected for dimension");
        }
        var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
        if (dim < 0 || dim >= size2.length) {
          throw new IndexError(dim, size2.length);
        }
        if (isMatrix(mat)) {
          return mat.create(_apply(mat.valueOf(), dim, callback));
        } else {
          return _apply(mat, dim, callback);
        }
      }
    });
  });
  function _apply(mat, dim, callback) {
    var i3, ret, tran;
    if (dim <= 0) {
      if (!Array.isArray(mat[0])) {
        return callback(mat);
      } else {
        tran = _switch2(mat);
        ret = [];
        for (i3 = 0; i3 < tran.length; i3++) {
          ret[i3] = _apply(tran[i3], dim - 1, callback);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i3 = 0; i3 < mat.length; i3++) {
        ret[i3] = _apply(mat[i3], dim - 1, callback);
      }
      return ret;
    }
  }
  function _switch2(mat) {
    var I2 = mat.length;
    var J = mat[0].length;
    var i3, j;
    var ret = [];
    for (j = 0; j < J; j++) {
      var tmp = [];
      for (i3 = 0; i3 < I2; i3++) {
        tmp.push(mat[i3][j]);
      }
      ret.push(tmp);
    }
    return ret;
  }

  // node_modules/mathjs/lib/esm/function/arithmetic/addScalar.js
  var name34 = "addScalar";
  var dependencies35 = ["typed"];
  var createAddScalar = /* @__PURE__ */ factory(name34, dependencies35, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name34, {
      "number, number": addNumber,
      "Complex, Complex": function ComplexComplex(x, y2) {
        return x.add(y2);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return x.plus(y2);
      },
      "Fraction, Fraction": function FractionFraction(x, y2) {
        return x.add(y2);
      },
      "Unit, Unit": typed3.referToSelf((self2) => (x, y2) => {
        if (x.value === null || x.value === void 0) {
          throw new Error("Parameter x contains a unit with undefined value");
        }
        if (y2.value === null || y2.value === void 0) {
          throw new Error("Parameter y contains a unit with undefined value");
        }
        if (!x.equalBase(y2))
          throw new Error("Units do not match");
        var res = x.clone();
        res.value = typed3.find(self2, [res.valueType(), y2.valueType()])(res.value, y2.value);
        res.fixPrefix = false;
        return res;
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/subtractScalar.js
  var name35 = "subtractScalar";
  var dependencies36 = ["typed"];
  var createSubtractScalar = /* @__PURE__ */ factory(name35, dependencies36, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name35, {
      "number, number": subtractNumber,
      "Complex, Complex": function ComplexComplex(x, y2) {
        return x.sub(y2);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return x.minus(y2);
      },
      "Fraction, Fraction": function FractionFraction(x, y2) {
        return x.sub(y2);
      },
      "Unit, Unit": typed3.referToSelf((self2) => (x, y2) => {
        if (x.value === null || x.value === void 0) {
          throw new Error("Parameter x contains a unit with undefined value");
        }
        if (y2.value === null || y2.value === void 0) {
          throw new Error("Parameter y contains a unit with undefined value");
        }
        if (!x.equalBase(y2))
          throw new Error("Units do not match");
        var res = x.clone();
        res.value = typed3.find(self2, [res.valueType(), y2.valueType()])(res.value, y2.value);
        res.fixPrefix = false;
        return res;
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/cbrt.js
  var name36 = "cbrt";
  var dependencies37 = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
  var createCbrt = /* @__PURE__ */ factory(name36, dependencies37, (_ref) => {
    var {
      config: config4,
      typed: typed3,
      isNegative: isNegative2,
      unaryMinus: unaryMinus2,
      matrix: matrix2,
      Complex: Complex3,
      BigNumber: BigNumber2,
      Fraction: Fraction3
    } = _ref;
    return typed3(name36, {
      number: cbrtNumber,
      // note: signature 'number, boolean' is also supported,
      //       created by typed as it knows how to convert number to Complex
      Complex: _cbrtComplex,
      "Complex, boolean": _cbrtComplex,
      BigNumber: function BigNumber3(x) {
        return x.cbrt();
      },
      Unit: _cbrtUnit
    });
    function _cbrtComplex(x, allRoots) {
      var arg3 = x.arg() / 3;
      var abs3 = x.abs();
      var principal = new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3).exp());
      if (allRoots) {
        var all = [principal, new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3 + Math.PI * 2 / 3).exp()), new Complex3(cbrtNumber(abs3), 0).mul(new Complex3(0, arg3 - Math.PI * 2 / 3).exp())];
        return config4.matrix === "Array" ? all : matrix2(all);
      } else {
        return principal;
      }
    }
    function _cbrtUnit(x) {
      if (x.value && isComplex(x.value)) {
        var result = x.clone();
        result.value = 1;
        result = result.pow(1 / 3);
        result.value = _cbrtComplex(x.value);
        return result;
      } else {
        var negate = isNegative2(x.value);
        if (negate) {
          x.value = unaryMinus2(x.value);
        }
        var third;
        if (isBigNumber(x.value)) {
          third = new BigNumber2(1).div(3);
        } else if (isFraction(x.value)) {
          third = new Fraction3(1, 3);
        } else {
          third = 1 / 3;
        }
        var _result = x.pow(third);
        if (negate) {
          _result.value = unaryMinus2(_result.value);
        }
        return _result;
      }
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo11xS0s.js
  var name37 = "matAlgo11xS0s";
  var dependencies38 = ["typed", "equalScalar"];
  var createMatAlgo11xS0s = /* @__PURE__ */ factory(name37, dependencies38, (_ref) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2
    } = _ref;
    return function matAlgo11xS0s(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
        b = typed3.convert(b, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var i3 = aindex[k];
          var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
          if (!eq(v, zero)) {
            cindex.push(i3);
            cvalues.push(v);
          }
        }
      }
      cptr[columns] = cindex.length;
      return s.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo12xSfs.js
  var name38 = "matAlgo12xSfs";
  var dependencies39 = ["typed", "DenseMatrix"];
  var createMatAlgo12xSfs = /* @__PURE__ */ factory(name38, dependencies39, (_ref) => {
    var {
      typed: typed3,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return function matAlgo12xSfs(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed3.convert(b, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cdata = [];
      var x = [];
      var w2 = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var r = aindex[k];
          x[r] = avalues[k];
          w2[r] = mark;
        }
        for (var i3 = 0; i3 < rows; i3++) {
          if (j === 0) {
            cdata[i3] = [];
          }
          if (w2[i3] === mark) {
            cdata[i3][j] = inverse ? cf(b, x[i3]) : cf(x[i3], b);
          } else {
            cdata[i3][j] = inverse ? cf(b, 0) : cf(0, b);
          }
        }
      }
      return new DenseMatrix2({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo14xDs.js
  var name39 = "matAlgo14xDs";
  var dependencies40 = ["typed"];
  var createMatAlgo14xDs = /* @__PURE__ */ factory(name39, dependencies40, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return function matAlgo14xDs(a, b, callback, inverse) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed3.convert(b, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: clone(asize),
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv, inverse) {
      var cv = [];
      if (level === s.length - 1) {
        for (var i3 = 0; i3 < n; i3++) {
          cv[i3] = inverse ? f(bv, av[i3]) : f(av[i3], bv);
        }
      } else {
        for (var j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
        }
      }
      return cv;
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/ceil.js
  var name40 = "ceil";
  var dependencies41 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createCeilNumber = /* @__PURE__ */ factory(name40, ["typed", "config", "round"], (_ref) => {
    var {
      typed: typed3,
      config: config4,
      round: round3
    } = _ref;
    return typed3(name40, {
      number: function number2(x) {
        if (nearlyEqual(x, round3(x), config4.epsilon)) {
          return round3(x);
        } else {
          return Math.ceil(x);
        }
      },
      "number, number": function numberNumber(x, n) {
        if (nearlyEqual(x, round3(x, n), config4.epsilon)) {
          return round3(x, n);
        } else {
          var [number2, exponent] = "".concat(x, "e").split("e");
          var result = Math.ceil(Number("".concat(number2, "e").concat(Number(exponent) + n)));
          [number2, exponent] = "".concat(result, "e").split("e");
          return Number("".concat(number2, "e").concat(Number(exponent) - n));
        }
      }
    });
  });
  var createCeil = /* @__PURE__ */ factory(name40, dependencies41, (_ref2) => {
    var {
      typed: typed3,
      config: config4,
      round: round3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      DenseMatrix: DenseMatrix2
    } = _ref2;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    var ceilNumber = createCeilNumber({
      typed: typed3,
      config: config4,
      round: round3
    });
    return typed3("ceil", {
      number: ceilNumber.signatures.number,
      "number,number": ceilNumber.signatures["number,number"],
      Complex: function Complex3(x) {
        return x.ceil();
      },
      "Complex, number": function ComplexNumber(x, n) {
        return x.ceil(n);
      },
      "Complex, BigNumber": function ComplexBigNumber(x, n) {
        return x.ceil(n.toNumber());
      },
      BigNumber: function BigNumber2(x) {
        if (nearlyEqual2(x, round3(x), config4.epsilon)) {
          return round3(x);
        } else {
          return x.ceil();
        }
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
        if (nearlyEqual2(x, round3(x, n), config4.epsilon)) {
          return round3(x, n);
        } else {
          return x.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_CEIL);
        }
      },
      Fraction: function Fraction3(x) {
        return x.ceil();
      },
      "Fraction, number": function FractionNumber(x, n) {
        return x.ceil(n);
      },
      "Fraction, BigNumber": function FractionBigNumber(x, n) {
        return x.ceil(n.toNumber());
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => {
        return deepMap(x, self2, true);
      }),
      "Array, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
        return deepMap(x, (i3) => self2(i3, n), true);
      }),
      "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        return matAlgo11xS0s(x, y2, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        return matAlgo14xDs(x, y2, self2, false);
      }),
      "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x, y2) => {
        return matAlgo14xDs(matrix2(y2), x, self2, true).valueOf();
      }),
      "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(x, 0))
          return zeros3(y2.size(), y2.storage());
        if (y2.storage() === "dense") {
          return matAlgo14xDs(y2, x, self2, true);
        }
        return matAlgo12xSfs(y2, x, self2, true);
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/cube.js
  var name41 = "cube";
  var dependencies42 = ["typed"];
  var createCube = /* @__PURE__ */ factory(name41, dependencies42, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name41, {
      number: cubeNumber,
      Complex: function Complex3(x) {
        return x.mul(x).mul(x);
      },
      BigNumber: function BigNumber2(x) {
        return x.times(x).times(x);
      },
      Fraction: function Fraction3(x) {
        return x.pow(3);
      },
      Unit: function Unit2(x) {
        return x.pow(3);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/exp.js
  var name42 = "exp";
  var dependencies43 = ["typed"];
  var createExp = /* @__PURE__ */ factory(name42, dependencies43, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name42, {
      number: expNumber,
      Complex: function Complex3(x) {
        return x.exp();
      },
      BigNumber: function BigNumber2(x) {
        return x.exp();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/expm1.js
  var name43 = "expm1";
  var dependencies44 = ["typed", "Complex"];
  var createExpm1 = /* @__PURE__ */ factory(name43, dependencies44, (_ref) => {
    var {
      typed: typed3,
      Complex: _Complex
    } = _ref;
    return typed3(name43, {
      number: expm1Number,
      Complex: function Complex3(x) {
        var r = Math.exp(x.re);
        return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
      },
      BigNumber: function BigNumber2(x) {
        return x.exp().minus(1);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/fix.js
  var name44 = "fix";
  var dependencies45 = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
  var createFixNumber = /* @__PURE__ */ factory(name44, ["typed", "ceil", "floor"], (_ref) => {
    var {
      typed: typed3,
      ceil: ceil3,
      floor: floor3
    } = _ref;
    return typed3(name44, {
      number: function number2(x) {
        return x > 0 ? floor3(x) : ceil3(x);
      },
      "number, number": function numberNumber(x, n) {
        return x > 0 ? floor3(x, n) : ceil3(x, n);
      }
    });
  });
  var createFix = /* @__PURE__ */ factory(name44, dependencies45, (_ref2) => {
    var {
      typed: typed3,
      Complex: _Complex,
      matrix: matrix2,
      ceil: ceil3,
      floor: floor3,
      equalScalar: equalScalar2,
      zeros: zeros3,
      DenseMatrix: DenseMatrix2
    } = _ref2;
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    var fixNumber = createFixNumber({
      typed: typed3,
      ceil: ceil3,
      floor: floor3
    });
    return typed3("fix", {
      number: fixNumber.signatures.number,
      "number, number | BigNumber": fixNumber.signatures["number,number"],
      Complex: function Complex3(x) {
        return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
      },
      "Complex, number": function ComplexNumber(x, n) {
        return new _Complex(x.re > 0 ? floor3(x.re, n) : ceil3(x.re, n), x.im > 0 ? floor3(x.im, n) : ceil3(x.im, n));
      },
      "Complex, BigNumber": function ComplexBigNumber(x, bn) {
        var n = bn.toNumber();
        return new _Complex(x.re > 0 ? floor3(x.re, n) : ceil3(x.re, n), x.im > 0 ? floor3(x.im, n) : ceil3(x.im, n));
      },
      BigNumber: function BigNumber2(x) {
        return x.isNegative() ? ceil3(x) : floor3(x);
      },
      "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x, n) {
        return x.isNegative() ? ceil3(x, n) : floor3(x, n);
      },
      Fraction: function Fraction3(x) {
        return x.s < 0 ? x.ceil() : x.floor();
      },
      "Fraction, number | BigNumber": function FractionNumberBigNumber(x, n) {
        return x.s < 0 ? ceil3(x, n) : floor3(x, n);
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => {
        return deepMap(x, self2, true);
      }),
      "Array | Matrix, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
        return deepMap(x, (i3) => self2(i3, n), true);
      }),
      "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x, y2) => {
        return matAlgo14xDs(matrix2(y2), x, self2, true).valueOf();
      }),
      "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(x, 0))
          return zeros3(y2.size(), y2.storage());
        if (y2.storage() === "dense") {
          return matAlgo14xDs(y2, x, self2, true);
        }
        return matAlgo12xSfs(y2, x, self2, true);
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/floor.js
  var name45 = "floor";
  var dependencies46 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
  var createFloorNumber = /* @__PURE__ */ factory(name45, ["typed", "config", "round"], (_ref) => {
    var {
      typed: typed3,
      config: config4,
      round: round3
    } = _ref;
    return typed3(name45, {
      number: function number2(x) {
        if (nearlyEqual(x, round3(x), config4.epsilon)) {
          return round3(x);
        } else {
          return Math.floor(x);
        }
      },
      "number, number": function numberNumber(x, n) {
        if (nearlyEqual(x, round3(x, n), config4.epsilon)) {
          return round3(x, n);
        } else {
          var [number2, exponent] = "".concat(x, "e").split("e");
          var result = Math.floor(Number("".concat(number2, "e").concat(Number(exponent) + n)));
          [number2, exponent] = "".concat(result, "e").split("e");
          return Number("".concat(number2, "e").concat(Number(exponent) - n));
        }
      }
    });
  });
  var createFloor = /* @__PURE__ */ factory(name45, dependencies46, (_ref2) => {
    var {
      typed: typed3,
      config: config4,
      round: round3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      DenseMatrix: DenseMatrix2
    } = _ref2;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    var floorNumber = createFloorNumber({
      typed: typed3,
      config: config4,
      round: round3
    });
    return typed3("floor", {
      number: floorNumber.signatures.number,
      "number,number": floorNumber.signatures["number,number"],
      Complex: function Complex3(x) {
        return x.floor();
      },
      "Complex, number": function ComplexNumber(x, n) {
        return x.floor(n);
      },
      "Complex, BigNumber": function ComplexBigNumber(x, n) {
        return x.floor(n.toNumber());
      },
      BigNumber: function BigNumber2(x) {
        if (nearlyEqual2(x, round3(x), config4.epsilon)) {
          return round3(x);
        } else {
          return x.floor();
        }
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
        if (nearlyEqual2(x, round3(x, n), config4.epsilon)) {
          return round3(x, n);
        } else {
          return x.toDecimalPlaces(n.toNumber(), decimal_default.ROUND_FLOOR);
        }
      },
      Fraction: function Fraction3(x) {
        return x.floor();
      },
      "Fraction, number": function FractionNumber(x, n) {
        return x.floor(n);
      },
      "Fraction, BigNumber": function FractionBigNumber(x, n) {
        return x.floor(n.toNumber());
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => {
        return deepMap(x, self2, true);
      }),
      "Array, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
        return deepMap(x, (i3) => self2(i3, n), true);
      }),
      "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        return matAlgo11xS0s(x, y2, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        return matAlgo14xDs(x, y2, self2, false);
      }),
      "number | Complex | Fraction | BigNumber, Array": typed3.referToSelf((self2) => (x, y2) => {
        return matAlgo14xDs(matrix2(y2), x, self2, true).valueOf();
      }),
      "number | Complex | Fraction | BigNumber, Matrix": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(x, 0))
          return zeros3(y2.size(), y2.storage());
        if (y2.storage() === "dense") {
          return matAlgo14xDs(y2, x, self2, true);
        }
        return matAlgo12xSfs(y2, x, self2, true);
      })
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo02xDS0.js
  var name46 = "matAlgo02xDS0";
  var dependencies47 = ["typed", "equalScalar"];
  var createMatAlgo02xDS0 = /* @__PURE__ */ factory(name46, dependencies47, (_ref) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2
    } = _ref;
    return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          var i3 = bindex[k];
          var cij = inverse ? cf(bvalues[k], adata[i3][j]) : cf(adata[i3][j], bvalues[k]);
          if (!eq(cij, zero)) {
            cindex.push(i3);
            cvalues.push(cij);
          }
        }
      }
      cptr[columns] = cindex.length;
      return sparseMatrix.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo03xDSf.js
  var name47 = "matAlgo03xDSf";
  var dependencies48 = ["typed"];
  var createMatAlgo03xDSf = /* @__PURE__ */ factory(name47, dependencies48, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        zero = typed3.convert(0, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cdata = [];
      for (var z = 0; z < rows; z++) {
        cdata[z] = [];
      }
      var x = [];
      var w2 = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          var i3 = bindex[k];
          x[i3] = inverse ? cf(bvalues[k], adata[i3][j]) : cf(adata[i3][j], bvalues[k]);
          w2[i3] = mark;
        }
        for (var y2 = 0; y2 < rows; y2++) {
          if (w2[y2] === mark) {
            cdata[y2][j] = x[y2];
          } else {
            cdata[y2][j] = inverse ? cf(zero, adata[y2][j]) : cf(adata[y2][j], zero);
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo05xSfSf.js
  var name48 = "matAlgo05xSfSf";
  var dependencies49 = ["typed", "equalScalar"];
  var createMatAlgo05xSfSf = /* @__PURE__ */ factory(name48, dependencies49, (_ref) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2
    } = _ref;
    return function matAlgo05xSfSf(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var xa = cvalues ? [] : void 0;
      var xb = cvalues ? [] : void 0;
      var wa = [];
      var wb = [];
      var i3, j, k, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
          i3 = aindex[k];
          cindex.push(i3);
          wa[i3] = mark;
          if (xa) {
            xa[i3] = avalues[k];
          }
        }
        for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
          i3 = bindex[k];
          if (wa[i3] !== mark) {
            cindex.push(i3);
          }
          wb[i3] = mark;
          if (xb) {
            xb[i3] = bvalues[k];
          }
        }
        if (cvalues) {
          k = cptr[j];
          while (k < cindex.length) {
            i3 = cindex[k];
            var wai = wa[i3];
            var wbi = wb[i3];
            if (wai === mark || wbi === mark) {
              var va = wai === mark ? xa[i3] : zero;
              var vb = wbi === mark ? xb[i3] : zero;
              var vc = cf(va, vb);
              if (!eq(vc, zero)) {
                cvalues.push(vc);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo13xDD.js
  var name49 = "matAlgo13xDD";
  var dependencies50 = ["typed"];
  var createMatAlgo13xDD = /* @__PURE__ */ factory(name49, dependencies50, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return function matAlgo13xDD(a, b, callback) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var csize = [];
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      for (var s = 0; s < asize.length; s++) {
        if (asize[s] !== bsize[s]) {
          throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
        }
        csize[s] = asize[s];
      }
      var dt;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        cf = typed3.find(callback, [dt, dt]);
      }
      var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
      return a.createDenseMatrix({
        data: cdata,
        size: csize,
        datatype: dt
      });
    };
    function _iterate(f, level, s, n, av, bv) {
      var cv = [];
      if (level === s.length - 1) {
        for (var i3 = 0; i3 < n; i3++) {
          cv[i3] = f(av[i3], bv[i3]);
        }
      } else {
        for (var j = 0; j < n; j++) {
          cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
        }
      }
      return cv;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/broadcast.js
  var name50 = "broadcast";
  var dependancies = ["concat"];
  var createBroadcast = /* @__PURE__ */ factory(name50, dependancies, (_ref) => {
    var {
      concat: concat3
    } = _ref;
    return function(A2, B2) {
      var N = Math.max(A2._size.length, B2._size.length);
      if (A2._size.length === B2._size.length) {
        if (A2._size.every((dim2, i3) => dim2 === B2._size[i3])) {
          return [A2, B2];
        }
      }
      var sizeA = _padLeft(A2._size, N, 0);
      var sizeB = _padLeft(B2._size, N, 0);
      var sizeMax = [];
      for (var dim = 0; dim < N; dim++) {
        sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);
      }
      checkBroadcastingRules(sizeA, sizeMax);
      checkBroadcastingRules(sizeB, sizeMax);
      var AA = A2.clone();
      var BB = B2.clone();
      if (AA._size.length < N) {
        AA.reshape(_padLeft(AA._size, N, 1));
      } else if (BB._size.length < N) {
        BB.reshape(_padLeft(BB._size, N, 1));
      }
      for (var _dim = 0; _dim < N; _dim++) {
        if (AA._size[_dim] < sizeMax[_dim]) {
          AA = _stretch(AA, sizeMax[_dim], _dim);
        }
        if (BB._size[_dim] < sizeMax[_dim]) {
          BB = _stretch(BB, sizeMax[_dim], _dim);
        }
      }
      return [AA, BB];
    };
    function _padLeft(shape, N, filler) {
      return [...Array(N - shape.length).fill(filler), ...shape];
    }
    function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {
      return concat3(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matrixAlgorithmSuite.js
  var name51 = "matrixAlgorithmSuite";
  var dependencies51 = ["typed", "matrix", "concat"];
  var createMatrixAlgorithmSuite = /* @__PURE__ */ factory(name51, dependencies51, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    } = _ref;
    var matAlgo13xDD = createMatAlgo13xDD({
      typed: typed3
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    var broadcast = createBroadcast({
      concat: concat3
    });
    return function matrixAlgorithmSuite(options) {
      var elop = options.elop;
      var SD = options.SD || options.DS;
      var matrixSignatures;
      if (elop) {
        matrixSignatures = {
          "DenseMatrix, DenseMatrix": (x, y2) => matAlgo13xDD(...broadcast(x, y2), elop),
          "Array, Array": (x, y2) => matAlgo13xDD(...broadcast(matrix2(x), matrix2(y2)), elop).valueOf(),
          "Array, DenseMatrix": (x, y2) => matAlgo13xDD(...broadcast(matrix2(x), y2), elop),
          "DenseMatrix, Array": (x, y2) => matAlgo13xDD(...broadcast(x, matrix2(y2)), elop)
        };
        if (options.SS) {
          matrixSignatures["SparseMatrix, SparseMatrix"] = (x, y2) => options.SS(...broadcast(x, y2), elop, false);
        }
        if (options.DS) {
          matrixSignatures["DenseMatrix, SparseMatrix"] = (x, y2) => options.DS(...broadcast(x, y2), elop, false);
          matrixSignatures["Array, SparseMatrix"] = (x, y2) => options.DS(...broadcast(matrix2(x), y2), elop, false);
        }
        if (SD) {
          matrixSignatures["SparseMatrix, DenseMatrix"] = (x, y2) => SD(...broadcast(y2, x), elop, true);
          matrixSignatures["SparseMatrix, Array"] = (x, y2) => SD(...broadcast(matrix2(y2), x), elop, true);
        }
      } else {
        matrixSignatures = {
          "DenseMatrix, DenseMatrix": typed3.referToSelf((self2) => (x, y2) => {
            return matAlgo13xDD(...broadcast(x, y2), self2);
          }),
          "Array, Array": typed3.referToSelf((self2) => (x, y2) => {
            return matAlgo13xDD(...broadcast(matrix2(x), matrix2(y2)), self2).valueOf();
          }),
          "Array, DenseMatrix": typed3.referToSelf((self2) => (x, y2) => {
            return matAlgo13xDD(...broadcast(matrix2(x), y2), self2);
          }),
          "DenseMatrix, Array": typed3.referToSelf((self2) => (x, y2) => {
            return matAlgo13xDD(...broadcast(x, matrix2(y2)), self2);
          })
        };
        if (options.SS) {
          matrixSignatures["SparseMatrix, SparseMatrix"] = typed3.referToSelf((self2) => (x, y2) => {
            return options.SS(...broadcast(x, y2), self2, false);
          });
        }
        if (options.DS) {
          matrixSignatures["DenseMatrix, SparseMatrix"] = typed3.referToSelf((self2) => (x, y2) => {
            return options.DS(...broadcast(x, y2), self2, false);
          });
          matrixSignatures["Array, SparseMatrix"] = typed3.referToSelf((self2) => (x, y2) => {
            return options.DS(...broadcast(matrix2(x), y2), self2, false);
          });
        }
        if (SD) {
          matrixSignatures["SparseMatrix, DenseMatrix"] = typed3.referToSelf((self2) => (x, y2) => {
            return SD(...broadcast(y2, x), self2, true);
          });
          matrixSignatures["SparseMatrix, Array"] = typed3.referToSelf((self2) => (x, y2) => {
            return SD(...broadcast(matrix2(y2), x), self2, true);
          });
        }
      }
      var scalar = options.scalar || "any";
      var Ds = options.Ds || options.Ss;
      if (Ds) {
        if (elop) {
          matrixSignatures["DenseMatrix," + scalar] = (x, y2) => matAlgo14xDs(x, y2, elop, false);
          matrixSignatures[scalar + ", DenseMatrix"] = (x, y2) => matAlgo14xDs(y2, x, elop, true);
          matrixSignatures["Array," + scalar] = (x, y2) => matAlgo14xDs(matrix2(x), y2, elop, false).valueOf();
          matrixSignatures[scalar + ", Array"] = (x, y2) => matAlgo14xDs(matrix2(y2), x, elop, true).valueOf();
        } else {
          matrixSignatures["DenseMatrix," + scalar] = typed3.referToSelf((self2) => (x, y2) => {
            return matAlgo14xDs(x, y2, self2, false);
          });
          matrixSignatures[scalar + ", DenseMatrix"] = typed3.referToSelf((self2) => (x, y2) => {
            return matAlgo14xDs(y2, x, self2, true);
          });
          matrixSignatures["Array," + scalar] = typed3.referToSelf((self2) => (x, y2) => {
            return matAlgo14xDs(matrix2(x), y2, self2, false).valueOf();
          });
          matrixSignatures[scalar + ", Array"] = typed3.referToSelf((self2) => (x, y2) => {
            return matAlgo14xDs(matrix2(y2), x, self2, true).valueOf();
          });
        }
      }
      var sS = options.sS !== void 0 ? options.sS : options.Ss;
      if (elop) {
        if (options.Ss) {
          matrixSignatures["SparseMatrix," + scalar] = (x, y2) => options.Ss(x, y2, elop, false);
        }
        if (sS) {
          matrixSignatures[scalar + ", SparseMatrix"] = (x, y2) => sS(y2, x, elop, true);
        }
      } else {
        if (options.Ss) {
          matrixSignatures["SparseMatrix," + scalar] = typed3.referToSelf((self2) => (x, y2) => {
            return options.Ss(x, y2, self2, false);
          });
        }
        if (sS) {
          matrixSignatures[scalar + ", SparseMatrix"] = typed3.referToSelf((self2) => (x, y2) => {
            return sS(y2, x, self2, true);
          });
        }
      }
      if (elop && elop.signatures) {
        extend(matrixSignatures, elop.signatures);
      }
      return matrixSignatures;
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/mod.js
  var name52 = "mod";
  var dependencies52 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
  var createMod = /* @__PURE__ */ factory(name52, dependencies52, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      round: round3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var floor3 = createFloor({
      typed: typed3,
      config: config4,
      round: round3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo05xSfSf = createMatAlgo05xSfSf({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name52, {
      "number, number": _modNumber,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return y2.isZero() ? x : x.sub(y2.mul(floor3(x.div(y2))));
      },
      "Fraction, Fraction": function FractionFraction(x, y2) {
        return y2.equals(0) ? x : x.sub(y2.mul(floor3(x.div(y2))));
      }
    }, matrixAlgorithmSuite({
      SS: matAlgo05xSfSf,
      DS: matAlgo03xDSf,
      SD: matAlgo02xDS0,
      Ss: matAlgo11xS0s,
      sS: matAlgo12xSfs
    }));
    function _modNumber(x, y2) {
      return y2 === 0 ? x : x - y2 * floor3(x / y2);
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo01xDSid.js
  var name53 = "matAlgo01xDSid";
  var dependencies53 = ["typed"];
  var createMatAlgo01xDSid = /* @__PURE__ */ factory(name53, dependencies53, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
      var adata = denseMatrix._data;
      var asize = denseMatrix._size;
      var adt = denseMatrix._datatype;
      var bvalues = sparseMatrix._values;
      var bindex = sparseMatrix._index;
      var bptr = sparseMatrix._ptr;
      var bsize = sparseMatrix._size;
      var bdt = sparseMatrix._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!bvalues) {
        throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt = typeof adt === "string" && adt === bdt ? adt : void 0;
      var cf = dt ? typed3.find(callback, [dt, dt]) : callback;
      var i3, j;
      var cdata = [];
      for (i3 = 0; i3 < rows; i3++) {
        cdata[i3] = [];
      }
      var x = [];
      var w2 = [];
      for (j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i3 = bindex[k];
          x[i3] = inverse ? cf(bvalues[k], adata[i3][j]) : cf(adata[i3][j], bvalues[k]);
          w2[i3] = mark;
        }
        for (i3 = 0; i3 < rows; i3++) {
          if (w2[i3] === mark) {
            cdata[i3][j] = x[i3];
          } else {
            cdata[i3][j] = adata[i3][j];
          }
        }
      }
      return denseMatrix.createDenseMatrix({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo04xSidSid.js
  var name54 = "matAlgo04xSidSid";
  var dependencies54 = ["typed", "equalScalar"];
  var createMatAlgo04xSidSid = /* @__PURE__ */ factory(name54, dependencies54, (_ref) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2
    } = _ref;
    return function matAlgo04xSidSid(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var xa = avalues && bvalues ? [] : void 0;
      var xb = avalues && bvalues ? [] : void 0;
      var wa = [];
      var wb = [];
      var i3, j, k, k0, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i3 = aindex[k];
          cindex.push(i3);
          wa[i3] = mark;
          if (xa) {
            xa[i3] = avalues[k];
          }
        }
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i3 = bindex[k];
          if (wa[i3] === mark) {
            if (xa) {
              var v = cf(xa[i3], bvalues[k]);
              if (!eq(v, zero)) {
                xa[i3] = v;
              } else {
                wa[i3] = null;
              }
            }
          } else {
            cindex.push(i3);
            wb[i3] = mark;
            if (xb) {
              xb[i3] = bvalues[k];
            }
          }
        }
        if (xa && xb) {
          k = cptr[j];
          while (k < cindex.length) {
            i3 = cindex[k];
            if (wa[i3] === mark) {
              cvalues[k] = xa[i3];
              k++;
            } else if (wb[i3] === mark) {
              cvalues[k] = xb[i3];
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo10xSids.js
  var name55 = "matAlgo10xSids";
  var dependencies55 = ["typed", "DenseMatrix"];
  var createMatAlgo10xSids = /* @__PURE__ */ factory(name55, dependencies55, (_ref) => {
    var {
      typed: typed3,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return function matAlgo10xSids(s, b, callback, inverse) {
      var avalues = s._values;
      var aindex = s._index;
      var aptr = s._ptr;
      var asize = s._size;
      var adt = s._datatype;
      if (!avalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var cf = callback;
      if (typeof adt === "string") {
        dt = adt;
        b = typed3.convert(b, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cdata = [];
      var x = [];
      var w2 = [];
      for (var j = 0; j < columns; j++) {
        var mark = j + 1;
        for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          var r = aindex[k];
          x[r] = avalues[k];
          w2[r] = mark;
        }
        for (var i3 = 0; i3 < rows; i3++) {
          if (j === 0) {
            cdata[i3] = [];
          }
          if (w2[i3] === mark) {
            cdata[i3][j] = inverse ? cf(b, x[i3]) : cf(x[i3], b);
          } else {
            cdata[i3][j] = b;
          }
        }
      }
      return new DenseMatrix2({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/error/ArgumentsError.js
  function ArgumentsError(fn, count2, min3, max3) {
    if (!(this instanceof ArgumentsError)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.fn = fn;
    this.count = count2;
    this.min = min3;
    this.max = max3;
    this.message = "Wrong number of arguments in function " + fn + " (" + count2 + " provided, " + min3 + (max3 !== void 0 && max3 !== null ? "-" + max3 : "") + " expected)";
    this.stack = new Error().stack;
  }
  ArgumentsError.prototype = new Error();
  ArgumentsError.prototype.constructor = Error;
  ArgumentsError.prototype.name = "ArgumentsError";
  ArgumentsError.prototype.isArgumentsError = true;

  // node_modules/mathjs/lib/esm/function/arithmetic/gcd.js
  var name56 = "gcd";
  var dependencies56 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix", "concat"];
  var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
  var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
  function is1d(array) {
    return !array.some((element) => Array.isArray(element));
  }
  var createGcd = /* @__PURE__ */ factory(name56, dependencies56, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      config: config4,
      round: round3,
      equalScalar: equalScalar2,
      zeros: zeros3,
      BigNumber: BigNumber2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var mod3 = createMod({
      typed: typed3,
      config: config4,
      round: round3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    });
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed: typed3
    });
    var matAlgo04xSidSid = createMatAlgo04xSidSid({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name56, {
      "number, number": _gcdNumber,
      "BigNumber, BigNumber": _gcdBigNumber,
      "Fraction, Fraction": (x, y2) => x.gcd(y2)
    }, matrixAlgorithmSuite({
      SS: matAlgo04xSidSid,
      DS: matAlgo01xDSid,
      Ss: matAlgo10xSids
    }), {
      [gcdManyTypesSignature]: typed3.referToSelf((self2) => (a, b, args) => {
        var res = self2(a, b);
        for (var i3 = 0; i3 < args.length; i3++) {
          res = self2(res, args[i3]);
        }
        return res;
      }),
      Array: typed3.referToSelf((self2) => (array) => {
        if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
          return self2(...array[0]);
        }
        if (is1d(array)) {
          return self2(...array);
        }
        throw new ArgumentsError("gcd() supports only 1d matrices!");
      }),
      Matrix: typed3.referToSelf((self2) => (matrix3) => {
        return self2(matrix3.toArray());
      })
    });
    function _gcdNumber(a, b) {
      if (!isInteger(a) || !isInteger(b)) {
        throw new Error("Parameters in function gcd must be integer numbers");
      }
      var r;
      while (b !== 0) {
        r = mod3(a, b);
        a = b;
        b = r;
      }
      return a < 0 ? -a : a;
    }
    function _gcdBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function gcd must be integer numbers");
      }
      var zero = new BigNumber2(0);
      while (!b.isZero()) {
        var r = mod3(a, b);
        a = b;
        b = r;
      }
      return a.lt(zero) ? a.neg() : a;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo06xS0S0.js
  var name57 = "matAlgo06xS0S0";
  var dependencies57 = ["typed", "equalScalar"];
  var createMatAlgo06xS0S0 = /* @__PURE__ */ factory(name57, dependencies57, (_ref) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2
    } = _ref;
    return function matAlgo06xS0S0(a, b, callback) {
      var avalues = a._values;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var x = cvalues ? [] : void 0;
      var w2 = [];
      var u = [];
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        scatter(a, j, w2, x, u, mark, cindex, cf);
        scatter(b, j, w2, x, u, mark, cindex, cf);
        if (x) {
          var k = cptr[j];
          while (k < cindex.length) {
            var i3 = cindex[k];
            if (u[i3] === mark) {
              var v = x[i3];
              if (!eq(v, zero)) {
                cvalues.push(v);
                k++;
              } else {
                cindex.splice(k, 1);
              }
            } else {
              cindex.splice(k, 1);
            }
          }
        } else {
          var p = cptr[j];
          while (p < cindex.length) {
            var r = cindex[p];
            if (u[r] !== mark) {
              cindex.splice(p, 1);
            } else {
              p++;
            }
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/lcm.js
  var name58 = "lcm";
  var dependencies58 = ["typed", "matrix", "equalScalar", "concat"];
  var createLcm = /* @__PURE__ */ factory(name58, dependencies58, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      concat: concat3
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo06xS0S0 = createMatAlgo06xS0S0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
    var lcmManySignature = {};
    lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed3.referToSelf((self2) => (a, b, args) => {
      var res = self2(a, b);
      for (var i3 = 0; i3 < args.length; i3++) {
        res = self2(res, args[i3]);
      }
      return res;
    });
    return typed3(name58, {
      "number, number": lcmNumber,
      "BigNumber, BigNumber": _lcmBigNumber,
      "Fraction, Fraction": (x, y2) => x.lcm(y2)
    }, matrixAlgorithmSuite({
      SS: matAlgo06xS0S0,
      DS: matAlgo02xDS0,
      Ss: matAlgo11xS0s
    }), lcmManySignature);
    function _lcmBigNumber(a, b) {
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function lcm must be integer numbers");
      }
      if (a.isZero()) {
        return a;
      }
      if (b.isZero()) {
        return b;
      }
      var prod2 = a.times(b);
      while (!b.isZero()) {
        var t = b;
        b = a.mod(t);
        a = t;
      }
      return prod2.div(a).abs();
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log10.js
  var name59 = "log10";
  var dependencies59 = ["typed", "config", "Complex"];
  var createLog10 = /* @__PURE__ */ factory(name59, dependencies59, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: _Complex
    } = _ref;
    return typed3(name59, {
      number: function number2(x) {
        if (x >= 0 || config4.predictable) {
          return log10Number(x);
        } else {
          return new _Complex(x, 0).log().div(Math.LN10);
        }
      },
      Complex: function Complex3(x) {
        return new _Complex(x).log().div(Math.LN10);
      },
      BigNumber: function BigNumber2(x) {
        if (!x.isNegative() || config4.predictable) {
          return x.log();
        } else {
          return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
        }
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log2.js
  var name60 = "log2";
  var dependencies60 = ["typed", "config", "Complex"];
  var createLog2 = /* @__PURE__ */ factory(name60, dependencies60, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: Complex3
    } = _ref;
    return typed3(name60, {
      number: function number2(x) {
        if (x >= 0 || config4.predictable) {
          return log2Number(x);
        } else {
          return _log2Complex(new Complex3(x, 0));
        }
      },
      Complex: _log2Complex,
      BigNumber: function BigNumber2(x) {
        if (!x.isNegative() || config4.predictable) {
          return x.log(2);
        } else {
          return _log2Complex(new Complex3(x.toNumber(), 0));
        }
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
    function _log2Complex(x) {
      var newX = Math.sqrt(x.re * x.re + x.im * x.im);
      return new Complex3(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/multiplyScalar.js
  var name61 = "multiplyScalar";
  var dependencies61 = ["typed"];
  var createMultiplyScalar = /* @__PURE__ */ factory(name61, dependencies61, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3("multiplyScalar", {
      "number, number": multiplyNumber,
      "Complex, Complex": function ComplexComplex(x, y2) {
        return x.mul(y2);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return x.times(y2);
      },
      "Fraction, Fraction": function FractionFraction(x, y2) {
        return x.mul(y2);
      },
      "number | Fraction | BigNumber | Complex, Unit": (x, y2) => y2.multiply(x),
      "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y2) => x.multiply(y2)
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/multiply.js
  var name62 = "multiply";
  var dependencies62 = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
  var createMultiply = /* @__PURE__ */ factory(name62, dependencies62, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      addScalar: addScalar2,
      multiplyScalar: multiplyScalar2,
      equalScalar: equalScalar2,
      dot: dot2
    } = _ref;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    function _validateMatrixDimensions(size1, size2) {
      switch (size1.length) {
        case 1:
          switch (size2.length) {
            case 1:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
              }
              break;
            case 2:
              if (size1[0] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        case 2:
          switch (size2.length) {
            case 1:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
              }
              break;
            case 2:
              if (size1[1] !== size2[0]) {
                throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
              }
              break;
            default:
              throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
          }
          break;
        default:
          throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
      }
    }
    function _multiplyVectorVector(a, b, n) {
      if (n === 0) {
        throw new Error("Cannot multiply two empty vectors");
      }
      return dot2(a, b);
    }
    function _multiplyVectorMatrix(a, b) {
      if (b.storage() !== "dense") {
        throw new Error("Support for SparseMatrix not implemented");
      }
      return _multiplyVectorDenseMatrix(a, b);
    }
    function _multiplyVectorDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var alength = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed3.find(addScalar2, [dt, dt]);
        mf = typed3.find(multiplyScalar2, [dt, dt]);
      }
      var c = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum3 = mf(adata[0], bdata[0][j]);
        for (var i3 = 1; i3 < alength; i3++) {
          sum3 = af(sum3, mf(adata[i3], bdata[i3][j]));
        }
        c[j] = sum3;
      }
      return a.createDenseMatrix({
        data: c,
        size: [bcolumns],
        datatype: dt
      });
    }
    var _multiplyMatrixVector = typed3("_multiplyMatrixVector", {
      "DenseMatrix, any": _multiplyDenseMatrixVector,
      "SparseMatrix, any": _multiplySparseMatrixVector
    });
    var _multiplyMatrixMatrix = typed3("_multiplyMatrixMatrix", {
      "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
      "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
      "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
      "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
    });
    function _multiplyDenseMatrixVector(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = asize[0];
      var acolumns = asize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed3.find(addScalar2, [dt, dt]);
        mf = typed3.find(multiplyScalar2, [dt, dt]);
      }
      var c = [];
      for (var i3 = 0; i3 < arows; i3++) {
        var row2 = adata[i3];
        var sum3 = mf(row2[0], bdata[0]);
        for (var j = 1; j < acolumns; j++) {
          sum3 = af(sum3, mf(row2[j], bdata[j]));
        }
        c[i3] = sum3;
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows],
        datatype: dt
      });
    }
    function _multiplyDenseMatrixDenseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bdata = b._data;
      var bsize = b._size;
      var bdt = b._datatype;
      var arows = asize[0];
      var acolumns = asize[1];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed3.find(addScalar2, [dt, dt]);
        mf = typed3.find(multiplyScalar2, [dt, dt]);
      }
      var c = [];
      for (var i3 = 0; i3 < arows; i3++) {
        var row2 = adata[i3];
        c[i3] = [];
        for (var j = 0; j < bcolumns; j++) {
          var sum3 = mf(row2[0], bdata[0][j]);
          for (var x = 1; x < acolumns; x++) {
            sum3 = af(sum3, mf(row2[x], bdata[x][j]));
          }
          c[i3][j] = sum3;
        }
      }
      return a.createDenseMatrix({
        data: c,
        size: [arows, bcolumns],
        datatype: dt
      });
    }
    function _multiplyDenseMatrixSparseMatrix(a, b) {
      var adata = a._data;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (!bvalues) {
        throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
      }
      var arows = asize[0];
      var bcolumns = bsize[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      var eq = equalScalar2;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed3.find(addScalar2, [dt, dt]);
        mf = typed3.find(multiplyScalar2, [dt, dt]);
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = b.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var kb0 = bptr[jb];
        var kb1 = bptr[jb + 1];
        if (kb1 > kb0) {
          var last = 0;
          for (var i3 = 0; i3 < arows; i3++) {
            var mark = i3 + 1;
            var cij = void 0;
            for (var kb = kb0; kb < kb1; kb++) {
              var ib = bindex[kb];
              if (last !== mark) {
                cij = mf(adata[i3][ib], bvalues[kb]);
                last = mark;
              } else {
                cij = af(cij, mf(adata[i3][ib], bvalues[kb]));
              }
            }
            if (last === mark && !eq(cij, zero)) {
              cindex.push(i3);
              cvalues.push(cij);
            }
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixVector(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = a._size[0];
      var brows = b._size[0];
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      var eq = equalScalar2;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed3.find(addScalar2, [dt, dt]);
        mf = typed3.find(multiplyScalar2, [dt, dt]);
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
      }
      var x = [];
      var w2 = [];
      cptr[0] = 0;
      for (var ib = 0; ib < brows; ib++) {
        var vbi = bdata[ib];
        if (!eq(vbi, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (!w2[ia]) {
              w2[ia] = true;
              cindex.push(ia);
              x[ia] = mf(vbi, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbi, avalues[ka]));
            }
          }
        }
      }
      for (var p1 = cindex.length, p = 0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
      cptr[1] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, 1],
        datatype: dt
      });
    }
    function _multiplySparseMatrixDenseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      if (!avalues) {
        throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
      }
      var bdata = b._data;
      var bdt = b._datatype;
      var arows = a._size[0];
      var brows = b._size[0];
      var bcolumns = b._size[1];
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      var eq = equalScalar2;
      var zero = 0;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed3.find(addScalar2, [dt, dt]);
        mf = typed3.find(multiplyScalar2, [dt, dt]);
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      var x = [];
      var w2 = [];
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (var ib = 0; ib < brows; ib++) {
          var vbij = bdata[ib][jb];
          if (!eq(vbij, zero)) {
            for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              var ia = aindex[ka];
              if (w2[ia] !== mark) {
                w2[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(vbij, avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(vbij, avalues[ka]));
              }
            }
          }
        }
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    function _multiplySparseMatrixSparseMatrix(a, b) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bdt = b._datatype;
      var arows = a._size[0];
      var bcolumns = b._size[1];
      var values = avalues && bvalues;
      var dt;
      var af = addScalar2;
      var mf = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        dt = adt;
        af = typed3.find(addScalar2, [dt, dt]);
        mf = typed3.find(multiplyScalar2, [dt, dt]);
      }
      var cvalues = values ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var c = a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [arows, bcolumns],
        datatype: dt
      });
      var x = values ? [] : void 0;
      var w2 = [];
      var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
      for (var jb = 0; jb < bcolumns; jb++) {
        cptr[jb] = cindex.length;
        var mark = jb + 1;
        for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
          ib = bindex[kb];
          if (values) {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w2[ia] !== mark) {
                w2[ia] = mark;
                cindex.push(ia);
                x[ia] = mf(bvalues[kb], avalues[ka]);
              } else {
                x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
              }
            }
          } else {
            for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
              ia = aindex[ka];
              if (w2[ia] !== mark) {
                w2[ia] = mark;
                cindex.push(ia);
              }
            }
          }
        }
        if (values) {
          for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
            var ic = cindex[p];
            cvalues[p] = x[ic];
          }
        }
      }
      cptr[bcolumns] = cindex.length;
      return c;
    }
    return typed3(name62, multiplyScalar2, {
      // we extend the signatures of multiplyScalar with signatures dealing with matrices
      "Array, Array": typed3.referTo("Matrix, Matrix", (selfMM) => (x, y2) => {
        _validateMatrixDimensions(arraySize(x), arraySize(y2));
        var m = selfMM(matrix2(x), matrix2(y2));
        return isMatrix(m) ? m.valueOf() : m;
      }),
      "Matrix, Matrix": function MatrixMatrix(x, y2) {
        var xsize = x.size();
        var ysize = y2.size();
        _validateMatrixDimensions(xsize, ysize);
        if (xsize.length === 1) {
          if (ysize.length === 1) {
            return _multiplyVectorVector(x, y2, xsize[0]);
          }
          return _multiplyVectorMatrix(x, y2);
        }
        if (ysize.length === 1) {
          return _multiplyMatrixVector(x, y2);
        }
        return _multiplyMatrixMatrix(x, y2);
      },
      "Matrix, Array": typed3.referTo("Matrix,Matrix", (selfMM) => (x, y2) => selfMM(x, matrix2(y2))),
      "Array, Matrix": typed3.referToSelf((self2) => (x, y2) => {
        return self2(matrix2(x, y2.storage()), y2);
      }),
      "SparseMatrix, any": function SparseMatrixAny(x, y2) {
        return matAlgo11xS0s(x, y2, multiplyScalar2, false);
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y2) {
        return matAlgo14xDs(x, y2, multiplyScalar2, false);
      },
      "any, SparseMatrix": function anySparseMatrix(x, y2) {
        return matAlgo11xS0s(y2, x, multiplyScalar2, true);
      },
      "any, DenseMatrix": function anyDenseMatrix(x, y2) {
        return matAlgo14xDs(y2, x, multiplyScalar2, true);
      },
      "Array, any": function ArrayAny(x, y2) {
        return matAlgo14xDs(matrix2(x), y2, multiplyScalar2, false).valueOf();
      },
      "any, Array": function anyArray(x, y2) {
        return matAlgo14xDs(matrix2(y2), x, multiplyScalar2, true).valueOf();
      },
      "any, any": multiplyScalar2,
      "any, any, ...any": typed3.referToSelf((self2) => (x, y2, rest) => {
        var result = self2(x, y2);
        for (var i3 = 0; i3 < rest.length; i3++) {
          result = self2(result, rest[i3]);
        }
        return result;
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/nthRoot.js
  var name63 = "nthRoot";
  var dependencies63 = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
  var createNthRoot = /* @__PURE__ */ factory(name63, dependencies63, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      BigNumber: _BigNumber,
      concat: concat3
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed: typed3
    });
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo06xS0S0 = createMatAlgo06xS0S0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    function complexErr() {
      throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
    }
    return typed3(name63, {
      number: nthRootNumber,
      "number, number": nthRootNumber,
      BigNumber: (x) => _bigNthRoot(x, new _BigNumber(2)),
      "BigNumber, BigNumber": _bigNthRoot,
      Complex: complexErr,
      "Complex, number": complexErr,
      Array: typed3.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(matrix2(x), 2).valueOf()),
      DenseMatrix: typed3.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(x, 2)),
      SparseMatrix: typed3.referTo("SparseMatrix,number", (selfSn) => (x) => selfSn(x, 2)),
      "SparseMatrix, SparseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (y2.density() === 1) {
          return matAlgo06xS0S0(x, y2, self2);
        } else {
          throw new Error("Root must be non-zero");
        }
      }),
      "DenseMatrix, SparseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (y2.density() === 1) {
          return matAlgo01xDSid(x, y2, self2, false);
        } else {
          throw new Error("Root must be non-zero");
        }
      }),
      "Array, SparseMatrix": typed3.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x, y2) => selfDS(matrix2(x), y2)),
      "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (y2.density() === 1) {
          return matAlgo11xS0s(y2, x, self2, true);
        } else {
          throw new Error("Root must be non-zero");
        }
      })
    }, matrixAlgorithmSuite({
      scalar: "number | BigNumber",
      SD: matAlgo02xDS0,
      Ss: matAlgo11xS0s,
      sS: false
    }));
    function _bigNthRoot(a, root) {
      var precision = _BigNumber.precision;
      var Big = _BigNumber.clone({
        precision: precision + 2
      });
      var zero = new _BigNumber(0);
      var one = new Big(1);
      var inv2 = root.isNegative();
      if (inv2) {
        root = root.neg();
      }
      if (root.isZero()) {
        throw new Error("Root must be non-zero");
      }
      if (a.isNegative() && !root.abs().mod(2).equals(1)) {
        throw new Error("Root must be odd when a is negative.");
      }
      if (a.isZero()) {
        return inv2 ? new Big(Infinity) : 0;
      }
      if (!a.isFinite()) {
        return inv2 ? zero : a;
      }
      var x = a.abs().pow(one.div(root));
      x = a.isNeg() ? x.neg() : x;
      return new _BigNumber((inv2 ? one.div(x) : x).toPrecision(precision));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/sign.js
  var name64 = "sign";
  var dependencies64 = ["typed", "BigNumber", "Fraction", "complex"];
  var createSign = /* @__PURE__ */ factory(name64, dependencies64, (_ref) => {
    var {
      typed: typed3,
      BigNumber: _BigNumber,
      complex: complex2,
      Fraction: _Fraction
    } = _ref;
    return typed3(name64, {
      number: signNumber,
      Complex: function Complex3(x) {
        return x.im === 0 ? complex2(signNumber(x.re)) : x.sign();
      },
      BigNumber: function BigNumber2(x) {
        return new _BigNumber(x.cmp(0));
      },
      Fraction: function Fraction3(x) {
        return new _Fraction(x.s, 1);
      },
      // deep map collection, skip zeros since sign(0) = 0
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2, true)),
      Unit: typed3.referToSelf((self2) => (x) => {
        if (!x._isDerived() && x.units[0].unit.offset !== 0) {
          throw new TypeError("sign is ambiguous for units with offset");
        }
        return typed3.find(self2, x.valueType())(x.value);
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/sqrt.js
  var name65 = "sqrt";
  var dependencies65 = ["config", "typed", "Complex"];
  var createSqrt = /* @__PURE__ */ factory(name65, dependencies65, (_ref) => {
    var {
      config: config4,
      typed: typed3,
      Complex: Complex3
    } = _ref;
    return typed3("sqrt", {
      number: _sqrtNumber,
      Complex: function Complex4(x) {
        return x.sqrt();
      },
      BigNumber: function BigNumber2(x) {
        if (!x.isNegative() || config4.predictable) {
          return x.sqrt();
        } else {
          return _sqrtNumber(x.toNumber());
        }
      },
      Unit: function Unit2(x) {
        return x.pow(0.5);
      }
    });
    function _sqrtNumber(x) {
      if (isNaN(x)) {
        return NaN;
      } else if (x >= 0 || config4.predictable) {
        return Math.sqrt(x);
      } else {
        return new Complex3(x, 0).sqrt();
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/square.js
  var name66 = "square";
  var dependencies66 = ["typed"];
  var createSquare = /* @__PURE__ */ factory(name66, dependencies66, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name66, {
      number: squareNumber,
      Complex: function Complex3(x) {
        return x.mul(x);
      },
      BigNumber: function BigNumber2(x) {
        return x.times(x);
      },
      Fraction: function Fraction3(x) {
        return x.mul(x);
      },
      Unit: function Unit2(x) {
        return x.pow(2);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/subtract.js
  var name67 = "subtract";
  var dependencies67 = ["typed", "matrix", "equalScalar", "subtractScalar", "unaryMinus", "DenseMatrix", "concat"];
  var createSubtract = /* @__PURE__ */ factory(name67, dependencies67, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      subtractScalar: subtractScalar2,
      unaryMinus: unaryMinus2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed: typed3
    });
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo05xSfSf = createMatAlgo05xSfSf({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name67, {
      "any, any": subtractScalar2
    }, matrixAlgorithmSuite({
      elop: subtractScalar2,
      SS: matAlgo05xSfSf,
      DS: matAlgo01xDSid,
      SD: matAlgo03xDSf,
      Ss: matAlgo12xSfs,
      sS: matAlgo10xSids
    }));
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/xgcd.js
  var name68 = "xgcd";
  var dependencies68 = ["typed", "config", "matrix", "BigNumber"];
  var createXgcd = /* @__PURE__ */ factory(name68, dependencies68, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      BigNumber: BigNumber2
    } = _ref;
    return typed3(name68, {
      "number, number": function numberNumber(a, b) {
        var res = xgcdNumber(a, b);
        return config4.matrix === "Array" ? res : matrix2(res);
      },
      "BigNumber, BigNumber": _xgcdBigNumber
      // TODO: implement support for Fraction
    });
    function _xgcdBigNumber(a, b) {
      var t;
      var q;
      var r;
      var zero = new BigNumber2(0);
      var one = new BigNumber2(1);
      var x = zero;
      var lastx = one;
      var y2 = one;
      var lasty = zero;
      if (!a.isInt() || !b.isInt()) {
        throw new Error("Parameters in function xgcd must be integer numbers");
      }
      while (!b.isZero()) {
        q = a.div(b).floor();
        r = a.mod(b);
        t = x;
        x = lastx.minus(q.times(x));
        lastx = t;
        t = y2;
        y2 = lasty.minus(q.times(y2));
        lasty = t;
        a = b;
        b = r;
      }
      var res;
      if (a.lt(zero)) {
        res = [a.neg(), lastx.neg(), lasty.neg()];
      } else {
        res = [a, !a.isZero() ? lastx : 0, lasty];
      }
      return config4.matrix === "Array" ? res : matrix2(res);
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/invmod.js
  var name69 = "invmod";
  var dependencies69 = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
  var createInvmod = /* @__PURE__ */ factory(name69, dependencies69, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      BigNumber: BigNumber2,
      xgcd: xgcd2,
      equal: equal2,
      smaller: smaller2,
      mod: mod3,
      add: add3,
      isInteger: isInteger3
    } = _ref;
    return typed3(name69, {
      "number, number": invmod2,
      "BigNumber, BigNumber": invmod2
    });
    function invmod2(a, b) {
      if (!isInteger3(a) || !isInteger3(b))
        throw new Error("Parameters in function invmod must be integer numbers");
      a = mod3(a, b);
      if (equal2(b, 0))
        throw new Error("Divisor must be non zero");
      var res = xgcd2(a, b);
      res = res.valueOf();
      var [gcd2, inv2] = res;
      if (!equal2(gcd2, BigNumber2(1)))
        return NaN;
      inv2 = mod3(inv2, b);
      if (smaller2(inv2, BigNumber2(0)))
        inv2 = add3(inv2, b);
      return inv2;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo09xS0Sf.js
  var name70 = "matAlgo09xS0Sf";
  var dependencies70 = ["typed", "equalScalar"];
  var createMatAlgo09xS0Sf = /* @__PURE__ */ factory(name70, dependencies70, (_ref) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2
    } = _ref;
    return function matAlgo09xS0Sf(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cvalues = avalues && bvalues ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var x = cvalues ? [] : void 0;
      var w2 = [];
      var i3, j, k, k0, k1;
      for (j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        if (x) {
          for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
            i3 = bindex[k];
            w2[i3] = mark;
            x[i3] = bvalues[k];
          }
        }
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i3 = aindex[k];
          if (x) {
            var vb = w2[i3] === mark ? x[i3] : zero;
            var vc = cf(avalues[k], vb);
            if (!eq(vc, zero)) {
              cindex.push(i3);
              cvalues.push(vc);
            }
          } else {
            cindex.push(i3);
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotMultiply.js
  var name71 = "dotMultiply";
  var dependencies71 = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"];
  var createDotMultiply = /* @__PURE__ */ factory(name71, dependencies71, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      multiplyScalar: multiplyScalar2,
      concat: concat3
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name71, matrixAlgorithmSuite({
      elop: multiplyScalar2,
      SS: matAlgo09xS0Sf,
      DS: matAlgo02xDS0,
      Ss: matAlgo11xS0s
    }));
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/bitwise.js
  function bitAndBigNumber(x, y2) {
    if (x.isFinite() && !x.isInteger() || y2.isFinite() && !y2.isInteger()) {
      throw new Error("Integers expected in function bitAnd");
    }
    var BigNumber2 = x.constructor;
    if (x.isNaN() || y2.isNaN()) {
      return new BigNumber2(NaN);
    }
    if (x.isZero() || y2.eq(-1) || x.eq(y2)) {
      return x;
    }
    if (y2.isZero() || x.eq(-1)) {
      return y2;
    }
    if (!x.isFinite() || !y2.isFinite()) {
      if (!x.isFinite() && !y2.isFinite()) {
        if (x.isNegative() === y2.isNegative()) {
          return x;
        }
        return new BigNumber2(0);
      }
      if (!x.isFinite()) {
        if (y2.isNegative()) {
          return x;
        }
        if (x.isNegative()) {
          return new BigNumber2(0);
        }
        return y2;
      }
      if (!y2.isFinite()) {
        if (x.isNegative()) {
          return y2;
        }
        if (y2.isNegative()) {
          return new BigNumber2(0);
        }
        return x;
      }
    }
    return bitwise(x, y2, function(a, b) {
      return a & b;
    });
  }
  function bitNotBigNumber(x) {
    if (x.isFinite() && !x.isInteger()) {
      throw new Error("Integer expected in function bitNot");
    }
    var BigNumber2 = x.constructor;
    var prevPrec = BigNumber2.precision;
    BigNumber2.config({
      precision: 1e9
    });
    var result = x.plus(new BigNumber2(1));
    result.s = -result.s || null;
    BigNumber2.config({
      precision: prevPrec
    });
    return result;
  }
  function bitOrBigNumber(x, y2) {
    if (x.isFinite() && !x.isInteger() || y2.isFinite() && !y2.isInteger()) {
      throw new Error("Integers expected in function bitOr");
    }
    var BigNumber2 = x.constructor;
    if (x.isNaN() || y2.isNaN()) {
      return new BigNumber2(NaN);
    }
    var negOne = new BigNumber2(-1);
    if (x.isZero() || y2.eq(negOne) || x.eq(y2)) {
      return y2;
    }
    if (y2.isZero() || x.eq(negOne)) {
      return x;
    }
    if (!x.isFinite() || !y2.isFinite()) {
      if (!x.isFinite() && !x.isNegative() && y2.isNegative() || x.isNegative() && !y2.isNegative() && !y2.isFinite()) {
        return negOne;
      }
      if (x.isNegative() && y2.isNegative()) {
        return x.isFinite() ? x : y2;
      }
      return x.isFinite() ? y2 : x;
    }
    return bitwise(x, y2, function(a, b) {
      return a | b;
    });
  }
  function bitwise(x, y2, func) {
    var BigNumber2 = x.constructor;
    var xBits, yBits;
    var xSign = +(x.s < 0);
    var ySign = +(y2.s < 0);
    if (xSign) {
      xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
      for (var i3 = 0; i3 < xBits.length; ++i3) {
        xBits[i3] ^= 1;
      }
    } else {
      xBits = decCoefficientToBinaryString(x);
    }
    if (ySign) {
      yBits = decCoefficientToBinaryString(bitNotBigNumber(y2));
      for (var _i = 0; _i < yBits.length; ++_i) {
        yBits[_i] ^= 1;
      }
    } else {
      yBits = decCoefficientToBinaryString(y2);
    }
    var minBits, maxBits, minSign;
    if (xBits.length <= yBits.length) {
      minBits = xBits;
      maxBits = yBits;
      minSign = xSign;
    } else {
      minBits = yBits;
      maxBits = xBits;
      minSign = ySign;
    }
    var shortLen = minBits.length;
    var longLen = maxBits.length;
    var expFuncVal = func(xSign, ySign) ^ 1;
    var outVal = new BigNumber2(expFuncVal ^ 1);
    var twoPower = new BigNumber2(1);
    var two = new BigNumber2(2);
    var prevPrec = BigNumber2.precision;
    BigNumber2.config({
      precision: 1e9
    });
    while (shortLen > 0) {
      if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }
      twoPower = twoPower.times(two);
    }
    while (longLen > 0) {
      if (func(minSign, maxBits[--longLen]) === expFuncVal) {
        outVal = outVal.plus(twoPower);
      }
      twoPower = twoPower.times(two);
    }
    BigNumber2.config({
      precision: prevPrec
    });
    if (expFuncVal === 0) {
      outVal.s = -outVal.s;
    }
    return outVal;
  }
  function decCoefficientToBinaryString(x) {
    var a = x.d;
    var r = a[0] + "";
    for (var i3 = 1; i3 < a.length; ++i3) {
      var s = a[i3] + "";
      for (var z = 7 - s.length; z--; ) {
        s = "0" + s;
      }
      r += s;
    }
    var j = r.length;
    while (r.charAt(j) === "0") {
      j--;
    }
    var xe = x.e;
    var str = r.slice(0, j + 1 || 1);
    var strL = str.length;
    if (xe > 0) {
      if (++xe > strL) {
        xe -= strL;
        while (xe--) {
          str += "0";
        }
      } else if (xe < strL) {
        str = str.slice(0, xe) + "." + str.slice(xe);
      }
    }
    var arr = [0];
    for (var _i2 = 0; _i2 < str.length; ) {
      var arrL = arr.length;
      while (arrL--) {
        arr[arrL] *= 10;
      }
      arr[0] += parseInt(str.charAt(_i2++));
      for (var _j = 0; _j < arr.length; ++_j) {
        if (arr[_j] > 1) {
          if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
            arr[_j + 1] = 0;
          }
          arr[_j + 1] += arr[_j] >> 1;
          arr[_j] &= 1;
        }
      }
    }
    return arr.reverse();
  }
  function bitXor(x, y2) {
    if (x.isFinite() && !x.isInteger() || y2.isFinite() && !y2.isInteger()) {
      throw new Error("Integers expected in function bitXor");
    }
    var BigNumber2 = x.constructor;
    if (x.isNaN() || y2.isNaN()) {
      return new BigNumber2(NaN);
    }
    if (x.isZero()) {
      return y2;
    }
    if (y2.isZero()) {
      return x;
    }
    if (x.eq(y2)) {
      return new BigNumber2(0);
    }
    var negOne = new BigNumber2(-1);
    if (x.eq(negOne)) {
      return bitNotBigNumber(y2);
    }
    if (y2.eq(negOne)) {
      return bitNotBigNumber(x);
    }
    if (!x.isFinite() || !y2.isFinite()) {
      if (!x.isFinite() && !y2.isFinite()) {
        return negOne;
      }
      return new BigNumber2(x.isNegative() === y2.isNegative() ? Infinity : -Infinity);
    }
    return bitwise(x, y2, function(a, b) {
      return a ^ b;
    });
  }
  function leftShiftBigNumber(x, y2) {
    if (x.isFinite() && !x.isInteger() || y2.isFinite() && !y2.isInteger()) {
      throw new Error("Integers expected in function leftShift");
    }
    var BigNumber2 = x.constructor;
    if (x.isNaN() || y2.isNaN() || y2.isNegative() && !y2.isZero()) {
      return new BigNumber2(NaN);
    }
    if (x.isZero() || y2.isZero()) {
      return x;
    }
    if (!x.isFinite() && !y2.isFinite()) {
      return new BigNumber2(NaN);
    }
    if (y2.lt(55)) {
      return x.times(Math.pow(2, y2.toNumber()) + "");
    }
    return x.times(new BigNumber2(2).pow(y2));
  }
  function rightArithShiftBigNumber(x, y2) {
    if (x.isFinite() && !x.isInteger() || y2.isFinite() && !y2.isInteger()) {
      throw new Error("Integers expected in function rightArithShift");
    }
    var BigNumber2 = x.constructor;
    if (x.isNaN() || y2.isNaN() || y2.isNegative() && !y2.isZero()) {
      return new BigNumber2(NaN);
    }
    if (x.isZero() || y2.isZero()) {
      return x;
    }
    if (!y2.isFinite()) {
      if (x.isNegative()) {
        return new BigNumber2(-1);
      }
      if (!x.isFinite()) {
        return new BigNumber2(NaN);
      }
      return new BigNumber2(0);
    }
    if (y2.lt(55)) {
      return x.div(Math.pow(2, y2.toNumber()) + "").floor();
    }
    return x.div(new BigNumber2(2).pow(y2)).floor();
  }

  // node_modules/mathjs/lib/esm/function/bitwise/bitAnd.js
  var name72 = "bitAnd";
  var dependencies72 = ["typed", "matrix", "equalScalar", "concat"];
  var createBitAnd = /* @__PURE__ */ factory(name72, dependencies72, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      concat: concat3
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo06xS0S0 = createMatAlgo06xS0S0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name72, {
      "number, number": bitAndNumber,
      "BigNumber, BigNumber": bitAndBigNumber
    }, matrixAlgorithmSuite({
      SS: matAlgo06xS0S0,
      DS: matAlgo02xDS0,
      Ss: matAlgo11xS0s
    }));
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitNot.js
  var name73 = "bitNot";
  var dependencies73 = ["typed"];
  var createBitNot = /* @__PURE__ */ factory(name73, dependencies73, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name73, {
      number: bitNotNumber,
      BigNumber: bitNotBigNumber,
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitOr.js
  var name74 = "bitOr";
  var dependencies74 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
  var createBitOr = /* @__PURE__ */ factory(name74, dependencies74, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed: typed3
    });
    var matAlgo04xSidSid = createMatAlgo04xSidSid({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name74, {
      "number, number": bitOrNumber,
      "BigNumber, BigNumber": bitOrBigNumber
    }, matrixAlgorithmSuite({
      SS: matAlgo04xSidSid,
      DS: matAlgo01xDSid,
      Ss: matAlgo10xSids
    }));
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo07xSSf.js
  var name75 = "matAlgo07xSSf";
  var dependencies75 = ["typed", "DenseMatrix"];
  var createMatAlgo07xSSf = /* @__PURE__ */ factory(name75, dependencies75, (_ref) => {
    var {
      typed: typed3,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return function matAlgo07xSSf(a, b, callback) {
      var asize = a._size;
      var adt = a._datatype;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        zero = typed3.convert(0, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var i3, j;
      var cdata = [];
      for (i3 = 0; i3 < rows; i3++) {
        cdata[i3] = [];
      }
      var xa = [];
      var xb = [];
      var wa = [];
      var wb = [];
      for (j = 0; j < columns; j++) {
        var mark = j + 1;
        _scatter(a, j, wa, xa, mark);
        _scatter(b, j, wb, xb, mark);
        for (i3 = 0; i3 < rows; i3++) {
          var va = wa[i3] === mark ? xa[i3] : zero;
          var vb = wb[i3] === mark ? xb[i3] : zero;
          cdata[i3][j] = cf(va, vb);
        }
      }
      return new DenseMatrix2({
        data: cdata,
        size: [rows, columns],
        datatype: dt
      });
    };
    function _scatter(m, j, w2, x, mark) {
      var values = m._values;
      var index2 = m._index;
      var ptr = m._ptr;
      for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
        var i3 = index2[k];
        w2[i3] = mark;
        x[i3] = values[k];
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/bitwise/bitXor.js
  var name76 = "bitXor";
  var dependencies76 = ["typed", "matrix", "DenseMatrix", "concat"];
  var createBitXor = /* @__PURE__ */ factory(name76, dependencies76, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name76, {
      "number, number": bitXorNumber,
      "BigNumber, BigNumber": bitXor
    }, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/complex/arg.js
  var name77 = "arg";
  var dependencies77 = ["typed"];
  var createArg = /* @__PURE__ */ factory(name77, dependencies77, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name77, {
      number: function number2(x) {
        return Math.atan2(0, x);
      },
      BigNumber: function BigNumber2(x) {
        return x.constructor.atan2(0, x);
      },
      Complex: function Complex3(x) {
        return x.arg();
      },
      // TODO: implement BigNumber support for function arg
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/conj.js
  var name78 = "conj";
  var dependencies78 = ["typed"];
  var createConj = /* @__PURE__ */ factory(name78, dependencies78, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name78, {
      "number | BigNumber | Fraction": (x) => x,
      Complex: (x) => x.conjugate(),
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/im.js
  var name79 = "im";
  var dependencies79 = ["typed"];
  var createIm = /* @__PURE__ */ factory(name79, dependencies79, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name79, {
      number: () => 0,
      "BigNumber | Fraction": (x) => x.mul(0),
      Complex: (x) => x.im,
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/complex/re.js
  var name80 = "re";
  var dependencies80 = ["typed"];
  var createRe = /* @__PURE__ */ factory(name80, dependencies80, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name80, {
      "number | BigNumber | Fraction": (x) => x,
      Complex: (x) => x.re,
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/logical/not.js
  var name81 = "not";
  var dependencies81 = ["typed"];
  var createNot = /* @__PURE__ */ factory(name81, dependencies81, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name81, {
      "null | undefined": () => true,
      number: notNumber,
      Complex: function Complex3(x) {
        return x.re === 0 && x.im === 0;
      },
      BigNumber: function BigNumber2(x) {
        return x.isZero() || x.isNaN();
      },
      Unit: typed3.referToSelf((self2) => (x) => typed3.find(self2, x.valueType())(x.value)),
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/logical/or.js
  var name82 = "or";
  var dependencies82 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
  var createOr = /* @__PURE__ */ factory(name82, dependencies82, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo05xSfSf = createMatAlgo05xSfSf({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name82, {
      "number, number": orNumber,
      "Complex, Complex": function ComplexComplex(x, y2) {
        return x.re !== 0 || x.im !== 0 || y2.re !== 0 || y2.im !== 0;
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return !x.isZero() && !x.isNaN() || !y2.isZero() && !y2.isNaN();
      },
      "Unit, Unit": typed3.referToSelf((self2) => (x, y2) => self2(x.value || 0, y2.value || 0))
    }, matrixAlgorithmSuite({
      SS: matAlgo05xSfSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/logical/xor.js
  var name83 = "xor";
  var dependencies83 = ["typed", "matrix", "DenseMatrix", "concat"];
  var createXor = /* @__PURE__ */ factory(name83, dependencies83, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name83, {
      "number, number": xorNumber,
      "Complex, Complex": function ComplexComplex(x, y2) {
        return (x.re !== 0 || x.im !== 0) !== (y2.re !== 0 || y2.im !== 0);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return (!x.isZero() && !x.isNaN()) !== (!y2.isZero() && !y2.isNaN());
      },
      "Unit, Unit": typed3.referToSelf((self2) => (x, y2) => self2(x.value || 0, y2.value || 0))
    }, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/matrix/concat.js
  var name84 = "concat";
  var dependencies84 = ["typed", "matrix", "isInteger"];
  var createConcat = /* @__PURE__ */ factory(name84, dependencies84, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      isInteger: isInteger3
    } = _ref;
    return typed3(name84, {
      // TODO: change signature to '...Array | Matrix, dim?' when supported
      "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
        var i3;
        var len = args.length;
        var dim = -1;
        var prevDim;
        var asMatrix = false;
        var matrices = [];
        for (i3 = 0; i3 < len; i3++) {
          var arg2 = args[i3];
          if (isMatrix(arg2)) {
            asMatrix = true;
          }
          if (isNumber(arg2) || isBigNumber(arg2)) {
            if (i3 !== len - 1) {
              throw new Error("Dimension must be specified as last argument");
            }
            prevDim = dim;
            dim = arg2.valueOf();
            if (!isInteger3(dim)) {
              throw new TypeError("Integer number expected for dimension");
            }
            if (dim < 0 || i3 > 0 && dim > prevDim) {
              throw new IndexError(dim, prevDim + 1);
            }
          } else {
            var m = clone(arg2).valueOf();
            var size2 = arraySize(m);
            matrices[i3] = m;
            prevDim = dim;
            dim = size2.length - 1;
            if (i3 > 0 && dim !== prevDim) {
              throw new DimensionError(prevDim + 1, dim + 1);
            }
          }
        }
        if (matrices.length === 0) {
          throw new SyntaxError("At least one matrix expected");
        }
        var res = matrices.shift();
        while (matrices.length) {
          res = concat(res, matrices.shift(), dim);
        }
        return asMatrix ? matrix2(res) : res;
      },
      "...string": function string2(args) {
        return args.join("");
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/column.js
  var name85 = "column";
  var dependencies85 = ["typed", "Index", "matrix", "range"];
  var createColumn = /* @__PURE__ */ factory(name85, dependencies85, (_ref) => {
    var {
      typed: typed3,
      Index: Index2,
      matrix: matrix2,
      range: range2
    } = _ref;
    return typed3(name85, {
      "Matrix, number": _column,
      "Array, number": function ArrayNumber(value, column2) {
        return _column(matrix2(clone(value)), column2).valueOf();
      }
    });
    function _column(value, column2) {
      if (value.size().length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(column2, value.size()[1]);
      var rowRange = range2(0, value.size()[0]);
      var index2 = new Index2(rowRange, column2);
      var result = value.subset(index2);
      return isMatrix(result) ? result : matrix2([[result]]);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/count.js
  var name86 = "count";
  var dependencies86 = ["typed", "size", "prod"];
  var createCount = /* @__PURE__ */ factory(name86, dependencies86, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      prod: prod2
    } = _ref;
    return typed3(name86, {
      string: function string2(x) {
        return x.length;
      },
      "Matrix | Array": function MatrixArray(x) {
        return prod2(size2(x));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/cross.js
  var name87 = "cross";
  var dependencies87 = ["typed", "matrix", "subtract", "multiply"];
  var createCross = /* @__PURE__ */ factory(name87, dependencies87, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      subtract: subtract2,
      multiply: multiply2
    } = _ref;
    return typed3(name87, {
      "Matrix, Matrix": function MatrixMatrix(x, y2) {
        return matrix2(_cross(x.toArray(), y2.toArray()));
      },
      "Matrix, Array": function MatrixArray(x, y2) {
        return matrix2(_cross(x.toArray(), y2));
      },
      "Array, Matrix": function ArrayMatrix(x, y2) {
        return matrix2(_cross(x, y2.toArray()));
      },
      "Array, Array": _cross
    });
    function _cross(x, y2) {
      var highestDimension = Math.max(arraySize(x).length, arraySize(y2).length);
      x = squeeze(x);
      y2 = squeeze(y2);
      var xSize = arraySize(x);
      var ySize = arraySize(y2);
      if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
        throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
      }
      var product3 = [subtract2(multiply2(x[1], y2[2]), multiply2(x[2], y2[1])), subtract2(multiply2(x[2], y2[0]), multiply2(x[0], y2[2])), subtract2(multiply2(x[0], y2[1]), multiply2(x[1], y2[0]))];
      if (highestDimension > 1) {
        return [product3];
      } else {
        return product3;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/diag.js
  var name88 = "diag";
  var dependencies88 = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
  var createDiag = /* @__PURE__ */ factory(name88, dependencies88, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    return typed3(name88, {
      // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
      Array: function Array2(x) {
        return _diag(x, 0, arraySize(x), null);
      },
      "Array, number": function ArrayNumber(x, k) {
        return _diag(x, k, arraySize(x), null);
      },
      "Array, BigNumber": function ArrayBigNumber(x, k) {
        return _diag(x, k.toNumber(), arraySize(x), null);
      },
      "Array, string": function ArrayString(x, format5) {
        return _diag(x, 0, arraySize(x), format5);
      },
      "Array, number, string": function ArrayNumberString(x, k, format5) {
        return _diag(x, k, arraySize(x), format5);
      },
      "Array, BigNumber, string": function ArrayBigNumberString(x, k, format5) {
        return _diag(x, k.toNumber(), arraySize(x), format5);
      },
      Matrix: function Matrix2(x) {
        return _diag(x, 0, x.size(), x.storage());
      },
      "Matrix, number": function MatrixNumber(x, k) {
        return _diag(x, k, x.size(), x.storage());
      },
      "Matrix, BigNumber": function MatrixBigNumber(x, k) {
        return _diag(x, k.toNumber(), x.size(), x.storage());
      },
      "Matrix, string": function MatrixString(x, format5) {
        return _diag(x, 0, x.size(), format5);
      },
      "Matrix, number, string": function MatrixNumberString(x, k, format5) {
        return _diag(x, k, x.size(), format5);
      },
      "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format5) {
        return _diag(x, k.toNumber(), x.size(), format5);
      }
    });
    function _diag(x, k, size2, format5) {
      if (!isInteger(k)) {
        throw new TypeError("Second parameter in function diag must be an integer");
      }
      var kSuper = k > 0 ? k : 0;
      var kSub = k < 0 ? -k : 0;
      switch (size2.length) {
        case 1:
          return _createDiagonalMatrix(x, k, format5, size2[0], kSub, kSuper);
        case 2:
          return _getDiagonal(x, k, format5, size2, kSub, kSuper);
      }
      throw new RangeError("Matrix for function diag must be 2 dimensional");
    }
    function _createDiagonalMatrix(x, k, format5, l, kSub, kSuper) {
      var ms = [l + kSub, l + kSuper];
      if (format5 && format5 !== "sparse" && format5 !== "dense") {
        throw new TypeError("Unknown matrix type ".concat(format5, '"'));
      }
      var m = format5 === "sparse" ? SparseMatrix2.diagonal(ms, x, k) : DenseMatrix2.diagonal(ms, x, k);
      return format5 !== null ? m : m.valueOf();
    }
    function _getDiagonal(x, k, format5, s, kSub, kSuper) {
      if (isMatrix(x)) {
        var dm = x.diagonal(k);
        if (format5 !== null) {
          if (format5 !== dm.storage()) {
            return matrix2(dm, format5);
          }
          return dm;
        }
        return dm.valueOf();
      }
      var n = Math.min(s[0] - kSub, s[1] - kSuper);
      var vector = [];
      for (var i3 = 0; i3 < n; i3++) {
        vector[i3] = x[i3 + kSub][i3 + kSuper];
      }
      return format5 !== null ? matrix2(vector) : vector;
    }
  });

  // node_modules/mathjs/lib/esm/utils/applyCallback.js
  var import_typed_function2 = __toESM(require_typed_function(), 1);
  function applyCallback(callback, value, index2, array, mappingFnName) {
    if (import_typed_function2.default.isTypedFunction(callback)) {
      var args3 = [value, index2, array];
      var signature3 = import_typed_function2.default.resolve(callback, args3);
      if (signature3) {
        return tryWithArgs(signature3.implementation, args3);
      }
      var args2 = [value, index2];
      var signature2 = import_typed_function2.default.resolve(callback, args2);
      if (signature2) {
        return tryWithArgs(signature2.implementation, args2);
      }
      var args1 = [value];
      var signature1 = import_typed_function2.default.resolve(callback, args1);
      if (signature1) {
        return tryWithArgs(signature1.implementation, args1);
      }
      return tryWithArgs(callback, args3);
    } else {
      return callback(value, index2, array);
    }
    function tryWithArgs(signature, args) {
      try {
        return signature.apply(signature, args);
      } catch (err) {
        var _err$data;
        if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === "wrongType") {
          var argsDesc = [];
          argsDesc.push("value: ".concat(typeOf(value)));
          if (args.length >= 2) {
            argsDesc.push("index: ".concat(typeOf(index2)));
          }
          if (args.length >= 3) {
            argsDesc.push("array: ".concat(typeOf(array)));
          }
          throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "".concat(callback.name, "(").concat(argsDesc.join(", "), ") at index ").concat(JSON.stringify(index2)));
        } else {
          throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "to function ".concat(callback.name, ": ").concat(err.message));
        }
      }
    }
  }

  // node_modules/mathjs/lib/esm/function/matrix/filter.js
  var name89 = "filter";
  var dependencies89 = ["typed"];
  var createFilter = /* @__PURE__ */ factory(name89, dependencies89, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3("filter", {
      "Array, function": _filterCallback,
      "Matrix, function": function MatrixFunction(x, test) {
        return x.create(_filterCallback(x.toArray(), test));
      },
      "Array, RegExp": filterRegExp,
      "Matrix, RegExp": function MatrixRegExp(x, test) {
        return x.create(filterRegExp(x.toArray(), test));
      }
    });
  });
  function _filterCallback(x, callback) {
    return filter(x, function(value, index2, array) {
      return applyCallback(callback, value, [index2], array, "filter");
    });
  }

  // node_modules/mathjs/lib/esm/function/matrix/flatten.js
  var name90 = "flatten";
  var dependencies90 = ["typed", "matrix"];
  var createFlatten = /* @__PURE__ */ factory(name90, dependencies90, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2
    } = _ref;
    return typed3(name90, {
      Array: function Array2(x) {
        return flatten(x);
      },
      Matrix: function Matrix2(x) {
        var flat = flatten(x.toArray());
        return matrix2(flat);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/forEach.js
  var name91 = "forEach";
  var dependencies91 = ["typed"];
  var createForEach = /* @__PURE__ */ factory(name91, dependencies91, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name91, {
      "Array, function": _forEach,
      "Matrix, function": function MatrixFunction(x, callback) {
        x.forEach(callback);
      }
    });
  });
  function _forEach(array, callback) {
    var recurse = function recurse2(value, index2) {
      if (Array.isArray(value)) {
        forEach(value, function(child, i3) {
          recurse2(child, index2.concat(i3));
        });
      } else {
        return applyCallback(callback, value, index2, array, "forEach");
      }
    };
    recurse(array, []);
  }

  // node_modules/mathjs/lib/esm/function/matrix/getMatrixDataType.js
  var name92 = "getMatrixDataType";
  var dependencies92 = ["typed"];
  var createGetMatrixDataType = /* @__PURE__ */ factory(name92, dependencies92, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name92, {
      Array: function Array2(x) {
        return getArrayDataType(x, typeOf);
      },
      Matrix: function Matrix2(x) {
        return x.getDataType();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/identity.js
  var name93 = "identity";
  var dependencies93 = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
  var createIdentity = /* @__PURE__ */ factory(name93, dependencies93, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      BigNumber: BigNumber2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    return typed3(name93, {
      "": function _() {
        return config4.matrix === "Matrix" ? matrix2([]) : [];
      },
      string: function string2(format5) {
        return matrix2(format5);
      },
      "number | BigNumber": function numberBigNumber(rows) {
        return _identity(rows, rows, config4.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, string": function numberBigNumberString(rows, format5) {
        return _identity(rows, rows, format5);
      },
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
        return _identity(rows, cols, config4.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format5) {
        return _identity(rows, cols, format5);
      },
      Array: function Array2(size2) {
        return _identityVector(size2);
      },
      "Array, string": function ArrayString(size2, format5) {
        return _identityVector(size2, format5);
      },
      Matrix: function Matrix2(size2) {
        return _identityVector(size2.valueOf(), size2.storage());
      },
      "Matrix, string": function MatrixString(size2, format5) {
        return _identityVector(size2.valueOf(), format5);
      }
    });
    function _identityVector(size2, format5) {
      switch (size2.length) {
        case 0:
          return format5 ? matrix2(format5) : [];
        case 1:
          return _identity(size2[0], size2[0], format5);
        case 2:
          return _identity(size2[0], size2[1], format5);
        default:
          throw new Error("Vector containing two values expected");
      }
    }
    function _identity(rows, cols, format5) {
      var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
      if (isBigNumber(rows))
        rows = rows.toNumber();
      if (isBigNumber(cols))
        cols = cols.toNumber();
      if (!isInteger(rows) || rows < 1) {
        throw new Error("Parameters in function identity must be positive integers");
      }
      if (!isInteger(cols) || cols < 1) {
        throw new Error("Parameters in function identity must be positive integers");
      }
      var one = Big ? new BigNumber2(1) : 1;
      var defaultValue = Big ? new Big(0) : 0;
      var size2 = [rows, cols];
      if (format5) {
        if (format5 === "sparse") {
          return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
        }
        if (format5 === "dense") {
          return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
        }
        throw new TypeError('Unknown matrix type "'.concat(format5, '"'));
      }
      var res = resize([], size2, defaultValue);
      var minimum = rows < cols ? rows : cols;
      for (var d = 0; d < minimum; d++) {
        res[d][d] = one;
      }
      return res;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/kron.js
  var name94 = "kron";
  var dependencies94 = ["typed", "matrix", "multiplyScalar"];
  var createKron = /* @__PURE__ */ factory(name94, dependencies94, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      multiplyScalar: multiplyScalar2
    } = _ref;
    return typed3(name94, {
      "Matrix, Matrix": function MatrixMatrix(x, y2) {
        return matrix2(_kron(x.toArray(), y2.toArray()));
      },
      "Matrix, Array": function MatrixArray(x, y2) {
        return matrix2(_kron(x.toArray(), y2));
      },
      "Array, Matrix": function ArrayMatrix(x, y2) {
        return matrix2(_kron(x, y2.toArray()));
      },
      "Array, Array": _kron
    });
    function _kron(a, b) {
      if (arraySize(a).length === 1) {
        a = [a];
      }
      if (arraySize(b).length === 1) {
        b = [b];
      }
      if (arraySize(a).length > 2 || arraySize(b).length > 2) {
        throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
      }
      var t = [];
      var r = [];
      return a.map(function(a2) {
        return b.map(function(b2) {
          r = [];
          t.push(r);
          return a2.map(function(y2) {
            return b2.map(function(x) {
              return r.push(multiplyScalar2(y2, x));
            });
          });
        });
      }) && t;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/map.js
  var name95 = "map";
  var dependencies95 = ["typed"];
  var createMap2 = /* @__PURE__ */ factory(name95, dependencies95, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name95, {
      "Array, function": _map,
      "Matrix, function": function MatrixFunction(x, callback) {
        return x.map(callback);
      }
    });
  });
  function _map(array, callback) {
    var recurse = function recurse2(value, index2) {
      if (Array.isArray(value)) {
        return value.map(function(child, i3) {
          return recurse2(child, index2.concat(i3));
        });
      } else {
        return applyCallback(callback, value, index2, array, "map");
      }
    };
    return recurse(array, []);
  }

  // node_modules/mathjs/lib/esm/function/matrix/diff.js
  var name96 = "diff";
  var dependencies96 = ["typed", "matrix", "subtract", "number"];
  var createDiff = /* @__PURE__ */ factory(name96, dependencies96, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      subtract: subtract2,
      number: number2
    } = _ref;
    return typed3(name96, {
      "Array | Matrix": function ArrayMatrix(arr) {
        if (isMatrix(arr)) {
          return matrix2(_diff(arr.toArray()));
        } else {
          return _diff(arr);
        }
      },
      "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
        if (!isInteger(dim))
          throw new RangeError("Dimension must be a whole number");
        if (isMatrix(arr)) {
          return matrix2(_recursive(arr.toArray(), dim));
        } else {
          return _recursive(arr, dim);
        }
      },
      "Array, BigNumber": typed3.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number2(dim))),
      "Matrix, BigNumber": typed3.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number2(dim)))
    });
    function _recursive(arr, dim) {
      if (isMatrix(arr)) {
        arr = arr.toArray();
      }
      if (!Array.isArray(arr)) {
        throw RangeError("Array/Matrix does not have that many dimensions");
      }
      if (dim > 0) {
        var result = [];
        arr.forEach((element) => {
          result.push(_recursive(element, dim - 1));
        });
        return result;
      } else if (dim === 0) {
        return _diff(arr);
      } else {
        throw RangeError("Cannot have negative dimension");
      }
    }
    function _diff(arr) {
      var result = [];
      var size2 = arr.length;
      for (var i3 = 1; i3 < size2; i3++) {
        result.push(_ElementDiff(arr[i3 - 1], arr[i3]));
      }
      return result;
    }
    function _ElementDiff(obj1, obj2) {
      if (isMatrix(obj1))
        obj1 = obj1.toArray();
      if (isMatrix(obj2))
        obj2 = obj2.toArray();
      var obj1IsArray = Array.isArray(obj1);
      var obj2IsArray = Array.isArray(obj2);
      if (obj1IsArray && obj2IsArray) {
        return _ArrayDiff(obj1, obj2);
      }
      if (!obj1IsArray && !obj2IsArray) {
        return subtract2(obj2, obj1);
      }
      throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
    }
    function _ArrayDiff(arr1, arr2) {
      if (arr1.length !== arr2.length) {
        throw RangeError("Not all sub-arrays have the same length");
      }
      var result = [];
      var size2 = arr1.length;
      for (var i3 = 0; i3 < size2; i3++) {
        result.push(_ElementDiff(arr1[i3], arr2[i3]));
      }
      return result;
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ones.js
  var name97 = "ones";
  var dependencies97 = ["typed", "config", "matrix", "BigNumber"];
  var createOnes = /* @__PURE__ */ factory(name97, dependencies97, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      BigNumber: BigNumber2
    } = _ref;
    return typed3("ones", {
      "": function _() {
        return config4.matrix === "Array" ? _ones([]) : _ones([], "default");
      },
      // math.ones(m, n, p, ..., format)
      // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
      "...number | BigNumber | string": function numberBigNumberString(size2) {
        var last = size2[size2.length - 1];
        if (typeof last === "string") {
          var format5 = size2.pop();
          return _ones(size2, format5);
        } else if (config4.matrix === "Array") {
          return _ones(size2);
        } else {
          return _ones(size2, "default");
        }
      },
      Array: _ones,
      Matrix: function Matrix2(size2) {
        var format5 = size2.storage();
        return _ones(size2.valueOf(), format5);
      },
      "Array | Matrix, string": function ArrayMatrixString(size2, format5) {
        return _ones(size2.valueOf(), format5);
      }
    });
    function _ones(size2, format5) {
      var hasBigNumbers = _normalize(size2);
      var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
      _validate2(size2);
      if (format5) {
        var m = matrix2(format5);
        if (size2.length > 0) {
          return m.resize(size2, defaultValue);
        }
        return m;
      } else {
        var arr = [];
        if (size2.length > 0) {
          return resize(arr, size2, defaultValue);
        }
        return arr;
      }
    }
    function _normalize(size2) {
      var hasBigNumbers = false;
      size2.forEach(function(value, index2, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index2] = value.toNumber();
        }
      });
      return hasBigNumbers;
    }
    function _validate2(size2) {
      size2.forEach(function(value) {
        if (typeof value !== "number" || !isInteger(value) || value < 0) {
          throw new Error("Parameters in function ones must be positive integers");
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/utils/noop.js
  function noBignumber() {
    throw new Error('No "bignumber" implementation available');
  }
  function noFraction() {
    throw new Error('No "fraction" implementation available');
  }
  function noMatrix() {
    throw new Error('No "matrix" implementation available');
  }

  // node_modules/mathjs/lib/esm/function/matrix/range.js
  var name98 = "range";
  var dependencies98 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
  var createRange = /* @__PURE__ */ factory(name98, dependencies98, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      bignumber: bignumber2,
      smaller: smaller2,
      smallerEq: smallerEq2,
      larger: larger2,
      largerEq: largerEq2,
      add: add3,
      isPositive: isPositive2
    } = _ref;
    return typed3(name98, {
      // TODO: simplify signatures when typed-function supports default values and optional arguments
      // TODO: a number or boolean should not be converted to string here
      string: _strRange,
      "string, boolean": _strRange,
      "number, number": function numberNumber(start, end) {
        return _out(_range(start, end, 1, false));
      },
      "number, number, number": function numberNumberNumber(start, end, step) {
        return _out(_range(start, end, step, false));
      },
      "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
        return _out(_range(start, end, 1, includeEnd));
      },
      "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
        return _out(_range(start, end, step, includeEnd));
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
        var BigNumber2 = start.constructor;
        return _out(_range(start, end, new BigNumber2(1), false));
      },
      "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
        return _out(_range(start, end, step, false));
      },
      "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
        var BigNumber2 = start.constructor;
        return _out(_range(start, end, new BigNumber2(1), includeEnd));
      },
      "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
        return _out(_range(start, end, step, includeEnd));
      },
      "Unit, Unit, Unit": function UnitUnitUnit(start, end, step) {
        return _out(_range(start, end, step, false));
      },
      "Unit, Unit, Unit, boolean": function UnitUnitUnitBoolean(start, end, step, includeEnd) {
        return _out(_range(start, end, step, includeEnd));
      }
    });
    function _out(arr) {
      if (config4.matrix === "Matrix") {
        return matrix2 ? matrix2(arr) : noMatrix();
      }
      return arr;
    }
    function _strRange(str, includeEnd) {
      var r = _parse(str);
      if (!r) {
        throw new SyntaxError('String "' + str + '" is no valid range');
      }
      if (config4.number === "BigNumber") {
        if (bignumber2 === void 0) {
          noBignumber();
        }
        return _out(_range(bignumber2(r.start), bignumber2(r.end), bignumber2(r.step)), includeEnd);
      } else {
        return _out(_range(r.start, r.end, r.step, includeEnd));
      }
    }
    function _range(start, end, step, includeEnd) {
      var array = [];
      var ongoing = isPositive2(step) ? includeEnd ? smallerEq2 : smaller2 : includeEnd ? largerEq2 : larger2;
      var x = start;
      while (ongoing(x, end)) {
        array.push(x);
        x = add3(x, step);
      }
      return array;
    }
    function _parse(str) {
      var args = str.split(":");
      var nums = args.map(function(arg2) {
        return Number(arg2);
      });
      var invalid = nums.some(function(num) {
        return isNaN(num);
      });
      if (invalid) {
        return null;
      }
      switch (nums.length) {
        case 2:
          return {
            start: nums[0],
            end: nums[1],
            step: 1
          };
        case 3:
          return {
            start: nums[0],
            end: nums[2],
            step: nums[1]
          };
        default:
          return null;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/reshape.js
  var name99 = "reshape";
  var dependencies99 = ["typed", "isInteger", "matrix"];
  var createReshape = /* @__PURE__ */ factory(name99, dependencies99, (_ref) => {
    var {
      typed: typed3,
      isInteger: isInteger3
    } = _ref;
    return typed3(name99, {
      "Matrix, Array": function MatrixArray(x, sizes) {
        return x.reshape(sizes, true);
      },
      "Array, Array": function ArrayArray(x, sizes) {
        sizes.forEach(function(size2) {
          if (!isInteger3(size2)) {
            throw new TypeError("Invalid size for dimension: " + size2);
          }
        });
        return reshape(x, sizes);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/resize.js
  var name100 = "resize";
  var dependencies100 = ["config", "matrix"];
  var createResize = /* @__PURE__ */ factory(name100, dependencies100, (_ref) => {
    var {
      config: config4,
      matrix: matrix2
    } = _ref;
    return function resize3(x, size2, defaultValue) {
      if (arguments.length !== 2 && arguments.length !== 3) {
        throw new ArgumentsError("resize", arguments.length, 2, 3);
      }
      if (isMatrix(size2)) {
        size2 = size2.valueOf();
      }
      if (isBigNumber(size2[0])) {
        size2 = size2.map(function(value) {
          return !isBigNumber(value) ? value : value.toNumber();
        });
      }
      if (isMatrix(x)) {
        return x.resize(size2, defaultValue, true);
      }
      if (typeof x === "string") {
        return _resizeString(x, size2, defaultValue);
      }
      var asMatrix = Array.isArray(x) ? false : config4.matrix !== "Array";
      if (size2.length === 0) {
        while (Array.isArray(x)) {
          x = x[0];
        }
        return clone(x);
      } else {
        if (!Array.isArray(x)) {
          x = [x];
        }
        x = clone(x);
        var res = resize(x, size2, defaultValue);
        return asMatrix ? matrix2(res) : res;
      }
    };
    function _resizeString(str, size2, defaultChar) {
      if (defaultChar !== void 0) {
        if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
          throw new TypeError("Single character expected as defaultValue");
        }
      } else {
        defaultChar = " ";
      }
      if (size2.length !== 1) {
        throw new DimensionError(size2.length, 1);
      }
      var len = size2[0];
      if (typeof len !== "number" || !isInteger(len)) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format3(size2) + ")");
      }
      if (str.length > len) {
        return str.substring(0, len);
      } else if (str.length < len) {
        var res = str;
        for (var i3 = 0, ii = len - str.length; i3 < ii; i3++) {
          res += defaultChar;
        }
        return res;
      } else {
        return str;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/rotate.js
  var name101 = "rotate";
  var dependencies101 = ["typed", "multiply", "rotationMatrix"];
  var createRotate = /* @__PURE__ */ factory(name101, dependencies101, (_ref) => {
    var {
      typed: typed3,
      multiply: multiply2,
      rotationMatrix: rotationMatrix2
    } = _ref;
    return typed3(name101, {
      "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w2, theta) {
        _validateSize(w2, 2);
        var matrixRes = multiply2(rotationMatrix2(theta), w2);
        return matrixRes.toArray();
      },
      "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w2, theta) {
        _validateSize(w2, 2);
        return multiply2(rotationMatrix2(theta), w2);
      },
      "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w2, theta, v) {
        _validateSize(w2, 3);
        var matrixRes = multiply2(rotationMatrix2(theta, v), w2);
        return matrixRes;
      },
      "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w2, theta, v) {
        _validateSize(w2, 3);
        return multiply2(rotationMatrix2(theta, v), w2);
      }
    });
    function _validateSize(v, expectedSize) {
      var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
      if (actualSize.length > 2) {
        throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
      }
      if (actualSize.length === 2 && actualSize[1] !== 1) {
        throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
      }
      if (actualSize[0] !== expectedSize) {
        throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/rotationMatrix.js
  var name102 = "rotationMatrix";
  var dependencies102 = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
  var createRotationMatrix = /* @__PURE__ */ factory(name102, dependencies102, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      multiplyScalar: multiplyScalar2,
      addScalar: addScalar2,
      unaryMinus: unaryMinus2,
      norm: norm2,
      BigNumber: BigNumber2,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2,
      cos: cos3,
      sin: sin3
    } = _ref;
    return typed3(name102, {
      "": function _() {
        return config4.matrix === "Matrix" ? matrix2([]) : [];
      },
      string: function string2(format5) {
        return matrix2(format5);
      },
      "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
        return _rotationMatrix2x2(theta, config4.matrix === "Matrix" ? "dense" : void 0);
      },
      "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format5) {
        return _rotationMatrix2x2(theta, format5);
      },
      "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
        var matrixV = matrix2(v);
        _validateVector(matrixV);
        return _rotationMatrix3x3(theta, matrixV, void 0);
      },
      "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
        _validateVector(v);
        var storageType = v.storage() || (config4.matrix === "Matrix" ? "dense" : void 0);
        return _rotationMatrix3x3(theta, v, storageType);
      },
      "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format5) {
        var matrixV = matrix2(v);
        _validateVector(matrixV);
        return _rotationMatrix3x3(theta, matrixV, format5);
      },
      "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format5) {
        _validateVector(v);
        return _rotationMatrix3x3(theta, v, format5);
      }
    });
    function _rotationMatrix2x2(theta, format5) {
      var Big = isBigNumber(theta);
      var minusOne = Big ? new BigNumber2(-1) : -1;
      var cosTheta = cos3(theta);
      var sinTheta = sin3(theta);
      var data = [[cosTheta, multiplyScalar2(minusOne, sinTheta)], [sinTheta, cosTheta]];
      return _convertToFormat(data, format5);
    }
    function _validateVector(v) {
      var size2 = v.size();
      if (size2.length < 1 || size2[0] !== 3) {
        throw new RangeError("Vector must be of dimensions 1x3");
      }
    }
    function _mul(array) {
      return array.reduce((p, curr) => multiplyScalar2(p, curr));
    }
    function _convertToFormat(data, format5) {
      if (format5) {
        if (format5 === "sparse") {
          return new SparseMatrix2(data);
        }
        if (format5 === "dense") {
          return new DenseMatrix2(data);
        }
        throw new TypeError('Unknown matrix type "'.concat(format5, '"'));
      }
      return data;
    }
    function _rotationMatrix3x3(theta, v, format5) {
      var normV = norm2(v);
      if (normV === 0) {
        throw new RangeError("Rotation around zero vector");
      }
      var Big = isBigNumber(theta) ? BigNumber2 : null;
      var one = Big ? new Big(1) : 1;
      var minusOne = Big ? new Big(-1) : -1;
      var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
      var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
      var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
      var c = cos3(theta);
      var oneMinusC = addScalar2(one, unaryMinus2(c));
      var s = sin3(theta);
      var r11 = addScalar2(c, _mul([vx, vx, oneMinusC]));
      var r12 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
      var r13 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
      var r21 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
      var r22 = addScalar2(c, _mul([vy, vy, oneMinusC]));
      var r23 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
      var r31 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
      var r32 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
      var r33 = addScalar2(c, _mul([vz, vz, oneMinusC]));
      var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
      return _convertToFormat(data, format5);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/row.js
  var name103 = "row";
  var dependencies103 = ["typed", "Index", "matrix", "range"];
  var createRow = /* @__PURE__ */ factory(name103, dependencies103, (_ref) => {
    var {
      typed: typed3,
      Index: Index2,
      matrix: matrix2,
      range: range2
    } = _ref;
    return typed3(name103, {
      "Matrix, number": _row,
      "Array, number": function ArrayNumber(value, row2) {
        return _row(matrix2(clone(value)), row2).valueOf();
      }
    });
    function _row(value, row2) {
      if (value.size().length !== 2) {
        throw new Error("Only two dimensional matrix is supported");
      }
      validateIndex(row2, value.size()[0]);
      var columnRange = range2(0, value.size()[1]);
      var index2 = new Index2(row2, columnRange);
      var result = value.subset(index2);
      return isMatrix(result) ? result : matrix2([[result]]);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/size.js
  var name104 = "size";
  var dependencies104 = ["typed", "config", "?matrix"];
  var createSize = /* @__PURE__ */ factory(name104, dependencies104, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2
    } = _ref;
    return typed3(name104, {
      Matrix: function Matrix2(x) {
        return x.create(x.size());
      },
      Array: arraySize,
      string: function string2(x) {
        return config4.matrix === "Array" ? [x.length] : matrix2([x.length]);
      },
      "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
        return config4.matrix === "Array" ? [] : matrix2 ? matrix2([]) : noMatrix();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/squeeze.js
  var name105 = "squeeze";
  var dependencies105 = ["typed", "matrix"];
  var createSqueeze = /* @__PURE__ */ factory(name105, dependencies105, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2
    } = _ref;
    return typed3(name105, {
      Array: function Array2(x) {
        return squeeze(clone(x));
      },
      Matrix: function Matrix2(x) {
        var res = squeeze(x.toArray());
        return Array.isArray(res) ? matrix2(res) : res;
      },
      any: function any(x) {
        return clone(x);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/subset.js
  var name106 = "subset";
  var dependencies106 = ["typed", "matrix", "zeros", "add"];
  var createSubset = /* @__PURE__ */ factory(name106, dependencies106, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      zeros: zeros3,
      add: add3
    } = _ref;
    return typed3(name106, {
      // get subset
      "Matrix, Index": function MatrixIndex(value, index2) {
        if (isEmptyIndex(index2)) {
          return matrix2();
        }
        validateIndexSourceSize(value, index2);
        return value.subset(index2);
      },
      "Array, Index": typed3.referTo("Matrix, Index", function(subsetRef) {
        return function(value, index2) {
          var subsetResult = subsetRef(matrix2(value), index2);
          return index2.isScalar() ? subsetResult : subsetResult.valueOf();
        };
      }),
      "Object, Index": _getObjectProperty,
      "string, Index": _getSubstring,
      // set subset
      "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index2, replacement, defaultValue) {
        if (isEmptyIndex(index2)) {
          return value;
        }
        validateIndexSourceSize(value, index2);
        return value.clone().subset(index2, _broadcastReplacement(replacement, index2), defaultValue);
      },
      "Array, Index, any, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
        return function(value, index2, replacement, defaultValue) {
          var subsetResult = subsetRef(matrix2(value), index2, replacement, defaultValue);
          return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
        };
      }),
      "Array, Index, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
        return function(value, index2, replacement) {
          return subsetRef(matrix2(value), index2, replacement, void 0).valueOf();
        };
      }),
      "Matrix, Index, any": typed3.referTo("Matrix, Index, any, any", function(subsetRef) {
        return function(value, index2, replacement) {
          return subsetRef(value, index2, replacement, void 0);
        };
      }),
      "string, Index, string": _setSubstring,
      "string, Index, string, string": _setSubstring,
      "Object, Index, any": _setObjectProperty
    });
    function _broadcastReplacement(replacement, index2) {
      if (typeof replacement === "string") {
        throw new Error("can't boradcast a string");
      }
      if (index2._isScalar) {
        return replacement;
      }
      var indexSize = index2.size();
      if (indexSize.every((d) => d > 0)) {
        try {
          return add3(replacement, zeros3(indexSize));
        } catch (error) {
          return replacement;
        }
      } else {
        return replacement;
      }
    }
  });
  function _getSubstring(str, index2) {
    if (!isIndex(index2)) {
      throw new TypeError("Index expected");
    }
    if (isEmptyIndex(index2)) {
      return "";
    }
    validateIndexSourceSize(Array.from(str), index2);
    if (index2.size().length !== 1) {
      throw new DimensionError(index2.size().length, 1);
    }
    var strLen = str.length;
    validateIndex(index2.min()[0], strLen);
    validateIndex(index2.max()[0], strLen);
    var range2 = index2.dimension(0);
    var substr = "";
    range2.forEach(function(v) {
      substr += str.charAt(v);
    });
    return substr;
  }
  function _setSubstring(str, index2, replacement, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Index expected");
    }
    if (isEmptyIndex(index2)) {
      return str;
    }
    validateIndexSourceSize(Array.from(str), index2);
    if (index2.size().length !== 1) {
      throw new DimensionError(index2.size().length, 1);
    }
    if (defaultValue !== void 0) {
      if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultValue = " ";
    }
    var range2 = index2.dimension(0);
    var len = range2.size()[0];
    if (len !== replacement.length) {
      throw new DimensionError(range2.size()[0], replacement.length);
    }
    var strLen = str.length;
    validateIndex(index2.min()[0]);
    validateIndex(index2.max()[0]);
    var chars = [];
    for (var i3 = 0; i3 < strLen; i3++) {
      chars[i3] = str.charAt(i3);
    }
    range2.forEach(function(v, i4) {
      chars[v] = replacement.charAt(i4[0]);
    });
    if (chars.length > strLen) {
      for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
        if (!chars[_i]) {
          chars[_i] = defaultValue;
        }
      }
    }
    return chars.join("");
  }
  function _getObjectProperty(object, index2) {
    if (isEmptyIndex(index2)) {
      return void 0;
    }
    if (index2.size().length !== 1) {
      throw new DimensionError(index2.size(), 1);
    }
    var key = index2.dimension(0);
    if (typeof key !== "string") {
      throw new TypeError("String expected as index to retrieve an object property");
    }
    return getSafeProperty(object, key);
  }
  function _setObjectProperty(object, index2, replacement) {
    if (isEmptyIndex(index2)) {
      return object;
    }
    if (index2.size().length !== 1) {
      throw new DimensionError(index2.size(), 1);
    }
    var key = index2.dimension(0);
    if (typeof key !== "string") {
      throw new TypeError("String expected as index to retrieve an object property");
    }
    var updated = clone(object);
    setSafeProperty(updated, key, replacement);
    return updated;
  }

  // node_modules/mathjs/lib/esm/function/matrix/transpose.js
  var name107 = "transpose";
  var dependencies107 = ["typed", "matrix"];
  var createTranspose = /* @__PURE__ */ factory(name107, dependencies107, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2
    } = _ref;
    return typed3(name107, {
      Array: (x) => transposeMatrix(matrix2(x)).valueOf(),
      Matrix: transposeMatrix,
      any: clone
      // scalars
    });
    function transposeMatrix(x) {
      var size2 = x.size();
      var c;
      switch (size2.length) {
        case 1:
          c = x.clone();
          break;
        case 2:
          {
            var rows = size2[0];
            var columns = size2[1];
            if (columns === 0) {
              throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format3(size2) + ")");
            }
            switch (x.storage()) {
              case "dense":
                c = _denseTranspose(x, rows, columns);
                break;
              case "sparse":
                c = _sparseTranspose(x, rows, columns);
                break;
            }
          }
          break;
        default:
          throw new RangeError("Matrix must be a vector or two dimensional (size: " + format3(size2) + ")");
      }
      return c;
    }
    function _denseTranspose(m, rows, columns) {
      var data = m._data;
      var transposed = [];
      var transposedRow;
      for (var j = 0; j < columns; j++) {
        transposedRow = transposed[j] = [];
        for (var i3 = 0; i3 < rows; i3++) {
          transposedRow[i3] = clone(data[i3][j]);
        }
      }
      return m.createDenseMatrix({
        data: transposed,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
    function _sparseTranspose(m, rows, columns) {
      var values = m._values;
      var index2 = m._index;
      var ptr = m._ptr;
      var cvalues = values ? [] : void 0;
      var cindex = [];
      var cptr = [];
      var w2 = [];
      for (var x = 0; x < rows; x++) {
        w2[x] = 0;
      }
      var p, l, j;
      for (p = 0, l = index2.length; p < l; p++) {
        w2[index2[p]]++;
      }
      var sum3 = 0;
      for (var i3 = 0; i3 < rows; i3++) {
        cptr.push(sum3);
        sum3 += w2[i3];
        w2[i3] = cptr[i3];
      }
      cptr.push(sum3);
      for (j = 0; j < columns; j++) {
        for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
          var q = w2[index2[k]]++;
          cindex[q] = j;
          if (values) {
            cvalues[q] = clone(values[k]);
          }
        }
      }
      return m.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [columns, rows],
        datatype: m._datatype
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ctranspose.js
  var name108 = "ctranspose";
  var dependencies108 = ["typed", "transpose", "conj"];
  var createCtranspose = /* @__PURE__ */ factory(name108, dependencies108, (_ref) => {
    var {
      typed: typed3,
      transpose: transpose2,
      conj: conj2
    } = _ref;
    return typed3(name108, {
      any: function any(x) {
        return conj2(transpose2(x));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/zeros.js
  var name109 = "zeros";
  var dependencies109 = ["typed", "config", "matrix", "BigNumber"];
  var createZeros = /* @__PURE__ */ factory(name109, dependencies109, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      BigNumber: BigNumber2
    } = _ref;
    return typed3(name109, {
      "": function _() {
        return config4.matrix === "Array" ? _zeros([]) : _zeros([], "default");
      },
      // math.zeros(m, n, p, ..., format)
      // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
      "...number | BigNumber | string": function numberBigNumberString(size2) {
        var last = size2[size2.length - 1];
        if (typeof last === "string") {
          var format5 = size2.pop();
          return _zeros(size2, format5);
        } else if (config4.matrix === "Array") {
          return _zeros(size2);
        } else {
          return _zeros(size2, "default");
        }
      },
      Array: _zeros,
      Matrix: function Matrix2(size2) {
        var format5 = size2.storage();
        return _zeros(size2.valueOf(), format5);
      },
      "Array | Matrix, string": function ArrayMatrixString(size2, format5) {
        return _zeros(size2.valueOf(), format5);
      }
    });
    function _zeros(size2, format5) {
      var hasBigNumbers = _normalize(size2);
      var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
      _validate2(size2);
      if (format5) {
        var m = matrix2(format5);
        if (size2.length > 0) {
          return m.resize(size2, defaultValue);
        }
        return m;
      } else {
        var arr = [];
        if (size2.length > 0) {
          return resize(arr, size2, defaultValue);
        }
        return arr;
      }
    }
    function _normalize(size2) {
      var hasBigNumbers = false;
      size2.forEach(function(value, index2, arr) {
        if (isBigNumber(value)) {
          hasBigNumbers = true;
          arr[index2] = value.toNumber();
        }
      });
      return hasBigNumbers;
    }
    function _validate2(size2) {
      size2.forEach(function(value) {
        if (typeof value !== "number" || !isInteger(value) || value < 0) {
          throw new Error("Parameters in function zeros must be positive integers");
        }
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/fft.js
  var name110 = "fft";
  var dependencies110 = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"];
  var createFft = /* @__PURE__ */ factory(name110, dependencies110, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      addScalar: addScalar2,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      exp: exp3,
      tau: tau3,
      i: I2,
      dotDivide: dotDivide2,
      conj: conj2,
      pow: pow3,
      ceil: ceil3,
      log2: log25
    } = _ref;
    return typed3(name110, {
      Array: _ndFft,
      Matrix: function Matrix2(matrix3) {
        return matrix3.create(_ndFft(matrix3.toArray()));
      }
    });
    function _ndFft(arr) {
      var size2 = arraySize(arr);
      if (size2.length === 1)
        return _fft(arr, size2[0]);
      return _1dFft(arr.map((slice) => _ndFft(slice, size2.slice(1))), 0);
    }
    function _1dFft(arr, dim) {
      var size2 = arraySize(arr);
      if (dim !== 0)
        return new Array(size2[0]).fill(0).map((_, i3) => _1dFft(arr[i3], dim - 1));
      if (size2.length === 1)
        return _fft(arr);
      function _transpose(arr2) {
        var size3 = arraySize(arr2);
        return new Array(size3[1]).fill(0).map((_, j) => new Array(size3[0]).fill(0).map((_2, i3) => arr2[i3][j]));
      }
      return _transpose(_1dFft(_transpose(arr), 1));
    }
    function _czt(arr) {
      var n = arr.length;
      var w2 = exp3(divideScalar2(multiplyScalar2(-1, multiplyScalar2(I2, tau3)), n));
      var chirp = [];
      for (var i3 = 1 - n; i3 < n; i3++) {
        chirp.push(pow3(w2, divideScalar2(pow3(i3, 2), 2)));
      }
      var N2 = pow3(2, ceil3(log25(n + n - 1)));
      var xp = [...new Array(n).fill(0).map((_, i4) => multiplyScalar2(arr[i4], chirp[n - 1 + i4])), ...new Array(N2 - n).fill(0)];
      var ichirp = [...new Array(n + n - 1).fill(0).map((_, i4) => divideScalar2(1, chirp[i4])), ...new Array(N2 - (n + n - 1)).fill(0)];
      var fftXp = _fft(xp);
      var fftIchirp = _fft(ichirp);
      var fftProduct = new Array(N2).fill(0).map((_, i4) => multiplyScalar2(fftXp[i4], fftIchirp[i4]));
      var ifftProduct = dotDivide2(conj2(_ndFft(conj2(fftProduct))), N2);
      var ret = [];
      for (var _i = n - 1; _i < n + n - 1; _i++) {
        ret.push(multiplyScalar2(ifftProduct[_i], chirp[_i]));
      }
      return ret;
    }
    function _fft(arr) {
      var len = arr.length;
      if (len === 1)
        return [arr[0]];
      if (len % 2 === 0) {
        var ret = [..._fft(arr.filter((_, i3) => i3 % 2 === 0), len / 2), ..._fft(arr.filter((_, i3) => i3 % 2 === 1), len / 2)];
        for (var k = 0; k < len / 2; k++) {
          var p = ret[k];
          var q = multiplyScalar2(ret[k + len / 2], exp3(multiplyScalar2(multiplyScalar2(tau3, I2), divideScalar2(-k, len))));
          ret[k] = addScalar2(p, q);
          ret[k + len / 2] = addScalar2(p, multiplyScalar2(-1, q));
        }
        return ret;
      } else {
        return _czt(arr);
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/ifft.js
  var name111 = "ifft";
  var dependencies111 = ["typed", "fft", "dotDivide", "conj"];
  var createIfft = /* @__PURE__ */ factory(name111, dependencies111, (_ref) => {
    var {
      typed: typed3,
      fft: fft2,
      dotDivide: dotDivide2,
      conj: conj2
    } = _ref;
    return typed3(name111, {
      "Array | Matrix": function ArrayMatrix(arr) {
        var size2 = isMatrix(arr) ? arr.size() : arraySize(arr);
        return dotDivide2(conj2(fft2(conj2(arr))), size2.reduce((acc, curr) => acc * curr, 1));
      }
    });
  });

  // node_modules/@babel/runtime/helpers/esm/typeof.js
  function _typeof(o2) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o3) {
      return typeof o3;
    } : function(o3) {
      return o3 && "function" == typeof Symbol && o3.constructor === Symbol && o3 !== Symbol.prototype ? "symbol" : typeof o3;
    }, _typeof(o2);
  }

  // node_modules/@babel/runtime/helpers/esm/toPrimitive.js
  function _toPrimitive(input2, hint) {
    if (_typeof(input2) !== "object" || input2 === null)
      return input2;
    var prim = input2[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input2, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input2);
  }

  // node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
  function _toPropertyKey(arg2) {
    var key = _toPrimitive(arg2, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }

  // node_modules/@babel/runtime/helpers/esm/defineProperty.js
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  // node_modules/mathjs/lib/esm/function/numeric/solveODE.js
  function ownKeys(e3, r) {
    var t = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e3);
      r && (o2 = o2.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  function _objectSpread(e3) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
        _defineProperty(e3, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
        Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e3;
  }
  var name112 = "solveODE";
  var dependencies112 = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"];
  var createSolveODE = /* @__PURE__ */ factory(name112, dependencies112, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      subtract: subtract2,
      multiply: multiply2,
      divide: divide3,
      max: max3,
      map: map3,
      abs: abs3,
      isPositive: isPositive2,
      isNegative: isNegative2,
      larger: larger2,
      smaller: smaller2,
      matrix: matrix2,
      bignumber: bignumber2,
      unaryMinus: unaryMinus2
    } = _ref;
    function _rk(butcherTableau) {
      return function(f, tspan, y0, options) {
        var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));
        if (wrongTSpan) {
          throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
        }
        var t0 = tspan[0];
        var tf = tspan[1];
        var isForwards = larger2(tf, t0);
        var firstStep = options.firstStep;
        if (firstStep !== void 0 && !isPositive2(firstStep)) {
          throw new Error('"firstStep" must be positive');
        }
        var maxStep = options.maxStep;
        if (maxStep !== void 0 && !isPositive2(maxStep)) {
          throw new Error('"maxStep" must be positive');
        }
        var minStep = options.minStep;
        if (minStep && isNegative2(minStep)) {
          throw new Error('"minStep" must be positive or zero');
        }
        var timeVars = [t0, tf, firstStep, minStep, maxStep].filter((x) => x !== void 0);
        if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {
          throw new Error('Inconsistent type of "t" dependant variables');
        }
        var steps = 1;
        var tol = options.tol ? options.tol : 1e-4;
        var minDelta = options.minDelta ? options.minDelta : 0.2;
        var maxDelta = options.maxDelta ? options.maxDelta : 5;
        var maxIter = options.maxIter ? options.maxIter : 1e4;
        var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);
        var [a, c, b, bp] = hasBigNumbers ? [bignumber2(butcherTableau.a), bignumber2(butcherTableau.c), bignumber2(butcherTableau.b), bignumber2(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];
        var h = firstStep ? isForwards ? firstStep : unaryMinus2(firstStep) : divide3(subtract2(tf, t0), steps);
        var t = [t0];
        var y2 = [y0];
        var deltaB = subtract2(b, bp);
        var n = 0;
        var iter = 0;
        var ongoing = _createOngoing(isForwards);
        var trimStep = _createTrimStep(isForwards);
        while (ongoing(t[n], tf)) {
          var k = [];
          h = trimStep(t[n], tf, h);
          k.push(f(t[n], y2[n]));
          for (var i3 = 1; i3 < c.length; ++i3) {
            k.push(f(add3(t[n], multiply2(c[i3], h)), add3(y2[n], multiply2(h, a[i3], k))));
          }
          var TE = max3(abs3(map3(multiply2(deltaB, k), (X) => isUnit(X) ? X.value : X)));
          if (TE < tol && tol / TE > 1 / 4) {
            t.push(add3(t[n], h));
            y2.push(add3(y2[n], multiply2(h, b, k)));
            n++;
          }
          var delta = 0.84 * (tol / TE) ** (1 / 5);
          if (smaller2(delta, minDelta)) {
            delta = minDelta;
          } else if (larger2(delta, maxDelta)) {
            delta = maxDelta;
          }
          delta = hasBigNumbers ? bignumber2(delta) : delta;
          h = multiply2(h, delta);
          if (maxStep && larger2(abs3(h), maxStep)) {
            h = isForwards ? maxStep : unaryMinus2(maxStep);
          } else if (minStep && smaller2(abs3(h), minStep)) {
            h = isForwards ? minStep : unaryMinus2(minStep);
          }
          iter++;
          if (iter > maxIter) {
            throw new Error("Maximum number of iterations reached, try changing options");
          }
        }
        return {
          t,
          y: y2
        };
      };
    }
    function _rk23(f, tspan, y0, options) {
      var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
      var c = [null, 1 / 2, 3 / 4, 1];
      var b = [2 / 9, 1 / 3, 4 / 9, 0];
      var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
      var butcherTableau = {
        a,
        c,
        b,
        bp
      };
      return _rk(butcherTableau)(f, tspan, y0, options);
    }
    function _rk45(f, tspan, y0, options) {
      var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];
      var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
      var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];
      var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];
      var butcherTableau = {
        a,
        c,
        b,
        bp
      };
      return _rk(butcherTableau)(f, tspan, y0, options);
    }
    function _solveODE(f, tspan, y0, opt) {
      var method = opt.method ? opt.method : "RK45";
      var methods = {
        RK23: _rk23,
        RK45: _rk45
      };
      if (method.toUpperCase() in methods) {
        var methodOptions = _objectSpread({}, opt);
        delete methodOptions.method;
        return methods[method.toUpperCase()](f, tspan, y0, methodOptions);
      } else {
        var methodsWithQuotes = Object.keys(methods).map((x) => '"'.concat(x, '"'));
        var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(", "), " and ").concat(methodsWithQuotes.slice(-1));
        throw new Error('Unavailable method "'.concat(method, '". Available methods are ').concat(availableMethodsString));
      }
    }
    function _createOngoing(isForwards) {
      return isForwards ? smaller2 : larger2;
    }
    function _createTrimStep(isForwards) {
      var outOfBounds = isForwards ? larger2 : smaller2;
      return function(t, tf, h) {
        var next = add3(t, h);
        return outOfBounds(next, tf) ? subtract2(tf, t) : h;
      };
    }
    function isNumOrBig(x) {
      return isBigNumber(x) || isNumber(x);
    }
    function _matrixSolveODE(f, T, y0, options) {
      var sol = _solveODE(f, T.toArray(), y0.toArray(), options);
      return {
        t: matrix2(sol.t),
        y: matrix2(sol.y)
      };
    }
    return typed3("solveODE", {
      "function, Array, Array, Object": _solveODE,
      "function, Matrix, Matrix, Object": _matrixSolveODE,
      "function, Array, Array": (f, T, y0) => _solveODE(f, T, y0, {}),
      "function, Matrix, Matrix": (f, T, y0) => _matrixSolveODE(f, T, y0, {}),
      "function, Array, number | BigNumber | Unit": (f, T, y0) => {
        var sol = _solveODE(f, T, [y0], {});
        return {
          t: sol.t,
          y: sol.y.map((Y) => Y[0])
        };
      },
      "function, Matrix, number | BigNumber | Unit": (f, T, y0) => {
        var sol = _solveODE(f, T.toArray(), [y0], {});
        return {
          t: matrix2(sol.t),
          y: matrix2(sol.y.map((Y) => Y[0]))
        };
      },
      "function, Array, number | BigNumber | Unit, Object": (f, T, y0, options) => {
        var sol = _solveODE(f, T, [y0], options);
        return {
          t: sol.t,
          y: sol.y.map((Y) => Y[0])
        };
      },
      "function, Matrix, number | BigNumber | Unit, Object": (f, T, y0, options) => {
        var sol = _solveODE(f, T.toArray(), [y0], options);
        return {
          t: matrix2(sol.t),
          y: matrix2(sol.y.map((Y) => Y[0]))
        };
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/special/erf.js
  var name113 = "erf";
  var dependencies113 = ["typed"];
  var createErf = /* @__PURE__ */ factory(name113, dependencies113, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3("name", {
      number: function number2(x) {
        var y2 = Math.abs(x);
        if (y2 >= MAX_NUM) {
          return sign(x);
        }
        if (y2 <= THRESH) {
          return sign(x) * erf1(y2);
        }
        if (y2 <= 4) {
          return sign(x) * (1 - erfc2(y2));
        }
        return sign(x) * (1 - erfc3(y2));
      },
      "Array | Matrix": typed3.referToSelf((self2) => (n) => deepMap(n, self2))
      // TODO: For complex numbers, use the approximation for the Faddeeva function
      //  from "More Efficient Computation of the Complex Error Function" (AMS)
    });
    function erf1(y2) {
      var ysq = y2 * y2;
      var xnum = P2[0][4] * ysq;
      var xden = ysq;
      var i3;
      for (i3 = 0; i3 < 3; i3 += 1) {
        xnum = (xnum + P2[0][i3]) * ysq;
        xden = (xden + Q2[0][i3]) * ysq;
      }
      return y2 * (xnum + P2[0][3]) / (xden + Q2[0][3]);
    }
    function erfc2(y2) {
      var xnum = P2[1][8] * y2;
      var xden = y2;
      var i3;
      for (i3 = 0; i3 < 7; i3 += 1) {
        xnum = (xnum + P2[1][i3]) * y2;
        xden = (xden + Q2[1][i3]) * y2;
      }
      var result = (xnum + P2[1][7]) / (xden + Q2[1][7]);
      var ysq = parseInt(y2 * 16) / 16;
      var del = (y2 - ysq) * (y2 + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
    function erfc3(y2) {
      var ysq = 1 / (y2 * y2);
      var xnum = P2[2][5] * ysq;
      var xden = ysq;
      var i3;
      for (i3 = 0; i3 < 4; i3 += 1) {
        xnum = (xnum + P2[2][i3]) * ysq;
        xden = (xden + Q2[2][i3]) * ysq;
      }
      var result = ysq * (xnum + P2[2][4]) / (xden + Q2[2][4]);
      result = (SQRPI - result) / y2;
      ysq = parseInt(y2 * 16) / 16;
      var del = (y2 - ysq) * (y2 + ysq);
      return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
    }
  });
  var THRESH = 0.46875;
  var SQRPI = 0.5641895835477563;
  var P2 = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
  var Q2 = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
  var MAX_NUM = Math.pow(2, 53);

  // node_modules/mathjs/lib/esm/function/special/zeta.js
  var name114 = "zeta";
  var dependencies114 = ["typed", "config", "multiply", "pow", "divide", "factorial", "equal", "smallerEq", "isNegative", "gamma", "sin", "subtract", "add", "?Complex", "?BigNumber", "pi"];
  var createZeta = /* @__PURE__ */ factory(name114, dependencies114, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      multiply: multiply2,
      pow: pow3,
      divide: divide3,
      factorial: factorial2,
      equal: equal2,
      smallerEq: smallerEq2,
      isNegative: isNegative2,
      gamma: gamma2,
      sin: sin3,
      subtract: subtract2,
      add: add3,
      Complex: Complex3,
      BigNumber: _BigNumber,
      pi: pi3
    } = _ref;
    return typed3(name114, {
      number: (s) => zetaNumeric(s, (value) => value, () => 20),
      BigNumber: (s) => zetaNumeric(s, (value) => new _BigNumber(value), () => {
        return Math.abs(Math.log10(config4.epsilon));
      }),
      Complex: zetaComplex
    });
    function zetaNumeric(s, createValue, determineDigits) {
      if (equal2(s, 0)) {
        return createValue(-0.5);
      }
      if (equal2(s, 1)) {
        return createValue(NaN);
      }
      if (!isFinite(s)) {
        return isNegative2(s) ? createValue(NaN) : createValue(1);
      }
      return zeta2(s, createValue, determineDigits, (s2) => s2);
    }
    function zetaComplex(s) {
      if (s.re === 0 && s.im === 0) {
        return new Complex3(-0.5);
      }
      if (s.re === 1) {
        return new Complex3(NaN, NaN);
      }
      if (s.re === Infinity && s.im === 0) {
        return new Complex3(1);
      }
      if (s.im === Infinity || s.re === -Infinity) {
        return new Complex3(NaN, NaN);
      }
      return zeta2(s, (value) => value, (s2) => Math.round(1.3 * 15 + 0.9 * Math.abs(s2.im)), (s2) => s2.re);
    }
    function zeta2(s, createValue, determineDigits, getRe) {
      var n = determineDigits(s);
      if (getRe(s) > -(n - 1) / 2) {
        return f(s, createValue(n), createValue);
      } else {
        var c = multiply2(pow3(2, s), pow3(createValue(pi3), subtract2(s, 1)));
        c = multiply2(c, sin3(multiply2(divide3(createValue(pi3), 2), s)));
        c = multiply2(c, gamma2(subtract2(1, s)));
        return multiply2(c, zeta2(subtract2(1, s), createValue, determineDigits, getRe));
      }
    }
    function d(k, n) {
      var S = k;
      for (var j = k; smallerEq2(j, n); j = add3(j, 1)) {
        var factor = divide3(multiply2(factorial2(add3(n, subtract2(j, 1))), pow3(4, j)), multiply2(factorial2(subtract2(n, j)), factorial2(multiply2(2, j))));
        S = add3(S, factor);
      }
      return multiply2(n, S);
    }
    function f(s, n, createValue) {
      var c = divide3(1, multiply2(d(createValue(0), n), subtract2(1, pow3(2, subtract2(1, s)))));
      var S = createValue(0);
      for (var k = createValue(1); smallerEq2(k, n); k = add3(k, 1)) {
        S = add3(S, divide3(multiply2((-1) ** (k - 1), d(k, n)), pow3(k, s)));
      }
      return multiply2(c, S);
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/mode.js
  var name115 = "mode";
  var dependencies115 = ["typed", "isNaN", "isNumeric"];
  var createMode = /* @__PURE__ */ factory(name115, dependencies115, (_ref) => {
    var {
      typed: typed3,
      isNaN: isNaN3,
      isNumeric: isNumeric2
    } = _ref;
    return typed3(name115, {
      "Array | Matrix": _mode,
      "...": function _(args) {
        return _mode(args);
      }
    });
    function _mode(values) {
      values = flatten(values.valueOf());
      var num = values.length;
      if (num === 0) {
        throw new Error("Cannot calculate mode of an empty array");
      }
      var count2 = {};
      var mode2 = [];
      var max3 = 0;
      for (var i3 = 0; i3 < values.length; i3++) {
        var value = values[i3];
        if (isNumeric2(value) && isNaN3(value)) {
          throw new Error("Cannot calculate mode of an array containing NaN values");
        }
        if (!(value in count2)) {
          count2[value] = 0;
        }
        count2[value]++;
        if (count2[value] === max3) {
          mode2.push(value);
        } else if (count2[value] > max3) {
          max3 = count2[value];
          mode2 = [value];
        }
      }
      return mode2;
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/utils/improveErrorMessage.js
  function improveErrorMessage(err, fnName, value) {
    var details;
    if (String(err).indexOf("Unexpected type") !== -1) {
      details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
      return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
    }
    if (String(err).indexOf("complex numbers") !== -1) {
      details = arguments.length > 2 ? " (type: " + typeOf(value) + ", value: " + JSON.stringify(value) + ")" : "";
      return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
    }
    return err;
  }

  // node_modules/mathjs/lib/esm/function/statistics/prod.js
  var name116 = "prod";
  var dependencies116 = ["typed", "config", "multiplyScalar", "numeric"];
  var createProd = /* @__PURE__ */ factory(name116, dependencies116, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      multiplyScalar: multiplyScalar2,
      numeric: numeric3
    } = _ref;
    return typed3(name116, {
      // prod([a, b, c, d, ...])
      "Array | Matrix": _prod,
      // prod([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        throw new Error("prod(A, dim) is not yet supported");
      },
      // prod(a, b, c, d, ...)
      "...": function _(args) {
        return _prod(args);
      }
    });
    function _prod(array) {
      var prod2;
      deepForEach(array, function(value) {
        try {
          prod2 = prod2 === void 0 ? value : multiplyScalar2(prod2, value);
        } catch (err) {
          throw improveErrorMessage(err, "prod", value);
        }
      });
      if (typeof prod2 === "string") {
        prod2 = numeric3(prod2, config4.number);
      }
      if (prod2 === void 0) {
        throw new Error("Cannot calculate prod of an empty array");
      }
      return prod2;
    }
  });

  // node_modules/mathjs/lib/esm/function/string/format.js
  var name117 = "format";
  var dependencies117 = ["typed"];
  var createFormat = /* @__PURE__ */ factory(name117, dependencies117, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name117, {
      any: format3,
      "any, Object | function | number": format3
    });
  });

  // node_modules/mathjs/lib/esm/function/string/bin.js
  var name118 = "bin";
  var dependencies118 = ["typed", "format"];
  var createBin = factory(name118, dependencies118, (_ref) => {
    var {
      typed: typed3,
      format: format5
    } = _ref;
    return typed3(name118, {
      "number | BigNumber": function numberBigNumber(n) {
        return format5(n, {
          notation: "bin"
        });
      },
      "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
        return format5(n, {
          notation: "bin",
          wordSize
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/string/oct.js
  var name119 = "oct";
  var dependencies119 = ["typed", "format"];
  var createOct = factory(name119, dependencies119, (_ref) => {
    var {
      typed: typed3,
      format: format5
    } = _ref;
    return typed3(name119, {
      "number | BigNumber": function numberBigNumber(n) {
        return format5(n, {
          notation: "oct"
        });
      },
      "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
        return format5(n, {
          notation: "oct",
          wordSize
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/string/hex.js
  var name120 = "hex";
  var dependencies120 = ["typed", "format"];
  var createHex = factory(name120, dependencies120, (_ref) => {
    var {
      typed: typed3,
      format: format5
    } = _ref;
    return typed3(name120, {
      "number | BigNumber": function numberBigNumber(n) {
        return format5(n, {
          notation: "hex"
        });
      },
      "number | BigNumber, number": function numberBigNumberNumber(n, wordSize) {
        return format5(n, {
          notation: "hex",
          wordSize
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/utils/print.js
  var printTemplate = /\$([\w.]+)/g;

  // node_modules/mathjs/lib/esm/function/string/print.js
  var name121 = "print";
  var dependencies121 = ["typed"];
  var createPrint = /* @__PURE__ */ factory(name121, dependencies121, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name121, {
      // note: Matrix will be converted automatically to an Array
      "string, Object | Array": _print,
      "string, Object | Array, number | Object": _print
    });
  });
  function _print(template, values, options) {
    return template.replace(printTemplate, function(original, key) {
      var keys = key.split(".");
      var value = values[keys.shift()];
      if (value !== void 0 && value.isMatrix) {
        value = value.toArray();
      }
      while (keys.length && value !== void 0) {
        var k = keys.shift();
        value = k ? value[k] : value + ".";
      }
      if (value !== void 0) {
        if (!isString(value)) {
          return format3(value, options);
        } else {
          return value;
        }
      }
      return original;
    });
  }

  // node_modules/mathjs/lib/esm/function/unit/to.js
  var name122 = "to";
  var dependencies122 = ["typed", "matrix", "concat"];
  var createTo = /* @__PURE__ */ factory(name122, dependencies122, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    } = _ref;
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name122, {
      "Unit, Unit | string": (x, unit2) => x.to(unit2)
    }, matrixAlgorithmSuite({
      Ds: true
    }));
  });

  // node_modules/mathjs/lib/esm/function/utils/isPrime.js
  var name123 = "isPrime";
  var dependencies123 = ["typed"];
  var createIsPrime = /* @__PURE__ */ factory(name123, dependencies123, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name123, {
      number: function number2(x) {
        if (x * 0 !== 0) {
          return false;
        }
        if (x <= 3) {
          return x > 1;
        }
        if (x % 2 === 0 || x % 3 === 0) {
          return false;
        }
        for (var i3 = 5; i3 * i3 <= x; i3 += 6) {
          if (x % i3 === 0 || x % (i3 + 2) === 0) {
            return false;
          }
        }
        return true;
      },
      BigNumber: function BigNumber2(n) {
        if (n.toNumber() * 0 !== 0) {
          return false;
        }
        if (n.lte(3))
          return n.gt(1);
        if (n.mod(2).eq(0) || n.mod(3).eq(0))
          return false;
        if (n.lt(Math.pow(2, 32))) {
          var x = n.toNumber();
          for (var i3 = 5; i3 * i3 <= x; i3 += 6) {
            if (x % i3 === 0 || x % (i3 + 2) === 0) {
              return false;
            }
          }
          return true;
        }
        function modPow(base, exponent, modulus) {
          var accumulator = 1;
          while (!exponent.eq(0)) {
            if (exponent.mod(2).eq(0)) {
              exponent = exponent.div(2);
              base = base.mul(base).mod(modulus);
            } else {
              exponent = exponent.sub(1);
              accumulator = base.mul(accumulator).mod(modulus);
            }
          }
          return accumulator;
        }
        var Decimal2 = n.constructor.clone({
          precision: n.toFixed(0).length * 2
        });
        n = new Decimal2(n);
        var r = 0;
        var d = n.sub(1);
        while (d.mod(2).eq(0)) {
          d = d.div(2);
          r += 1;
        }
        var bases = null;
        if (n.lt("3317044064679887385961981")) {
          bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x2) => x2 < n);
        } else {
          var max3 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
          bases = [];
          for (var _i = 2; _i <= max3; _i += 1) {
            bases.push(max3);
          }
        }
        for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
          var a = bases[_i2];
          var adn = modPow(n.sub(n).add(a), d, n);
          if (!adn.eq(1)) {
            for (var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
              if (_i3 === r - 1) {
                return false;
              }
            }
          }
        }
        return true;
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/utils/numeric.js
  var name124 = "numeric";
  var dependencies124 = ["number", "?bignumber", "?fraction"];
  var createNumeric = /* @__PURE__ */ factory(name124, dependencies124, (_ref) => {
    var {
      number: _number,
      bignumber: bignumber2,
      fraction: fraction2
    } = _ref;
    var validInputTypes = {
      string: true,
      number: true,
      BigNumber: true,
      Fraction: true
    };
    var validOutputTypes = {
      number: (x) => _number(x),
      BigNumber: bignumber2 ? (x) => bignumber2(x) : noBignumber,
      Fraction: fraction2 ? (x) => fraction2(x) : noFraction
    };
    return function numeric3(value) {
      var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number";
      var check = arguments.length > 2 ? arguments[2] : void 0;
      if (check !== void 0) {
        throw new SyntaxError("numeric() takes one or two arguments");
      }
      var inputType = typeOf(value);
      if (!(inputType in validInputTypes)) {
        throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
      }
      if (!(outputType in validOutputTypes)) {
        throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
      }
      if (outputType === inputType) {
        return value;
      } else {
        return validOutputTypes[outputType](value);
      }
    };
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/divideScalar.js
  var name125 = "divideScalar";
  var dependencies125 = ["typed", "numeric"];
  var createDivideScalar = /* @__PURE__ */ factory(name125, dependencies125, (_ref) => {
    var {
      typed: typed3,
      numeric: numeric3
    } = _ref;
    return typed3(name125, {
      "number, number": function numberNumber(x, y2) {
        return x / y2;
      },
      "Complex, Complex": function ComplexComplex(x, y2) {
        return x.div(y2);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return x.div(y2);
      },
      "Fraction, Fraction": function FractionFraction(x, y2) {
        return x.div(y2);
      },
      "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y2) => x.divide(y2),
      "number | Fraction | Complex | BigNumber, Unit": (x, y2) => y2.divideInto(x)
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/pow.js
  var name126 = "pow";
  var dependencies126 = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
  var createPow = /* @__PURE__ */ factory(name126, dependencies126, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      identity: identity2,
      multiply: multiply2,
      matrix: matrix2,
      inv: inv2,
      number: number2,
      fraction: fraction2,
      Complex: Complex3
    } = _ref;
    return typed3(name126, {
      "number, number": _pow,
      "Complex, Complex": function ComplexComplex(x, y2) {
        return x.pow(y2);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        if (y2.isInteger() || x >= 0 || config4.predictable) {
          return x.pow(y2);
        } else {
          return new Complex3(x.toNumber(), 0).pow(y2.toNumber(), 0);
        }
      },
      "Fraction, Fraction": function FractionFraction(x, y2) {
        var result = x.pow(y2);
        if (result != null) {
          return result;
        }
        if (config4.predictable) {
          throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
        } else {
          return _pow(x.valueOf(), y2.valueOf());
        }
      },
      "Array, number": _powArray,
      "Array, BigNumber": function ArrayBigNumber(x, y2) {
        return _powArray(x, y2.toNumber());
      },
      "Matrix, number": _powMatrix,
      "Matrix, BigNumber": function MatrixBigNumber(x, y2) {
        return _powMatrix(x, y2.toNumber());
      },
      "Unit, number | BigNumber": function UnitNumberBigNumber(x, y2) {
        return x.pow(y2);
      }
    });
    function _pow(x, y2) {
      if (config4.predictable && !isInteger(y2) && x < 0) {
        try {
          var yFrac = fraction2(y2);
          var yNum = number2(yFrac);
          if (y2 === yNum || Math.abs((y2 - yNum) / y2) < 1e-14) {
            if (yFrac.d % 2 === 1) {
              return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y2);
            }
          }
        } catch (ex) {
        }
      }
      if (config4.predictable && (x < -1 && y2 === Infinity || x > -1 && x < 0 && y2 === -Infinity)) {
        return NaN;
      }
      if (isInteger(y2) || x >= 0 || config4.predictable) {
        return powNumber(x, y2);
      } else {
        if (x * x < 1 && y2 === Infinity || x * x > 1 && y2 === -Infinity) {
          return 0;
        }
        return new Complex3(x, 0).pow(y2, 0);
      }
    }
    function _powArray(x, y2) {
      if (!isInteger(y2)) {
        throw new TypeError("For A^b, b must be an integer (value is " + y2 + ")");
      }
      var s = arraySize(x);
      if (s.length !== 2) {
        throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
      }
      if (s[0] !== s[1]) {
        throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
      }
      if (y2 < 0) {
        try {
          return _powArray(inv2(x), -y2);
        } catch (error) {
          if (error.message === "Cannot calculate inverse, determinant is zero") {
            throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y2 + ")");
          }
          throw error;
        }
      }
      var res = identity2(s[0]).valueOf();
      var px = x;
      while (y2 >= 1) {
        if ((y2 & 1) === 1) {
          res = multiply2(px, res);
        }
        y2 >>= 1;
        px = multiply2(px, px);
      }
      return res;
    }
    function _powMatrix(x, y2) {
      return matrix2(_powArray(x.valueOf(), y2));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/round.js
  var NO_INT = "Number of decimals in function round must be an integer";
  var name127 = "round";
  var dependencies127 = ["typed", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
  var createRound = /* @__PURE__ */ factory(name127, dependencies127, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      BigNumber: BigNumber2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    return typed3(name127, {
      number: roundNumber,
      "number, number": roundNumber,
      "number, BigNumber": function numberBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return new BigNumber2(x).toDecimalPlaces(n.toNumber());
      },
      Complex: function Complex3(x) {
        return x.round();
      },
      "Complex, number": function ComplexNumber(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }
        return x.round(n);
      },
      "Complex, BigNumber": function ComplexBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        var _n = n.toNumber();
        return x.round(_n);
      },
      BigNumber: function BigNumber3(x) {
        return x.toDecimalPlaces(0);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return x.toDecimalPlaces(n.toNumber());
      },
      Fraction: function Fraction3(x) {
        return x.round();
      },
      "Fraction, number": function FractionNumber(x, n) {
        if (n % 1) {
          throw new TypeError(NO_INT);
        }
        return x.round(n);
      },
      "Fraction, BigNumber": function FractionBigNumber(x, n) {
        if (!n.isInteger()) {
          throw new TypeError(NO_INT);
        }
        return x.round(n.toNumber());
      },
      "Unit, number, Unit": typed3.referToSelf((self2) => function(x, n, unit2) {
        var valueless = x.toNumeric(unit2);
        return unit2.multiply(self2(valueless, n));
      }),
      "Unit, BigNumber, Unit": typed3.referToSelf((self2) => (x, n, unit2) => self2(x, n.toNumber(), unit2)),
      "Unit, Unit": typed3.referToSelf((self2) => (x, unit2) => self2(x, 0, unit2)),
      "Array | Matrix, number, Unit": typed3.referToSelf((self2) => (x, n, unit2) => {
        return deepMap(x, (value) => self2(value, n, unit2), true);
      }),
      "Array | Matrix, BigNumber, Unit": typed3.referToSelf((self2) => (x, n, unit2) => self2(x, n.toNumber(), unit2)),
      "Array | Matrix, Unit": typed3.referToSelf((self2) => (x, unit2) => self2(x, 0, unit2)),
      "Array | Matrix": typed3.referToSelf((self2) => (x) => {
        return deepMap(x, self2, true);
      }),
      "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
        return matAlgo11xS0s(x, n, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
        return matAlgo14xDs(x, n, self2, false);
      }),
      "Array, number | BigNumber": typed3.referToSelf((self2) => (x, n) => {
        return matAlgo14xDs(matrix2(x), n, self2, false).valueOf();
      }),
      "number | Complex | BigNumber | Fraction, SparseMatrix": typed3.referToSelf((self2) => (x, n) => {
        if (equalScalar2(x, 0)) {
          return zeros3(n.size(), n.storage());
        }
        return matAlgo12xSfs(n, x, self2, true);
      }),
      "number | Complex | BigNumber | Fraction, DenseMatrix": typed3.referToSelf((self2) => (x, n) => {
        if (equalScalar2(x, 0)) {
          return zeros3(n.size(), n.storage());
        }
        return matAlgo14xDs(n, x, self2, true);
      }),
      "number | Complex | BigNumber | Fraction, Array": typed3.referToSelf((self2) => (x, n) => {
        return matAlgo14xDs(matrix2(n), x, self2, true).valueOf();
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log.js
  var name128 = "log";
  var dependencies128 = ["config", "typed", "divideScalar", "Complex"];
  var createLog = /* @__PURE__ */ factory(name128, dependencies128, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      divideScalar: divideScalar2,
      Complex: Complex3
    } = _ref;
    return typed3(name128, {
      number: function number2(x) {
        if (x >= 0 || config4.predictable) {
          return logNumber(x);
        } else {
          return new Complex3(x, 0).log();
        }
      },
      Complex: function Complex4(x) {
        return x.log();
      },
      BigNumber: function BigNumber2(x) {
        if (!x.isNegative() || config4.predictable) {
          return x.ln();
        } else {
          return new Complex3(x.toNumber(), 0).log();
        }
      },
      "any, any": typed3.referToSelf((self2) => (x, base) => {
        return divideScalar2(self2(x), self2(base));
      })
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/log1p.js
  var name129 = "log1p";
  var dependencies129 = ["typed", "config", "divideScalar", "log", "Complex"];
  var createLog1p = /* @__PURE__ */ factory(name129, dependencies129, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      divideScalar: divideScalar2,
      log: log4,
      Complex: Complex3
    } = _ref;
    return typed3(name129, {
      number: function number2(x) {
        if (x >= -1 || config4.predictable) {
          return log1p(x);
        } else {
          return _log1pComplex(new Complex3(x, 0));
        }
      },
      Complex: _log1pComplex,
      BigNumber: function BigNumber2(x) {
        var y2 = x.plus(1);
        if (!y2.isNegative() || config4.predictable) {
          return y2.ln();
        } else {
          return _log1pComplex(new Complex3(x.toNumber(), 0));
        }
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2)),
      "any, any": typed3.referToSelf((self2) => (x, base) => {
        return divideScalar2(self2(x), log4(base));
      })
    });
    function _log1pComplex(x) {
      var xRe1p = x.re + 1;
      return new Complex3(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/nthRoots.js
  var name130 = "nthRoots";
  var dependencies130 = ["config", "typed", "divideScalar", "Complex"];
  var createNthRoots = /* @__PURE__ */ factory(name130, dependencies130, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      divideScalar: divideScalar2,
      Complex: Complex3
    } = _ref;
    var _calculateExactResult = [function realPos(val) {
      return new Complex3(val, 0);
    }, function imagPos(val) {
      return new Complex3(0, val);
    }, function realNeg(val) {
      return new Complex3(-val, 0);
    }, function imagNeg(val) {
      return new Complex3(0, -val);
    }];
    function _nthComplexRoots(a, root) {
      if (root < 0)
        throw new Error("Root must be greater than zero");
      if (root === 0)
        throw new Error("Root must be non-zero");
      if (root % 1 !== 0)
        throw new Error("Root must be an integer");
      if (a === 0 || a.abs() === 0)
        return [new Complex3(0, 0)];
      var aIsNumeric = typeof a === "number";
      var offset;
      if (aIsNumeric || a.re === 0 || a.im === 0) {
        if (aIsNumeric) {
          offset = 2 * +(a < 0);
        } else if (a.im === 0) {
          offset = 2 * +(a.re < 0);
        } else {
          offset = 2 * +(a.im < 0) + 1;
        }
      }
      var arg2 = a.arg();
      var abs3 = a.abs();
      var roots = [];
      var r = Math.pow(abs3, 1 / root);
      for (var k = 0; k < root; k++) {
        var halfPiFactor = (offset + 4 * k) / root;
        if (halfPiFactor === Math.round(halfPiFactor)) {
          roots.push(_calculateExactResult[halfPiFactor % 4](r));
          continue;
        }
        roots.push(new Complex3({
          r,
          phi: (arg2 + 2 * Math.PI * k) / root
        }));
      }
      return roots;
    }
    return typed3(name130, {
      Complex: function Complex4(x) {
        return _nthComplexRoots(x, 2);
      },
      "Complex, number": _nthComplexRoots
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotPow.js
  var name131 = "dotPow";
  var dependencies131 = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat"];
  var createDotPow = /* @__PURE__ */ factory(name131, dependencies131, (_ref) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2,
      matrix: matrix2,
      pow: pow3,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var powScalarSignatures = {};
    for (var signature in pow3.signatures) {
      if (Object.prototype.hasOwnProperty.call(pow3.signatures, signature)) {
        if (!signature.includes("Matrix") && !signature.includes("Array")) {
          powScalarSignatures[signature] = pow3.signatures[signature];
        }
      }
    }
    var powScalar = typed3(powScalarSignatures);
    return typed3(name131, matrixAlgorithmSuite({
      elop: powScalar,
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo11xS0s,
      sS: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/dotDivide.js
  var name132 = "dotDivide";
  var dependencies132 = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat"];
  var createDotDivide = /* @__PURE__ */ factory(name132, dependencies132, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      divideScalar: divideScalar2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name132, matrixAlgorithmSuite({
      elop: divideScalar2,
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      SD: matAlgo02xDS0,
      Ss: matAlgo11xS0s,
      sS: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/utils/solveValidation.js
  function createSolveValidation(_ref) {
    var {
      DenseMatrix: DenseMatrix2
    } = _ref;
    return function solveValidation(m, b, copy) {
      var mSize = m.size();
      if (mSize.length !== 2) {
        throw new RangeError("Matrix must be two dimensional (size: " + format3(mSize) + ")");
      }
      var rows = mSize[0];
      var columns = mSize[1];
      if (rows !== columns) {
        throw new RangeError("Matrix must be square (size: " + format3(mSize) + ")");
      }
      var data = [];
      if (isMatrix(b)) {
        var bSize = b.size();
        var bdata = b._data;
        if (bSize.length === 1) {
          if (bSize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var i3 = 0; i3 < rows; i3++) {
            data[i3] = [bdata[i3]];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
        if (bSize.length === 2) {
          if (bSize[0] !== rows || bSize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          if (isDenseMatrix(b)) {
            if (copy) {
              data = [];
              for (var _i = 0; _i < rows; _i++) {
                data[_i] = [bdata[_i][0]];
              }
              return new DenseMatrix2({
                data,
                size: [rows, 1],
                datatype: b._datatype
              });
            }
            return b;
          }
          if (isSparseMatrix(b)) {
            for (var _i2 = 0; _i2 < rows; _i2++) {
              data[_i2] = [0];
            }
            var values = b._values;
            var index2 = b._index;
            var ptr = b._ptr;
            for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
              var _i3 = index2[k];
              data[_i3][0] = values[k];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
      if (isArray(b)) {
        var bsize = arraySize(b);
        if (bsize.length === 1) {
          if (bsize[0] !== rows) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i4 = 0; _i4 < rows; _i4++) {
            data[_i4] = [b[_i4]];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1]
          });
        }
        if (bsize.length === 2) {
          if (bsize[0] !== rows || bsize[1] !== 1) {
            throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
          }
          for (var _i5 = 0; _i5 < rows; _i5++) {
            data[_i5] = [b[_i5][0]];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1]
          });
        }
        throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
      }
    };
  }

  // node_modules/mathjs/lib/esm/function/algebra/solver/lsolve.js
  var name133 = "lsolve";
  var dependencies133 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
  var createLsolve = /* @__PURE__ */ factory(name133, dependencies133, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      subtractScalar: subtractScalar2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix2
    });
    return typed3(name133, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseForwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseForwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix2(a);
        var r = _denseForwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseForwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var x = [];
      var mdata = m._data;
      for (var j = 0; j < columns; j++) {
        var bj = bdata[j][0] || 0;
        var xj = void 0;
        if (!equalScalar2(bj, 0)) {
          var vjj = mdata[j][j];
          if (equalScalar2(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          xj = divideScalar2(bj, vjj);
          for (var i3 = j + 1; i3 < rows; i3++) {
            bdata[i3] = [subtractScalar2(bdata[i3][0] || 0, multiplyScalar2(xj, mdata[i3][j]))];
          }
        } else {
          xj = 0;
        }
        x[j] = [xj];
      }
      return new DenseMatrix2({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseForwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var values = m._values;
      var index2 = m._index;
      var ptr = m._ptr;
      var x = [];
      for (var j = 0; j < columns; j++) {
        var bj = bdata[j][0] || 0;
        if (!equalScalar2(bj, 0)) {
          var vjj = 0;
          var jValues = [];
          var jIndices = [];
          var firstIndex = ptr[j];
          var lastIndex = ptr[j + 1];
          for (var k = firstIndex; k < lastIndex; k++) {
            var i3 = index2[k];
            if (i3 === j) {
              vjj = values[k];
            } else if (i3 > j) {
              jValues.push(values[k]);
              jIndices.push(i3);
            }
          }
          if (equalScalar2(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          var xj = divideScalar2(bj, vjj);
          for (var _k = 0, l = jIndices.length; _k < l; _k++) {
            var _i = jIndices[_k];
            bdata[_i] = [subtractScalar2(bdata[_i][0] || 0, multiplyScalar2(xj, jValues[_k]))];
          }
          x[j] = [xj];
        } else {
          x[j] = [0];
        }
      }
      return new DenseMatrix2({
        data: x,
        size: [rows, 1]
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/usolve.js
  var name134 = "usolve";
  var dependencies134 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
  var createUsolve = /* @__PURE__ */ factory(name134, dependencies134, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      subtractScalar: subtractScalar2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix2
    });
    return typed3(name134, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix2(a);
        var r = _denseBackwardSubstitution(m, b);
        return r.valueOf();
      }
    });
    function _denseBackwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var x = [];
      var mdata = m._data;
      for (var j = columns - 1; j >= 0; j--) {
        var bj = bdata[j][0] || 0;
        var xj = void 0;
        if (!equalScalar2(bj, 0)) {
          var vjj = mdata[j][j];
          if (equalScalar2(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          xj = divideScalar2(bj, vjj);
          for (var i3 = j - 1; i3 >= 0; i3--) {
            bdata[i3] = [subtractScalar2(bdata[i3][0] || 0, multiplyScalar2(xj, mdata[i3][j]))];
          }
        } else {
          xj = 0;
        }
        x[j] = [xj];
      }
      return new DenseMatrix2({
        data: x,
        size: [rows, 1]
      });
    }
    function _sparseBackwardSubstitution(m, b) {
      b = solveValidation(m, b, true);
      var bdata = b._data;
      var rows = m._size[0];
      var columns = m._size[1];
      var values = m._values;
      var index2 = m._index;
      var ptr = m._ptr;
      var x = [];
      for (var j = columns - 1; j >= 0; j--) {
        var bj = bdata[j][0] || 0;
        if (!equalScalar2(bj, 0)) {
          var vjj = 0;
          var jValues = [];
          var jIndices = [];
          var firstIndex = ptr[j];
          var lastIndex = ptr[j + 1];
          for (var k = lastIndex - 1; k >= firstIndex; k--) {
            var i3 = index2[k];
            if (i3 === j) {
              vjj = values[k];
            } else if (i3 < j) {
              jValues.push(values[k]);
              jIndices.push(i3);
            }
          }
          if (equalScalar2(vjj, 0)) {
            throw new Error("Linear system cannot be solved since matrix is singular");
          }
          var xj = divideScalar2(bj, vjj);
          for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
            var _i = jIndices[_k];
            bdata[_i] = [subtractScalar2(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
          }
          x[j] = [xj];
        } else {
          x[j] = [0];
        }
      }
      return new DenseMatrix2({
        data: x,
        size: [rows, 1]
      });
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/lsolveAll.js
  var name135 = "lsolveAll";
  var dependencies135 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
  var createLsolveAll = /* @__PURE__ */ factory(name135, dependencies135, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      subtractScalar: subtractScalar2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix2
    });
    return typed3(name135, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseForwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseForwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix2(a);
        var R = _denseForwardSubstitution(m, b);
        return R.map((r) => r.valueOf());
      }
    });
    function _denseForwardSubstitution(m, b_) {
      var B2 = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
      var M = m._data;
      var rows = m._size[0];
      var columns = m._size[1];
      for (var i3 = 0; i3 < columns; i3++) {
        var L = B2.length;
        for (var k = 0; k < L; k++) {
          var b = B2[k];
          if (!equalScalar2(M[i3][i3], 0)) {
            b[i3] = divideScalar2(b[i3], M[i3][i3]);
            for (var j = i3 + 1; j < columns; j++) {
              b[j] = subtractScalar2(b[j], multiplyScalar2(b[i3], M[j][i3]));
            }
          } else if (!equalScalar2(b[i3], 0)) {
            if (k === 0) {
              return [];
            } else {
              B2.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i3] = 1;
            for (var _j = i3 + 1; _j < columns; _j++) {
              bNew[_j] = subtractScalar2(bNew[_j], M[_j][i3]);
            }
            B2.push(bNew);
          }
        }
      }
      return B2.map((x) => new DenseMatrix2({
        data: x.map((e3) => [e3]),
        size: [rows, 1]
      }));
    }
    function _sparseForwardSubstitution(m, b_) {
      var B2 = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
      var rows = m._size[0];
      var columns = m._size[1];
      var values = m._values;
      var index2 = m._index;
      var ptr = m._ptr;
      for (var i3 = 0; i3 < columns; i3++) {
        var L = B2.length;
        for (var k = 0; k < L; k++) {
          var b = B2[k];
          var iValues = [];
          var iIndices = [];
          var firstIndex = ptr[i3];
          var lastIndex = ptr[i3 + 1];
          var Mii = 0;
          for (var j = firstIndex; j < lastIndex; j++) {
            var J = index2[j];
            if (J === i3) {
              Mii = values[j];
            } else if (J > i3) {
              iValues.push(values[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar2(Mii, 0)) {
            b[i3] = divideScalar2(b[i3], Mii);
            for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
              var _J = iIndices[_j2];
              b[_J] = subtractScalar2(b[_J], multiplyScalar2(b[i3], iValues[_j2]));
            }
          } else if (!equalScalar2(b[i3], 0)) {
            if (k === 0) {
              return [];
            } else {
              B2.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i3] = 1;
            for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
              var _J2 = iIndices[_j3];
              bNew[_J2] = subtractScalar2(bNew[_J2], iValues[_j3]);
            }
            B2.push(bNew);
          }
        }
      }
      return B2.map((x) => new DenseMatrix2({
        data: x.map((e3) => [e3]),
        size: [rows, 1]
      }));
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/solver/usolveAll.js
  var name136 = "usolveAll";
  var dependencies136 = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
  var createUsolveAll = /* @__PURE__ */ factory(name136, dependencies136, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      subtractScalar: subtractScalar2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix2
    });
    return typed3(name136, {
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
        return _sparseBackwardSubstitution(m, b);
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
        return _denseBackwardSubstitution(m, b);
      },
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        var m = matrix2(a);
        var R = _denseBackwardSubstitution(m, b);
        return R.map((r) => r.valueOf());
      }
    });
    function _denseBackwardSubstitution(m, b_) {
      var B2 = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
      var M = m._data;
      var rows = m._size[0];
      var columns = m._size[1];
      for (var i3 = columns - 1; i3 >= 0; i3--) {
        var L = B2.length;
        for (var k = 0; k < L; k++) {
          var b = B2[k];
          if (!equalScalar2(M[i3][i3], 0)) {
            b[i3] = divideScalar2(b[i3], M[i3][i3]);
            for (var j = i3 - 1; j >= 0; j--) {
              b[j] = subtractScalar2(b[j], multiplyScalar2(b[i3], M[j][i3]));
            }
          } else if (!equalScalar2(b[i3], 0)) {
            if (k === 0) {
              return [];
            } else {
              B2.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i3] = 1;
            for (var _j = i3 - 1; _j >= 0; _j--) {
              bNew[_j] = subtractScalar2(bNew[_j], M[_j][i3]);
            }
            B2.push(bNew);
          }
        }
      }
      return B2.map((x) => new DenseMatrix2({
        data: x.map((e3) => [e3]),
        size: [rows, 1]
      }));
    }
    function _sparseBackwardSubstitution(m, b_) {
      var B2 = [solveValidation(m, b_, true)._data.map((e3) => e3[0])];
      var rows = m._size[0];
      var columns = m._size[1];
      var values = m._values;
      var index2 = m._index;
      var ptr = m._ptr;
      for (var i3 = columns - 1; i3 >= 0; i3--) {
        var L = B2.length;
        for (var k = 0; k < L; k++) {
          var b = B2[k];
          var iValues = [];
          var iIndices = [];
          var firstIndex = ptr[i3];
          var lastIndex = ptr[i3 + 1];
          var Mii = 0;
          for (var j = lastIndex - 1; j >= firstIndex; j--) {
            var J = index2[j];
            if (J === i3) {
              Mii = values[j];
            } else if (J < i3) {
              iValues.push(values[j]);
              iIndices.push(J);
            }
          }
          if (!equalScalar2(Mii, 0)) {
            b[i3] = divideScalar2(b[i3], Mii);
            for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
              var _J = iIndices[_j2];
              b[_J] = subtractScalar2(b[_J], multiplyScalar2(b[i3], iValues[_j2]));
            }
          } else if (!equalScalar2(b[i3], 0)) {
            if (k === 0) {
              return [];
            } else {
              B2.splice(k, 1);
              k -= 1;
              L -= 1;
            }
          } else if (k === 0) {
            var bNew = [...b];
            bNew[i3] = 1;
            for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
              var _J2 = iIndices[_j3];
              bNew[_J2] = subtractScalar2(bNew[_J2], iValues[_j3]);
            }
            B2.push(bNew);
          }
        }
      }
      return B2.map((x) => new DenseMatrix2({
        data: x.map((e3) => [e3]),
        size: [rows, 1]
      }));
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/utils/matAlgo08xS0Sid.js
  var name137 = "matAlgo08xS0Sid";
  var dependencies137 = ["typed", "equalScalar"];
  var createMatAlgo08xS0Sid = /* @__PURE__ */ factory(name137, dependencies137, (_ref) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2
    } = _ref;
    return function matAlgo08xS0Sid(a, b, callback) {
      var avalues = a._values;
      var aindex = a._index;
      var aptr = a._ptr;
      var asize = a._size;
      var adt = a._datatype;
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var bsize = b._size;
      var bdt = b._datatype;
      if (asize.length !== bsize.length) {
        throw new DimensionError(asize.length, bsize.length);
      }
      if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      if (!avalues || !bvalues) {
        throw new Error("Cannot perform operation on Pattern Sparse Matrices");
      }
      var rows = asize[0];
      var columns = asize[1];
      var dt;
      var eq = equalScalar2;
      var zero = 0;
      var cf = callback;
      if (typeof adt === "string" && adt === bdt) {
        dt = adt;
        eq = typed3.find(equalScalar2, [dt, dt]);
        zero = typed3.convert(0, dt);
        cf = typed3.find(callback, [dt, dt]);
      }
      var cvalues = [];
      var cindex = [];
      var cptr = [];
      var x = [];
      var w2 = [];
      var k, k0, k1, i3;
      for (var j = 0; j < columns; j++) {
        cptr[j] = cindex.length;
        var mark = j + 1;
        for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
          i3 = aindex[k];
          w2[i3] = mark;
          x[i3] = avalues[k];
          cindex.push(i3);
        }
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i3 = bindex[k];
          if (w2[i3] === mark) {
            x[i3] = cf(x[i3], bvalues[k]);
          }
        }
        k = cptr[j];
        while (k < cindex.length) {
          i3 = cindex[k];
          var v = x[i3];
          if (!eq(v, zero)) {
            cvalues.push(v);
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
      cptr[columns] = cindex.length;
      return a.createSparseMatrix({
        values: cvalues,
        index: cindex,
        ptr: cptr,
        size: [rows, columns],
        datatype: dt
      });
    };
  });

  // node_modules/mathjs/lib/esm/function/bitwise/useMatrixForArrayScalar.js
  var createUseMatrixForArrayScalar = /* @__PURE__ */ factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2
    } = _ref;
    return {
      "Array, number": typed3.referTo("DenseMatrix, number", (selfDn) => (x, y2) => selfDn(matrix2(x), y2).valueOf()),
      "Array, BigNumber": typed3.referTo("DenseMatrix, BigNumber", (selfDB) => (x, y2) => selfDB(matrix2(x), y2).valueOf()),
      "number, Array": typed3.referTo("number, DenseMatrix", (selfnD) => (x, y2) => selfnD(x, matrix2(y2)).valueOf()),
      "BigNumber, Array": typed3.referTo("BigNumber, DenseMatrix", (selfBD) => (x, y2) => selfBD(x, matrix2(y2)).valueOf())
    };
  });

  // node_modules/mathjs/lib/esm/function/bitwise/leftShift.js
  var name138 = "leftShift";
  var dependencies138 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
  var createLeftShift = /* @__PURE__ */ factory(name138, dependencies138, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed: typed3
    });
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
      typed: typed3,
      matrix: matrix2
    });
    return typed3(name138, {
      "number, number": leftShiftNumber,
      "BigNumber, BigNumber": leftShiftBigNumber,
      "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(y2, 0)) {
          return x.clone();
        }
        return matAlgo11xS0s(x, y2, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(y2, 0)) {
          return x.clone();
        }
        return matAlgo14xDs(x, y2, self2, false);
      }),
      "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(x, 0)) {
          return zeros3(y2.size(), y2.storage());
        }
        return matAlgo10xSids(y2, x, self2, true);
      }),
      "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(x, 0)) {
          return zeros3(y2.size(), y2.storage());
        }
        return matAlgo14xDs(y2, x, self2, true);
      })
    }, useMatrixForArrayScalar, matrixAlgorithmSuite({
      SS: matAlgo08xS0Sid,
      DS: matAlgo01xDSid,
      SD: matAlgo02xDS0
    }));
  });

  // node_modules/mathjs/lib/esm/function/bitwise/rightArithShift.js
  var name139 = "rightArithShift";
  var dependencies139 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
  var createRightArithShift = /* @__PURE__ */ factory(name139, dependencies139, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed: typed3
    });
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
      typed: typed3,
      matrix: matrix2
    });
    return typed3(name139, {
      "number, number": rightArithShiftNumber,
      "BigNumber, BigNumber": rightArithShiftBigNumber,
      "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(y2, 0)) {
          return x.clone();
        }
        return matAlgo11xS0s(x, y2, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(y2, 0)) {
          return x.clone();
        }
        return matAlgo14xDs(x, y2, self2, false);
      }),
      "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(x, 0)) {
          return zeros3(y2.size(), y2.storage());
        }
        return matAlgo10xSids(y2, x, self2, true);
      }),
      "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(x, 0)) {
          return zeros3(y2.size(), y2.storage());
        }
        return matAlgo14xDs(y2, x, self2, true);
      })
    }, useMatrixForArrayScalar, matrixAlgorithmSuite({
      SS: matAlgo08xS0Sid,
      DS: matAlgo01xDSid,
      SD: matAlgo02xDS0
    }));
  });

  // node_modules/mathjs/lib/esm/function/bitwise/rightLogShift.js
  var name140 = "rightLogShift";
  var dependencies140 = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
  var createRightLogShift = /* @__PURE__ */ factory(name140, dependencies140, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed: typed3
    });
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
      typed: typed3,
      matrix: matrix2
    });
    return typed3(name140, {
      "number, number": rightLogShiftNumber,
      // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
      "SparseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(y2, 0)) {
          return x.clone();
        }
        return matAlgo11xS0s(x, y2, self2, false);
      }),
      "DenseMatrix, number | BigNumber": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(y2, 0)) {
          return x.clone();
        }
        return matAlgo14xDs(x, y2, self2, false);
      }),
      "number | BigNumber, SparseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(x, 0)) {
          return zeros3(y2.size(), y2.storage());
        }
        return matAlgo10xSids(y2, x, self2, true);
      }),
      "number | BigNumber, DenseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (equalScalar2(x, 0)) {
          return zeros3(y2.size(), y2.storage());
        }
        return matAlgo14xDs(y2, x, self2, true);
      })
    }, useMatrixForArrayScalar, matrixAlgorithmSuite({
      SS: matAlgo08xS0Sid,
      DS: matAlgo01xDSid,
      SD: matAlgo02xDS0
    }));
  });

  // node_modules/mathjs/lib/esm/function/logical/and.js
  var name141 = "and";
  var dependencies141 = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"];
  var createAnd = /* @__PURE__ */ factory(name141, dependencies141, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      zeros: zeros3,
      not: not2,
      concat: concat3
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo06xS0S0 = createMatAlgo06xS0S0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name141, {
      "number, number": andNumber,
      "Complex, Complex": function ComplexComplex(x, y2) {
        return (x.re !== 0 || x.im !== 0) && (y2.re !== 0 || y2.im !== 0);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return !x.isZero() && !y2.isZero() && !x.isNaN() && !y2.isNaN();
      },
      "Unit, Unit": typed3.referToSelf((self2) => (x, y2) => self2(x.value || 0, y2.value || 0)),
      "SparseMatrix, any": typed3.referToSelf((self2) => (x, y2) => {
        if (not2(y2)) {
          return zeros3(x.size(), x.storage());
        }
        return matAlgo11xS0s(x, y2, self2, false);
      }),
      "DenseMatrix, any": typed3.referToSelf((self2) => (x, y2) => {
        if (not2(y2)) {
          return zeros3(x.size(), x.storage());
        }
        return matAlgo14xDs(x, y2, self2, false);
      }),
      "any, SparseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (not2(x)) {
          return zeros3(x.size(), x.storage());
        }
        return matAlgo11xS0s(y2, x, self2, true);
      }),
      "any, DenseMatrix": typed3.referToSelf((self2) => (x, y2) => {
        if (not2(x)) {
          return zeros3(x.size(), x.storage());
        }
        return matAlgo14xDs(y2, x, self2, true);
      }),
      "Array, any": typed3.referToSelf((self2) => (x, y2) => {
        return self2(matrix2(x), y2).valueOf();
      }),
      "any, Array": typed3.referToSelf((self2) => (x, y2) => {
        return self2(x, matrix2(y2)).valueOf();
      })
    }, matrixAlgorithmSuite({
      SS: matAlgo06xS0S0,
      DS: matAlgo02xDS0
    }));
  });

  // node_modules/mathjs/lib/esm/function/relational/compare.js
  var name142 = "compare";
  var dependencies142 = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"];
  var createCompare = /* @__PURE__ */ factory(name142, dependencies142, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      equalScalar: equalScalar2,
      matrix: matrix2,
      BigNumber: BigNumber2,
      Fraction: Fraction3,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo05xSfSf = createMatAlgo05xSfSf({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var compareUnits = createCompareUnits({
      typed: typed3
    });
    return typed3(name142, createCompareNumber({
      typed: typed3,
      config: config4
    }), {
      "boolean, boolean": function booleanBoolean(x, y2) {
        return x === y2 ? 0 : x > y2 ? 1 : -1;
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return nearlyEqual2(x, y2, config4.epsilon) ? new BigNumber2(0) : new BigNumber2(x.cmp(y2));
      },
      "Fraction, Fraction": function FractionFraction(x, y2) {
        return new Fraction3(x.compare(y2));
      },
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo05xSfSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createCompareNumber = /* @__PURE__ */ factory(name142, ["typed", "config"], (_ref2) => {
    var {
      typed: typed3,
      config: config4
    } = _ref2;
    return typed3(name142, {
      "number, number": function numberNumber(x, y2) {
        return nearlyEqual(x, y2, config4.epsilon) ? 0 : x > y2 ? 1 : -1;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/compareNatural.js
  var import_javascript_natural_sort = __toESM(require_naturalSort(), 1);
  var name143 = "compareNatural";
  var dependencies143 = ["typed", "compare"];
  var createCompareNatural = /* @__PURE__ */ factory(name143, dependencies143, (_ref) => {
    var {
      typed: typed3,
      compare: compare2
    } = _ref;
    var compareBooleans = compare2.signatures["boolean,boolean"];
    return typed3(name143, {
      "any, any": _compareNatural
    });
    function _compareNatural(x, y2) {
      var typeX = typeOf(x);
      var typeY = typeOf(y2);
      var c;
      if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
        c = compare2(x, y2);
        if (c.toString() !== "0") {
          return c > 0 ? 1 : -1;
        } else {
          return (0, import_javascript_natural_sort.default)(typeX, typeY);
        }
      }
      var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
      if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
        c = compareMatricesAndArrays(_compareNatural, x, y2);
        if (c !== 0) {
          return c;
        } else {
          return (0, import_javascript_natural_sort.default)(typeX, typeY);
        }
      }
      if (typeX !== typeY) {
        return (0, import_javascript_natural_sort.default)(typeX, typeY);
      }
      if (typeX === "Complex") {
        return compareComplexNumbers(x, y2);
      }
      if (typeX === "Unit") {
        if (x.equalBase(y2)) {
          return _compareNatural(x.value, y2.value);
        }
        return compareArrays(_compareNatural, x.formatUnits(), y2.formatUnits());
      }
      if (typeX === "boolean") {
        return compareBooleans(x, y2);
      }
      if (typeX === "string") {
        return (0, import_javascript_natural_sort.default)(x, y2);
      }
      if (typeX === "Object") {
        return compareObjects(_compareNatural, x, y2);
      }
      if (typeX === "null") {
        return 0;
      }
      if (typeX === "undefined") {
        return 0;
      }
      throw new TypeError('Unsupported type of value "' + typeX + '"');
    }
    function compareMatricesAndArrays(compareNatural2, x, y2) {
      if (isSparseMatrix(x) && isSparseMatrix(y2)) {
        return compareArrays(compareNatural2, x.toJSON().values, y2.toJSON().values);
      }
      if (isSparseMatrix(x)) {
        return compareMatricesAndArrays(compareNatural2, x.toArray(), y2);
      }
      if (isSparseMatrix(y2)) {
        return compareMatricesAndArrays(compareNatural2, x, y2.toArray());
      }
      if (isDenseMatrix(x)) {
        return compareMatricesAndArrays(compareNatural2, x.toJSON().data, y2);
      }
      if (isDenseMatrix(y2)) {
        return compareMatricesAndArrays(compareNatural2, x, y2.toJSON().data);
      }
      if (!Array.isArray(x)) {
        return compareMatricesAndArrays(compareNatural2, [x], y2);
      }
      if (!Array.isArray(y2)) {
        return compareMatricesAndArrays(compareNatural2, x, [y2]);
      }
      return compareArrays(compareNatural2, x, y2);
    }
    function compareArrays(compareNatural2, x, y2) {
      for (var i3 = 0, ii = Math.min(x.length, y2.length); i3 < ii; i3++) {
        var v = compareNatural2(x[i3], y2[i3]);
        if (v !== 0) {
          return v;
        }
      }
      if (x.length > y2.length) {
        return 1;
      }
      if (x.length < y2.length) {
        return -1;
      }
      return 0;
    }
    function compareObjects(compareNatural2, x, y2) {
      var keysX = Object.keys(x);
      var keysY = Object.keys(y2);
      keysX.sort(import_javascript_natural_sort.default);
      keysY.sort(import_javascript_natural_sort.default);
      var c = compareArrays(compareNatural2, keysX, keysY);
      if (c !== 0) {
        return c;
      }
      for (var i3 = 0; i3 < keysX.length; i3++) {
        var v = compareNatural2(x[keysX[i3]], y2[keysY[i3]]);
        if (v !== 0) {
          return v;
        }
      }
      return 0;
    }
  });
  function compareComplexNumbers(x, y2) {
    if (x.re > y2.re) {
      return 1;
    }
    if (x.re < y2.re) {
      return -1;
    }
    if (x.im > y2.im) {
      return 1;
    }
    if (x.im < y2.im) {
      return -1;
    }
    return 0;
  }

  // node_modules/mathjs/lib/esm/function/relational/compareText.js
  var name144 = "compareText";
  var dependencies144 = ["typed", "matrix", "concat"];
  compareText.signature = "any, any";
  var createCompareText = /* @__PURE__ */ factory(name144, dependencies144, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    } = _ref;
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name144, compareText, matrixAlgorithmSuite({
      elop: compareText,
      Ds: true
    }));
  });

  // node_modules/mathjs/lib/esm/function/relational/equal.js
  var name145 = "equal";
  var dependencies145 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
  var createEqual = /* @__PURE__ */ factory(name145, dependencies145, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name145, createEqualNumber({
      typed: typed3,
      equalScalar: equalScalar2
    }), matrixAlgorithmSuite({
      elop: equalScalar2,
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createEqualNumber = factory(name145, ["typed", "equalScalar"], (_ref2) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2
    } = _ref2;
    return typed3(name145, {
      "any, any": function anyAny(x, y2) {
        if (x === null) {
          return y2 === null;
        }
        if (y2 === null) {
          return x === null;
        }
        if (x === void 0) {
          return y2 === void 0;
        }
        if (y2 === void 0) {
          return x === void 0;
        }
        return equalScalar2(x, y2);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/equalText.js
  var name146 = "equalText";
  var dependencies146 = ["typed", "compareText", "isZero"];
  var createEqualText = /* @__PURE__ */ factory(name146, dependencies146, (_ref) => {
    var {
      typed: typed3,
      compareText: compareText3,
      isZero: isZero2
    } = _ref;
    return typed3(name146, {
      "any, any": function anyAny(x, y2) {
        return isZero2(compareText3(x, y2));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/smaller.js
  var name147 = "smaller";
  var dependencies147 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
  var createSmaller = /* @__PURE__ */ factory(name147, dependencies147, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var compareUnits = createCompareUnits({
      typed: typed3
    });
    return typed3(name147, createSmallerNumber({
      typed: typed3,
      config: config4
    }), {
      "boolean, boolean": (x, y2) => x < y2,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return x.lt(y2) && !nearlyEqual2(x, y2, config4.epsilon);
      },
      "Fraction, Fraction": (x, y2) => x.compare(y2) === -1,
      "Complex, Complex": function ComplexComplex(x, y2) {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createSmallerNumber = /* @__PURE__ */ factory(name147, ["typed", "config"], (_ref2) => {
    var {
      typed: typed3,
      config: config4
    } = _ref2;
    return typed3(name147, {
      "number, number": function numberNumber(x, y2) {
        return x < y2 && !nearlyEqual(x, y2, config4.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/smallerEq.js
  var name148 = "smallerEq";
  var dependencies148 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
  var createSmallerEq = /* @__PURE__ */ factory(name148, dependencies148, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var compareUnits = createCompareUnits({
      typed: typed3
    });
    return typed3(name148, createSmallerEqNumber({
      typed: typed3,
      config: config4
    }), {
      "boolean, boolean": (x, y2) => x <= y2,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return x.lte(y2) || nearlyEqual2(x, y2, config4.epsilon);
      },
      "Fraction, Fraction": (x, y2) => x.compare(y2) !== 1,
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createSmallerEqNumber = /* @__PURE__ */ factory(name148, ["typed", "config"], (_ref2) => {
    var {
      typed: typed3,
      config: config4
    } = _ref2;
    return typed3(name148, {
      "number, number": function numberNumber(x, y2) {
        return x <= y2 || nearlyEqual(x, y2, config4.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/larger.js
  var name149 = "larger";
  var dependencies149 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
  var createLarger = /* @__PURE__ */ factory(name149, dependencies149, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var compareUnits = createCompareUnits({
      typed: typed3
    });
    return typed3(name149, createLargerNumber({
      typed: typed3,
      config: config4
    }), {
      "boolean, boolean": (x, y2) => x > y2,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return x.gt(y2) && !nearlyEqual2(x, y2, config4.epsilon);
      },
      "Fraction, Fraction": (x, y2) => x.compare(y2) === 1,
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createLargerNumber = /* @__PURE__ */ factory(name149, ["typed", "config"], (_ref2) => {
    var {
      typed: typed3,
      config: config4
    } = _ref2;
    return typed3(name149, {
      "number, number": function numberNumber(x, y2) {
        return x > y2 && !nearlyEqual(x, y2, config4.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/largerEq.js
  var name150 = "largerEq";
  var dependencies150 = ["typed", "config", "matrix", "DenseMatrix", "concat"];
  var createLargerEq = /* @__PURE__ */ factory(name150, dependencies150, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    var compareUnits = createCompareUnits({
      typed: typed3
    });
    return typed3(name150, createLargerEqNumber({
      typed: typed3,
      config: config4
    }), {
      "boolean, boolean": (x, y2) => x >= y2,
      "BigNumber, BigNumber": function BigNumberBigNumber(x, y2) {
        return x.gte(y2) || nearlyEqual2(x, y2, config4.epsilon);
      },
      "Fraction, Fraction": (x, y2) => x.compare(y2) !== -1,
      "Complex, Complex": function ComplexComplex() {
        throw new TypeError("No ordering relation is defined for complex numbers");
      }
    }, compareUnits, matrixAlgorithmSuite({
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
  });
  var createLargerEqNumber = /* @__PURE__ */ factory(name150, ["typed", "config"], (_ref2) => {
    var {
      typed: typed3,
      config: config4
    } = _ref2;
    return typed3(name150, {
      "number, number": function numberNumber(x, y2) {
        return x >= y2 || nearlyEqual(x, y2, config4.epsilon);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/relational/deepEqual.js
  var name151 = "deepEqual";
  var dependencies151 = ["typed", "equal"];
  var createDeepEqual = /* @__PURE__ */ factory(name151, dependencies151, (_ref) => {
    var {
      typed: typed3,
      equal: equal2
    } = _ref;
    return typed3(name151, {
      "any, any": function anyAny(x, y2) {
        return _deepEqual(x.valueOf(), y2.valueOf());
      }
    });
    function _deepEqual(x, y2) {
      if (Array.isArray(x)) {
        if (Array.isArray(y2)) {
          var len = x.length;
          if (len !== y2.length) {
            return false;
          }
          for (var i3 = 0; i3 < len; i3++) {
            if (!_deepEqual(x[i3], y2[i3])) {
              return false;
            }
          }
          return true;
        } else {
          return false;
        }
      } else {
        if (Array.isArray(y2)) {
          return false;
        } else {
          return equal2(x, y2);
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/relational/unequal.js
  var name152 = "unequal";
  var dependencies152 = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat"];
  var createUnequal = /* @__PURE__ */ factory(name152, dependencies152, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      equalScalar: equalScalar2,
      matrix: matrix2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo07xSSf = createMatAlgo07xSSf({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name152, createUnequalNumber({
      typed: typed3,
      equalScalar: equalScalar2
    }), matrixAlgorithmSuite({
      elop: _unequal,
      SS: matAlgo07xSSf,
      DS: matAlgo03xDSf,
      Ss: matAlgo12xSfs
    }));
    function _unequal(x, y2) {
      return !equalScalar2(x, y2);
    }
  });
  var createUnequalNumber = factory(name152, ["typed", "equalScalar"], (_ref2) => {
    var {
      typed: typed3,
      equalScalar: equalScalar2
    } = _ref2;
    return typed3(name152, {
      "any, any": function anyAny(x, y2) {
        if (x === null) {
          return y2 !== null;
        }
        if (y2 === null) {
          return x !== null;
        }
        if (x === void 0) {
          return y2 !== void 0;
        }
        if (y2 === void 0) {
          return x !== void 0;
        }
        return !equalScalar2(x, y2);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/partitionSelect.js
  var name153 = "partitionSelect";
  var dependencies153 = ["typed", "isNumeric", "isNaN", "compare"];
  var createPartitionSelect = /* @__PURE__ */ factory(name153, dependencies153, (_ref) => {
    var {
      typed: typed3,
      isNumeric: isNumeric2,
      isNaN: isNaN3,
      compare: compare2
    } = _ref;
    var asc = compare2;
    var desc = (a, b) => -compare2(a, b);
    return typed3(name153, {
      "Array | Matrix, number": function ArrayMatrixNumber(x, k) {
        return _partitionSelect(x, k, asc);
      },
      "Array | Matrix, number, string": function ArrayMatrixNumberString(x, k, compare3) {
        if (compare3 === "asc") {
          return _partitionSelect(x, k, asc);
        } else if (compare3 === "desc") {
          return _partitionSelect(x, k, desc);
        } else {
          throw new Error('Compare string must be "asc" or "desc"');
        }
      },
      "Array | Matrix, number, function": _partitionSelect
    });
    function _partitionSelect(x, k, compare3) {
      if (!isInteger(k) || k < 0) {
        throw new Error("k must be a non-negative integer");
      }
      if (isMatrix(x)) {
        var size2 = x.size();
        if (size2.length > 1) {
          throw new Error("Only one dimensional matrices supported");
        }
        return quickSelect(x.valueOf(), k, compare3);
      }
      if (Array.isArray(x)) {
        return quickSelect(x, k, compare3);
      }
    }
    function quickSelect(arr, k, compare3) {
      if (k >= arr.length) {
        throw new Error("k out of bounds");
      }
      for (var i3 = 0; i3 < arr.length; i3++) {
        if (isNumeric2(arr[i3]) && isNaN3(arr[i3])) {
          return arr[i3];
        }
      }
      var from = 0;
      var to2 = arr.length - 1;
      while (from < to2) {
        var r = from;
        var w2 = to2;
        var pivot = arr[Math.floor(Math.random() * (to2 - from + 1)) + from];
        while (r < w2) {
          if (compare3(arr[r], pivot) >= 0) {
            var tmp = arr[w2];
            arr[w2] = arr[r];
            arr[r] = tmp;
            --w2;
          } else {
            ++r;
          }
        }
        if (compare3(arr[r], pivot) > 0) {
          --r;
        }
        if (k <= r) {
          to2 = r;
        } else {
          from = r + 1;
        }
      }
      return arr[k];
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/sort.js
  var name154 = "sort";
  var dependencies154 = ["typed", "matrix", "compare", "compareNatural"];
  var createSort = /* @__PURE__ */ factory(name154, dependencies154, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      compare: compare2,
      compareNatural: compareNatural2
    } = _ref;
    var compareAsc = compare2;
    var compareDesc = (a, b) => -compare2(a, b);
    return typed3(name154, {
      Array: function Array2(x) {
        _arrayIsVector(x);
        return x.sort(compareAsc);
      },
      Matrix: function Matrix2(x) {
        _matrixIsVector(x);
        return matrix2(x.toArray().sort(compareAsc), x.storage());
      },
      "Array, function": function ArrayFunction(x, _comparator2) {
        _arrayIsVector(x);
        return x.sort(_comparator2);
      },
      "Matrix, function": function MatrixFunction(x, _comparator2) {
        _matrixIsVector(x);
        return matrix2(x.toArray().sort(_comparator2), x.storage());
      },
      "Array, string": function ArrayString(x, order) {
        _arrayIsVector(x);
        return x.sort(_comparator(order));
      },
      "Matrix, string": function MatrixString(x, order) {
        _matrixIsVector(x);
        return matrix2(x.toArray().sort(_comparator(order)), x.storage());
      }
    });
    function _comparator(order) {
      if (order === "asc") {
        return compareAsc;
      } else if (order === "desc") {
        return compareDesc;
      } else if (order === "natural") {
        return compareNatural2;
      } else {
        throw new Error('String "asc", "desc", or "natural" expected');
      }
    }
    function _arrayIsVector(array) {
      if (arraySize(array).length !== 1) {
        throw new Error("One dimensional array expected");
      }
    }
    function _matrixIsVector(matrix3) {
      if (matrix3.size().length !== 1) {
        throw new Error("One dimensional matrix expected");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/max.js
  var name155 = "max";
  var dependencies155 = ["typed", "config", "numeric", "larger"];
  var createMax = /* @__PURE__ */ factory(name155, dependencies155, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      numeric: numeric3,
      larger: larger2
    } = _ref;
    return typed3(name155, {
      // max([a, b, c, d, ...])
      "Array | Matrix": _max,
      // max([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        return reduce(array, dim.valueOf(), _largest);
      },
      // max(a, b, c, d, ...)
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function max");
        }
        return _max(args);
      }
    });
    function _largest(x, y2) {
      try {
        return larger2(x, y2) ? x : y2;
      } catch (err) {
        throw improveErrorMessage(err, "max", y2);
      }
    }
    function _max(array) {
      var res;
      deepForEach(array, function(value) {
        try {
          if (isNaN(value) && typeof value === "number") {
            res = NaN;
          } else if (res === void 0 || larger2(value, res)) {
            res = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, "max", value);
        }
      });
      if (res === void 0) {
        throw new Error("Cannot calculate max of an empty array");
      }
      if (typeof res === "string") {
        res = numeric3(res, config4.number);
      }
      return res;
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/min.js
  var name156 = "min";
  var dependencies156 = ["typed", "config", "numeric", "smaller"];
  var createMin = /* @__PURE__ */ factory(name156, dependencies156, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      numeric: numeric3,
      smaller: smaller2
    } = _ref;
    return typed3(name156, {
      // min([a, b, c, d, ...])
      "Array | Matrix": _min,
      // min([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        return reduce(array, dim.valueOf(), _smallest);
      },
      // min(a, b, c, d, ...)
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function min");
        }
        return _min(args);
      }
    });
    function _smallest(x, y2) {
      try {
        return smaller2(x, y2) ? x : y2;
      } catch (err) {
        throw improveErrorMessage(err, "min", y2);
      }
    }
    function _min(array) {
      var min3;
      deepForEach(array, function(value) {
        try {
          if (isNaN(value) && typeof value === "number") {
            min3 = NaN;
          } else if (min3 === void 0 || smaller2(value, min3)) {
            min3 = value;
          }
        } catch (err) {
          throw improveErrorMessage(err, "min", value);
        }
      });
      if (min3 === void 0) {
        throw new Error("Cannot calculate min of an empty array");
      }
      if (typeof min3 === "string") {
        min3 = numeric3(min3, config4.number);
      }
      return min3;
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/ImmutableDenseMatrix.js
  var name157 = "ImmutableDenseMatrix";
  var dependencies157 = ["smaller", "DenseMatrix"];
  var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name157, dependencies157, (_ref) => {
    var {
      smaller: smaller2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    function ImmutableDenseMatrix2(data, datatype) {
      if (!(this instanceof ImmutableDenseMatrix2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (datatype && !isString(datatype)) {
        throw new Error("Invalid datatype: " + datatype);
      }
      if (isMatrix(data) || isArray(data)) {
        var matrix2 = new DenseMatrix2(data, datatype);
        this._data = matrix2._data;
        this._size = matrix2._size;
        this._datatype = matrix2._datatype;
        this._min = null;
        this._max = null;
      } else if (data && isArray(data.data) && isArray(data.size)) {
        this._data = data.data;
        this._size = data.size;
        this._datatype = data.datatype;
        this._min = typeof data.min !== "undefined" ? data.min : null;
        this._max = typeof data.max !== "undefined" ? data.max : null;
      } else if (data) {
        throw new TypeError("Unsupported type of data (" + typeOf(data) + ")");
      } else {
        this._data = [];
        this._size = [0];
        this._datatype = datatype;
        this._min = null;
        this._max = null;
      }
    }
    ImmutableDenseMatrix2.prototype = new DenseMatrix2();
    ImmutableDenseMatrix2.prototype.type = "ImmutableDenseMatrix";
    ImmutableDenseMatrix2.prototype.isImmutableDenseMatrix = true;
    ImmutableDenseMatrix2.prototype.subset = function(index2) {
      switch (arguments.length) {
        case 1: {
          var m = DenseMatrix2.prototype.subset.call(this, index2);
          if (isMatrix(m)) {
            return new ImmutableDenseMatrix2({
              data: m._data,
              size: m._size,
              datatype: m._datatype
            });
          }
          return m;
        }
        case 2:
        case 3:
          throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
        default:
          throw new SyntaxError("Wrong number of arguments");
      }
    };
    ImmutableDenseMatrix2.prototype.set = function() {
      throw new Error("Cannot invoke set on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix2.prototype.resize = function() {
      throw new Error("Cannot invoke resize on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix2.prototype.reshape = function() {
      throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix2.prototype.clone = function() {
      return new ImmutableDenseMatrix2({
        data: clone(this._data),
        size: clone(this._size),
        datatype: this._datatype
      });
    };
    ImmutableDenseMatrix2.prototype.toJSON = function() {
      return {
        mathjs: "ImmutableDenseMatrix",
        data: this._data,
        size: this._size,
        datatype: this._datatype
      };
    };
    ImmutableDenseMatrix2.fromJSON = function(json) {
      return new ImmutableDenseMatrix2(json);
    };
    ImmutableDenseMatrix2.prototype.swapRows = function() {
      throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
    };
    ImmutableDenseMatrix2.prototype.min = function() {
      if (this._min === null) {
        var m = null;
        this.forEach(function(v) {
          if (m === null || smaller2(v, m)) {
            m = v;
          }
        });
        this._min = m !== null ? m : void 0;
      }
      return this._min;
    };
    ImmutableDenseMatrix2.prototype.max = function() {
      if (this._max === null) {
        var m = null;
        this.forEach(function(v) {
          if (m === null || smaller2(m, v)) {
            m = v;
          }
        });
        this._max = m !== null ? m : void 0;
      }
      return this._max;
    };
    return ImmutableDenseMatrix2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/MatrixIndex.js
  var name158 = "Index";
  var dependencies158 = ["ImmutableDenseMatrix", "getMatrixDataType"];
  var createIndexClass = /* @__PURE__ */ factory(name158, dependencies158, (_ref) => {
    var {
      ImmutableDenseMatrix: ImmutableDenseMatrix2,
      getMatrixDataType: getMatrixDataType2
    } = _ref;
    function Index2(ranges) {
      if (!(this instanceof Index2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._dimensions = [];
      this._sourceSize = [];
      this._isScalar = true;
      for (var i3 = 0, ii = arguments.length; i3 < ii; i3++) {
        var arg2 = arguments[i3];
        var argIsArray = isArray(arg2);
        var argIsMatrix = isMatrix(arg2);
        var sourceSize = null;
        if (isRange(arg2)) {
          this._dimensions.push(arg2);
          this._isScalar = false;
        } else if (argIsArray || argIsMatrix) {
          var m = void 0;
          if (getMatrixDataType2(arg2) === "boolean") {
            if (argIsArray)
              m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2).valueOf());
            if (argIsMatrix)
              m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2._data).valueOf());
            sourceSize = arg2.valueOf().length;
          } else {
            m = _createImmutableMatrix(arg2.valueOf());
          }
          this._dimensions.push(m);
          var size2 = m.size();
          if (size2.length !== 1 || size2[0] !== 1 || sourceSize !== null) {
            this._isScalar = false;
          }
        } else if (typeof arg2 === "number") {
          this._dimensions.push(_createImmutableMatrix([arg2]));
        } else if (typeof arg2 === "string") {
          this._dimensions.push(arg2);
        } else {
          throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
        }
        this._sourceSize.push(sourceSize);
      }
    }
    Index2.prototype.type = "Index";
    Index2.prototype.isIndex = true;
    function _createImmutableMatrix(arg2) {
      for (var i3 = 0, l = arg2.length; i3 < l; i3++) {
        if (typeof arg2[i3] !== "number" || !isInteger(arg2[i3])) {
          throw new TypeError("Index parameters must be positive integer numbers");
        }
      }
      return new ImmutableDenseMatrix2(arg2);
    }
    Index2.prototype.clone = function() {
      var index2 = new Index2();
      index2._dimensions = clone(this._dimensions);
      index2._isScalar = this._isScalar;
      index2._sourceSize = this._sourceSize;
      return index2;
    };
    Index2.create = function(ranges) {
      var index2 = new Index2();
      Index2.apply(index2, ranges);
      return index2;
    };
    Index2.prototype.size = function() {
      var size2 = [];
      for (var i3 = 0, ii = this._dimensions.length; i3 < ii; i3++) {
        var d = this._dimensions[i3];
        size2[i3] = typeof d === "string" ? 1 : d.size()[0];
      }
      return size2;
    };
    Index2.prototype.max = function() {
      var values = [];
      for (var i3 = 0, ii = this._dimensions.length; i3 < ii; i3++) {
        var range2 = this._dimensions[i3];
        values[i3] = typeof range2 === "string" ? range2 : range2.max();
      }
      return values;
    };
    Index2.prototype.min = function() {
      var values = [];
      for (var i3 = 0, ii = this._dimensions.length; i3 < ii; i3++) {
        var range2 = this._dimensions[i3];
        values[i3] = typeof range2 === "string" ? range2 : range2.min();
      }
      return values;
    };
    Index2.prototype.forEach = function(callback) {
      for (var i3 = 0, ii = this._dimensions.length; i3 < ii; i3++) {
        callback(this._dimensions[i3], i3, this);
      }
    };
    Index2.prototype.dimension = function(dim) {
      return this._dimensions[dim] || null;
    };
    Index2.prototype.isObjectProperty = function() {
      return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
    };
    Index2.prototype.getObjectProperty = function() {
      return this.isObjectProperty() ? this._dimensions[0] : null;
    };
    Index2.prototype.isScalar = function() {
      return this._isScalar;
    };
    Index2.prototype.toArray = function() {
      var array = [];
      for (var i3 = 0, ii = this._dimensions.length; i3 < ii; i3++) {
        var dimension = this._dimensions[i3];
        array.push(typeof dimension === "string" ? dimension : dimension.toArray());
      }
      return array;
    };
    Index2.prototype.valueOf = Index2.prototype.toArray;
    Index2.prototype.toString = function() {
      var strings = [];
      for (var i3 = 0, ii = this._dimensions.length; i3 < ii; i3++) {
        var dimension = this._dimensions[i3];
        if (typeof dimension === "string") {
          strings.push(JSON.stringify(dimension));
        } else {
          strings.push(dimension.toString());
        }
      }
      return "[" + strings.join(", ") + "]";
    };
    Index2.prototype.toJSON = function() {
      return {
        mathjs: "Index",
        dimensions: this._dimensions
      };
    };
    Index2.fromJSON = function(json) {
      return Index2.create(json.dimensions);
    };
    return Index2;
  }, {
    isClass: true
  });
  function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
    var indexOfNumbers = [];
    booleanArrayIndex.forEach((bool, idx) => {
      if (bool) {
        indexOfNumbers.push(idx);
      }
    });
    return indexOfNumbers;
  }

  // node_modules/mathjs/lib/esm/type/matrix/FibonacciHeap.js
  var name159 = "FibonacciHeap";
  var dependencies159 = ["smaller", "larger"];
  var createFibonacciHeapClass = /* @__PURE__ */ factory(name159, dependencies159, (_ref) => {
    var {
      smaller: smaller2,
      larger: larger2
    } = _ref;
    var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
    function FibonacciHeap2() {
      if (!(this instanceof FibonacciHeap2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._minimum = null;
      this._size = 0;
    }
    FibonacciHeap2.prototype.type = "FibonacciHeap";
    FibonacciHeap2.prototype.isFibonacciHeap = true;
    FibonacciHeap2.prototype.insert = function(key, value) {
      var node = {
        key,
        value,
        degree: 0
      };
      if (this._minimum) {
        var minimum = this._minimum;
        node.left = minimum;
        node.right = minimum.right;
        minimum.right = node;
        node.right.left = node;
        if (smaller2(key, minimum.key)) {
          this._minimum = node;
        }
      } else {
        node.left = node;
        node.right = node;
        this._minimum = node;
      }
      this._size++;
      return node;
    };
    FibonacciHeap2.prototype.size = function() {
      return this._size;
    };
    FibonacciHeap2.prototype.clear = function() {
      this._minimum = null;
      this._size = 0;
    };
    FibonacciHeap2.prototype.isEmpty = function() {
      return this._size === 0;
    };
    FibonacciHeap2.prototype.extractMinimum = function() {
      var node = this._minimum;
      if (node === null) {
        return node;
      }
      var minimum = this._minimum;
      var numberOfChildren = node.degree;
      var x = node.child;
      while (numberOfChildren > 0) {
        var tempRight = x.right;
        x.left.right = x.right;
        x.right.left = x.left;
        x.left = minimum;
        x.right = minimum.right;
        minimum.right = x;
        x.right.left = x;
        x.parent = null;
        x = tempRight;
        numberOfChildren--;
      }
      node.left.right = node.right;
      node.right.left = node.left;
      if (node === node.right) {
        minimum = null;
      } else {
        minimum = node.right;
        minimum = _findMinimumNode(minimum, this._size);
      }
      this._size--;
      this._minimum = minimum;
      return node;
    };
    FibonacciHeap2.prototype.remove = function(node) {
      this._minimum = _decreaseKey(this._minimum, node, -1);
      this.extractMinimum();
    };
    function _decreaseKey(minimum, node, key) {
      node.key = key;
      var parent = node.parent;
      if (parent && smaller2(node.key, parent.key)) {
        _cut(minimum, node, parent);
        _cascadingCut(minimum, parent);
      }
      if (smaller2(node.key, minimum.key)) {
        minimum = node;
      }
      return minimum;
    }
    function _cut(minimum, node, parent) {
      node.left.right = node.right;
      node.right.left = node.left;
      parent.degree--;
      if (parent.child === node) {
        parent.child = node.right;
      }
      if (parent.degree === 0) {
        parent.child = null;
      }
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      node.parent = null;
      node.mark = false;
    }
    function _cascadingCut(minimum, node) {
      var parent = node.parent;
      if (!parent) {
        return;
      }
      if (!node.mark) {
        node.mark = true;
      } else {
        _cut(minimum, node, parent);
        _cascadingCut(parent);
      }
    }
    var _linkNodes = function _linkNodes2(node, parent) {
      node.left.right = node.right;
      node.right.left = node.left;
      node.parent = parent;
      if (!parent.child) {
        parent.child = node;
        node.right = node;
        node.left = node;
      } else {
        node.left = parent.child;
        node.right = parent.child.right;
        parent.child.right = node;
        node.right.left = node;
      }
      parent.degree++;
      node.mark = false;
    };
    function _findMinimumNode(minimum, size2) {
      var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
      var array = new Array(arraySize2);
      var numRoots = 0;
      var x = minimum;
      if (x) {
        numRoots++;
        x = x.right;
        while (x !== minimum) {
          numRoots++;
          x = x.right;
        }
      }
      var y2;
      while (numRoots > 0) {
        var d = x.degree;
        var next = x.right;
        while (true) {
          y2 = array[d];
          if (!y2) {
            break;
          }
          if (larger2(x.key, y2.key)) {
            var temp = y2;
            y2 = x;
            x = temp;
          }
          _linkNodes(y2, x);
          array[d] = null;
          d++;
        }
        array[d] = x;
        x = next;
        numRoots--;
      }
      minimum = null;
      for (var i3 = 0; i3 < arraySize2; i3++) {
        y2 = array[i3];
        if (!y2) {
          continue;
        }
        if (minimum) {
          y2.left.right = y2.right;
          y2.right.left = y2.left;
          y2.left = minimum;
          y2.right = minimum.right;
          minimum.right = y2;
          y2.right.left = y2;
          if (smaller2(y2.key, minimum.key)) {
            minimum = y2;
          }
        } else {
          minimum = y2;
        }
      }
      return minimum;
    }
    return FibonacciHeap2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/matrix/Spa.js
  var name160 = "Spa";
  var dependencies160 = ["addScalar", "equalScalar", "FibonacciHeap"];
  var createSpaClass = /* @__PURE__ */ factory(name160, dependencies160, (_ref) => {
    var {
      addScalar: addScalar2,
      equalScalar: equalScalar2,
      FibonacciHeap: FibonacciHeap2
    } = _ref;
    function Spa2() {
      if (!(this instanceof Spa2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      this._values = [];
      this._heap = new FibonacciHeap2();
    }
    Spa2.prototype.type = "Spa";
    Spa2.prototype.isSpa = true;
    Spa2.prototype.set = function(i3, v) {
      if (!this._values[i3]) {
        var node = this._heap.insert(i3, v);
        this._values[i3] = node;
      } else {
        this._values[i3].value = v;
      }
    };
    Spa2.prototype.get = function(i3) {
      var node = this._values[i3];
      if (node) {
        return node.value;
      }
      return 0;
    };
    Spa2.prototype.accumulate = function(i3, v) {
      var node = this._values[i3];
      if (!node) {
        node = this._heap.insert(i3, v);
        this._values[i3] = node;
      } else {
        node.value = addScalar2(node.value, v);
      }
    };
    Spa2.prototype.forEach = function(from, to2, callback) {
      var heap = this._heap;
      var values = this._values;
      var nodes = [];
      var node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
      while (node && node.key <= to2) {
        if (node.key >= from) {
          if (!equalScalar2(node.value, 0)) {
            callback(node.key, node.value, this);
          }
        }
        node = heap.extractMinimum();
        if (node) {
          nodes.push(node);
        }
      }
      for (var i3 = 0; i3 < nodes.length; i3++) {
        var n = nodes[i3];
        node = heap.insert(n.key, n.value);
        values[node.key] = node;
      }
    };
    Spa2.prototype.swap = function(i3, j) {
      var nodei = this._values[i3];
      var nodej = this._values[j];
      if (!nodei && nodej) {
        nodei = this._heap.insert(i3, nodej.value);
        this._heap.remove(nodej);
        this._values[i3] = nodei;
        this._values[j] = void 0;
      } else if (nodei && !nodej) {
        nodej = this._heap.insert(j, nodei.value);
        this._heap.remove(nodei);
        this._values[j] = nodej;
        this._values[i3] = void 0;
      } else if (nodei && nodej) {
        var v = nodei.value;
        nodei.value = nodej.value;
        nodej.value = v;
      }
    };
    return Spa2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/utils/bignumber/constants.js
  var createBigNumberE = memoize(function(BigNumber2) {
    return new BigNumber2(1).exp();
  }, {
    hasher
  });
  var createBigNumberPhi = memoize(function(BigNumber2) {
    return new BigNumber2(1).plus(new BigNumber2(5).sqrt()).div(2);
  }, {
    hasher
  });
  var createBigNumberPi = memoize(function(BigNumber2) {
    return BigNumber2.acos(-1);
  }, {
    hasher
  });
  var createBigNumberTau = memoize(function(BigNumber2) {
    return createBigNumberPi(BigNumber2).times(2);
  }, {
    hasher
  });
  function hasher(args) {
    return args[0].precision;
  }

  // node_modules/mathjs/lib/esm/type/unit/Unit.js
  function ownKeys2(e3, r) {
    var t = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e3);
      r && (o2 = o2.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  function _objectSpread2(e3) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
        _defineProperty(e3, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
        Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e3;
  }
  var name161 = "Unit";
  var dependencies161 = ["?on", "config", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
  var createUnitClass = /* @__PURE__ */ factory(name161, dependencies161, (_ref) => {
    var {
      on,
      config: config4,
      addScalar: addScalar2,
      subtractScalar: subtractScalar2,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      pow: pow3,
      abs: abs3,
      fix: fix2,
      round: round3,
      equal: equal2,
      isNumeric: isNumeric2,
      format: format5,
      number: _number,
      Complex: Complex3,
      BigNumber: _BigNumber,
      Fraction: _Fraction
    } = _ref;
    var toNumber = _number;
    function Unit2(value, valuelessUnit) {
      if (!(this instanceof Unit2)) {
        throw new Error("Constructor must be called with the new operator");
      }
      if (!(value === null || value === void 0 || isNumeric2(value) || isComplex(value))) {
        throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
      }
      this.fixPrefix = false;
      this.skipAutomaticSimplification = true;
      if (valuelessUnit === void 0) {
        this.units = [];
        this.dimensions = BASE_DIMENSIONS.map((x) => 0);
      } else if (typeof valuelessUnit === "string") {
        var u = Unit2.parse(valuelessUnit);
        this.units = u.units;
        this.dimensions = u.dimensions;
      } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
        this.fixPrefix = valuelessUnit.fixPrefix;
        this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
        this.dimensions = valuelessUnit.dimensions.slice(0);
        this.units = valuelessUnit.units.map((u2) => _extends({}, u2));
      } else {
        throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
      }
      this.value = this._normalize(value);
    }
    Object.defineProperty(Unit2, "name", {
      value: "Unit"
    });
    Unit2.prototype.constructor = Unit2;
    Unit2.prototype.type = "Unit";
    Unit2.prototype.isUnit = true;
    var text, index2, c;
    function skipWhitespace() {
      while (c === " " || c === "	") {
        next();
      }
    }
    function isDigitDot(c2) {
      return c2 >= "0" && c2 <= "9" || c2 === ".";
    }
    function isDigit(c2) {
      return c2 >= "0" && c2 <= "9";
    }
    function next() {
      index2++;
      c = text.charAt(index2);
    }
    function revert(oldIndex) {
      index2 = oldIndex;
      c = text.charAt(index2);
    }
    function parseNumber() {
      var number2 = "";
      var oldIndex = index2;
      if (c === "+") {
        next();
      } else if (c === "-") {
        number2 += c;
        next();
      }
      if (!isDigitDot(c)) {
        revert(oldIndex);
        return null;
      }
      if (c === ".") {
        number2 += c;
        next();
        if (!isDigit(c)) {
          revert(oldIndex);
          return null;
        }
      } else {
        while (isDigit(c)) {
          number2 += c;
          next();
        }
        if (c === ".") {
          number2 += c;
          next();
        }
      }
      while (isDigit(c)) {
        number2 += c;
        next();
      }
      if (c === "E" || c === "e") {
        var tentativeNumber = "";
        var tentativeIndex = index2;
        tentativeNumber += c;
        next();
        if (c === "+" || c === "-") {
          tentativeNumber += c;
          next();
        }
        if (!isDigit(c)) {
          revert(tentativeIndex);
          return number2;
        }
        number2 = number2 + tentativeNumber;
        while (isDigit(c)) {
          number2 += c;
          next();
        }
      }
      return number2;
    }
    function parseUnit() {
      var unitName = "";
      while (isDigit(c) || Unit2.isValidAlpha(c)) {
        unitName += c;
        next();
      }
      var firstC = unitName.charAt(0);
      if (Unit2.isValidAlpha(firstC)) {
        return unitName;
      } else {
        return null;
      }
    }
    function parseCharacter(toFind) {
      if (c === toFind) {
        next();
        return toFind;
      } else {
        return null;
      }
    }
    Unit2.parse = function(str, options) {
      options = options || {};
      text = str;
      index2 = -1;
      c = "";
      if (typeof text !== "string") {
        throw new TypeError("Invalid argument in Unit.parse, string expected");
      }
      var unit3 = new Unit2();
      unit3.units = [];
      var powerMultiplierCurrent = 1;
      var expectingUnit = false;
      next();
      skipWhitespace();
      var valueStr = parseNumber();
      var value = null;
      if (valueStr) {
        if (config4.number === "BigNumber") {
          value = new _BigNumber(valueStr);
        } else if (config4.number === "Fraction") {
          try {
            value = new _Fraction(valueStr);
          } catch (err) {
            value = parseFloat(valueStr);
          }
        } else {
          value = parseFloat(valueStr);
        }
        skipWhitespace();
        if (parseCharacter("*")) {
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter("/")) {
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        }
      }
      var powerMultiplierStack = [];
      var powerMultiplierStackProduct = 1;
      while (true) {
        skipWhitespace();
        while (c === "(") {
          powerMultiplierStack.push(powerMultiplierCurrent);
          powerMultiplierStackProduct *= powerMultiplierCurrent;
          powerMultiplierCurrent = 1;
          next();
          skipWhitespace();
        }
        var uStr = void 0;
        if (c) {
          var oldC = c;
          uStr = parseUnit();
          if (uStr === null) {
            throw new SyntaxError('Unexpected "' + oldC + '" in "' + text + '" at index ' + index2.toString());
          }
        } else {
          break;
        }
        var res = _findUnit(uStr);
        if (res === null) {
          throw new SyntaxError('Unit "' + uStr + '" not found.');
        }
        var power = powerMultiplierCurrent * powerMultiplierStackProduct;
        skipWhitespace();
        if (parseCharacter("^")) {
          skipWhitespace();
          var p = parseNumber();
          if (p === null) {
            throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
          }
          power *= p;
        }
        unit3.units.push({
          unit: res.unit,
          prefix: res.prefix,
          power
        });
        for (var i3 = 0; i3 < BASE_DIMENSIONS.length; i3++) {
          unit3.dimensions[i3] += (res.unit.dimensions[i3] || 0) * power;
        }
        skipWhitespace();
        while (c === ")") {
          if (powerMultiplierStack.length === 0) {
            throw new SyntaxError('Unmatched ")" in "' + text + '" at index ' + index2.toString());
          }
          powerMultiplierStackProduct /= powerMultiplierStack.pop();
          next();
          skipWhitespace();
        }
        expectingUnit = false;
        if (parseCharacter("*")) {
          powerMultiplierCurrent = 1;
          expectingUnit = true;
        } else if (parseCharacter("/")) {
          powerMultiplierCurrent = -1;
          expectingUnit = true;
        } else {
          powerMultiplierCurrent = 1;
        }
        if (res.unit.base) {
          var baseDim = res.unit.base.key;
          UNIT_SYSTEMS.auto[baseDim] = {
            unit: res.unit,
            prefix: res.prefix
          };
        }
      }
      skipWhitespace();
      if (c) {
        throw new SyntaxError('Could not parse: "' + str + '"');
      }
      if (expectingUnit) {
        throw new SyntaxError('Trailing characters: "' + str + '"');
      }
      if (powerMultiplierStack.length !== 0) {
        throw new SyntaxError('Unmatched "(" in "' + text + '"');
      }
      if (unit3.units.length === 0 && !options.allowNoUnits) {
        throw new SyntaxError('"' + str + '" contains no units');
      }
      unit3.value = value !== void 0 ? unit3._normalize(value) : null;
      return unit3;
    };
    Unit2.prototype.clone = function() {
      var unit3 = new Unit2();
      unit3.fixPrefix = this.fixPrefix;
      unit3.skipAutomaticSimplification = this.skipAutomaticSimplification;
      unit3.value = clone(this.value);
      unit3.dimensions = this.dimensions.slice(0);
      unit3.units = [];
      for (var i3 = 0; i3 < this.units.length; i3++) {
        unit3.units[i3] = {};
        for (var p in this.units[i3]) {
          if (hasOwnProperty(this.units[i3], p)) {
            unit3.units[i3][p] = this.units[i3][p];
          }
        }
      }
      return unit3;
    };
    Unit2.prototype.valueType = function() {
      return typeOf(this.value);
    };
    Unit2.prototype._isDerived = function() {
      if (this.units.length === 0) {
        return false;
      }
      return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
    };
    Unit2.prototype._normalize = function(value) {
      if (value === null || value === void 0 || this.units.length === 0) {
        return value;
      }
      var res = value;
      var convert = Unit2._getNumberConverter(typeOf(value));
      for (var i3 = 0; i3 < this.units.length; i3++) {
        var unitValue = convert(this.units[i3].unit.value);
        var unitPrefixValue = convert(this.units[i3].prefix.value);
        var unitPower = convert(this.units[i3].power);
        res = multiplyScalar2(res, pow3(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
      }
      return res;
    };
    Unit2.prototype._denormalize = function(value, prefixValue) {
      if (value === null || value === void 0 || this.units.length === 0) {
        return value;
      }
      var res = value;
      var convert = Unit2._getNumberConverter(typeOf(value));
      for (var i3 = 0; i3 < this.units.length; i3++) {
        var unitValue = convert(this.units[i3].unit.value);
        var unitPrefixValue = convert(this.units[i3].prefix.value);
        var unitPower = convert(this.units[i3].power);
        res = divideScalar2(res, pow3(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
      }
      return res;
    };
    var _findUnit = memoize((str) => {
      if (hasOwnProperty(UNITS, str)) {
        var unit3 = UNITS[str];
        var prefix = unit3.prefixes[""];
        return {
          unit: unit3,
          prefix
        };
      }
      for (var _name in UNITS) {
        if (hasOwnProperty(UNITS, _name)) {
          if (endsWith(str, _name)) {
            var _unit = UNITS[_name];
            var prefixLen = str.length - _name.length;
            var prefixName = str.substring(0, prefixLen);
            var _prefix = hasOwnProperty(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
            if (_prefix !== void 0) {
              return {
                unit: _unit,
                prefix: _prefix
              };
            }
          }
        }
      }
      return null;
    }, {
      hasher: (args) => args[0],
      limit: 100
    });
    Unit2.isValuelessUnit = function(name310) {
      return _findUnit(name310) !== null;
    };
    Unit2.prototype.hasBase = function(base) {
      if (typeof base === "string") {
        base = BASE_UNITS[base];
      }
      if (!base) {
        return false;
      }
      for (var i3 = 0; i3 < BASE_DIMENSIONS.length; i3++) {
        if (Math.abs((this.dimensions[i3] || 0) - (base.dimensions[i3] || 0)) > 1e-12) {
          return false;
        }
      }
      return true;
    };
    Unit2.prototype.equalBase = function(other) {
      for (var i3 = 0; i3 < BASE_DIMENSIONS.length; i3++) {
        if (Math.abs((this.dimensions[i3] || 0) - (other.dimensions[i3] || 0)) > 1e-12) {
          return false;
        }
      }
      return true;
    };
    Unit2.prototype.equals = function(other) {
      return this.equalBase(other) && equal2(this.value, other.value);
    };
    Unit2.prototype.multiply = function(_other) {
      var res = this.clone();
      var other = isUnit(_other) ? _other : new Unit2(_other);
      for (var i3 = 0; i3 < BASE_DIMENSIONS.length; i3++) {
        res.dimensions[i3] = (this.dimensions[i3] || 0) + (other.dimensions[i3] || 0);
      }
      for (var _i = 0; _i < other.units.length; _i++) {
        var inverted = _objectSpread2({}, other.units[_i]);
        res.units.push(inverted);
      }
      if (this.value !== null || other.value !== null) {
        var valThis = this.value === null ? this._normalize(1) : this.value;
        var valOther = other.value === null ? other._normalize(1) : other.value;
        res.value = multiplyScalar2(valThis, valOther);
      } else {
        res.value = null;
      }
      if (isUnit(_other)) {
        res.skipAutomaticSimplification = false;
      }
      return getNumericIfUnitless(res);
    };
    Unit2.prototype.divideInto = function(numerator) {
      return new Unit2(numerator).divide(this);
    };
    Unit2.prototype.divide = function(_other) {
      var res = this.clone();
      var other = isUnit(_other) ? _other : new Unit2(_other);
      for (var i3 = 0; i3 < BASE_DIMENSIONS.length; i3++) {
        res.dimensions[i3] = (this.dimensions[i3] || 0) - (other.dimensions[i3] || 0);
      }
      for (var _i2 = 0; _i2 < other.units.length; _i2++) {
        var inverted = _objectSpread2(_objectSpread2({}, other.units[_i2]), {}, {
          power: -other.units[_i2].power
        });
        res.units.push(inverted);
      }
      if (this.value !== null || other.value !== null) {
        var valThis = this.value === null ? this._normalize(1) : this.value;
        var valOther = other.value === null ? other._normalize(1) : other.value;
        res.value = divideScalar2(valThis, valOther);
      } else {
        res.value = null;
      }
      if (isUnit(_other)) {
        res.skipAutomaticSimplification = false;
      }
      return getNumericIfUnitless(res);
    };
    Unit2.prototype.pow = function(p) {
      var res = this.clone();
      for (var i3 = 0; i3 < BASE_DIMENSIONS.length; i3++) {
        res.dimensions[i3] = (this.dimensions[i3] || 0) * p;
      }
      for (var _i3 = 0; _i3 < res.units.length; _i3++) {
        res.units[_i3].power *= p;
      }
      if (res.value !== null) {
        res.value = pow3(res.value, p);
      } else {
        res.value = null;
      }
      res.skipAutomaticSimplification = false;
      return getNumericIfUnitless(res);
    };
    function getNumericIfUnitless(unit3) {
      if (unit3.equalBase(BASE_UNITS.NONE) && unit3.value !== null && !config4.predictable) {
        return unit3.value;
      } else {
        return unit3;
      }
    }
    Unit2.prototype.abs = function() {
      var ret = this.clone();
      if (ret.value !== null) {
        if (ret._isDerived() || ret.units[0].unit.offset === 0) {
          ret.value = abs3(ret.value);
        } else {
          var convert = ret._numberConverter();
          var unitValue = convert(ret.units[0].unit.value);
          var nominalOffset = convert(ret.units[0].unit.offset);
          var unitOffset = multiplyScalar2(unitValue, nominalOffset);
          ret.value = subtractScalar2(abs3(addScalar2(ret.value, unitOffset)), unitOffset);
        }
      }
      for (var i3 in ret.units) {
        if (ret.units[i3].unit.name === "VA" || ret.units[i3].unit.name === "VAR") {
          ret.units[i3].unit = UNITS.W;
        }
      }
      return ret;
    };
    Unit2.prototype.to = function(valuelessUnit) {
      var value = this.value === null ? this._normalize(1) : this.value;
      var other;
      if (typeof valuelessUnit === "string") {
        other = Unit2.parse(valuelessUnit);
      } else if (isUnit(valuelessUnit)) {
        other = valuelessUnit.clone();
      } else {
        throw new Error("String or Unit expected as parameter");
      }
      if (!this.equalBase(other)) {
        throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
      }
      if (other.value !== null) {
        throw new Error("Cannot convert to a unit with a value");
      }
      if (this.value === null || this._isDerived() || this.units[0].unit.offset === other.units[0].unit.offset) {
        other.value = clone(value);
      } else {
        var convert = Unit2._getNumberConverter(typeOf(value));
        var thisUnitValue = this.units[0].unit.value;
        var thisNominalOffset = this.units[0].unit.offset;
        var thisUnitOffset = multiplyScalar2(thisUnitValue, thisNominalOffset);
        var otherUnitValue = other.units[0].unit.value;
        var otherNominalOffset = other.units[0].unit.offset;
        var otherUnitOffset = multiplyScalar2(otherUnitValue, otherNominalOffset);
        other.value = addScalar2(value, convert(subtractScalar2(thisUnitOffset, otherUnitOffset)));
      }
      other.fixPrefix = true;
      other.skipAutomaticSimplification = true;
      return other;
    };
    Unit2.prototype.toNumber = function(valuelessUnit) {
      return toNumber(this.toNumeric(valuelessUnit));
    };
    Unit2.prototype.toNumeric = function(valuelessUnit) {
      var other;
      if (valuelessUnit) {
        other = this.to(valuelessUnit);
      } else {
        other = this.clone();
      }
      if (other._isDerived() || other.units.length === 0) {
        return other._denormalize(other.value);
      } else {
        return other._denormalize(other.value, other.units[0].prefix.value);
      }
    };
    Unit2.prototype.toString = function() {
      return this.format();
    };
    Unit2.prototype.toJSON = function() {
      return {
        mathjs: "Unit",
        value: this._denormalize(this.value),
        unit: this.formatUnits(),
        fixPrefix: this.fixPrefix
      };
    };
    Unit2.fromJSON = function(json) {
      var unit3 = new Unit2(json.value, json.unit);
      unit3.fixPrefix = json.fixPrefix || false;
      return unit3;
    };
    Unit2.prototype.valueOf = Unit2.prototype.toString;
    Unit2.prototype.simplify = function() {
      var ret = this.clone();
      var proposedUnitList = [];
      var matchingBase;
      for (var key2 in currentUnitSystem) {
        if (hasOwnProperty(currentUnitSystem, key2)) {
          if (ret.hasBase(BASE_UNITS[key2])) {
            matchingBase = key2;
            break;
          }
        }
      }
      if (matchingBase === "NONE") {
        ret.units = [];
      } else {
        var matchingUnit;
        if (matchingBase) {
          if (hasOwnProperty(currentUnitSystem, matchingBase)) {
            matchingUnit = currentUnitSystem[matchingBase];
          }
        }
        if (matchingUnit) {
          ret.units = [{
            unit: matchingUnit.unit,
            prefix: matchingUnit.prefix,
            power: 1
          }];
        } else {
          var missingBaseDim = false;
          for (var i3 = 0; i3 < BASE_DIMENSIONS.length; i3++) {
            var baseDim = BASE_DIMENSIONS[i3];
            if (Math.abs(ret.dimensions[i3] || 0) > 1e-12) {
              if (hasOwnProperty(currentUnitSystem, baseDim)) {
                proposedUnitList.push({
                  unit: currentUnitSystem[baseDim].unit,
                  prefix: currentUnitSystem[baseDim].prefix,
                  power: ret.dimensions[i3] || 0
                });
              } else {
                missingBaseDim = true;
              }
            }
          }
          if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
            ret.units = proposedUnitList;
          }
        }
      }
      return ret;
    };
    Unit2.prototype.toSI = function() {
      var ret = this.clone();
      var proposedUnitList = [];
      for (var i3 = 0; i3 < BASE_DIMENSIONS.length; i3++) {
        var baseDim = BASE_DIMENSIONS[i3];
        if (Math.abs(ret.dimensions[i3] || 0) > 1e-12) {
          if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
            proposedUnitList.push({
              unit: UNIT_SYSTEMS.si[baseDim].unit,
              prefix: UNIT_SYSTEMS.si[baseDim].prefix,
              power: ret.dimensions[i3] || 0
            });
          } else {
            throw new Error("Cannot express custom unit " + baseDim + " in SI units");
          }
        }
      }
      ret.units = proposedUnitList;
      ret.fixPrefix = true;
      ret.skipAutomaticSimplification = true;
      return ret;
    };
    Unit2.prototype.formatUnits = function() {
      var strNum = "";
      var strDen = "";
      var nNum = 0;
      var nDen = 0;
      for (var i3 = 0; i3 < this.units.length; i3++) {
        if (this.units[i3].power > 0) {
          nNum++;
          strNum += " " + this.units[i3].prefix.name + this.units[i3].unit.name;
          if (Math.abs(this.units[i3].power - 1) > 1e-15) {
            strNum += "^" + this.units[i3].power;
          }
        } else if (this.units[i3].power < 0) {
          nDen++;
        }
      }
      if (nDen > 0) {
        for (var _i4 = 0; _i4 < this.units.length; _i4++) {
          if (this.units[_i4].power < 0) {
            if (nNum > 0) {
              strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
              if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
                strDen += "^" + -this.units[_i4].power;
              }
            } else {
              strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
              strDen += "^" + this.units[_i4].power;
            }
          }
        }
      }
      strNum = strNum.substr(1);
      strDen = strDen.substr(1);
      if (nNum > 1 && nDen > 0) {
        strNum = "(" + strNum + ")";
      }
      if (nDen > 1 && nNum > 0) {
        strDen = "(" + strDen + ")";
      }
      var str = strNum;
      if (nNum > 0 && nDen > 0) {
        str += " / ";
      }
      str += strDen;
      return str;
    };
    Unit2.prototype.format = function(options) {
      var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
      var isImaginary = false;
      if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
        isImaginary = Math.abs(simp.value.re) < 1e-14;
      }
      for (var i3 in simp.units) {
        if (hasOwnProperty(simp.units, i3)) {
          if (simp.units[i3].unit) {
            if (simp.units[i3].unit.name === "VA" && isImaginary) {
              simp.units[i3].unit = UNITS.VAR;
            } else if (simp.units[i3].unit.name === "VAR" && !isImaginary) {
              simp.units[i3].unit = UNITS.VA;
            }
          }
        }
      }
      if (simp.units.length === 1 && !simp.fixPrefix) {
        if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
          simp.units[0].prefix = simp._bestPrefix();
        }
      }
      var value = simp._denormalize(simp.value);
      var str = simp.value !== null ? format5(value, options || {}) : "";
      var unitStr = simp.formatUnits();
      if (simp.value && isComplex(simp.value)) {
        str = "(" + str + ")";
      }
      if (unitStr.length > 0 && str.length > 0) {
        str += " ";
      }
      str += unitStr;
      return str;
    };
    Unit2.prototype._bestPrefix = function() {
      if (this.units.length !== 1) {
        throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
      }
      if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
        throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
      }
      var absValue = this.value !== null ? abs3(this.value) : 0;
      var absUnitValue = abs3(this.units[0].unit.value);
      var bestPrefix = this.units[0].prefix;
      if (absValue === 0) {
        return bestPrefix;
      }
      var power = this.units[0].power;
      var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
      if (bestDiff > -2.200001 && bestDiff < 1.800001)
        return bestPrefix;
      bestDiff = Math.abs(bestDiff);
      var prefixes = this.units[0].unit.prefixes;
      for (var p in prefixes) {
        if (hasOwnProperty(prefixes, p)) {
          var prefix = prefixes[p];
          if (prefix.scientific) {
            var diff2 = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
            if (diff2 < bestDiff || diff2 === bestDiff && prefix.name.length < bestPrefix.name.length) {
              bestPrefix = prefix;
              bestDiff = diff2;
            }
          }
        }
      }
      return bestPrefix;
    };
    Unit2.prototype.splitUnit = function(parts) {
      var x = this.clone();
      var ret = [];
      for (var i3 = 0; i3 < parts.length; i3++) {
        x = x.to(parts[i3]);
        if (i3 === parts.length - 1)
          break;
        var xNumeric = x.toNumeric();
        var xRounded = round3(xNumeric);
        var xFixed = void 0;
        var isNearlyEqual = equal2(xRounded, xNumeric);
        if (isNearlyEqual) {
          xFixed = xRounded;
        } else {
          xFixed = fix2(x.toNumeric());
        }
        var y2 = new Unit2(xFixed, parts[i3].toString());
        ret.push(y2);
        x = subtractScalar2(x, y2);
      }
      var testSum = 0;
      for (var _i5 = 0; _i5 < ret.length; _i5++) {
        testSum = addScalar2(testSum, ret[_i5].value);
      }
      if (equal2(testSum, this.value)) {
        x.value = 0;
      }
      ret.push(x);
      return ret;
    };
    var PREFIXES = {
      NONE: {
        "": {
          name: "",
          value: 1,
          scientific: true
        }
      },
      SHORT: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        da: {
          name: "da",
          value: 10,
          scientific: false
        },
        h: {
          name: "h",
          value: 100,
          scientific: false
        },
        k: {
          name: "k",
          value: 1e3,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e6,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e9,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e12,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e15,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e18,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e21,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e24,
          scientific: true
        },
        d: {
          name: "d",
          value: 0.1,
          scientific: false
        },
        c: {
          name: "c",
          value: 0.01,
          scientific: false
        },
        m: {
          name: "m",
          value: 1e-3,
          scientific: true
        },
        u: {
          name: "u",
          value: 1e-6,
          scientific: true
        },
        n: {
          name: "n",
          value: 1e-9,
          scientific: true
        },
        p: {
          name: "p",
          value: 1e-12,
          scientific: true
        },
        f: {
          name: "f",
          value: 1e-15,
          scientific: true
        },
        a: {
          name: "a",
          value: 1e-18,
          scientific: true
        },
        z: {
          name: "z",
          value: 1e-21,
          scientific: true
        },
        y: {
          name: "y",
          value: 1e-24,
          scientific: true
        }
      },
      LONG: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        deca: {
          name: "deca",
          value: 10,
          scientific: false
        },
        hecto: {
          name: "hecto",
          value: 100,
          scientific: false
        },
        kilo: {
          name: "kilo",
          value: 1e3,
          scientific: true
        },
        mega: {
          name: "mega",
          value: 1e6,
          scientific: true
        },
        giga: {
          name: "giga",
          value: 1e9,
          scientific: true
        },
        tera: {
          name: "tera",
          value: 1e12,
          scientific: true
        },
        peta: {
          name: "peta",
          value: 1e15,
          scientific: true
        },
        exa: {
          name: "exa",
          value: 1e18,
          scientific: true
        },
        zetta: {
          name: "zetta",
          value: 1e21,
          scientific: true
        },
        yotta: {
          name: "yotta",
          value: 1e24,
          scientific: true
        },
        deci: {
          name: "deci",
          value: 0.1,
          scientific: false
        },
        centi: {
          name: "centi",
          value: 0.01,
          scientific: false
        },
        milli: {
          name: "milli",
          value: 1e-3,
          scientific: true
        },
        micro: {
          name: "micro",
          value: 1e-6,
          scientific: true
        },
        nano: {
          name: "nano",
          value: 1e-9,
          scientific: true
        },
        pico: {
          name: "pico",
          value: 1e-12,
          scientific: true
        },
        femto: {
          name: "femto",
          value: 1e-15,
          scientific: true
        },
        atto: {
          name: "atto",
          value: 1e-18,
          scientific: true
        },
        zepto: {
          name: "zepto",
          value: 1e-21,
          scientific: true
        },
        yocto: {
          name: "yocto",
          value: 1e-24,
          scientific: true
        }
      },
      SQUARED: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        da: {
          name: "da",
          value: 100,
          scientific: false
        },
        h: {
          name: "h",
          value: 1e4,
          scientific: false
        },
        k: {
          name: "k",
          value: 1e6,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e12,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e18,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e24,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e30,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e36,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e42,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e48,
          scientific: true
        },
        d: {
          name: "d",
          value: 0.01,
          scientific: false
        },
        c: {
          name: "c",
          value: 1e-4,
          scientific: false
        },
        m: {
          name: "m",
          value: 1e-6,
          scientific: true
        },
        u: {
          name: "u",
          value: 1e-12,
          scientific: true
        },
        n: {
          name: "n",
          value: 1e-18,
          scientific: true
        },
        p: {
          name: "p",
          value: 1e-24,
          scientific: true
        },
        f: {
          name: "f",
          value: 1e-30,
          scientific: true
        },
        a: {
          name: "a",
          value: 1e-36,
          scientific: true
        },
        z: {
          name: "z",
          value: 1e-42,
          scientific: true
        },
        y: {
          name: "y",
          value: 1e-48,
          scientific: true
        }
      },
      CUBIC: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        da: {
          name: "da",
          value: 1e3,
          scientific: false
        },
        h: {
          name: "h",
          value: 1e6,
          scientific: false
        },
        k: {
          name: "k",
          value: 1e9,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e18,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e27,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e36,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e45,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e54,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e63,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e72,
          scientific: true
        },
        d: {
          name: "d",
          value: 1e-3,
          scientific: false
        },
        c: {
          name: "c",
          value: 1e-6,
          scientific: false
        },
        m: {
          name: "m",
          value: 1e-9,
          scientific: true
        },
        u: {
          name: "u",
          value: 1e-18,
          scientific: true
        },
        n: {
          name: "n",
          value: 1e-27,
          scientific: true
        },
        p: {
          name: "p",
          value: 1e-36,
          scientific: true
        },
        f: {
          name: "f",
          value: 1e-45,
          scientific: true
        },
        a: {
          name: "a",
          value: 1e-54,
          scientific: true
        },
        z: {
          name: "z",
          value: 1e-63,
          scientific: true
        },
        y: {
          name: "y",
          value: 1e-72,
          scientific: true
        }
      },
      BINARY_SHORT_SI: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        k: {
          name: "k",
          value: 1e3,
          scientific: true
        },
        M: {
          name: "M",
          value: 1e6,
          scientific: true
        },
        G: {
          name: "G",
          value: 1e9,
          scientific: true
        },
        T: {
          name: "T",
          value: 1e12,
          scientific: true
        },
        P: {
          name: "P",
          value: 1e15,
          scientific: true
        },
        E: {
          name: "E",
          value: 1e18,
          scientific: true
        },
        Z: {
          name: "Z",
          value: 1e21,
          scientific: true
        },
        Y: {
          name: "Y",
          value: 1e24,
          scientific: true
        }
      },
      BINARY_SHORT_IEC: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        Ki: {
          name: "Ki",
          value: 1024,
          scientific: true
        },
        Mi: {
          name: "Mi",
          value: Math.pow(1024, 2),
          scientific: true
        },
        Gi: {
          name: "Gi",
          value: Math.pow(1024, 3),
          scientific: true
        },
        Ti: {
          name: "Ti",
          value: Math.pow(1024, 4),
          scientific: true
        },
        Pi: {
          name: "Pi",
          value: Math.pow(1024, 5),
          scientific: true
        },
        Ei: {
          name: "Ei",
          value: Math.pow(1024, 6),
          scientific: true
        },
        Zi: {
          name: "Zi",
          value: Math.pow(1024, 7),
          scientific: true
        },
        Yi: {
          name: "Yi",
          value: Math.pow(1024, 8),
          scientific: true
        }
      },
      BINARY_LONG_SI: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        kilo: {
          name: "kilo",
          value: 1e3,
          scientific: true
        },
        mega: {
          name: "mega",
          value: 1e6,
          scientific: true
        },
        giga: {
          name: "giga",
          value: 1e9,
          scientific: true
        },
        tera: {
          name: "tera",
          value: 1e12,
          scientific: true
        },
        peta: {
          name: "peta",
          value: 1e15,
          scientific: true
        },
        exa: {
          name: "exa",
          value: 1e18,
          scientific: true
        },
        zetta: {
          name: "zetta",
          value: 1e21,
          scientific: true
        },
        yotta: {
          name: "yotta",
          value: 1e24,
          scientific: true
        }
      },
      BINARY_LONG_IEC: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        kibi: {
          name: "kibi",
          value: 1024,
          scientific: true
        },
        mebi: {
          name: "mebi",
          value: Math.pow(1024, 2),
          scientific: true
        },
        gibi: {
          name: "gibi",
          value: Math.pow(1024, 3),
          scientific: true
        },
        tebi: {
          name: "tebi",
          value: Math.pow(1024, 4),
          scientific: true
        },
        pebi: {
          name: "pebi",
          value: Math.pow(1024, 5),
          scientific: true
        },
        exi: {
          name: "exi",
          value: Math.pow(1024, 6),
          scientific: true
        },
        zebi: {
          name: "zebi",
          value: Math.pow(1024, 7),
          scientific: true
        },
        yobi: {
          name: "yobi",
          value: Math.pow(1024, 8),
          scientific: true
        }
      },
      BTU: {
        "": {
          name: "",
          value: 1,
          scientific: true
        },
        MM: {
          name: "MM",
          value: 1e6,
          scientific: true
        }
      }
    };
    PREFIXES.SHORTLONG = _extends({}, PREFIXES.SHORT, PREFIXES.LONG);
    PREFIXES.BINARY_SHORT = _extends({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
    PREFIXES.BINARY_LONG = _extends({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
    var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
    var BASE_UNITS = {
      NONE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      MASS: {
        dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
      },
      LENGTH: {
        dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
      },
      TIME: {
        dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
      },
      CURRENT: {
        dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
      },
      TEMPERATURE: {
        dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
      },
      LUMINOUS_INTENSITY: {
        dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
      },
      AMOUNT_OF_SUBSTANCE: {
        dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
      },
      FORCE: {
        dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
      },
      SURFACE: {
        dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
      },
      VOLUME: {
        dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
      },
      ENERGY: {
        dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
      },
      POWER: {
        dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
      },
      PRESSURE: {
        dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CHARGE: {
        dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CAPACITANCE: {
        dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_POTENTIAL: {
        dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
      },
      ELECTRIC_RESISTANCE: {
        dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_INDUCTANCE: {
        dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
      },
      ELECTRIC_CONDUCTANCE: {
        dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX: {
        dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
      },
      MAGNETIC_FLUX_DENSITY: {
        dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
      },
      FREQUENCY: {
        dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
      },
      ANGLE: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
      },
      BIT: {
        dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
      }
    };
    for (var key in BASE_UNITS) {
      if (hasOwnProperty(BASE_UNITS, key)) {
        BASE_UNITS[key].key = key;
      }
    }
    var BASE_UNIT_NONE = {};
    var UNIT_NONE = {
      name: "",
      base: BASE_UNIT_NONE,
      value: 1,
      offset: 0,
      dimensions: BASE_DIMENSIONS.map((x) => 0)
    };
    var UNITS = {
      // length
      meter: {
        name: "meter",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      inch: {
        name: "inch",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      foot: {
        name: "foot",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yard: {
        name: "yard",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mile: {
        name: "mile",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      link: {
        name: "link",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rod: {
        name: "rod",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.0292,
        offset: 0
      },
      chain: {
        name: "chain",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      angstrom: {
        name: "angstrom",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1e-10,
        offset: 0
      },
      m: {
        name: "m",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      in: {
        name: "in",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.0254,
        offset: 0
      },
      ft: {
        name: "ft",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.3048,
        offset: 0
      },
      yd: {
        name: "yd",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.9144,
        offset: 0
      },
      mi: {
        name: "mi",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 1609.344,
        offset: 0
      },
      li: {
        name: "li",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 0.201168,
        offset: 0
      },
      rd: {
        name: "rd",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 5.02921,
        offset: 0
      },
      ch: {
        name: "ch",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 20.1168,
        offset: 0
      },
      mil: {
        name: "mil",
        base: BASE_UNITS.LENGTH,
        prefixes: PREFIXES.NONE,
        value: 254e-7,
        offset: 0
      },
      // 1/1000 inch
      // Surface
      m2: {
        name: "m2",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.SQUARED,
        value: 1,
        offset: 0
      },
      sqin: {
        name: "sqin",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 64516e-8,
        offset: 0
      },
      // 645.16 mm2
      sqft: {
        name: "sqft",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.09290304,
        offset: 0
      },
      // 0.09290304 m2
      sqyd: {
        name: "sqyd",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 0.83612736,
        offset: 0
      },
      // 0.83612736 m2
      sqmi: {
        name: "sqmi",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 2589988110336e-6,
        offset: 0
      },
      // 2.589988110336 km2
      sqrd: {
        name: "sqrd",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 25.29295,
        offset: 0
      },
      // 25.29295 m2
      sqch: {
        name: "sqch",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 404.6873,
        offset: 0
      },
      // 404.6873 m2
      sqmil: {
        name: "sqmil",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 64516e-14,
        offset: 0
      },
      // 6.4516 * 10^-10 m2
      acre: {
        name: "acre",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 4046.86,
        offset: 0
      },
      // 4046.86 m2
      hectare: {
        name: "hectare",
        base: BASE_UNITS.SURFACE,
        prefixes: PREFIXES.NONE,
        value: 1e4,
        offset: 0
      },
      // 10000 m2
      // Volume
      m3: {
        name: "m3",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.CUBIC,
        value: 1,
        offset: 0
      },
      L: {
        name: "L",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      // litre
      l: {
        name: "l",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      // litre
      litre: {
        name: "litre",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.LONG,
        value: 1e-3,
        offset: 0
      },
      cuin: {
        name: "cuin",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 16387064e-12,
        offset: 0
      },
      // 1.6387064e-5 m3
      cuft: {
        name: "cuft",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.028316846592,
        offset: 0
      },
      // 28.316 846 592 L
      cuyd: {
        name: "cuyd",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.764554857984,
        offset: 0
      },
      // 764.554 857 984 L
      teaspoon: {
        name: "teaspoon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-6,
        offset: 0
      },
      // 5 mL
      tablespoon: {
        name: "tablespoon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 15e-6,
        offset: 0
      },
      // 15 mL
      // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
      drop: {
        name: "drop",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      // 0.05 mL = 5e-8 m3
      gtt: {
        name: "gtt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 5e-8,
        offset: 0
      },
      // 0.05 mL = 5e-8 m3
      // Liquid volume
      minim: {
        name: "minim",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 6161152e-14,
        offset: 0
      },
      // 0.06161152 mL
      fluiddram: {
        name: "fluiddram",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 36966911e-13,
        offset: 0
      },
      // 3.696691 mL
      fluidounce: {
        name: "fluidounce",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2957353e-11,
        offset: 0
      },
      // 29.57353 mL
      gill: {
        name: "gill",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1182941e-10,
        offset: 0
      },
      // 118.2941 mL
      cc: {
        name: "cc",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1e-6,
        offset: 0
      },
      // 1e-6 L
      cup: {
        name: "cup",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2365882e-10,
        offset: 0
      },
      // 236.5882 mL
      pint: {
        name: "pint",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 4731765e-10,
        offset: 0
      },
      // 473.1765 mL
      quart: {
        name: "quart",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 9463529e-10,
        offset: 0
      },
      // 946.3529 mL
      gallon: {
        name: "gallon",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 3785412e-9,
        offset: 0
      },
      // 3.785412 L
      beerbarrel: {
        name: "beerbarrel",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1173478,
        offset: 0
      },
      // 117.3478 L
      oilbarrel: {
        name: "oilbarrel",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1589873,
        offset: 0
      },
      // 158.9873 L
      hogshead: {
        name: "hogshead",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.238481,
        offset: 0
      },
      // 238.4810 L
      // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
      fldr: {
        name: "fldr",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 36966911e-13,
        offset: 0
      },
      // 3.696691 mL
      floz: {
        name: "floz",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2957353e-11,
        offset: 0
      },
      // 29.57353 mL
      gi: {
        name: "gi",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 1182941e-10,
        offset: 0
      },
      // 118.2941 mL
      cp: {
        name: "cp",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 2365882e-10,
        offset: 0
      },
      // 236.5882 mL
      pt: {
        name: "pt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 4731765e-10,
        offset: 0
      },
      // 473.1765 mL
      qt: {
        name: "qt",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 9463529e-10,
        offset: 0
      },
      // 946.3529 mL
      gal: {
        name: "gal",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 3785412e-9,
        offset: 0
      },
      // 3.785412 L
      bbl: {
        name: "bbl",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1173478,
        offset: 0
      },
      // 117.3478 L
      obl: {
        name: "obl",
        base: BASE_UNITS.VOLUME,
        prefixes: PREFIXES.NONE,
        value: 0.1589873,
        offset: 0
      },
      // 158.9873 L
      // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
      // Mass
      g: {
        name: "g",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 1e-3,
        offset: 0
      },
      gram: {
        name: "gram",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 1e-3,
        offset: 0
      },
      ton: {
        name: "ton",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 907.18474,
        offset: 0
      },
      t: {
        name: "t",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.SHORT,
        value: 1e3,
        offset: 0
      },
      tonne: {
        name: "tonne",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.LONG,
        value: 1e3,
        offset: 0
      },
      grain: {
        name: "grain",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6479891e-11,
        offset: 0
      },
      dram: {
        name: "dram",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.0017718451953125,
        offset: 0
      },
      ounce: {
        name: "ounce",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.028349523125,
        offset: 0
      },
      poundmass: {
        name: "poundmass",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.45359237,
        offset: 0
      },
      hundredweight: {
        name: "hundredweight",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      stick: {
        name: "stick",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.115,
        offset: 0
      },
      stone: {
        name: "stone",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6.35029318,
        offset: 0
      },
      gr: {
        name: "gr",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 6479891e-11,
        offset: 0
      },
      dr: {
        name: "dr",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.0017718451953125,
        offset: 0
      },
      oz: {
        name: "oz",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.028349523125,
        offset: 0
      },
      lbm: {
        name: "lbm",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 0.45359237,
        offset: 0
      },
      cwt: {
        name: "cwt",
        base: BASE_UNITS.MASS,
        prefixes: PREFIXES.NONE,
        value: 45.359237,
        offset: 0
      },
      // Time
      s: {
        name: "s",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      min: {
        name: "min",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      h: {
        name: "h",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      second: {
        name: "second",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      sec: {
        name: "sec",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      minute: {
        name: "minute",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 60,
        offset: 0
      },
      hour: {
        name: "hour",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 3600,
        offset: 0
      },
      day: {
        name: "day",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 86400,
        offset: 0
      },
      week: {
        name: "week",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 7 * 86400,
        offset: 0
      },
      month: {
        name: "month",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 2629800,
        // 1/12th of Julian year
        offset: 0
      },
      year: {
        name: "year",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 31557600,
        // Julian year
        offset: 0
      },
      decade: {
        name: "decade",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e3,
        // Julian decade
        offset: 0
      },
      century: {
        name: "century",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e4,
        // Julian century
        offset: 0
      },
      millennium: {
        name: "millennium",
        base: BASE_UNITS.TIME,
        prefixes: PREFIXES.NONE,
        value: 315576e5,
        // Julian millennium
        offset: 0
      },
      // Frequency
      hertz: {
        name: "Hertz",
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      Hz: {
        name: "Hz",
        base: BASE_UNITS.FREQUENCY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0,
        reciprocal: true
      },
      // Angle
      rad: {
        name: "rad",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      radian: {
        name: "radian",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
      deg: {
        name: "deg",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      degree: {
        name: "degree",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
      grad: {
        name: "grad",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.SHORT,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      gradian: {
        name: "gradian",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.LONG,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
      cycle: {
        name: "cycle",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
      arcsec: {
        name: "arcsec",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
      arcmin: {
        name: "arcmin",
        base: BASE_UNITS.ANGLE,
        prefixes: PREFIXES.NONE,
        value: null,
        // will be filled in by calculateAngleValues()
        offset: 0
      },
      // Electric current
      A: {
        name: "A",
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      ampere: {
        name: "ampere",
        base: BASE_UNITS.CURRENT,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // Temperature
      // K(C) = C + 273.15
      // K(F) = (F + 459.67) * (5 / 9)
      // K(R) = R * (5 / 9)
      K: {
        name: "K",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      degC: {
        name: "degC",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 273.15
      },
      degF: {
        name: "degF",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: new _Fraction(5, 9),
        offset: 459.67
      },
      degR: {
        name: "degR",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.SHORT,
        value: new _Fraction(5, 9),
        offset: 0
      },
      kelvin: {
        name: "kelvin",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      celsius: {
        name: "celsius",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 273.15
      },
      fahrenheit: {
        name: "fahrenheit",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: new _Fraction(5, 9),
        offset: 459.67
      },
      rankine: {
        name: "rankine",
        base: BASE_UNITS.TEMPERATURE,
        prefixes: PREFIXES.LONG,
        value: new _Fraction(5, 9),
        offset: 0
      },
      // amount of substance
      mol: {
        name: "mol",
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      mole: {
        name: "mole",
        base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // luminous intensity
      cd: {
        name: "cd",
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      candela: {
        name: "candela",
        base: BASE_UNITS.LUMINOUS_INTENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      // TODO: units STERADIAN
      // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
      // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
      // Force
      N: {
        name: "N",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      newton: {
        name: "newton",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      dyn: {
        name: "dyn",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.SHORT,
        value: 1e-5,
        offset: 0
      },
      dyne: {
        name: "dyne",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 1e-5,
        offset: 0
      },
      lbf: {
        name: "lbf",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      poundforce: {
        name: "poundforce",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 4.4482216152605,
        offset: 0
      },
      kip: {
        name: "kip",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.LONG,
        value: 4448.2216,
        offset: 0
      },
      kilogramforce: {
        name: "kilogramforce",
        base: BASE_UNITS.FORCE,
        prefixes: PREFIXES.NONE,
        value: 9.80665,
        offset: 0
      },
      // Energy
      J: {
        name: "J",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      joule: {
        name: "joule",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      erg: {
        name: "erg",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORTLONG,
        // Both kiloerg and kerg are acceptable
        value: 1e-7,
        offset: 0
      },
      Wh: {
        name: "Wh",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 3600,
        offset: 0
      },
      BTU: {
        name: "BTU",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.BTU,
        value: 1055.05585262,
        offset: 0
      },
      eV: {
        name: "eV",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.SHORT,
        value: 1602176565e-28,
        offset: 0
      },
      electronvolt: {
        name: "electronvolt",
        base: BASE_UNITS.ENERGY,
        prefixes: PREFIXES.LONG,
        value: 1602176565e-28,
        offset: 0
      },
      // Power
      W: {
        name: "W",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      watt: {
        name: "watt",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      hp: {
        name: "hp",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.NONE,
        value: 745.6998715386,
        offset: 0
      },
      // Electrical power units
      VAR: {
        name: "VAR",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: Complex3.I,
        offset: 0
      },
      VA: {
        name: "VA",
        base: BASE_UNITS.POWER,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Pressure
      Pa: {
        name: "Pa",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      psi: {
        name: "psi",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 6894.75729276459,
        offset: 0
      },
      atm: {
        name: "atm",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 101325,
        offset: 0
      },
      bar: {
        name: "bar",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.SHORTLONG,
        value: 1e5,
        offset: 0
      },
      torr: {
        name: "torr",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmHg: {
        name: "mmHg",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 133.322,
        offset: 0
      },
      mmH2O: {
        name: "mmH2O",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 9.80665,
        offset: 0
      },
      cmH2O: {
        name: "cmH2O",
        base: BASE_UNITS.PRESSURE,
        prefixes: PREFIXES.NONE,
        value: 98.0665,
        offset: 0
      },
      // Electric charge
      coulomb: {
        name: "coulomb",
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      C: {
        name: "C",
        base: BASE_UNITS.ELECTRIC_CHARGE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric capacitance
      farad: {
        name: "farad",
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      F: {
        name: "F",
        base: BASE_UNITS.ELECTRIC_CAPACITANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric potential
      volt: {
        name: "volt",
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      V: {
        name: "V",
        base: BASE_UNITS.ELECTRIC_POTENTIAL,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric resistance
      ohm: {
        name: "ohm",
        base: BASE_UNITS.ELECTRIC_RESISTANCE,
        prefixes: PREFIXES.SHORTLONG,
        // Both Mohm and megaohm are acceptable
        value: 1,
        offset: 0
      },
      /*
       * Unicode breaks in browsers if charset is not specified
      : {
        name: '',
        base: BASE_UNITS.ELECTRIC_RESISTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      */
      // Electric inductance
      henry: {
        name: "henry",
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      H: {
        name: "H",
        base: BASE_UNITS.ELECTRIC_INDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Electric conductance
      siemens: {
        name: "siemens",
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      S: {
        name: "S",
        base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Magnetic flux
      weber: {
        name: "weber",
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      Wb: {
        name: "Wb",
        base: BASE_UNITS.MAGNETIC_FLUX,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Magnetic flux density
      tesla: {
        name: "tesla",
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.LONG,
        value: 1,
        offset: 0
      },
      T: {
        name: "T",
        base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
        prefixes: PREFIXES.SHORT,
        value: 1,
        offset: 0
      },
      // Binary
      b: {
        name: "b",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 1,
        offset: 0
      },
      bits: {
        name: "bits",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 1,
        offset: 0
      },
      B: {
        name: "B",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_SHORT,
        value: 8,
        offset: 0
      },
      bytes: {
        name: "bytes",
        base: BASE_UNITS.BIT,
        prefixes: PREFIXES.BINARY_LONG,
        value: 8,
        offset: 0
      }
    };
    var ALIASES = {
      meters: "meter",
      inches: "inch",
      feet: "foot",
      yards: "yard",
      miles: "mile",
      links: "link",
      rods: "rod",
      chains: "chain",
      angstroms: "angstrom",
      lt: "l",
      litres: "litre",
      liter: "litre",
      liters: "litre",
      teaspoons: "teaspoon",
      tablespoons: "tablespoon",
      minims: "minim",
      fluiddrams: "fluiddram",
      fluidounces: "fluidounce",
      gills: "gill",
      cups: "cup",
      pints: "pint",
      quarts: "quart",
      gallons: "gallon",
      beerbarrels: "beerbarrel",
      oilbarrels: "oilbarrel",
      hogsheads: "hogshead",
      gtts: "gtt",
      grams: "gram",
      tons: "ton",
      tonnes: "tonne",
      grains: "grain",
      drams: "dram",
      ounces: "ounce",
      poundmasses: "poundmass",
      hundredweights: "hundredweight",
      sticks: "stick",
      lb: "lbm",
      lbs: "lbm",
      kips: "kip",
      kgf: "kilogramforce",
      acres: "acre",
      hectares: "hectare",
      sqfeet: "sqft",
      sqyard: "sqyd",
      sqmile: "sqmi",
      sqmiles: "sqmi",
      mmhg: "mmHg",
      mmh2o: "mmH2O",
      cmh2o: "cmH2O",
      seconds: "second",
      secs: "second",
      minutes: "minute",
      mins: "minute",
      hours: "hour",
      hr: "hour",
      hrs: "hour",
      days: "day",
      weeks: "week",
      months: "month",
      years: "year",
      decades: "decade",
      centuries: "century",
      millennia: "millennium",
      hertz: "hertz",
      radians: "radian",
      degrees: "degree",
      gradians: "gradian",
      cycles: "cycle",
      arcsecond: "arcsec",
      arcseconds: "arcsec",
      arcminute: "arcmin",
      arcminutes: "arcmin",
      BTUs: "BTU",
      watts: "watt",
      joules: "joule",
      amperes: "ampere",
      amps: "ampere",
      amp: "ampere",
      coulombs: "coulomb",
      volts: "volt",
      ohms: "ohm",
      farads: "farad",
      webers: "weber",
      teslas: "tesla",
      electronvolts: "electronvolt",
      moles: "mole",
      bit: "bits",
      byte: "bytes"
    };
    function calculateAngleValues(config5) {
      if (config5.number === "BigNumber") {
        var pi3 = createBigNumberPi(_BigNumber);
        UNITS.rad.value = new _BigNumber(1);
        UNITS.deg.value = pi3.div(180);
        UNITS.grad.value = pi3.div(200);
        UNITS.cycle.value = pi3.times(2);
        UNITS.arcsec.value = pi3.div(648e3);
        UNITS.arcmin.value = pi3.div(10800);
      } else {
        UNITS.rad.value = 1;
        UNITS.deg.value = Math.PI / 180;
        UNITS.grad.value = Math.PI / 200;
        UNITS.cycle.value = Math.PI * 2;
        UNITS.arcsec.value = Math.PI / 648e3;
        UNITS.arcmin.value = Math.PI / 10800;
      }
      UNITS.radian.value = UNITS.rad.value;
      UNITS.degree.value = UNITS.deg.value;
      UNITS.gradian.value = UNITS.grad.value;
    }
    calculateAngleValues(config4);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.number !== prev.number) {
          calculateAngleValues(curr);
        }
      });
    }
    var UNIT_SYSTEMS = {
      si: {
        // Base units
        NONE: {
          unit: UNIT_NONE,
          prefix: PREFIXES.NONE[""]
        },
        LENGTH: {
          unit: UNITS.m,
          prefix: PREFIXES.SHORT[""]
        },
        MASS: {
          unit: UNITS.g,
          prefix: PREFIXES.SHORT.k
        },
        TIME: {
          unit: UNITS.s,
          prefix: PREFIXES.SHORT[""]
        },
        CURRENT: {
          unit: UNITS.A,
          prefix: PREFIXES.SHORT[""]
        },
        TEMPERATURE: {
          unit: UNITS.K,
          prefix: PREFIXES.SHORT[""]
        },
        LUMINOUS_INTENSITY: {
          unit: UNITS.cd,
          prefix: PREFIXES.SHORT[""]
        },
        AMOUNT_OF_SUBSTANCE: {
          unit: UNITS.mol,
          prefix: PREFIXES.SHORT[""]
        },
        ANGLE: {
          unit: UNITS.rad,
          prefix: PREFIXES.SHORT[""]
        },
        BIT: {
          unit: UNITS.bits,
          prefix: PREFIXES.SHORT[""]
        },
        // Derived units
        FORCE: {
          unit: UNITS.N,
          prefix: PREFIXES.SHORT[""]
        },
        ENERGY: {
          unit: UNITS.J,
          prefix: PREFIXES.SHORT[""]
        },
        POWER: {
          unit: UNITS.W,
          prefix: PREFIXES.SHORT[""]
        },
        PRESSURE: {
          unit: UNITS.Pa,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_CHARGE: {
          unit: UNITS.C,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_CAPACITANCE: {
          unit: UNITS.F,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_POTENTIAL: {
          unit: UNITS.V,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_RESISTANCE: {
          unit: UNITS.ohm,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_INDUCTANCE: {
          unit: UNITS.H,
          prefix: PREFIXES.SHORT[""]
        },
        ELECTRIC_CONDUCTANCE: {
          unit: UNITS.S,
          prefix: PREFIXES.SHORT[""]
        },
        MAGNETIC_FLUX: {
          unit: UNITS.Wb,
          prefix: PREFIXES.SHORT[""]
        },
        MAGNETIC_FLUX_DENSITY: {
          unit: UNITS.T,
          prefix: PREFIXES.SHORT[""]
        },
        FREQUENCY: {
          unit: UNITS.Hz,
          prefix: PREFIXES.SHORT[""]
        }
      }
    };
    UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.cgs.LENGTH = {
      unit: UNITS.m,
      prefix: PREFIXES.SHORT.c
    };
    UNIT_SYSTEMS.cgs.MASS = {
      unit: UNITS.g,
      prefix: PREFIXES.SHORT[""]
    };
    UNIT_SYSTEMS.cgs.FORCE = {
      unit: UNITS.dyn,
      prefix: PREFIXES.SHORT[""]
    };
    UNIT_SYSTEMS.cgs.ENERGY = {
      unit: UNITS.erg,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    UNIT_SYSTEMS.us.LENGTH = {
      unit: UNITS.ft,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.MASS = {
      unit: UNITS.lbm,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.TEMPERATURE = {
      unit: UNITS.degF,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.FORCE = {
      unit: UNITS.lbf,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.ENERGY = {
      unit: UNITS.BTU,
      prefix: PREFIXES.BTU[""]
    };
    UNIT_SYSTEMS.us.POWER = {
      unit: UNITS.hp,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.us.PRESSURE = {
      unit: UNITS.psi,
      prefix: PREFIXES.NONE[""]
    };
    UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
    var currentUnitSystem = UNIT_SYSTEMS.auto;
    Unit2.setUnitSystem = function(name310) {
      if (hasOwnProperty(UNIT_SYSTEMS, name310)) {
        currentUnitSystem = UNIT_SYSTEMS[name310];
      } else {
        throw new Error("Unit system " + name310 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
      }
    };
    Unit2.getUnitSystem = function() {
      for (var _key in UNIT_SYSTEMS) {
        if (hasOwnProperty(UNIT_SYSTEMS, _key)) {
          if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
            return _key;
          }
        }
      }
    };
    Unit2.typeConverters = {
      BigNumber: function BigNumber2(x) {
        if (x !== null && x !== void 0 && x.isFraction)
          return new _BigNumber(x.n).div(x.d).times(x.s);
        return new _BigNumber(x + "");
      },
      Fraction: function Fraction3(x) {
        return new _Fraction(x);
      },
      Complex: function Complex4(x) {
        return x;
      },
      number: function number2(x) {
        if (x !== null && x !== void 0 && x.isFraction)
          return _number(x);
        return x;
      }
    };
    Unit2.prototype._numberConverter = function() {
      var convert = Unit2.typeConverters[this.valueType()];
      if (convert) {
        return convert;
      }
      throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
    };
    Unit2._getNumberConverter = function(type) {
      if (!Unit2.typeConverters[type]) {
        throw new TypeError('Unsupported type "' + type + '"');
      }
      return Unit2.typeConverters[type];
    };
    for (var _key2 in UNITS) {
      if (hasOwnProperty(UNITS, _key2)) {
        var unit2 = UNITS[_key2];
        unit2.dimensions = unit2.base.dimensions;
      }
    }
    for (var _name2 in ALIASES) {
      if (hasOwnProperty(ALIASES, _name2)) {
        var _unit2 = UNITS[ALIASES[_name2]];
        var alias = {};
        for (var _key3 in _unit2) {
          if (hasOwnProperty(_unit2, _key3)) {
            alias[_key3] = _unit2[_key3];
          }
        }
        alias.name = _name2;
        UNITS[_name2] = alias;
      }
    }
    Unit2.isValidAlpha = function isValidAlpha(c2) {
      return /^[a-zA-Z]$/.test(c2);
    };
    function assertUnitNameIsValid(name310) {
      for (var i3 = 0; i3 < name310.length; i3++) {
        c = name310.charAt(i3);
        if (i3 === 0 && !Unit2.isValidAlpha(c)) {
          throw new Error('Invalid unit name (must begin with alpha character): "' + name310 + '"');
        }
        if (i3 > 0 && !(Unit2.isValidAlpha(c) || isDigit(c))) {
          throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name310 + '"');
        }
      }
    }
    Unit2.createUnit = function(obj, options) {
      if (typeof obj !== "object") {
        throw new TypeError("createUnit expects first parameter to be of type 'Object'");
      }
      if (options && options.override) {
        for (var _key4 in obj) {
          if (hasOwnProperty(obj, _key4)) {
            Unit2.deleteUnit(_key4);
          }
          if (obj[_key4].aliases) {
            for (var i3 = 0; i3 < obj[_key4].aliases.length; i3++) {
              Unit2.deleteUnit(obj[_key4].aliases[i3]);
            }
          }
        }
      }
      var lastUnit;
      for (var _key5 in obj) {
        if (hasOwnProperty(obj, _key5)) {
          lastUnit = Unit2.createUnitSingle(_key5, obj[_key5]);
        }
      }
      return lastUnit;
    };
    Unit2.createUnitSingle = function(name310, obj) {
      if (typeof obj === "undefined" || obj === null) {
        obj = {};
      }
      if (typeof name310 !== "string") {
        throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
      }
      if (hasOwnProperty(UNITS, name310)) {
        throw new Error('Cannot create unit "' + name310 + '": a unit with that name already exists');
      }
      assertUnitNameIsValid(name310);
      var defUnit = null;
      var aliases = [];
      var offset = 0;
      var definition;
      var prefixes;
      var baseName;
      if (obj && obj.type === "Unit") {
        defUnit = obj.clone();
      } else if (typeof obj === "string") {
        if (obj !== "") {
          definition = obj;
        }
      } else if (typeof obj === "object") {
        definition = obj.definition;
        prefixes = obj.prefixes;
        offset = obj.offset;
        baseName = obj.baseName;
        if (obj.aliases) {
          aliases = obj.aliases.valueOf();
        }
      } else {
        throw new TypeError('Cannot create unit "' + name310 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
      }
      if (aliases) {
        for (var i3 = 0; i3 < aliases.length; i3++) {
          if (hasOwnProperty(UNITS, aliases[i3])) {
            throw new Error('Cannot create alias "' + aliases[i3] + '": a unit with that name already exists');
          }
        }
      }
      if (definition && typeof definition === "string" && !defUnit) {
        try {
          defUnit = Unit2.parse(definition, {
            allowNoUnits: true
          });
        } catch (ex) {
          ex.message = 'Could not create unit "' + name310 + '" from "' + definition + '": ' + ex.message;
          throw ex;
        }
      } else if (definition && definition.type === "Unit") {
        defUnit = definition.clone();
      }
      aliases = aliases || [];
      offset = offset || 0;
      if (prefixes && prefixes.toUpperCase) {
        prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
      } else {
        prefixes = PREFIXES.NONE;
      }
      var newUnit = {};
      if (!defUnit) {
        baseName = baseName || name310 + "_STUFF";
        if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
          throw new Error('Cannot create new base unit "' + name310 + '": a base unit with that name already exists (and cannot be overridden)');
        }
        BASE_DIMENSIONS.push(baseName);
        for (var b in BASE_UNITS) {
          if (hasOwnProperty(BASE_UNITS, b)) {
            BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
          }
        }
        var newBaseUnit = {
          dimensions: []
        };
        for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
          newBaseUnit.dimensions[_i6] = 0;
        }
        newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
        newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = newBaseUnit;
        newUnit = {
          name: name310,
          value: 1,
          dimensions: BASE_UNITS[baseName].dimensions.slice(0),
          prefixes,
          offset,
          base: BASE_UNITS[baseName]
        };
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
      } else {
        newUnit = {
          name: name310,
          value: defUnit.value,
          dimensions: defUnit.dimensions.slice(0),
          prefixes,
          offset
        };
        var anyMatch = false;
        for (var _i7 in BASE_UNITS) {
          if (hasOwnProperty(BASE_UNITS, _i7)) {
            var match = true;
            for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
              if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
                match = false;
                break;
              }
            }
            if (match) {
              anyMatch = true;
              newUnit.base = BASE_UNITS[_i7];
              break;
            }
          }
        }
        if (!anyMatch) {
          baseName = baseName || name310 + "_STUFF";
          var _newBaseUnit = {
            dimensions: defUnit.dimensions.slice(0)
          };
          _newBaseUnit.key = baseName;
          BASE_UNITS[baseName] = _newBaseUnit;
          currentUnitSystem[baseName] = {
            unit: newUnit,
            prefix: PREFIXES.NONE[""]
          };
          newUnit.base = BASE_UNITS[baseName];
        }
      }
      Unit2.UNITS[name310] = newUnit;
      for (var _i8 = 0; _i8 < aliases.length; _i8++) {
        var aliasName = aliases[_i8];
        var _alias = {};
        for (var _key6 in newUnit) {
          if (hasOwnProperty(newUnit, _key6)) {
            _alias[_key6] = newUnit[_key6];
          }
        }
        _alias.name = aliasName;
        Unit2.UNITS[aliasName] = _alias;
      }
      delete _findUnit.cache;
      return new Unit2(null, name310);
    };
    Unit2.deleteUnit = function(name310) {
      delete Unit2.UNITS[name310];
    };
    Unit2.PREFIXES = PREFIXES;
    Unit2.BASE_DIMENSIONS = BASE_DIMENSIONS;
    Unit2.BASE_UNITS = BASE_UNITS;
    Unit2.UNIT_SYSTEMS = UNIT_SYSTEMS;
    Unit2.UNITS = UNITS;
    return Unit2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/unit/function/unit.js
  var name162 = "unit";
  var dependencies162 = ["typed", "Unit"];
  var createUnitFunction = /* @__PURE__ */ factory(name162, dependencies162, (_ref) => {
    var {
      typed: typed3,
      Unit: Unit2
    } = _ref;
    return typed3(name162, {
      Unit: function Unit3(x) {
        return x.clone();
      },
      string: function string2(x) {
        if (Unit2.isValuelessUnit(x)) {
          return new Unit2(null, x);
        }
        return Unit2.parse(x, {
          allowNoUnits: true
        });
      },
      "number | BigNumber | Fraction | Complex, string | Unit": function numberBigNumberFractionComplexStringUnit(value, unit2) {
        return new Unit2(value, unit2);
      },
      "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
        return new Unit2(value);
      },
      "Array | Matrix": typed3.referToSelf((self2) => (x) => deepMap(x, self2))
    });
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/sparse.js
  var name163 = "sparse";
  var dependencies163 = ["typed", "SparseMatrix"];
  var createSparse = /* @__PURE__ */ factory(name163, dependencies163, (_ref) => {
    var {
      typed: typed3,
      SparseMatrix: SparseMatrix2
    } = _ref;
    return typed3(name163, {
      "": function _() {
        return new SparseMatrix2([]);
      },
      string: function string2(datatype) {
        return new SparseMatrix2([], datatype);
      },
      "Array | Matrix": function ArrayMatrix(data) {
        return new SparseMatrix2(data);
      },
      "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
        return new SparseMatrix2(data, datatype);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/unit/function/createUnit.js
  var name164 = "createUnit";
  var dependencies164 = ["typed", "Unit"];
  var createCreateUnit = /* @__PURE__ */ factory(name164, dependencies164, (_ref) => {
    var {
      typed: typed3,
      Unit: Unit2
    } = _ref;
    return typed3(name164, {
      // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
      "Object, Object": function ObjectObject(obj, options) {
        return Unit2.createUnit(obj, options);
      },
      // Same as above but without the options.
      Object: function Object2(obj) {
        return Unit2.createUnit(obj, {});
      },
      // Shortcut method for creating one unit.
      "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name310, def, options) {
        var obj = {};
        obj[name310] = def;
        return Unit2.createUnit(obj, options);
      },
      // Same as above but without the options.
      "string, Unit | string | Object": function stringUnitStringObject(name310, def) {
        var obj = {};
        obj[name310] = def;
        return Unit2.createUnit(obj, {});
      },
      // Without a definition, creates a base unit.
      string: function string2(name310) {
        var obj = {};
        obj[name310] = {};
        return Unit2.createUnit(obj, {});
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acos.js
  var name165 = "acos";
  var dependencies165 = ["typed", "config", "Complex"];
  var createAcos = /* @__PURE__ */ factory(name165, dependencies165, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: Complex3
    } = _ref;
    return typed3(name165, {
      number: function number2(x) {
        if (x >= -1 && x <= 1 || config4.predictable) {
          return Math.acos(x);
        } else {
          return new Complex3(x, 0).acos();
        }
      },
      Complex: function Complex4(x) {
        return x.acos();
      },
      BigNumber: function BigNumber2(x) {
        return x.acos();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acosh.js
  var name166 = "acosh";
  var dependencies166 = ["typed", "config", "Complex"];
  var createAcosh = /* @__PURE__ */ factory(name166, dependencies166, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: Complex3
    } = _ref;
    return typed3(name166, {
      number: function number2(x) {
        if (x >= 1 || config4.predictable) {
          return acoshNumber(x);
        }
        if (x <= -1) {
          return new Complex3(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
        }
        return new Complex3(x, 0).acosh();
      },
      Complex: function Complex4(x) {
        return x.acosh();
      },
      BigNumber: function BigNumber2(x) {
        return x.acosh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acot.js
  var name167 = "acot";
  var dependencies167 = ["typed", "BigNumber"];
  var createAcot = /* @__PURE__ */ factory(name167, dependencies167, (_ref) => {
    var {
      typed: typed3,
      BigNumber: _BigNumber
    } = _ref;
    return typed3(name167, {
      number: acotNumber,
      Complex: function Complex3(x) {
        return x.acot();
      },
      BigNumber: function BigNumber2(x) {
        return new _BigNumber(1).div(x).atan();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acoth.js
  var name168 = "acoth";
  var dependencies168 = ["typed", "config", "Complex", "BigNumber"];
  var createAcoth = /* @__PURE__ */ factory(name168, dependencies168, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: Complex3,
      BigNumber: _BigNumber
    } = _ref;
    return typed3(name168, {
      number: function number2(x) {
        if (x >= 1 || x <= -1 || config4.predictable) {
          return acothNumber(x);
        }
        return new Complex3(x, 0).acoth();
      },
      Complex: function Complex4(x) {
        return x.acoth();
      },
      BigNumber: function BigNumber2(x) {
        return new _BigNumber(1).div(x).atanh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acsc.js
  var name169 = "acsc";
  var dependencies169 = ["typed", "config", "Complex", "BigNumber"];
  var createAcsc = /* @__PURE__ */ factory(name169, dependencies169, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: Complex3,
      BigNumber: _BigNumber
    } = _ref;
    return typed3(name169, {
      number: function number2(x) {
        if (x <= -1 || x >= 1 || config4.predictable) {
          return acscNumber(x);
        }
        return new Complex3(x, 0).acsc();
      },
      Complex: function Complex4(x) {
        return x.acsc();
      },
      BigNumber: function BigNumber2(x) {
        return new _BigNumber(1).div(x).asin();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/acsch.js
  var name170 = "acsch";
  var dependencies170 = ["typed", "BigNumber"];
  var createAcsch = /* @__PURE__ */ factory(name170, dependencies170, (_ref) => {
    var {
      typed: typed3,
      BigNumber: _BigNumber
    } = _ref;
    return typed3(name170, {
      number: acschNumber,
      Complex: function Complex3(x) {
        return x.acsch();
      },
      BigNumber: function BigNumber2(x) {
        return new _BigNumber(1).div(x).asinh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asec.js
  var name171 = "asec";
  var dependencies171 = ["typed", "config", "Complex", "BigNumber"];
  var createAsec = /* @__PURE__ */ factory(name171, dependencies171, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: Complex3,
      BigNumber: _BigNumber
    } = _ref;
    return typed3(name171, {
      number: function number2(x) {
        if (x <= -1 || x >= 1 || config4.predictable) {
          return asecNumber(x);
        }
        return new Complex3(x, 0).asec();
      },
      Complex: function Complex4(x) {
        return x.asec();
      },
      BigNumber: function BigNumber2(x) {
        return new _BigNumber(1).div(x).acos();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asech.js
  var name172 = "asech";
  var dependencies172 = ["typed", "config", "Complex", "BigNumber"];
  var createAsech = /* @__PURE__ */ factory(name172, dependencies172, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: Complex3,
      BigNumber: _BigNumber
    } = _ref;
    return typed3(name172, {
      number: function number2(x) {
        if (x <= 1 && x >= -1 || config4.predictable) {
          var xInv = 1 / x;
          if (xInv > 0 || config4.predictable) {
            return asechNumber(x);
          }
          var ret = Math.sqrt(xInv * xInv - 1);
          return new Complex3(Math.log(ret - xInv), Math.PI);
        }
        return new Complex3(x, 0).asech();
      },
      Complex: function Complex4(x) {
        return x.asech();
      },
      BigNumber: function BigNumber2(x) {
        return new _BigNumber(1).div(x).acosh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asin.js
  var name173 = "asin";
  var dependencies173 = ["typed", "config", "Complex"];
  var createAsin = /* @__PURE__ */ factory(name173, dependencies173, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: Complex3
    } = _ref;
    return typed3(name173, {
      number: function number2(x) {
        if (x >= -1 && x <= 1 || config4.predictable) {
          return Math.asin(x);
        } else {
          return new Complex3(x, 0).asin();
        }
      },
      Complex: function Complex4(x) {
        return x.asin();
      },
      BigNumber: function BigNumber2(x) {
        return x.asin();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/asinh.js
  var name174 = "asinh";
  var dependencies174 = ["typed"];
  var createAsinh = /* @__PURE__ */ factory(name174, dependencies174, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3("asinh", {
      number: asinhNumber,
      Complex: function Complex3(x) {
        return x.asinh();
      },
      BigNumber: function BigNumber2(x) {
        return x.asinh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atan.js
  var name175 = "atan";
  var dependencies175 = ["typed"];
  var createAtan = /* @__PURE__ */ factory(name175, dependencies175, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3("atan", {
      number: function number2(x) {
        return Math.atan(x);
      },
      Complex: function Complex3(x) {
        return x.atan();
      },
      BigNumber: function BigNumber2(x) {
        return x.atan();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atan2.js
  var name176 = "atan2";
  var dependencies176 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
  var createAtan2 = /* @__PURE__ */ factory(name176, dependencies176, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      equalScalar: equalScalar2,
      BigNumber: BigNumber2,
      DenseMatrix: DenseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo02xDS0 = createMatAlgo02xDS0({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo03xDSf = createMatAlgo03xDSf({
      typed: typed3
    });
    var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo12xSfs = createMatAlgo12xSfs({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name176, {
      "number, number": Math.atan2,
      // Complex numbers doesn't seem to have a reasonable implementation of
      // atan2(). Even Matlab removed the support, after they only calculated
      // the atan only on base of the real part of the numbers and ignored
      // the imaginary.
      "BigNumber, BigNumber": (y2, x) => BigNumber2.atan2(y2, x)
    }, matrixAlgorithmSuite({
      scalar: "number | BigNumber",
      SS: matAlgo09xS0Sf,
      DS: matAlgo03xDSf,
      SD: matAlgo02xDS0,
      Ss: matAlgo11xS0s,
      sS: matAlgo12xSfs
    }));
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/atanh.js
  var name177 = "atanh";
  var dependencies177 = ["typed", "config", "Complex"];
  var createAtanh = /* @__PURE__ */ factory(name177, dependencies177, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      Complex: Complex3
    } = _ref;
    return typed3(name177, {
      number: function number2(x) {
        if (x <= 1 && x >= -1 || config4.predictable) {
          return atanhNumber(x);
        }
        return new Complex3(x, 0).atanh();
      },
      Complex: function Complex4(x) {
        return x.atanh();
      },
      BigNumber: function BigNumber2(x) {
        return x.atanh();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/trigUnit.js
  var createTrigUnit = /* @__PURE__ */ factory("trigUnit", ["typed"], (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return {
      Unit: typed3.referToSelf((self2) => (x) => {
        if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
          throw new TypeError("Unit in function cot is no angle");
        }
        return typed3.find(self2, x.valueType())(x.value);
      })
    };
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cos.js
  var name178 = "cos";
  var dependencies178 = ["typed"];
  var createCos = /* @__PURE__ */ factory(name178, dependencies178, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    var trigUnit = createTrigUnit({
      typed: typed3
    });
    return typed3(name178, {
      number: Math.cos,
      "Complex | BigNumber": (x) => x.cos()
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cosh.js
  var name179 = "cosh";
  var dependencies179 = ["typed"];
  var createCosh = /* @__PURE__ */ factory(name179, dependencies179, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name179, {
      number: cosh,
      "Complex | BigNumber": (x) => x.cosh()
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/cot.js
  var name180 = "cot";
  var dependencies180 = ["typed", "BigNumber"];
  var createCot = /* @__PURE__ */ factory(name180, dependencies180, (_ref) => {
    var {
      typed: typed3,
      BigNumber: _BigNumber
    } = _ref;
    var trigUnit = createTrigUnit({
      typed: typed3
    });
    return typed3(name180, {
      number: cotNumber,
      Complex: (x) => x.cot(),
      BigNumber: (x) => new _BigNumber(1).div(x.tan())
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/coth.js
  var name181 = "coth";
  var dependencies181 = ["typed", "BigNumber"];
  var createCoth = /* @__PURE__ */ factory(name181, dependencies181, (_ref) => {
    var {
      typed: typed3,
      BigNumber: _BigNumber
    } = _ref;
    return typed3(name181, {
      number: cothNumber,
      Complex: (x) => x.coth(),
      BigNumber: (x) => new _BigNumber(1).div(x.tanh())
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/csc.js
  var name182 = "csc";
  var dependencies182 = ["typed", "BigNumber"];
  var createCsc = /* @__PURE__ */ factory(name182, dependencies182, (_ref) => {
    var {
      typed: typed3,
      BigNumber: _BigNumber
    } = _ref;
    var trigUnit = createTrigUnit({
      typed: typed3
    });
    return typed3(name182, {
      number: cscNumber,
      Complex: (x) => x.csc(),
      BigNumber: (x) => new _BigNumber(1).div(x.sin())
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/csch.js
  var name183 = "csch";
  var dependencies183 = ["typed", "BigNumber"];
  var createCsch = /* @__PURE__ */ factory(name183, dependencies183, (_ref) => {
    var {
      typed: typed3,
      BigNumber: _BigNumber
    } = _ref;
    return typed3(name183, {
      number: cschNumber,
      Complex: (x) => x.csch(),
      BigNumber: (x) => new _BigNumber(1).div(x.sinh())
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sec.js
  var name184 = "sec";
  var dependencies184 = ["typed", "BigNumber"];
  var createSec = /* @__PURE__ */ factory(name184, dependencies184, (_ref) => {
    var {
      typed: typed3,
      BigNumber: _BigNumber
    } = _ref;
    var trigUnit = createTrigUnit({
      typed: typed3
    });
    return typed3(name184, {
      number: secNumber,
      Complex: (x) => x.sec(),
      BigNumber: (x) => new _BigNumber(1).div(x.cos())
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sech.js
  var name185 = "sech";
  var dependencies185 = ["typed", "BigNumber"];
  var createSech = /* @__PURE__ */ factory(name185, dependencies185, (_ref) => {
    var {
      typed: typed3,
      BigNumber: _BigNumber
    } = _ref;
    return typed3(name185, {
      number: sechNumber,
      Complex: (x) => x.sech(),
      BigNumber: (x) => new _BigNumber(1).div(x.cosh())
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sin.js
  var name186 = "sin";
  var dependencies186 = ["typed"];
  var createSin = /* @__PURE__ */ factory(name186, dependencies186, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    var trigUnit = createTrigUnit({
      typed: typed3
    });
    return typed3(name186, {
      number: Math.sin,
      "Complex | BigNumber": (x) => x.sin()
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/sinh.js
  var name187 = "sinh";
  var dependencies187 = ["typed"];
  var createSinh = /* @__PURE__ */ factory(name187, dependencies187, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name187, {
      number: sinhNumber,
      "Complex | BigNumber": (x) => x.sinh()
    });
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/tan.js
  var name188 = "tan";
  var dependencies188 = ["typed"];
  var createTan = /* @__PURE__ */ factory(name188, dependencies188, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    var trigUnit = createTrigUnit({
      typed: typed3
    });
    return typed3(name188, {
      number: Math.tan,
      "Complex | BigNumber": (x) => x.tan()
    }, trigUnit);
  });

  // node_modules/mathjs/lib/esm/function/trigonometry/tanh.js
  var name189 = "tanh";
  var dependencies189 = ["typed"];
  var createTanh = /* @__PURE__ */ factory(name189, dependencies189, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3("tanh", {
      number: tanh,
      "Complex | BigNumber": (x) => x.tanh()
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setCartesian.js
  var name190 = "setCartesian";
  var dependencies190 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetCartesian = /* @__PURE__ */ factory(name190, dependencies190, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      subset: subset2,
      compareNatural: compareNatural2,
      Index: Index2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return typed3(name190, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        var result = [];
        if (subset2(size2(a1), new Index2(0)) !== 0 && subset2(size2(a2), new Index2(0)) !== 0) {
          var b1 = flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2);
          var b2 = flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2);
          result = [];
          for (var i3 = 0; i3 < b1.length; i3++) {
            for (var j = 0; j < b2.length; j++) {
              result.push([b1[i3], b2[j]]);
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return result;
        }
        return new DenseMatrix2(result);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setDifference.js
  var name191 = "setDifference";
  var dependencies191 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetDifference = /* @__PURE__ */ factory(name191, dependencies191, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      subset: subset2,
      compareNatural: compareNatural2,
      Index: Index2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return typed3(name191, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        var result;
        if (subset2(size2(a1), new Index2(0)) === 0) {
          result = [];
        } else if (subset2(size2(a2), new Index2(0)) === 0) {
          return flatten(a1.toArray());
        } else {
          var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
          var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
          result = [];
          var inb2;
          for (var i3 = 0; i3 < b1.length; i3++) {
            inb2 = false;
            for (var j = 0; j < b2.length; j++) {
              if (compareNatural2(b1[i3].value, b2[j].value) === 0 && b1[i3].identifier === b2[j].identifier) {
                inb2 = true;
                break;
              }
            }
            if (!inb2) {
              result.push(b1[i3]);
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        }
        return new DenseMatrix2(generalize(result));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setDistinct.js
  var name192 = "setDistinct";
  var dependencies192 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetDistinct = /* @__PURE__ */ factory(name192, dependencies192, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      subset: subset2,
      compareNatural: compareNatural2,
      Index: Index2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return typed3(name192, {
      "Array | Matrix": function ArrayMatrix(a) {
        var result;
        if (subset2(size2(a), new Index2(0)) === 0) {
          result = [];
        } else {
          var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
          result = [];
          result.push(b[0]);
          for (var i3 = 1; i3 < b.length; i3++) {
            if (compareNatural2(b[i3], b[i3 - 1]) !== 0) {
              result.push(b[i3]);
            }
          }
        }
        if (Array.isArray(a)) {
          return result;
        }
        return new DenseMatrix2(result);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setIntersect.js
  var name193 = "setIntersect";
  var dependencies193 = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
  var createSetIntersect = /* @__PURE__ */ factory(name193, dependencies193, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      subset: subset2,
      compareNatural: compareNatural2,
      Index: Index2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    return typed3(name193, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        var result;
        if (subset2(size2(a1), new Index2(0)) === 0 || subset2(size2(a2), new Index2(0)) === 0) {
          result = [];
        } else {
          var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
          var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
          result = [];
          for (var i3 = 0; i3 < b1.length; i3++) {
            for (var j = 0; j < b2.length; j++) {
              if (compareNatural2(b1[i3].value, b2[j].value) === 0 && b1[i3].identifier === b2[j].identifier) {
                result.push(b1[i3]);
                break;
              }
            }
          }
        }
        if (Array.isArray(a1) && Array.isArray(a2)) {
          return generalize(result);
        }
        return new DenseMatrix2(generalize(result));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setIsSubset.js
  var name194 = "setIsSubset";
  var dependencies194 = ["typed", "size", "subset", "compareNatural", "Index"];
  var createSetIsSubset = /* @__PURE__ */ factory(name194, dependencies194, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      subset: subset2,
      compareNatural: compareNatural2,
      Index: Index2
    } = _ref;
    return typed3(name194, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset2(size2(a1), new Index2(0)) === 0) {
          return true;
        } else if (subset2(size2(a2), new Index2(0)) === 0) {
          return false;
        }
        var b1 = identify(flatten(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        var inb2;
        for (var i3 = 0; i3 < b1.length; i3++) {
          inb2 = false;
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i3].value, b2[j].value) === 0 && b1[i3].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (inb2 === false) {
            return false;
          }
        }
        return true;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setMultiplicity.js
  var name195 = "setMultiplicity";
  var dependencies195 = ["typed", "size", "subset", "compareNatural", "Index"];
  var createSetMultiplicity = /* @__PURE__ */ factory(name195, dependencies195, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      subset: subset2,
      compareNatural: compareNatural2,
      Index: Index2
    } = _ref;
    return typed3(name195, {
      "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e3, a) {
        if (subset2(size2(a), new Index2(0)) === 0) {
          return 0;
        }
        var b = flatten(Array.isArray(a) ? a : a.toArray());
        var count2 = 0;
        for (var i3 = 0; i3 < b.length; i3++) {
          if (compareNatural2(b[i3], e3) === 0) {
            count2++;
          }
        }
        return count2;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setPowerset.js
  var name196 = "setPowerset";
  var dependencies196 = ["typed", "size", "subset", "compareNatural", "Index"];
  var createSetPowerset = /* @__PURE__ */ factory(name196, dependencies196, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      subset: subset2,
      compareNatural: compareNatural2,
      Index: Index2
    } = _ref;
    return typed3(name196, {
      "Array | Matrix": function ArrayMatrix(a) {
        if (subset2(size2(a), new Index2(0)) === 0) {
          return [];
        }
        var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        var result = [];
        var number2 = 0;
        while (number2.toString(2).length <= b.length) {
          result.push(_subset(b, number2.toString(2).split("").reverse()));
          number2++;
        }
        return _sort(result);
      }
    });
    function _subset(array, bitarray) {
      var result = [];
      for (var i3 = 0; i3 < bitarray.length; i3++) {
        if (bitarray[i3] === "1") {
          result.push(array[i3]);
        }
      }
      return result;
    }
    function _sort(array) {
      var temp = [];
      for (var i3 = array.length - 1; i3 > 0; i3--) {
        for (var j = 0; j < i3; j++) {
          if (array[j].length > array[j + 1].length) {
            temp = array[j];
            array[j] = array[j + 1];
            array[j + 1] = temp;
          }
        }
      }
      return array;
    }
  });

  // node_modules/mathjs/lib/esm/function/set/setSize.js
  var name197 = "setSize";
  var dependencies197 = ["typed", "compareNatural"];
  var createSetSize = /* @__PURE__ */ factory(name197, dependencies197, (_ref) => {
    var {
      typed: typed3,
      compareNatural: compareNatural2
    } = _ref;
    return typed3(name197, {
      "Array | Matrix": function ArrayMatrix(a) {
        return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
      },
      "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique) {
        if (unique === false || a.length === 0) {
          return Array.isArray(a) ? flatten(a).length : flatten(a.toArray()).length;
        } else {
          var b = flatten(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
          var count2 = 1;
          for (var i3 = 1; i3 < b.length; i3++) {
            if (compareNatural2(b[i3], b[i3 - 1]) !== 0) {
              count2++;
            }
          }
          return count2;
        }
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setSymDifference.js
  var name198 = "setSymDifference";
  var dependencies198 = ["typed", "size", "concat", "subset", "setDifference", "Index"];
  var createSetSymDifference = /* @__PURE__ */ factory(name198, dependencies198, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      concat: concat3,
      subset: subset2,
      setDifference: setDifference2,
      Index: Index2
    } = _ref;
    return typed3(name198, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset2(size2(a1), new Index2(0)) === 0) {
          return flatten(a2);
        } else if (subset2(size2(a2), new Index2(0)) === 0) {
          return flatten(a1);
        }
        var b1 = flatten(a1);
        var b2 = flatten(a2);
        return concat3(setDifference2(b1, b2), setDifference2(b2, b1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/set/setUnion.js
  var name199 = "setUnion";
  var dependencies199 = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
  var createSetUnion = /* @__PURE__ */ factory(name199, dependencies199, (_ref) => {
    var {
      typed: typed3,
      size: size2,
      concat: concat3,
      subset: subset2,
      setIntersect: setIntersect2,
      setSymDifference: setSymDifference2,
      Index: Index2
    } = _ref;
    return typed3(name199, {
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
        if (subset2(size2(a1), new Index2(0)) === 0) {
          return flatten(a2);
        } else if (subset2(size2(a2), new Index2(0)) === 0) {
          return flatten(a1);
        }
        var b1 = flatten(a1);
        var b2 = flatten(a2);
        return concat3(setSymDifference2(b1, b2), setIntersect2(b1, b2));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/add.js
  var name200 = "add";
  var dependencies200 = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"];
  var createAdd = /* @__PURE__ */ factory(name200, dependencies200, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      addScalar: addScalar2,
      equalScalar: equalScalar2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2,
      concat: concat3
    } = _ref;
    var matAlgo01xDSid = createMatAlgo01xDSid({
      typed: typed3
    });
    var matAlgo04xSidSid = createMatAlgo04xSidSid({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo10xSids = createMatAlgo10xSids({
      typed: typed3,
      DenseMatrix: DenseMatrix2
    });
    var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
      typed: typed3,
      matrix: matrix2,
      concat: concat3
    });
    return typed3(name200, {
      "any, any": addScalar2,
      "any, any, ...any": typed3.referToSelf((self2) => (x, y2, rest) => {
        var result = self2(x, y2);
        for (var i3 = 0; i3 < rest.length; i3++) {
          result = self2(result, rest[i3]);
        }
        return result;
      })
    }, matrixAlgorithmSuite({
      elop: addScalar2,
      DS: matAlgo01xDSid,
      SS: matAlgo04xSidSid,
      Ss: matAlgo10xSids
    }));
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/hypot.js
  var name201 = "hypot";
  var dependencies201 = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
  var createHypot = /* @__PURE__ */ factory(name201, dependencies201, (_ref) => {
    var {
      typed: typed3,
      abs: abs3,
      addScalar: addScalar2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      sqrt: sqrt3,
      smaller: smaller2,
      isPositive: isPositive2
    } = _ref;
    return typed3(name201, {
      "... number | BigNumber": _hypot,
      Array: _hypot,
      Matrix: (M) => _hypot(flatten(M.toArray()))
    });
    function _hypot(args) {
      var result = 0;
      var largest = 0;
      for (var i3 = 0; i3 < args.length; i3++) {
        if (isComplex(args[i3])) {
          throw new TypeError("Unexpected type of argument to hypot");
        }
        var value = abs3(args[i3]);
        if (smaller2(largest, value)) {
          result = multiplyScalar2(result, multiplyScalar2(divideScalar2(largest, value), divideScalar2(largest, value)));
          result = addScalar2(result, 1);
          largest = value;
        } else {
          result = addScalar2(result, isPositive2(value) ? multiplyScalar2(divideScalar2(value, largest), divideScalar2(value, largest)) : value);
        }
      }
      return multiplyScalar2(largest, sqrt3(result));
    }
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/norm.js
  var name202 = "norm";
  var dependencies202 = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
  var createNorm = /* @__PURE__ */ factory(name202, dependencies202, (_ref) => {
    var {
      typed: typed3,
      abs: abs3,
      add: add3,
      pow: pow3,
      conj: conj2,
      sqrt: sqrt3,
      multiply: multiply2,
      equalScalar: equalScalar2,
      larger: larger2,
      smaller: smaller2,
      matrix: matrix2,
      ctranspose: ctranspose2,
      eigs: eigs2
    } = _ref;
    return typed3(name202, {
      number: Math.abs,
      Complex: function Complex3(x) {
        return x.abs();
      },
      BigNumber: function BigNumber2(x) {
        return x.abs();
      },
      boolean: function boolean2(x) {
        return Math.abs(x);
      },
      Array: function Array2(x) {
        return _norm(matrix2(x), 2);
      },
      Matrix: function Matrix2(x) {
        return _norm(x, 2);
      },
      "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
        return _norm(matrix2(x), p);
      },
      "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
        return _norm(x, p);
      }
    });
    function _vectorNormPlusInfinity(x) {
      var pinf = 0;
      x.forEach(function(value) {
        var v = abs3(value);
        if (larger2(v, pinf)) {
          pinf = v;
        }
      }, true);
      return pinf;
    }
    function _vectorNormMinusInfinity(x) {
      var ninf;
      x.forEach(function(value) {
        var v = abs3(value);
        if (!ninf || smaller2(v, ninf)) {
          ninf = v;
        }
      }, true);
      return ninf || 0;
    }
    function _vectorNorm(x, p) {
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _vectorNormPlusInfinity(x);
      }
      if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
        return _vectorNormMinusInfinity(x);
      }
      if (p === "fro") {
        return _norm(x, 2);
      }
      if (typeof p === "number" && !isNaN(p)) {
        if (!equalScalar2(p, 0)) {
          var n = 0;
          x.forEach(function(value) {
            n = add3(pow3(abs3(value), p), n);
          }, true);
          return pow3(n, 1 / p);
        }
        return Number.POSITIVE_INFINITY;
      }
      throw new Error("Unsupported parameter value");
    }
    function _matrixNormFrobenius(x) {
      var fro = 0;
      x.forEach(function(value, index2) {
        fro = add3(fro, multiply2(value, conj2(value)));
      });
      return abs3(sqrt3(fro));
    }
    function _matrixNormOne(x) {
      var c = [];
      var maxc = 0;
      x.forEach(function(value, index2) {
        var j = index2[1];
        var cj = add3(c[j] || 0, abs3(value));
        if (larger2(cj, maxc)) {
          maxc = cj;
        }
        c[j] = cj;
      }, true);
      return maxc;
    }
    function _matrixNormTwo(x) {
      var sizeX = x.size();
      if (sizeX[0] !== sizeX[1]) {
        throw new RangeError("Invalid matrix dimensions");
      }
      var tx = ctranspose2(x);
      var squaredX = multiply2(tx, x);
      var eigenVals = eigs2(squaredX).values.toArray();
      var rho = eigenVals[eigenVals.length - 1];
      return abs3(sqrt3(rho));
    }
    function _matrixNormInfinity(x) {
      var r = [];
      var maxr = 0;
      x.forEach(function(value, index2) {
        var i3 = index2[0];
        var ri = add3(r[i3] || 0, abs3(value));
        if (larger2(ri, maxr)) {
          maxr = ri;
        }
        r[i3] = ri;
      }, true);
      return maxr;
    }
    function _matrixNorm(x, p) {
      if (p === 1) {
        return _matrixNormOne(x);
      }
      if (p === Number.POSITIVE_INFINITY || p === "inf") {
        return _matrixNormInfinity(x);
      }
      if (p === "fro") {
        return _matrixNormFrobenius(x);
      }
      if (p === 2) {
        return _matrixNormTwo(x);
      }
      throw new Error("Unsupported parameter value " + p);
    }
    function _norm(x, p) {
      var sizeX = x.size();
      if (sizeX.length === 1) {
        return _vectorNorm(x, p);
      }
      if (sizeX.length === 2) {
        if (sizeX[0] && sizeX[1]) {
          return _matrixNorm(x, p);
        } else {
          throw new RangeError("Invalid matrix dimensions");
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/dot.js
  var name203 = "dot";
  var dependencies203 = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
  var createDot = /* @__PURE__ */ factory(name203, dependencies203, (_ref) => {
    var {
      typed: typed3,
      addScalar: addScalar2,
      multiplyScalar: multiplyScalar2,
      conj: conj2,
      size: size2
    } = _ref;
    return typed3(name203, {
      "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
      "SparseMatrix, SparseMatrix": _sparseDot
    });
    function _validateDim(x, y2) {
      var xSize = _size(x);
      var ySize = _size(y2);
      var xLen, yLen;
      if (xSize.length === 1) {
        xLen = xSize[0];
      } else if (xSize.length === 2 && xSize[1] === 1) {
        xLen = xSize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
      }
      if (ySize.length === 1) {
        yLen = ySize[0];
      } else if (ySize.length === 2 && ySize[1] === 1) {
        yLen = ySize[0];
      } else {
        throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
      }
      if (xLen !== yLen)
        throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
      if (xLen === 0)
        throw new RangeError("Cannot calculate the dot product of empty vectors");
      return xLen;
    }
    function _denseDot(a, b) {
      var N = _validateDim(a, b);
      var adata = isMatrix(a) ? a._data : a;
      var adt = isMatrix(a) ? a._datatype : void 0;
      var bdata = isMatrix(b) ? b._data : b;
      var bdt = isMatrix(b) ? b._datatype : void 0;
      var aIsColumn = _size(a).length === 2;
      var bIsColumn = _size(b).length === 2;
      var add3 = addScalar2;
      var mul2 = multiplyScalar2;
      if (adt && bdt && adt === bdt && typeof adt === "string") {
        var dt = adt;
        add3 = typed3.find(addScalar2, [dt, dt]);
        mul2 = typed3.find(multiplyScalar2, [dt, dt]);
      }
      if (!aIsColumn && !bIsColumn) {
        var c = mul2(conj2(adata[0]), bdata[0]);
        for (var i3 = 1; i3 < N; i3++) {
          c = add3(c, mul2(conj2(adata[i3]), bdata[i3]));
        }
        return c;
      }
      if (!aIsColumn && bIsColumn) {
        var _c = mul2(conj2(adata[0]), bdata[0][0]);
        for (var _i = 1; _i < N; _i++) {
          _c = add3(_c, mul2(conj2(adata[_i]), bdata[_i][0]));
        }
        return _c;
      }
      if (aIsColumn && !bIsColumn) {
        var _c2 = mul2(conj2(adata[0][0]), bdata[0]);
        for (var _i2 = 1; _i2 < N; _i2++) {
          _c2 = add3(_c2, mul2(conj2(adata[_i2][0]), bdata[_i2]));
        }
        return _c2;
      }
      if (aIsColumn && bIsColumn) {
        var _c3 = mul2(conj2(adata[0][0]), bdata[0][0]);
        for (var _i3 = 1; _i3 < N; _i3++) {
          _c3 = add3(_c3, mul2(conj2(adata[_i3][0]), bdata[_i3][0]));
        }
        return _c3;
      }
    }
    function _sparseDot(x, y2) {
      _validateDim(x, y2);
      var xindex = x._index;
      var xvalues = x._values;
      var yindex = y2._index;
      var yvalues = y2._values;
      var c = 0;
      var add3 = addScalar2;
      var mul2 = multiplyScalar2;
      var i3 = 0;
      var j = 0;
      while (i3 < xindex.length && j < yindex.length) {
        var I2 = xindex[i3];
        var J = yindex[j];
        if (I2 < J) {
          i3++;
          continue;
        }
        if (I2 > J) {
          j++;
          continue;
        }
        if (I2 === J) {
          c = add3(c, mul2(xvalues[i3], yvalues[j]));
          i3++;
          j++;
        }
      }
      return c;
    }
    function _size(x) {
      return isMatrix(x) ? x.size() : size2(x);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/trace.js
  var name204 = "trace";
  var dependencies204 = ["typed", "matrix", "add"];
  var createTrace = /* @__PURE__ */ factory(name204, dependencies204, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      add: add3
    } = _ref;
    return typed3("trace", {
      Array: function _arrayTrace(x) {
        return _denseTrace(matrix2(x));
      },
      SparseMatrix: _sparseTrace,
      DenseMatrix: _denseTrace,
      any: clone
    });
    function _denseTrace(m) {
      var size2 = m._size;
      var data = m._data;
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            return clone(data[0]);
          }
          throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            var sum3 = 0;
            for (var i3 = 0; i3 < rows; i3++) {
              sum3 = add3(sum3, data[i3][i3]);
            }
            return sum3;
          } else {
            throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
      }
    }
    function _sparseTrace(m) {
      var values = m._values;
      var index2 = m._index;
      var ptr = m._ptr;
      var size2 = m._size;
      var rows = size2[0];
      var columns = size2[1];
      if (rows === columns) {
        var sum3 = 0;
        if (values.length > 0) {
          for (var j = 0; j < columns; j++) {
            var k0 = ptr[j];
            var k1 = ptr[j + 1];
            for (var k = k0; k < k1; k++) {
              var i3 = index2[k];
              if (i3 === j) {
                sum3 = add3(sum3, values[k]);
                break;
              }
              if (i3 > j) {
                break;
              }
            }
          }
        }
        return sum3;
      }
      throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
    }
  });

  // node_modules/mathjs/lib/esm/type/matrix/function/index.js
  var name205 = "index";
  var dependencies205 = ["typed", "Index"];
  var createIndex = /* @__PURE__ */ factory(name205, dependencies205, (_ref) => {
    var {
      typed: typed3,
      Index: Index2
    } = _ref;
    return typed3(name205, {
      "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
        var ranges = args.map(function(arg2) {
          if (isBigNumber(arg2)) {
            return arg2.toNumber();
          } else if (isArray(arg2) || isMatrix(arg2)) {
            return arg2.map(function(elem) {
              return isBigNumber(elem) ? elem.toNumber() : elem;
            });
          } else {
            return arg2;
          }
        });
        var res = new Index2();
        Index2.apply(res, ranges);
        return res;
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/keywords.js
  var keywords = /* @__PURE__ */ new Set(["end"]);

  // node_modules/mathjs/lib/esm/expression/node/Node.js
  var name206 = "Node";
  var dependencies206 = ["mathWithTransform"];
  var createNode = /* @__PURE__ */ factory(name206, dependencies206, (_ref) => {
    var {
      mathWithTransform: mathWithTransform2
    } = _ref;
    function _validateScope(scope) {
      for (var symbol of [...keywords]) {
        if (scope.has(symbol)) {
          throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
        }
      }
    }
    class Node2 {
      get type() {
        return "Node";
      }
      get isNode() {
        return true;
      }
      /**
       * Evaluate the node
       * @param {Object} [scope]  Scope to read/write variables
       * @return {*}              Returns the result
       */
      evaluate(scope) {
        return this.compile().evaluate(scope);
      }
      /**
       * Compile the node into an optimized, evauatable JavaScript function
       * @return {{evaluate: function([Object])}} object
       *                Returns an object with a function 'evaluate',
       *                which can be invoked as expr.evaluate([scope: Object]),
       *                where scope is an optional object with
       *                variables.
       */
      compile() {
        var expr = this._compile(mathWithTransform2, {});
        var args = {};
        var context = null;
        function evaluate2(scope) {
          var s = createMap(scope);
          _validateScope(s);
          return expr(s, args, context);
        }
        return {
          evaluate: evaluate2
        };
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        throw new Error("Method _compile must be implemented by type " + this.type);
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        throw new Error("Cannot run forEach on a Node interface");
      }
      /**
       * Create a new Node whose children are the results of calling the
       * provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {OperatorNode} Returns a transformed copy of the node
       */
      map(callback) {
        throw new Error("Cannot run map on a Node interface");
      }
      /**
       * Validate whether an object is a Node, for use with map
       * @param {Node} node
       * @returns {Node} Returns the input if it's a node, else throws an Error
       * @protected
       */
      _ifNode(node) {
        if (!isNode(node)) {
          throw new TypeError("Callback function must return a Node");
        }
        return node;
      }
      /**
       * Recursively traverse all nodes in a node tree. Executes given callback for
       * this node and each of its child nodes.
       * @param {function(node: Node, path: string, parent: Node)} callback
       *          A callback called for every node in the node tree.
       */
      traverse(callback) {
        callback(this, null, null);
        function _traverse(node, callback2) {
          node.forEach(function(child, path, parent) {
            callback2(child, path, parent);
            _traverse(child, callback2);
          });
        }
        _traverse(this, callback);
      }
      /**
       * Recursively transform a node tree via a transform function.
       *
       * For example, to replace all nodes of type SymbolNode having name 'x' with
       * a ConstantNode with value 2:
       *
       *     const res = Node.transform(function (node, path, parent) {
       *       if (node && node.isSymbolNode) && (node.name === 'x')) {
       *         return new ConstantNode(2)
       *       }
       *       else {
       *         return node
       *       }
       *     })
       *
       * @param {function(node: Node, path: string, parent: Node) : Node} callback
       *          A mapping function accepting a node, and returning
       *          a replacement for the node or the original node. The "signature"
       *          of the callback must be:
       *          callback(node: Node, index: string, parent: Node) : Node
       * @return {Node} Returns the original node or its replacement
       */
      transform(callback) {
        function _transform(child, path, parent) {
          var replacement = callback(child, path, parent);
          if (replacement !== child) {
            return replacement;
          }
          return child.map(_transform);
        }
        return _transform(this, null, null);
      }
      /**
       * Find any node in the node tree matching given filter function. For
       * example, to find all nodes of type SymbolNode having name 'x':
       *
       *     const results = Node.filter(function (node) {
       *       return (node && node.isSymbolNode) && (node.name === 'x')
       *     })
       *
       * @param {function(node: Node, path: string, parent: Node) : Node} callback
       *            A test function returning true when a node matches, and false
       *            otherwise. Function signature:
       *            callback(node: Node, index: string, parent: Node) : boolean
       * @return {Node[]} nodes
       *            An array with nodes matching given filter criteria
       */
      filter(callback) {
        var nodes = [];
        this.traverse(function(node, path, parent) {
          if (callback(node, path, parent)) {
            nodes.push(node);
          }
        });
        return nodes;
      }
      /**
       * Create a shallow clone of this node
       * @return {Node}
       */
      clone() {
        throw new Error("Cannot clone a Node interface");
      }
      /**
       * Create a deep clone of this node
       * @return {Node}
       */
      cloneDeep() {
        return this.map(function(node) {
          return node.cloneDeep();
        });
      }
      /**
       * Deep compare this node with another node.
       * @param {Node} other
       * @return {boolean} Returns true when both nodes are of the same type and
       *                   contain the same values (as do their childs)
       */
      equals(other) {
        return other ? this.type === other.type && deepStrictEqual(this, other) : false;
      }
      /**
       * Get string representation. (wrapper function)
       *
       * This function can get an object of the following form:
       * {
       *    handler: //This can be a callback function of the form
       *             // "function callback(node, options)"or
       *             // a map that maps function names (used in FunctionNodes)
       *             // to callbacks
       *    parenthesis: "keep" //the parenthesis option (This is optional)
       * }
       *
       * @param {Object} [options]
       * @return {string}
       */
      toString(options) {
        var customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this._toString(options);
      }
      /**
       * Get a JSON representation of the node
       * Both .toJSON() and the static .fromJSON(json) should be implemented by all
       * implementations of Node
       * @returns {Object}
       */
      toJSON() {
        throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
      }
      /**
       * Get HTML representation. (wrapper function)
       *
       * This function can get an object of the following form:
       * {
       *    handler: //This can be a callback function of the form
       *             // "function callback(node, options)" or
       *             // a map that maps function names (used in FunctionNodes)
       *             // to callbacks
       *    parenthesis: "keep" //the parenthesis option (This is optional)
       * }
       *
       * @param {Object} [options]
       * @return {string}
       */
      toHTML(options) {
        var customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this.toHTML(options);
      }
      /**
       * Internal function to generate the string output.
       * This has to be implemented by every Node
       *
       * @throws {Error}
       */
      _toString() {
        throw new Error("_toString not implemented for " + this.type);
      }
      /**
       * Get LaTeX representation. (wrapper function)
       *
       * This function can get an object of the following form:
       * {
       *    handler: //This can be a callback function of the form
       *             // "function callback(node, options)"or
       *             // a map that maps function names (used in FunctionNodes)
       *             // to callbacks
       *    parenthesis: "keep" //the parenthesis option (This is optional)
       * }
       *
       * @param {Object} [options]
       * @return {string}
       */
      toTex(options) {
        var customString = this._getCustomString(options);
        if (typeof customString !== "undefined") {
          return customString;
        }
        return this._toTex(options);
      }
      /**
       * Internal function to generate the LaTeX output.
       * This has to be implemented by every Node
       *
       * @param {Object} [options]
       * @throws {Error}
       */
      _toTex(options) {
        throw new Error("_toTex not implemented for " + this.type);
      }
      /**
       * Helper used by `to...` functions.
       */
      _getCustomString(options) {
        if (options && typeof options === "object") {
          switch (typeof options.handler) {
            case "object":
            case "undefined":
              return;
            case "function":
              return options.handler(this, options);
            default:
              throw new TypeError("Object or function expected as callback");
          }
        }
      }
      /**
       * Get identifier.
       * @return {string}
       */
      getIdentifier() {
        return this.type;
      }
      /**
       * Get the content of the current Node.
       * @return {Node} node
       **/
      getContent() {
        return this;
      }
    }
    return Node2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/utils/errorTransform.js
  function errorTransform(err) {
    if (err && err.isIndexError) {
      return new IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
    }
    return err;
  }

  // node_modules/mathjs/lib/esm/expression/node/utils/access.js
  function accessFactory(_ref) {
    var {
      subset: subset2
    } = _ref;
    return function access(object, index2) {
      try {
        if (Array.isArray(object)) {
          return subset2(object, index2);
        } else if (object && typeof object.subset === "function") {
          return object.subset(index2);
        } else if (typeof object === "string") {
          return subset2(object, index2);
        } else if (typeof object === "object") {
          if (!index2.isObjectProperty()) {
            throw new TypeError("Cannot apply a numeric index as object property");
          }
          return getSafeProperty(object, index2.getObjectProperty());
        } else {
          throw new TypeError("Cannot apply index: unsupported type of object");
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }

  // node_modules/mathjs/lib/esm/expression/node/AccessorNode.js
  var name207 = "AccessorNode";
  var dependencies207 = ["subset", "Node"];
  var createAccessorNode = /* @__PURE__ */ factory(name207, dependencies207, (_ref) => {
    var {
      subset: subset2,
      Node: Node2
    } = _ref;
    var access = accessFactory({
      subset: subset2
    });
    function needParenthesis(node) {
      return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
    }
    class AccessorNode2 extends Node2 {
      /**
       * @constructor AccessorNode
       * @extends {Node}
       * Access an object property or get a matrix subset
       *
       * @param {Node} object                 The object from which to retrieve
       *                                      a property or subset.
       * @param {IndexNode} index             IndexNode containing ranges
       */
      constructor(object, index2) {
        super();
        if (!isNode(object)) {
          throw new TypeError('Node expected for parameter "object"');
        }
        if (!isIndexNode(index2)) {
          throw new TypeError('IndexNode expected for parameter "index"');
        }
        this.object = object;
        this.index = index2;
      }
      // readonly property name
      get name() {
        if (this.index) {
          return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
        } else {
          return this.object.name || "";
        }
      }
      get type() {
        return name207;
      }
      get isAccessorNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var evalObject = this.object._compile(math2, argNames);
        var evalIndex = this.index._compile(math2, argNames);
        if (this.index.isObjectProperty()) {
          var prop = this.index.getObjectProperty();
          return function evalAccessorNode(scope, args, context) {
            return getSafeProperty(evalObject(scope, args, context), prop);
          };
        } else {
          return function evalAccessorNode(scope, args, context) {
            var object = evalObject(scope, args, context);
            var index2 = evalIndex(scope, args, object);
            return access(object, index2);
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.object, "object", this);
        callback(this.index, "index", this);
      }
      /**
       * Create a new AccessorNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {AccessorNode} Returns a transformed copy of the node
       */
      map(callback) {
        return new AccessorNode2(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {AccessorNode}
       */
      clone() {
        return new AccessorNode2(this.object, this.index);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string}
       */
      _toString(options) {
        var object = this.object.toString(options);
        if (needParenthesis(this.object)) {
          object = "(" + object + ")";
        }
        return object + this.index.toString(options);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string}
       */
      toHTML(options) {
        var object = this.object.toHTML(options);
        if (needParenthesis(this.object)) {
          object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return object + this.index.toHTML(options);
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string}
       */
      _toTex(options) {
        var object = this.object.toTex(options);
        if (needParenthesis(this.object)) {
          object = "\\left(' + object + '\\right)";
        }
        return object + this.index.toTex(options);
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name207,
          object: this.object,
          index: this.index
        };
      }
      /**
       * Instantiate an AccessorNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
       *     where mathjs is optional
       * @returns {AccessorNode}
       */
      static fromJSON(json) {
        return new AccessorNode2(json.object, json.index);
      }
    }
    _defineProperty(AccessorNode2, "name", name207);
    return AccessorNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ArrayNode.js
  var name208 = "ArrayNode";
  var dependencies208 = ["Node"];
  var createArrayNode = /* @__PURE__ */ factory(name208, dependencies208, (_ref) => {
    var {
      Node: Node2
    } = _ref;
    class ArrayNode2 extends Node2 {
      /**
       * @constructor ArrayNode
       * @extends {Node}
       * Holds an 1-dimensional array with items
       * @param {Node[]} [items]   1 dimensional array with items
       */
      constructor(items) {
        super();
        this.items = items || [];
        if (!Array.isArray(this.items) || !this.items.every(isNode)) {
          throw new TypeError("Array containing Nodes expected");
        }
      }
      get type() {
        return name208;
      }
      get isArrayNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var evalItems = map(this.items, function(item) {
          return item._compile(math2, argNames);
        });
        var asMatrix = math2.config.matrix !== "Array";
        if (asMatrix) {
          var matrix2 = math2.matrix;
          return function evalArrayNode(scope, args, context) {
            return matrix2(map(evalItems, function(evalItem) {
              return evalItem(scope, args, context);
            }));
          };
        } else {
          return function evalArrayNode(scope, args, context) {
            return map(evalItems, function(evalItem) {
              return evalItem(scope, args, context);
            });
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (var i3 = 0; i3 < this.items.length; i3++) {
          var node = this.items[i3];
          callback(node, "items[" + i3 + "]", this);
        }
      }
      /**
       * Create a new ArrayNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {ArrayNode} Returns a transformed copy of the node
       */
      map(callback) {
        var items = [];
        for (var i3 = 0; i3 < this.items.length; i3++) {
          items[i3] = this._ifNode(callback(this.items[i3], "items[" + i3 + "]", this));
        }
        return new ArrayNode2(items);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ArrayNode}
       */
      clone() {
        return new ArrayNode2(this.items.slice(0));
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(options) {
        var items = this.items.map(function(node) {
          return node.toString(options);
        });
        return "[" + items.join(", ") + "]";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name208,
          items: this.items
        };
      }
      /**
       * Instantiate an ArrayNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "ArrayNode", items: [...]}`,
       *                       where mathjs is optional
       * @returns {ArrayNode}
       */
      static fromJSON(json) {
        return new ArrayNode2(json.items);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      toHTML(options) {
        var items = this.items.map(function(node) {
          return node.toHTML(options);
        });
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        function itemsToTex(items, nested) {
          var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
          var itemsFormRow = nested || mixedItems;
          var itemSep = itemsFormRow ? "&" : "\\\\";
          var itemsTex = items.map(function(node) {
            if (node.items) {
              return itemsToTex(node.items, !nested);
            } else {
              return node.toTex(options);
            }
          }).join(itemSep);
          return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
        }
        return itemsToTex(this.items, false);
      }
    }
    _defineProperty(ArrayNode2, "name", name208);
    return ArrayNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/utils/assign.js
  function assignFactory(_ref) {
    var {
      subset: subset2,
      matrix: matrix2
    } = _ref;
    return function assign2(object, index2, value) {
      try {
        if (Array.isArray(object)) {
          var result = matrix2(object).subset(index2, value).valueOf();
          result.forEach((item, index3) => {
            object[index3] = item;
          });
          return object;
        } else if (object && typeof object.subset === "function") {
          return object.subset(index2, value);
        } else if (typeof object === "string") {
          return subset2(object, index2, value);
        } else if (typeof object === "object") {
          if (!index2.isObjectProperty()) {
            throw TypeError("Cannot apply a numeric index as object property");
          }
          setSafeProperty(object, index2.getObjectProperty(), value);
          return object;
        } else {
          throw new TypeError("Cannot apply index: unsupported type of object");
        }
      } catch (err) {
        throw errorTransform(err);
      }
    };
  }

  // node_modules/mathjs/lib/esm/expression/operators.js
  var properties = [{
    // assignment
    AssignmentNode: {},
    FunctionAssignmentNode: {}
  }, {
    // conditional expression
    ConditionalNode: {
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
      // conditionals don't need parentheses in LaTeX because
      // they are 2 dimensional
    }
  }, {
    // logical or
    "OperatorNode:or": {
      op: "or",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // logical xor
    "OperatorNode:xor": {
      op: "xor",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // logical and
    "OperatorNode:and": {
      op: "and",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // bitwise or
    "OperatorNode:bitOr": {
      op: "|",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // bitwise xor
    "OperatorNode:bitXor": {
      op: "^|",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // bitwise and
    "OperatorNode:bitAnd": {
      op: "&",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // relational operators
    "OperatorNode:equal": {
      op: "==",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:unequal": {
      op: "!=",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:smaller": {
      op: "<",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:larger": {
      op: ">",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:smallerEq": {
      op: "<=",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:largerEq": {
      op: ">=",
      associativity: "left",
      associativeWith: []
    },
    RelationalNode: {
      associativity: "left",
      associativeWith: []
    }
  }, {
    // bitshift operators
    "OperatorNode:leftShift": {
      op: "<<",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:rightArithShift": {
      op: ">>",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:rightLogShift": {
      op: ">>>",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // unit conversion
    "OperatorNode:to": {
      op: "to",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // range
    RangeNode: {}
  }, {
    // addition, subtraction
    "OperatorNode:add": {
      op: "+",
      associativity: "left",
      associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
    },
    "OperatorNode:subtract": {
      op: "-",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // multiply, divide, modulus
    "OperatorNode:multiply": {
      op: "*",
      associativity: "left",
      associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
    },
    "OperatorNode:divide": {
      op: "/",
      associativity: "left",
      associativeWith: [],
      latexLeftParens: false,
      latexRightParens: false,
      latexParens: false
      // fractions don't require parentheses because
      // they're 2 dimensional, so parens aren't needed
      // in LaTeX
    },
    "OperatorNode:dotMultiply": {
      op: ".*",
      associativity: "left",
      associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
    },
    "OperatorNode:dotDivide": {
      op: "./",
      associativity: "left",
      associativeWith: []
    },
    "OperatorNode:mod": {
      op: "mod",
      associativity: "left",
      associativeWith: []
    }
  }, {
    // Repeat multiplication for implicit multiplication
    "OperatorNode:multiply": {
      associativity: "left",
      associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
    }
  }, {
    // unary prefix operators
    "OperatorNode:unaryPlus": {
      op: "+",
      associativity: "right"
    },
    "OperatorNode:unaryMinus": {
      op: "-",
      associativity: "right"
    },
    "OperatorNode:bitNot": {
      op: "~",
      associativity: "right"
    },
    "OperatorNode:not": {
      op: "not",
      associativity: "right"
    }
  }, {
    // exponentiation
    "OperatorNode:pow": {
      op: "^",
      associativity: "right",
      associativeWith: [],
      latexRightParens: false
      // the exponent doesn't need parentheses in
      // LaTeX because it's 2 dimensional
      // (it's on top)
    },
    "OperatorNode:dotPow": {
      op: ".^",
      associativity: "right",
      associativeWith: []
    }
  }, {
    // factorial
    "OperatorNode:factorial": {
      op: "!",
      associativity: "left"
    }
  }, {
    // matrix transpose
    "OperatorNode:ctranspose": {
      op: "'",
      associativity: "left"
    }
  }];
  function unwrapParen(_node, parenthesis) {
    if (!parenthesis || parenthesis !== "auto")
      return _node;
    var node = _node;
    while (isParenthesisNode(node))
      node = node.content;
    return node;
  }
  function getPrecedence(_node, parenthesis, implicit, parent) {
    var node = _node;
    if (parenthesis !== "keep") {
      node = _node.getContent();
    }
    var identifier = node.getIdentifier();
    var precedence = null;
    for (var i3 = 0; i3 < properties.length; i3++) {
      if (identifier in properties[i3]) {
        precedence = i3;
        break;
      }
    }
    if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
      var leftArg = unwrapParen(node.args[0], parenthesis);
      if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
        precedence += 1;
      }
    }
    return precedence;
  }
  function getAssociativity(_node, parenthesis) {
    var node = _node;
    if (parenthesis !== "keep") {
      node = _node.getContent();
    }
    var identifier = node.getIdentifier();
    var index2 = getPrecedence(node, parenthesis);
    if (index2 === null) {
      return null;
    }
    var property = properties[index2][identifier];
    if (hasOwnProperty(property, "associativity")) {
      if (property.associativity === "left") {
        return "left";
      }
      if (property.associativity === "right") {
        return "right";
      }
      throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
    }
    return null;
  }
  function isAssociativeWith(nodeA, nodeB, parenthesis) {
    var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
    var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
    var identifierA = a.getIdentifier();
    var identifierB = b.getIdentifier();
    var index2 = getPrecedence(a, parenthesis);
    if (index2 === null) {
      return null;
    }
    var property = properties[index2][identifierA];
    if (hasOwnProperty(property, "associativeWith") && property.associativeWith instanceof Array) {
      for (var i3 = 0; i3 < property.associativeWith.length; i3++) {
        if (property.associativeWith[i3] === identifierB) {
          return true;
        }
      }
      return false;
    }
    return null;
  }
  function getOperator(fn) {
    var identifier = "OperatorNode:" + fn;
    for (var group of properties) {
      if (identifier in group) {
        return group[identifier].op;
      }
    }
    return null;
  }

  // node_modules/mathjs/lib/esm/expression/node/AssignmentNode.js
  var name209 = "AssignmentNode";
  var dependencies209 = [
    "subset",
    "?matrix",
    // FIXME: should not be needed at all, should be handled by subset
    "Node"
  ];
  var createAssignmentNode = /* @__PURE__ */ factory(name209, dependencies209, (_ref) => {
    var {
      subset: subset2,
      matrix: matrix2,
      Node: Node2
    } = _ref;
    var access = accessFactory({
      subset: subset2
    });
    var assign2 = assignFactory({
      subset: subset2,
      matrix: matrix2
    });
    function needParenthesis(node, parenthesis, implicit) {
      if (!parenthesis) {
        parenthesis = "keep";
      }
      var precedence = getPrecedence(node, parenthesis, implicit);
      var exprPrecedence = getPrecedence(node.value, parenthesis, implicit);
      return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    class AssignmentNode2 extends Node2 {
      /**
       * @constructor AssignmentNode
       * @extends {Node}
       *
       * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
       * replace a subset of a matrix like `A[2,2]=42`.
       *
       * Syntax:
       *
       *     new AssignmentNode(symbol, value)
       *     new AssignmentNode(object, index, value)
       *
       * Usage:
       *
       *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
       *    new AssignmentNode(new SymbolNode('a'),
       *                       new IndexNode('b'),
       *                       new ConstantNode(2))   // a.b=2
       *    new AssignmentNode(new SymbolNode('a'),
       *                       new IndexNode(1, 2),
       *                       new ConstantNode(3))  // a[1,2]=3
       *
       * @param {SymbolNode | AccessorNode} object
       *     Object on which to assign a value
       * @param {IndexNode} [index=null]
       *     Index, property name or matrix index. Optional. If not provided
       *     and `object` is a SymbolNode, the property is assigned to the
       *     global scope.
       * @param {Node} value
       *     The value to be assigned
       */
      constructor(object, index2, value) {
        super();
        this.object = object;
        this.index = value ? index2 : null;
        this.value = value || index2;
        if (!isSymbolNode(object) && !isAccessorNode(object)) {
          throw new TypeError('SymbolNode or AccessorNode expected as "object"');
        }
        if (isSymbolNode(object) && object.name === "end") {
          throw new Error('Cannot assign to symbol "end"');
        }
        if (this.index && !isIndexNode(this.index)) {
          throw new TypeError('IndexNode expected as "index"');
        }
        if (!isNode(this.value)) {
          throw new TypeError('Node expected as "value"');
        }
      }
      // class name for typing purposes:
      // readonly property name
      get name() {
        if (this.index) {
          return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
        } else {
          return this.object.name || "";
        }
      }
      get type() {
        return name209;
      }
      get isAssignmentNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var evalObject = this.object._compile(math2, argNames);
        var evalIndex = this.index ? this.index._compile(math2, argNames) : null;
        var evalValue = this.value._compile(math2, argNames);
        var name310 = this.object.name;
        if (!this.index) {
          if (!isSymbolNode(this.object)) {
            throw new TypeError("SymbolNode expected as object");
          }
          return function evalAssignmentNode(scope, args, context) {
            var value = evalValue(scope, args, context);
            scope.set(name310, value);
            return value;
          };
        } else if (this.index.isObjectProperty()) {
          var prop = this.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var object = evalObject(scope, args, context);
            var value = evalValue(scope, args, context);
            setSafeProperty(object, prop, value);
            return value;
          };
        } else if (isSymbolNode(this.object)) {
          return function evalAssignmentNode(scope, args, context) {
            var childObject = evalObject(scope, args, context);
            var value = evalValue(scope, args, context);
            var index2 = evalIndex(scope, args, childObject);
            scope.set(name310, assign2(childObject, index2, value));
            return value;
          };
        } else {
          var evalParentObject = this.object.object._compile(math2, argNames);
          if (this.object.index.isObjectProperty()) {
            var parentProp = this.object.index.getObjectProperty();
            return function evalAssignmentNode(scope, args, context) {
              var parent = evalParentObject(scope, args, context);
              var childObject = getSafeProperty(parent, parentProp);
              var index2 = evalIndex(scope, args, childObject);
              var value = evalValue(scope, args, context);
              setSafeProperty(parent, parentProp, assign2(childObject, index2, value));
              return value;
            };
          } else {
            var evalParentIndex = this.object.index._compile(math2, argNames);
            return function evalAssignmentNode(scope, args, context) {
              var parent = evalParentObject(scope, args, context);
              var parentIndex = evalParentIndex(scope, args, parent);
              var childObject = access(parent, parentIndex);
              var index2 = evalIndex(scope, args, childObject);
              var value = evalValue(scope, args, context);
              assign2(parent, parentIndex, assign2(childObject, index2, value));
              return value;
            };
          }
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.object, "object", this);
        if (this.index) {
          callback(this.index, "index", this);
        }
        callback(this.value, "value", this);
      }
      /**
       * Create a new AssignmentNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {AssignmentNode} Returns a transformed copy of the node
       */
      map(callback) {
        var object = this._ifNode(callback(this.object, "object", this));
        var index2 = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
        var value = this._ifNode(callback(this.value, "value", this));
        return new AssignmentNode2(object, index2, value);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {AssignmentNode}
       */
      clone() {
        return new AssignmentNode2(this.object, this.index, this.value);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string}
       */
      _toString(options) {
        var object = this.object.toString(options);
        var index2 = this.index ? this.index.toString(options) : "";
        var value = this.value.toString(options);
        if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
          value = "(" + value + ")";
        }
        return object + index2 + " = " + value;
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name209,
          object: this.object,
          index: this.index,
          value: this.value
        };
      }
      /**
       * Instantiate an AssignmentNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
       *     where mathjs is optional
       * @returns {AssignmentNode}
       */
      static fromJSON(json) {
        return new AssignmentNode2(json.object, json.index, json.value);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string}
       */
      toHTML(options) {
        var object = this.object.toHTML(options);
        var index2 = this.index ? this.index.toHTML(options) : "";
        var value = this.value.toHTML(options);
        if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
          value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
        return object + index2 + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string}
       */
      _toTex(options) {
        var object = this.object.toTex(options);
        var index2 = this.index ? this.index.toTex(options) : "";
        var value = this.value.toTex(options);
        if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
          value = "\\left(".concat(value, "\\right)");
        }
        return object + index2 + "=" + value;
      }
    }
    _defineProperty(AssignmentNode2, "name", name209);
    return AssignmentNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/BlockNode.js
  var name210 = "BlockNode";
  var dependencies210 = ["ResultSet", "Node"];
  var createBlockNode = /* @__PURE__ */ factory(name210, dependencies210, (_ref) => {
    var {
      ResultSet: ResultSet2,
      Node: Node2
    } = _ref;
    class BlockNode2 extends Node2 {
      /**
       * @constructor BlockNode
       * @extends {Node}
       * Holds a set with blocks
       * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
       *            An array with blocks, where a block is constructed as an
       *            Object with properties block, which is a Node, and visible,
       *            which is a boolean. The property visible is optional and
       *            is true by default
       */
      constructor(blocks) {
        super();
        if (!Array.isArray(blocks))
          throw new Error("Array expected");
        this.blocks = blocks.map(function(block) {
          var node = block && block.node;
          var visible = block && block.visible !== void 0 ? block.visible : true;
          if (!isNode(node))
            throw new TypeError('Property "node" must be a Node');
          if (typeof visible !== "boolean") {
            throw new TypeError('Property "visible" must be a boolean');
          }
          return {
            node,
            visible
          };
        });
      }
      get type() {
        return name210;
      }
      get isBlockNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var evalBlocks = map(this.blocks, function(block) {
          return {
            evaluate: block.node._compile(math2, argNames),
            visible: block.visible
          };
        });
        return function evalBlockNodes(scope, args, context) {
          var results = [];
          forEach(evalBlocks, function evalBlockNode(block) {
            var result = block.evaluate(scope, args, context);
            if (block.visible) {
              results.push(result);
            }
          });
          return new ResultSet2(results);
        };
      }
      /**
       * Execute a callback for each of the child blocks of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (var i3 = 0; i3 < this.blocks.length; i3++) {
          callback(this.blocks[i3].node, "blocks[" + i3 + "].node", this);
        }
      }
      /**
       * Create a new BlockNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {BlockNode} Returns a transformed copy of the node
       */
      map(callback) {
        var blocks = [];
        for (var i3 = 0; i3 < this.blocks.length; i3++) {
          var block = this.blocks[i3];
          var node = this._ifNode(callback(block.node, "blocks[" + i3 + "].node", this));
          blocks[i3] = {
            node,
            visible: block.visible
          };
        }
        return new BlockNode2(blocks);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {BlockNode}
       */
      clone() {
        var blocks = this.blocks.map(function(block) {
          return {
            node: block.node,
            visible: block.visible
          };
        });
        return new BlockNode2(blocks);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(options) {
        return this.blocks.map(function(param) {
          return param.node.toString(options) + (param.visible ? "" : ";");
        }).join("\n");
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name210,
          blocks: this.blocks
        };
      }
      /**
       * Instantiate an BlockNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
       *     where mathjs is optional
       * @returns {BlockNode}
       */
      static fromJSON(json) {
        return new BlockNode2(json.blocks);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      toHTML(options) {
        return this.blocks.map(function(param) {
          return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
        }).join('<span class="math-separator"><br /></span>');
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        return this.blocks.map(function(param) {
          return param.node.toTex(options) + (param.visible ? "" : ";");
        }).join("\\;\\;\n");
      }
    }
    _defineProperty(BlockNode2, "name", name210);
    return BlockNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ConditionalNode.js
  var name211 = "ConditionalNode";
  var dependencies211 = ["Node"];
  var createConditionalNode = /* @__PURE__ */ factory(name211, dependencies211, (_ref) => {
    var {
      Node: Node2
    } = _ref;
    function testCondition(condition) {
      if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
        return !!condition;
      }
      if (condition) {
        if (isBigNumber(condition)) {
          return !condition.isZero();
        }
        if (isComplex(condition)) {
          return !!(condition.re || condition.im);
        }
        if (isUnit(condition)) {
          return !!condition.value;
        }
      }
      if (condition === null || condition === void 0) {
        return false;
      }
      throw new TypeError('Unsupported type of condition "' + typeOf(condition) + '"');
    }
    class ConditionalNode2 extends Node2 {
      /**
       * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
       *
       * @param {Node} condition   Condition, must result in a boolean
       * @param {Node} trueExpr    Expression evaluated when condition is true
       * @param {Node} falseExpr   Expression evaluated when condition is true
       *
       * @constructor ConditionalNode
       * @extends {Node}
       */
      constructor(condition, trueExpr, falseExpr) {
        super();
        if (!isNode(condition)) {
          throw new TypeError("Parameter condition must be a Node");
        }
        if (!isNode(trueExpr)) {
          throw new TypeError("Parameter trueExpr must be a Node");
        }
        if (!isNode(falseExpr)) {
          throw new TypeError("Parameter falseExpr must be a Node");
        }
        this.condition = condition;
        this.trueExpr = trueExpr;
        this.falseExpr = falseExpr;
      }
      get type() {
        return name211;
      }
      get isConditionalNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var evalCondition = this.condition._compile(math2, argNames);
        var evalTrueExpr = this.trueExpr._compile(math2, argNames);
        var evalFalseExpr = this.falseExpr._compile(math2, argNames);
        return function evalConditionalNode(scope, args, context) {
          return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.condition, "condition", this);
        callback(this.trueExpr, "trueExpr", this);
        callback(this.falseExpr, "falseExpr", this);
      }
      /**
       * Create a new ConditionalNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {ConditionalNode} Returns a transformed copy of the node
       */
      map(callback) {
        return new ConditionalNode2(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ConditionalNode}
       */
      clone() {
        return new ConditionalNode2(this.condition, this.trueExpr, this.falseExpr);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var condition = this.condition.toString(options);
        var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
          condition = "(" + condition + ")";
        }
        var trueExpr = this.trueExpr.toString(options);
        var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
          trueExpr = "(" + trueExpr + ")";
        }
        var falseExpr = this.falseExpr.toString(options);
        var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
          falseExpr = "(" + falseExpr + ")";
        }
        return condition + " ? " + trueExpr + " : " + falseExpr;
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name211,
          condition: this.condition,
          trueExpr: this.trueExpr,
          falseExpr: this.falseExpr
        };
      }
      /**
       * Instantiate an ConditionalNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     ```
       *     {"mathjs": "ConditionalNode",
       *      "condition": ...,
       *      "trueExpr": ...,
       *      "falseExpr": ...}
       *     ```
       *     where mathjs is optional
       * @returns {ConditionalNode}
       */
      static fromJSON(json) {
        return new ConditionalNode2(json.condition, json.trueExpr, json.falseExpr);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var condition = this.condition.toHTML(options);
        var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
          condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        var trueExpr = this.trueExpr.toHTML(options);
        var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
          trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        var falseExpr = this.falseExpr.toHTML(options);
        var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
        if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
          falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
      }
    }
    _defineProperty(ConditionalNode2, "name", name211);
    return ConditionalNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/utils/latex.js
  var import_escape_latex = __toESM(require_dist(), 1);
  var latexSymbols = {
    // GREEK LETTERS
    Alpha: "A",
    alpha: "\\alpha",
    Beta: "B",
    beta: "\\beta",
    Gamma: "\\Gamma",
    gamma: "\\gamma",
    Delta: "\\Delta",
    delta: "\\delta",
    Epsilon: "E",
    epsilon: "\\epsilon",
    varepsilon: "\\varepsilon",
    Zeta: "Z",
    zeta: "\\zeta",
    Eta: "H",
    eta: "\\eta",
    Theta: "\\Theta",
    theta: "\\theta",
    vartheta: "\\vartheta",
    Iota: "I",
    iota: "\\iota",
    Kappa: "K",
    kappa: "\\kappa",
    varkappa: "\\varkappa",
    Lambda: "\\Lambda",
    lambda: "\\lambda",
    Mu: "M",
    mu: "\\mu",
    Nu: "N",
    nu: "\\nu",
    Xi: "\\Xi",
    xi: "\\xi",
    Omicron: "O",
    omicron: "o",
    Pi: "\\Pi",
    pi: "\\pi",
    varpi: "\\varpi",
    Rho: "P",
    rho: "\\rho",
    varrho: "\\varrho",
    Sigma: "\\Sigma",
    sigma: "\\sigma",
    varsigma: "\\varsigma",
    Tau: "T",
    tau: "\\tau",
    Upsilon: "\\Upsilon",
    upsilon: "\\upsilon",
    Phi: "\\Phi",
    phi: "\\phi",
    varphi: "\\varphi",
    Chi: "X",
    chi: "\\chi",
    Psi: "\\Psi",
    psi: "\\psi",
    Omega: "\\Omega",
    omega: "\\omega",
    // logic
    true: "\\mathrm{True}",
    false: "\\mathrm{False}",
    // other
    i: "i",
    // TODO use \i ??
    inf: "\\infty",
    Inf: "\\infty",
    infinity: "\\infty",
    Infinity: "\\infty",
    oo: "\\infty",
    lim: "\\lim",
    undefined: "\\mathbf{?}"
  };
  var latexOperators = {
    transpose: "^\\top",
    ctranspose: "^H",
    factorial: "!",
    pow: "^",
    dotPow: ".^\\wedge",
    // TODO find ideal solution
    unaryPlus: "+",
    unaryMinus: "-",
    bitNot: "\\~",
    // TODO find ideal solution
    not: "\\neg",
    multiply: "\\cdot",
    divide: "\\frac",
    // TODO how to handle that properly?
    dotMultiply: ".\\cdot",
    // TODO find ideal solution
    dotDivide: ".:",
    // TODO find ideal solution
    mod: "\\mod",
    add: "+",
    subtract: "-",
    to: "\\rightarrow",
    leftShift: "<<",
    rightArithShift: ">>",
    rightLogShift: ">>>",
    equal: "=",
    unequal: "\\neq",
    smaller: "<",
    larger: ">",
    smallerEq: "\\leq",
    largerEq: "\\geq",
    bitAnd: "\\&",
    bitXor: "\\underline{|}",
    bitOr: "|",
    and: "\\wedge",
    xor: "\\veebar",
    or: "\\vee"
  };
  var latexFunctions = {
    // arithmetic
    abs: {
      1: "\\left|${args[0]}\\right|"
    },
    add: {
      2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
    },
    cbrt: {
      1: "\\sqrt[3]{${args[0]}}"
    },
    ceil: {
      1: "\\left\\lceil${args[0]}\\right\\rceil"
    },
    cube: {
      1: "\\left(${args[0]}\\right)^3"
    },
    divide: {
      2: "\\frac{${args[0]}}{${args[1]}}"
    },
    dotDivide: {
      2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
    },
    dotMultiply: {
      2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
    },
    dotPow: {
      2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
    },
    exp: {
      1: "\\exp\\left(${args[0]}\\right)"
    },
    expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
    fix: {
      1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
    },
    floor: {
      1: "\\left\\lfloor${args[0]}\\right\\rfloor"
    },
    gcd: "\\gcd\\left(${args}\\right)",
    hypot: "\\hypot\\left(${args}\\right)",
    log: {
      1: "\\ln\\left(${args[0]}\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
    },
    log10: {
      1: "\\log_{10}\\left(${args[0]}\\right)"
    },
    log1p: {
      1: "\\ln\\left(${args[0]}+1\\right)",
      2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
    },
    log2: "\\log_{2}\\left(${args[0]}\\right)",
    mod: {
      2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
    },
    multiply: {
      2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
    },
    norm: {
      1: "\\left\\|${args[0]}\\right\\|",
      2: void 0
      // use default template
    },
    nthRoot: {
      2: "\\sqrt[${args[1]}]{${args[0]}}"
    },
    nthRoots: {
      2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
    },
    pow: {
      2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
    },
    round: {
      1: "\\left\\lfloor${args[0]}\\right\\rceil",
      2: void 0
      // use default template
    },
    sign: {
      1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
    },
    sqrt: {
      1: "\\sqrt{${args[0]}}"
    },
    square: {
      1: "\\left(${args[0]}\\right)^2"
    },
    subtract: {
      2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
    },
    unaryMinus: {
      1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
    },
    unaryPlus: {
      1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
    },
    // bitwise
    bitAnd: {
      2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
    },
    bitNot: {
      1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
    },
    bitOr: {
      2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
    },
    bitXor: {
      2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
    },
    leftShift: {
      2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
    },
    rightArithShift: {
      2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
    },
    rightLogShift: {
      2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
    },
    // combinatorics
    bellNumbers: {
      1: "\\mathrm{B}_{${args[0]}}"
    },
    catalan: {
      1: "\\mathrm{C}_{${args[0]}}"
    },
    stirlingS2: {
      2: "\\mathrm{S}\\left(${args}\\right)"
    },
    // complex
    arg: {
      1: "\\arg\\left(${args[0]}\\right)"
    },
    conj: {
      1: "\\left(${args[0]}\\right)^*"
    },
    im: {
      1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
    },
    re: {
      1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
    },
    // logical
    and: {
      2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
    },
    not: {
      1: latexOperators.not + "\\left(${args[0]}\\right)"
    },
    or: {
      2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
    },
    xor: {
      2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
    },
    // matrix
    cross: {
      2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
    },
    ctranspose: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
    },
    det: {
      1: "\\det\\left(${args[0]}\\right)"
    },
    dot: {
      2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
    },
    expm: {
      1: "\\exp\\left(${args[0]}\\right)"
    },
    inv: {
      1: "\\left(${args[0]}\\right)^{-1}"
    },
    pinv: {
      1: "\\left(${args[0]}\\right)^{+}"
    },
    sqrtm: {
      1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
    },
    trace: {
      1: "\\mathrm{tr}\\left(${args[0]}\\right)"
    },
    transpose: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
    },
    // probability
    combinations: {
      2: "\\binom{${args[0]}}{${args[1]}}"
    },
    combinationsWithRep: {
      2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
    },
    factorial: {
      1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
    },
    gamma: {
      1: "\\Gamma\\left(${args[0]}\\right)"
    },
    lgamma: {
      1: "\\ln\\Gamma\\left(${args[0]}\\right)"
    },
    // relational
    equal: {
      2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
    },
    larger: {
      2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
    },
    largerEq: {
      2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
    },
    smaller: {
      2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
    },
    smallerEq: {
      2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
    },
    unequal: {
      2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
    },
    // special
    erf: {
      1: "erf\\left(${args[0]}\\right)"
    },
    // statistics
    max: "\\max\\left(${args}\\right)",
    min: "\\min\\left(${args}\\right)",
    variance: "\\mathrm{Var}\\left(${args}\\right)",
    // trigonometry
    acos: {
      1: "\\cos^{-1}\\left(${args[0]}\\right)"
    },
    acosh: {
      1: "\\cosh^{-1}\\left(${args[0]}\\right)"
    },
    acot: {
      1: "\\cot^{-1}\\left(${args[0]}\\right)"
    },
    acoth: {
      1: "\\coth^{-1}\\left(${args[0]}\\right)"
    },
    acsc: {
      1: "\\csc^{-1}\\left(${args[0]}\\right)"
    },
    acsch: {
      1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
    },
    asec: {
      1: "\\sec^{-1}\\left(${args[0]}\\right)"
    },
    asech: {
      1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
    },
    asin: {
      1: "\\sin^{-1}\\left(${args[0]}\\right)"
    },
    asinh: {
      1: "\\sinh^{-1}\\left(${args[0]}\\right)"
    },
    atan: {
      1: "\\tan^{-1}\\left(${args[0]}\\right)"
    },
    atan2: {
      2: "\\mathrm{atan2}\\left(${args}\\right)"
    },
    atanh: {
      1: "\\tanh^{-1}\\left(${args[0]}\\right)"
    },
    cos: {
      1: "\\cos\\left(${args[0]}\\right)"
    },
    cosh: {
      1: "\\cosh\\left(${args[0]}\\right)"
    },
    cot: {
      1: "\\cot\\left(${args[0]}\\right)"
    },
    coth: {
      1: "\\coth\\left(${args[0]}\\right)"
    },
    csc: {
      1: "\\csc\\left(${args[0]}\\right)"
    },
    csch: {
      1: "\\mathrm{csch}\\left(${args[0]}\\right)"
    },
    sec: {
      1: "\\sec\\left(${args[0]}\\right)"
    },
    sech: {
      1: "\\mathrm{sech}\\left(${args[0]}\\right)"
    },
    sin: {
      1: "\\sin\\left(${args[0]}\\right)"
    },
    sinh: {
      1: "\\sinh\\left(${args[0]}\\right)"
    },
    tan: {
      1: "\\tan\\left(${args[0]}\\right)"
    },
    tanh: {
      1: "\\tanh\\left(${args[0]}\\right)"
    },
    // unit
    to: {
      2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
    },
    // utils
    numeric: function numeric(node, options) {
      return node.args[0].toTex();
    },
    // type
    number: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
    },
    string: {
      0: '\\mathtt{""}',
      1: "\\mathrm{string}\\left(${args[0]}\\right)"
    },
    bignumber: {
      0: "0",
      1: "\\left(${args[0]}\\right)"
    },
    complex: {
      0: "0",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
    },
    matrix: {
      0: "\\begin{bmatrix}\\end{bmatrix}",
      1: "\\left(${args[0]}\\right)",
      2: "\\left(${args[0]}\\right)"
    },
    sparse: {
      0: "\\begin{bsparse}\\end{bsparse}",
      1: "\\left(${args[0]}\\right)"
    },
    unit: {
      1: "\\left(${args[0]}\\right)",
      2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
    }
  };
  var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
  var latexUnits = {
    deg: "^\\circ"
  };
  function escapeLatex(string2) {
    return (0, import_escape_latex.default)(string2, {
      preserveFormatting: true
    });
  }
  function toSymbol(name310, isUnit2) {
    isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
    if (isUnit2) {
      if (hasOwnProperty(latexUnits, name310)) {
        return latexUnits[name310];
      }
      return "\\mathrm{" + escapeLatex(name310) + "}";
    }
    if (hasOwnProperty(latexSymbols, name310)) {
      return latexSymbols[name310];
    }
    return escapeLatex(name310);
  }

  // node_modules/mathjs/lib/esm/expression/node/ConstantNode.js
  var name212 = "ConstantNode";
  var dependencies212 = ["Node"];
  var createConstantNode = /* @__PURE__ */ factory(name212, dependencies212, (_ref) => {
    var {
      Node: Node2
    } = _ref;
    class ConstantNode2 extends Node2 {
      /**
       * A ConstantNode holds a constant value like a number or string.
       *
       * Usage:
       *
       *     new ConstantNode(2.3)
       *     new ConstantNode('hello')
       *
       * @param {*} value    Value can be any type (number, BigNumber, string, ...)
       * @constructor ConstantNode
       * @extends {Node}
       */
      constructor(value) {
        super();
        this.value = value;
      }
      get type() {
        return name212;
      }
      get isConstantNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var value = this.value;
        return function evalConstantNode() {
          return value;
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
      }
      /**
       * Create a new ConstantNode with children produced by the given callback.
       * Trivial because there are no children.
       * @param {function(child: Node, path: string, parent: Node) : Node} callback
       * @returns {ConstantNode} Returns a clone of the node
       */
      map(callback) {
        return this.clone();
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ConstantNode}
       */
      clone() {
        return new ConstantNode2(this.value);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        return format3(this.value, options);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      toHTML(options) {
        var value = this._toString(options);
        switch (typeOf(this.value)) {
          case "number":
          case "BigNumber":
          case "Fraction":
            return '<span class="math-number">' + value + "</span>";
          case "string":
            return '<span class="math-string">' + value + "</span>";
          case "boolean":
            return '<span class="math-boolean">' + value + "</span>";
          case "null":
            return '<span class="math-null-symbol">' + value + "</span>";
          case "undefined":
            return '<span class="math-undefined">' + value + "</span>";
          default:
            return '<span class="math-symbol">' + value + "</span>";
        }
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name212,
          value: this.value
        };
      }
      /**
       * Instantiate a ConstantNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "SymbolNode", value: 2.3}`,
       *                       where mathjs is optional
       * @returns {ConstantNode}
       */
      static fromJSON(json) {
        return new ConstantNode2(json.value);
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        var value = this._toString(options);
        switch (typeOf(this.value)) {
          case "string":
            return "\\mathtt{" + escapeLatex(value) + "}";
          case "number":
          case "BigNumber":
            {
              if (!isFinite(this.value)) {
                return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
              }
              var index2 = value.toLowerCase().indexOf("e");
              if (index2 !== -1) {
                return value.substring(0, index2) + "\\cdot10^{" + value.substring(index2 + 1) + "}";
              }
            }
            return value;
          case "Fraction":
            return this.value.toLatex();
          default:
            return value;
        }
      }
    }
    _defineProperty(ConstantNode2, "name", name212);
    return ConstantNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/FunctionAssignmentNode.js
  var name213 = "FunctionAssignmentNode";
  var dependencies213 = ["typed", "Node"];
  var createFunctionAssignmentNode = /* @__PURE__ */ factory(name213, dependencies213, (_ref) => {
    var {
      typed: typed3,
      Node: Node2
    } = _ref;
    function needParenthesis(node, parenthesis, implicit) {
      var precedence = getPrecedence(node, parenthesis, implicit);
      var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);
      return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
    }
    class FunctionAssignmentNode2 extends Node2 {
      /**
       * @constructor FunctionAssignmentNode
       * @extends {Node}
       * Function assignment
       *
       * @param {string} name           Function name
       * @param {string[] | Array.<{name: string, type: string}>} params
       *                                Array with function parameter names, or an
       *                                array with objects containing the name
       *                                and type of the parameter
       * @param {Node} expr             The function expression
       */
      constructor(name310, params, expr) {
        super();
        if (typeof name310 !== "string") {
          throw new TypeError('String expected for parameter "name"');
        }
        if (!Array.isArray(params)) {
          throw new TypeError('Array containing strings or objects expected for parameter "params"');
        }
        if (!isNode(expr)) {
          throw new TypeError('Node expected for parameter "expr"');
        }
        if (keywords.has(name310)) {
          throw new Error('Illegal function name, "' + name310 + '" is a reserved keyword');
        }
        var paramNames = /* @__PURE__ */ new Set();
        for (var param of params) {
          var _name = typeof param === "string" ? param : param.name;
          if (paramNames.has(_name)) {
            throw new Error('Duplicate parameter name "'.concat(_name, '"'));
          } else {
            paramNames.add(_name);
          }
        }
        this.name = name310;
        this.params = params.map(function(param2) {
          return param2 && param2.name || param2;
        });
        this.types = params.map(function(param2) {
          return param2 && param2.type || "any";
        });
        this.expr = expr;
      }
      get type() {
        return name213;
      }
      get isFunctionAssignmentNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var childArgNames = Object.create(argNames);
        forEach(this.params, function(param) {
          childArgNames[param] = true;
        });
        var evalExpr = this.expr._compile(math2, childArgNames);
        var name310 = this.name;
        var params = this.params;
        var signature = join(this.types, ",");
        var syntax = name310 + "(" + join(this.params, ", ") + ")";
        return function evalFunctionAssignmentNode(scope, args, context) {
          var signatures = {};
          signatures[signature] = function() {
            var childArgs = Object.create(args);
            for (var i3 = 0; i3 < params.length; i3++) {
              childArgs[params[i3]] = arguments[i3];
            }
            return evalExpr(scope, childArgs, context);
          };
          var fn = typed3(name310, signatures);
          fn.syntax = syntax;
          scope.set(name310, fn);
          return fn;
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.expr, "expr", this);
      }
      /**
       * Create a new FunctionAssignmentNode whose children are the results of
       * calling the provided callback function for each child of the original
       * node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
       */
      map(callback) {
        var expr = this._ifNode(callback(this.expr, "expr", this));
        return new FunctionAssignmentNode2(this.name, this.params.slice(0), expr);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {FunctionAssignmentNode}
       */
      clone() {
        return new FunctionAssignmentNode2(this.name, this.params.slice(0), this.expr);
      }
      /**
       * get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var expr = this.expr.toString(options);
        if (needParenthesis(this, parenthesis, options && options.implicit)) {
          expr = "(" + expr + ")";
        }
        return this.name + "(" + this.params.join(", ") + ") = " + expr;
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        var types = this.types;
        return {
          mathjs: name213,
          name: this.name,
          params: this.params.map(function(param, index2) {
            return {
              name: param,
              type: types[index2]
            };
          }),
          expr: this.expr
        };
      }
      /**
       * Instantiate an FunctionAssignmentNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     ```
       *     {"mathjs": "FunctionAssignmentNode",
       *      name: ..., params: ..., expr: ...}
       *     ```
       *     where mathjs is optional
       * @returns {FunctionAssignmentNode}
       */
      static fromJSON(json) {
        return new FunctionAssignmentNode2(json.name, json.params, json.expr);
      }
      /**
       * get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var params = [];
        for (var i3 = 0; i3 < this.params.length; i3++) {
          params.push('<span class="math-symbol math-parameter">' + escape(this.params[i3]) + "</span>");
        }
        var expr = this.expr.toHTML(options);
        if (needParenthesis(this, parenthesis, options && options.implicit)) {
          expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return '<span class="math-function">' + escape(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
      }
      /**
       * get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var expr = this.expr.toTex(options);
        if (needParenthesis(this, parenthesis, options && options.implicit)) {
          expr = "\\left(".concat(expr, "\\right)");
        }
        return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right)=" + expr;
      }
    }
    _defineProperty(FunctionAssignmentNode2, "name", name213);
    return FunctionAssignmentNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/IndexNode.js
  var name214 = "IndexNode";
  var dependencies214 = ["Node", "size"];
  var createIndexNode = /* @__PURE__ */ factory(name214, dependencies214, (_ref) => {
    var {
      Node: Node2,
      size: size2
    } = _ref;
    class IndexNode2 extends Node2 {
      /**
       * @constructor IndexNode
       * @extends Node
       *
       * Describes a subset of a matrix or an object property.
       * Cannot be used on its own, needs to be used within an AccessorNode or
       * AssignmentNode.
       *
       * @param {Node[]} dimensions
       * @param {boolean} [dotNotation=false]
       *     Optional property describing whether this index was written using dot
       *     notation like `a.b`, or using bracket notation like `a["b"]`
       *     (which is the default). This property is used for string conversion.
       */
      constructor(dimensions, dotNotation) {
        super();
        this.dimensions = dimensions;
        this.dotNotation = dotNotation || false;
        if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
          throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
        }
        if (this.dotNotation && !this.isObjectProperty()) {
          throw new Error("dotNotation only applicable for object properties");
        }
      }
      get type() {
        return name214;
      }
      get isIndexNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var evalDimensions = map(this.dimensions, function(dimension, i3) {
          var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
          if (needsEnd) {
            var childArgNames = Object.create(argNames);
            childArgNames.end = true;
            var _evalDimension = dimension._compile(math2, childArgNames);
            return function evalDimension(scope, args, context) {
              if (!isMatrix(context) && !isArray(context) && !isString(context)) {
                throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + typeOf(context));
              }
              var s = size2(context).valueOf();
              var childArgs = Object.create(args);
              childArgs.end = s[i3];
              return _evalDimension(scope, childArgs, context);
            };
          } else {
            return dimension._compile(math2, argNames);
          }
        });
        var index2 = getSafeProperty(math2, "index");
        return function evalIndexNode(scope, args, context) {
          var dimensions = map(evalDimensions, function(evalDimension) {
            return evalDimension(scope, args, context);
          });
          return index2(...dimensions);
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (var i3 = 0; i3 < this.dimensions.length; i3++) {
          callback(this.dimensions[i3], "dimensions[" + i3 + "]", this);
        }
      }
      /**
       * Create a new IndexNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {IndexNode} Returns a transformed copy of the node
       */
      map(callback) {
        var dimensions = [];
        for (var i3 = 0; i3 < this.dimensions.length; i3++) {
          dimensions[i3] = this._ifNode(callback(this.dimensions[i3], "dimensions[" + i3 + "]", this));
        }
        return new IndexNode2(dimensions, this.dotNotation);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {IndexNode}
       */
      clone() {
        return new IndexNode2(this.dimensions.slice(0), this.dotNotation);
      }
      /**
       * Test whether this IndexNode contains a single property name
       * @return {boolean}
       */
      isObjectProperty() {
        return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
      }
      /**
       * Returns the property name if IndexNode contains a property.
       * If not, returns null.
       * @return {string | null}
       */
      getObjectProperty() {
        return this.isObjectProperty() ? this.dimensions[0].value : null;
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name214,
          dimensions: this.dimensions,
          dotNotation: this.dotNotation
        };
      }
      /**
       * Instantiate an IndexNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
       *     where mathjs is optional
       * @returns {IndexNode}
       */
      static fromJSON(json) {
        return new IndexNode2(json.dimensions, json.dotNotation);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      toHTML(options) {
        var dimensions = [];
        for (var i3 = 0; i3 < this.dimensions.length; i3++) {
          dimensions[i3] = this.dimensions[i3].toHTML();
        }
        if (this.dotNotation) {
          return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
        } else {
          return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
        }
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        var dimensions = this.dimensions.map(function(range2) {
          return range2.toTex(options);
        });
        return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
      }
    }
    _defineProperty(IndexNode2, "name", name214);
    return IndexNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ObjectNode.js
  var name215 = "ObjectNode";
  var dependencies215 = ["Node"];
  var createObjectNode = /* @__PURE__ */ factory(name215, dependencies215, (_ref) => {
    var {
      Node: Node2
    } = _ref;
    class ObjectNode2 extends Node2 {
      /**
       * @constructor ObjectNode
       * @extends {Node}
       * Holds an object with keys/values
       * @param {Object.<string, Node>} [properties]   object with key/value pairs
       */
      constructor(properties2) {
        super();
        this.properties = properties2 || {};
        if (properties2) {
          if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
            return isNode(properties2[key]);
          })) {
            throw new TypeError("Object containing Nodes expected");
          }
        }
      }
      get type() {
        return name215;
      }
      get isObjectNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var evalEntries = {};
        for (var key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            var stringifiedKey = stringify(key);
            var parsedKey = JSON.parse(stringifiedKey);
            var prop = getSafeProperty(this.properties, key);
            evalEntries[parsedKey] = prop._compile(math2, argNames);
          }
        }
        return function evalObjectNode(scope, args, context) {
          var obj = {};
          for (var _key in evalEntries) {
            if (hasOwnProperty(evalEntries, _key)) {
              obj[_key] = evalEntries[_key](scope, args, context);
            }
          }
          return obj;
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (var key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            callback(this.properties[key], "properties[" + stringify(key) + "]", this);
          }
        }
      }
      /**
       * Create a new ObjectNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {ObjectNode} Returns a transformed copy of the node
       */
      map(callback) {
        var properties2 = {};
        for (var key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
          }
        }
        return new ObjectNode2(properties2);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ObjectNode}
       */
      clone() {
        var properties2 = {};
        for (var key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            properties2[key] = this.properties[key];
          }
        }
        return new ObjectNode2(properties2);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(options) {
        var entries = [];
        for (var key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            entries.push(stringify(key) + ": " + this.properties[key].toString(options));
          }
        }
        return "{" + entries.join(", ") + "}";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name215,
          properties: this.properties
        };
      }
      /**
       * Instantiate an OperatorNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
       *                       where mathjs is optional
       * @returns {ObjectNode}
       */
      static fromJSON(json) {
        return new ObjectNode2(json.properties);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      toHTML(options) {
        var entries = [];
        for (var key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            entries.push('<span class="math-symbol math-property">' + escape(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
          }
        }
        return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        var entries = [];
        for (var key in this.properties) {
          if (hasOwnProperty(this.properties, key)) {
            entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
          }
        }
        var tex = "\\left\\{\\begin{array}{ll}" + entries.join("\n") + "\\end{array}\\right\\}";
        return tex;
      }
    }
    _defineProperty(ObjectNode2, "name", name215);
    return ObjectNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/OperatorNode.js
  var name216 = "OperatorNode";
  var dependencies216 = ["Node"];
  var createOperatorNode = /* @__PURE__ */ factory(name216, dependencies216, (_ref) => {
    var {
      Node: Node2
    } = _ref;
    function startsWithConstant(expr, parenthesis) {
      var curNode = expr;
      if (parenthesis === "auto") {
        while (isParenthesisNode(curNode))
          curNode = curNode.content;
      }
      if (isConstantNode(curNode))
        return true;
      if (isOperatorNode(curNode)) {
        return startsWithConstant(curNode.args[0], parenthesis);
      }
      return false;
    }
    function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
      var precedence = getPrecedence(root, parenthesis, implicit);
      var associativity = getAssociativity(root, parenthesis);
      if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
        return args.map(function(arg2) {
          switch (arg2.getContent().type) {
            case "ArrayNode":
            case "ConstantNode":
            case "SymbolNode":
            case "ParenthesisNode":
              return false;
            default:
              return true;
          }
        });
      }
      var result;
      switch (args.length) {
        case 0:
          result = [];
          break;
        case 1:
          {
            var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
            if (latex && operandPrecedence !== null) {
              var operandIdentifier;
              var rootIdentifier;
              if (parenthesis === "keep") {
                operandIdentifier = args[0].getIdentifier();
                rootIdentifier = root.getIdentifier();
              } else {
                operandIdentifier = args[0].getContent().getIdentifier();
                rootIdentifier = root.getContent().getIdentifier();
              }
              if (properties[precedence][rootIdentifier].latexLeftParens === false) {
                result = [false];
                break;
              }
              if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
                result = [false];
                break;
              }
            }
            if (operandPrecedence === null) {
              result = [false];
              break;
            }
            if (operandPrecedence <= precedence) {
              result = [true];
              break;
            }
            result = [false];
          }
          break;
        case 2:
          {
            var lhsParens;
            var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
            var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
            if (lhsPrecedence === null) {
              lhsParens = false;
            } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
              lhsParens = true;
            } else if (lhsPrecedence < precedence) {
              lhsParens = true;
            } else {
              lhsParens = false;
            }
            var rhsParens;
            var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);
            var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
            if (rhsPrecedence === null) {
              rhsParens = false;
            } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
              rhsParens = true;
            } else if (rhsPrecedence < precedence) {
              rhsParens = true;
            } else {
              rhsParens = false;
            }
            if (latex) {
              var _rootIdentifier;
              var lhsIdentifier;
              var rhsIdentifier;
              if (parenthesis === "keep") {
                _rootIdentifier = root.getIdentifier();
                lhsIdentifier = root.args[0].getIdentifier();
                rhsIdentifier = root.args[1].getIdentifier();
              } else {
                _rootIdentifier = root.getContent().getIdentifier();
                lhsIdentifier = root.args[0].getContent().getIdentifier();
                rhsIdentifier = root.args[1].getContent().getIdentifier();
              }
              if (lhsPrecedence !== null) {
                if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                  lhsParens = false;
                }
                if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                  lhsParens = false;
                }
              }
              if (rhsPrecedence !== null) {
                if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                  rhsParens = false;
                }
                if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                  rhsParens = false;
                }
              }
            }
            result = [lhsParens, rhsParens];
          }
          break;
        default:
          if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
            result = args.map(function(arg2) {
              var argPrecedence = getPrecedence(arg2, parenthesis, implicit, root);
              var assocWithArg = isAssociativeWith(root, arg2, parenthesis);
              var argAssociativity = getAssociativity(arg2, parenthesis);
              if (argPrecedence === null) {
                return false;
              } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
                return true;
              } else if (argPrecedence < precedence) {
                return true;
              }
              return false;
            });
          }
          break;
      }
      if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis !== "all" && implicit === "hide") {
        for (var i3 = 1; i3 < result.length; ++i3) {
          if (startsWithConstant(args[i3], parenthesis) && !result[i3 - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i3 - 1]))) {
            result[i3] = true;
          }
        }
      }
      return result;
    }
    class OperatorNode2 extends Node2 {
      /**
       * @constructor OperatorNode
       * @extends {Node}
       * An operator with two arguments, like 2+3
       *
       * @param {string} op           Operator name, for example '+'
       * @param {string} fn           Function name, for example 'add'
       * @param {Node[]} args         Operator arguments
       * @param {boolean} [implicit]  Is this an implicit multiplication?
       * @param {boolean} [isPercentage] Is this an percentage Operation?
       */
      constructor(op, fn, args, implicit, isPercentage) {
        super();
        if (typeof op !== "string") {
          throw new TypeError('string expected for parameter "op"');
        }
        if (typeof fn !== "string") {
          throw new TypeError('string expected for parameter "fn"');
        }
        if (!Array.isArray(args) || !args.every(isNode)) {
          throw new TypeError('Array containing Nodes expected for parameter "args"');
        }
        this.implicit = implicit === true;
        this.isPercentage = isPercentage === true;
        this.op = op;
        this.fn = fn;
        this.args = args || [];
      }
      get type() {
        return name216;
      }
      get isOperatorNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        if (typeof this.fn !== "string" || !isSafeMethod(math2, this.fn)) {
          if (!math2[this.fn]) {
            throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
          } else {
            throw new Error('No access to function "' + this.fn + '"');
          }
        }
        var fn = getSafeProperty(math2, this.fn);
        var evalArgs = map(this.args, function(arg2) {
          return arg2._compile(math2, argNames);
        });
        if (evalArgs.length === 1) {
          var evalArg0 = evalArgs[0];
          return function evalOperatorNode(scope, args, context) {
            return fn(evalArg0(scope, args, context));
          };
        } else if (evalArgs.length === 2) {
          var _evalArg = evalArgs[0];
          var evalArg1 = evalArgs[1];
          return function evalOperatorNode(scope, args, context) {
            return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
          };
        } else {
          return function evalOperatorNode(scope, args, context) {
            return fn.apply(null, map(evalArgs, function(evalArg) {
              return evalArg(scope, args, context);
            }));
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        for (var i3 = 0; i3 < this.args.length; i3++) {
          callback(this.args[i3], "args[" + i3 + "]", this);
        }
      }
      /**
       * Create a new OperatorNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {OperatorNode} Returns a transformed copy of the node
       */
      map(callback) {
        var args = [];
        for (var i3 = 0; i3 < this.args.length; i3++) {
          args[i3] = this._ifNode(callback(this.args[i3], "args[" + i3 + "]", this));
        }
        return new OperatorNode2(this.op, this.fn, args, this.implicit, this.isPercentage);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {OperatorNode}
       */
      clone() {
        return new OperatorNode2(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
      }
      /**
       * Check whether this is an unary OperatorNode:
       * has exactly one argument, like `-a`.
       * @return {boolean}
       *     Returns true when an unary operator node, false otherwise.
       */
      isUnary() {
        return this.args.length === 1;
      }
      /**
       * Check whether this is a binary OperatorNode:
       * has exactly two arguments, like `a + b`.
       * @return {boolean}
       *     Returns true when a binary operator node, false otherwise.
       */
      isBinary() {
        return this.args.length === 2;
      }
      /**
       * Get string representation.
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var implicit = options && options.implicit ? options.implicit : "hide";
        var args = this.args;
        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
        if (args.length === 1) {
          var assoc = getAssociativity(this, parenthesis);
          var operand = args[0].toString(options);
          if (parens[0]) {
            operand = "(" + operand + ")";
          }
          var opIsNamed = /[a-zA-Z]+/.test(this.op);
          if (assoc === "right") {
            return this.op + (opIsNamed ? " " : "") + operand;
          } else if (assoc === "left") {
            return operand + (opIsNamed ? " " : "") + this.op;
          }
          return operand + this.op;
        } else if (args.length === 2) {
          var lhs = args[0].toString(options);
          var rhs = args[1].toString(options);
          if (parens[0]) {
            lhs = "(" + lhs + ")";
          }
          if (parens[1]) {
            rhs = "(" + rhs + ")";
          }
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return lhs + " " + rhs;
          }
          return lhs + " " + this.op + " " + rhs;
        } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          var stringifiedArgs = args.map(function(arg2, index2) {
            arg2 = arg2.toString(options);
            if (parens[index2]) {
              arg2 = "(" + arg2 + ")";
            }
            return arg2;
          });
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join(" ");
          }
          return stringifiedArgs.join(" " + this.op + " ");
        } else {
          return this.fn + "(" + this.args.join(", ") + ")";
        }
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name216,
          op: this.op,
          fn: this.fn,
          args: this.args,
          implicit: this.implicit,
          isPercentage: this.isPercentage
        };
      }
      /**
       * Instantiate an OperatorNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     ```
       *     {"mathjs": "OperatorNode",
       *      "op": "+", "fn": "add", "args": [...],
       *      "implicit": false,
       *      "isPercentage":false}
       *     ```
       *     where mathjs is optional
       * @returns {OperatorNode}
       */
      static fromJSON(json) {
        return new OperatorNode2(json.op, json.fn, json.args, json.implicit, json.isPercentage);
      }
      /**
       * Get HTML representation.
       * @param {Object} options
       * @return {string} str
       */
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var implicit = options && options.implicit ? options.implicit : "hide";
        var args = this.args;
        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
        if (args.length === 1) {
          var assoc = getAssociativity(this, parenthesis);
          var operand = args[0].toHTML(options);
          if (parens[0]) {
            operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (assoc === "right") {
            return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
          } else {
            return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
          }
        } else if (args.length === 2) {
          var lhs = args[0].toHTML(options);
          var rhs = args[1].toHTML(options);
          if (parens[0]) {
            lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (parens[1]) {
            rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
          }
          return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
        } else {
          var stringifiedArgs = args.map(function(arg2, index2) {
            arg2 = arg2.toHTML(options);
            if (parens[index2]) {
              arg2 = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg2 + '<span class="math-parenthesis math-round-parenthesis">)</span>';
            }
            return arg2;
          });
          if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
            if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
              return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
            }
            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>");
          } else {
            return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
          }
        }
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var implicit = options && options.implicit ? options.implicit : "hide";
        var args = this.args;
        var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
        var op = latexOperators[this.fn];
        op = typeof op === "undefined" ? this.op : op;
        if (args.length === 1) {
          var assoc = getAssociativity(this, parenthesis);
          var operand = args[0].toTex(options);
          if (parens[0]) {
            operand = "\\left(".concat(operand, "\\right)");
          }
          if (assoc === "right") {
            return op + operand;
          } else if (assoc === "left") {
            return operand + op;
          }
          return operand + op;
        } else if (args.length === 2) {
          var lhs = args[0];
          var lhsTex = lhs.toTex(options);
          if (parens[0]) {
            lhsTex = "\\left(".concat(lhsTex, "\\right)");
          }
          var rhs = args[1];
          var rhsTex = rhs.toTex(options);
          if (parens[1]) {
            rhsTex = "\\left(".concat(rhsTex, "\\right)");
          }
          var lhsIdentifier;
          if (parenthesis === "keep") {
            lhsIdentifier = lhs.getIdentifier();
          } else {
            lhsIdentifier = lhs.getContent().getIdentifier();
          }
          switch (this.getIdentifier()) {
            case "OperatorNode:divide":
              return op + "{" + lhsTex + "}{" + rhsTex + "}";
            case "OperatorNode:pow":
              lhsTex = "{" + lhsTex + "}";
              rhsTex = "{" + rhsTex + "}";
              switch (lhsIdentifier) {
                case "ConditionalNode":
                case "OperatorNode:divide":
                  lhsTex = "\\left(".concat(lhsTex, "\\right)");
              }
              break;
            case "OperatorNode:multiply":
              if (this.implicit && implicit === "hide") {
                return lhsTex + "~" + rhsTex;
              }
          }
          return lhsTex + op + rhsTex;
        } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          var texifiedArgs = args.map(function(arg2, index2) {
            arg2 = arg2.toTex(options);
            if (parens[index2]) {
              arg2 = "\\left(".concat(arg2, "\\right)");
            }
            return arg2;
          });
          if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
            return texifiedArgs.join("~");
          }
          return texifiedArgs.join(op);
        } else {
          return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg2) {
            return arg2.toTex(options);
          }).join(",") + "\\right)";
        }
      }
      /**
       * Get identifier.
       * @return {string}
       */
      getIdentifier() {
        return this.type + ":" + this.fn;
      }
    }
    _defineProperty(OperatorNode2, "name", name216);
    return OperatorNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/ParenthesisNode.js
  var name217 = "ParenthesisNode";
  var dependencies217 = ["Node"];
  var createParenthesisNode = /* @__PURE__ */ factory(name217, dependencies217, (_ref) => {
    var {
      Node: Node2
    } = _ref;
    class ParenthesisNode2 extends Node2 {
      /**
       * @constructor ParenthesisNode
       * @extends {Node}
       * A parenthesis node describes manual parenthesis from the user input
       * @param {Node} content
       * @extends {Node}
       */
      constructor(content) {
        super();
        if (!isNode(content)) {
          throw new TypeError('Node expected for parameter "content"');
        }
        this.content = content;
      }
      get type() {
        return name217;
      }
      get isParenthesisNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        return this.content._compile(math2, argNames);
      }
      /**
       * Get the content of the current Node.
       * @return {Node} content
       * @override
       **/
      getContent() {
        return this.content.getContent();
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.content, "content", this);
      }
      /**
       * Create a new ParenthesisNode whose child is the result of calling
       * the provided callback function on the child of this node.
       * @param {function(child: Node, path: string, parent: Node) : Node} callback
       * @returns {ParenthesisNode} Returns a clone of the node
       */
      map(callback) {
        var content = callback(this.content, "content", this);
        return new ParenthesisNode2(content);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {ParenthesisNode}
       */
      clone() {
        return new ParenthesisNode2(this.content);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return "(" + this.content.toString(options) + ")";
        }
        return this.content.toString(options);
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name217,
          content: this.content
        };
      }
      /**
       * Instantiate an ParenthesisNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
       *                       where mathjs is optional
       * @returns {ParenthesisNode}
       */
      static fromJSON(json) {
        return new ParenthesisNode2(json.content);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      toHTML(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        return this.content.toHTML(options);
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toTex(options) {
        if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
          return "\\left(".concat(this.content.toTex(options), "\\right)");
        }
        return this.content.toTex(options);
      }
    }
    _defineProperty(ParenthesisNode2, "name", name217);
    return ParenthesisNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/RangeNode.js
  var name218 = "RangeNode";
  var dependencies218 = ["Node"];
  var createRangeNode = /* @__PURE__ */ factory(name218, dependencies218, (_ref) => {
    var {
      Node: Node2
    } = _ref;
    function calculateNecessaryParentheses(node, parenthesis, implicit) {
      var precedence = getPrecedence(node, parenthesis, implicit);
      var parens = {};
      var startPrecedence = getPrecedence(node.start, parenthesis, implicit);
      parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
      if (node.step) {
        var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);
        parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
      }
      var endPrecedence = getPrecedence(node.end, parenthesis, implicit);
      parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
      return parens;
    }
    class RangeNode2 extends Node2 {
      /**
       * @constructor RangeNode
       * @extends {Node}
       * create a range
       * @param {Node} start  included lower-bound
       * @param {Node} end    included upper-bound
       * @param {Node} [step] optional step
       */
      constructor(start, end, step) {
        super();
        if (!isNode(start))
          throw new TypeError("Node expected");
        if (!isNode(end))
          throw new TypeError("Node expected");
        if (step && !isNode(step))
          throw new TypeError("Node expected");
        if (arguments.length > 3)
          throw new Error("Too many arguments");
        this.start = start;
        this.end = end;
        this.step = step || null;
      }
      get type() {
        return name218;
      }
      get isRangeNode() {
        return true;
      }
      /**
       * Check whether the RangeNode needs the `end` symbol to be defined.
       * This end is the size of the Matrix in current dimension.
       * @return {boolean}
       */
      needsEnd() {
        var endSymbols = this.filter(function(node) {
          return isSymbolNode(node) && node.name === "end";
        });
        return endSymbols.length > 0;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var range2 = math2.range;
        var evalStart = this.start._compile(math2, argNames);
        var evalEnd = this.end._compile(math2, argNames);
        if (this.step) {
          var evalStep = this.step._compile(math2, argNames);
          return function evalRangeNode(scope, args, context) {
            return range2(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
          };
        } else {
          return function evalRangeNode(scope, args, context) {
            return range2(evalStart(scope, args, context), evalEnd(scope, args, context));
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.start, "start", this);
        callback(this.end, "end", this);
        if (this.step) {
          callback(this.step, "step", this);
        }
      }
      /**
       * Create a new RangeNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {RangeNode} Returns a transformed copy of the node
       */
      map(callback) {
        return new RangeNode2(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {RangeNode}
       */
      clone() {
        return new RangeNode2(this.start, this.end, this.step && this.step);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
        var str;
        var start = this.start.toString(options);
        if (parens.start) {
          start = "(" + start + ")";
        }
        str = start;
        if (this.step) {
          var step = this.step.toString(options);
          if (parens.step) {
            step = "(" + step + ")";
          }
          str += ":" + step;
        }
        var end = this.end.toString(options);
        if (parens.end) {
          end = "(" + end + ")";
        }
        str += ":" + end;
        return str;
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name218,
          start: this.start,
          end: this.end,
          step: this.step
        };
      }
      /**
       * Instantiate an RangeNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
       *     where mathjs is optional
       * @returns {RangeNode}
       */
      static fromJSON(json) {
        return new RangeNode2(json.start, json.end, json.step);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
        var str;
        var start = this.start.toHTML(options);
        if (parens.start) {
          start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str = start;
        if (this.step) {
          var step = this.step.toHTML(options);
          if (parens.step) {
            step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          str += '<span class="math-operator math-range-operator">:</span>' + step;
        }
        var end = this.end.toHTML(options);
        if (parens.end) {
          end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + end;
        return str;
      }
      /**
       * Get LaTeX representation
       * @params {Object} options
       * @return {string} str
       */
      _toTex(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
        var str = this.start.toTex(options);
        if (parens.start) {
          str = "\\left(".concat(str, "\\right)");
        }
        if (this.step) {
          var step = this.step.toTex(options);
          if (parens.step) {
            step = "\\left(".concat(step, "\\right)");
          }
          str += ":" + step;
        }
        var end = this.end.toTex(options);
        if (parens.end) {
          end = "\\left(".concat(end, "\\right)");
        }
        str += ":" + end;
        return str;
      }
    }
    _defineProperty(RangeNode2, "name", name218);
    return RangeNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/RelationalNode.js
  var name219 = "RelationalNode";
  var dependencies219 = ["Node"];
  var createRelationalNode = /* @__PURE__ */ factory(name219, dependencies219, (_ref) => {
    var {
      Node: Node2
    } = _ref;
    var operatorMap = {
      equal: "==",
      unequal: "!=",
      smaller: "<",
      larger: ">",
      smallerEq: "<=",
      largerEq: ">="
    };
    class RelationalNode2 extends Node2 {
      /**
       * A node representing a chained conditional expression, such as 'x > y > z'
       *
       * @param {String[]} conditionals
       *     An array of conditional operators used to compare the parameters
       * @param {Node[]} params
       *     The parameters that will be compared
       *
       * @constructor RelationalNode
       * @extends {Node}
       */
      constructor(conditionals, params) {
        super();
        if (!Array.isArray(conditionals)) {
          throw new TypeError("Parameter conditionals must be an array");
        }
        if (!Array.isArray(params)) {
          throw new TypeError("Parameter params must be an array");
        }
        if (conditionals.length !== params.length - 1) {
          throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
        }
        this.conditionals = conditionals;
        this.params = params;
      }
      get type() {
        return name219;
      }
      get isRelationalNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math2, argNames) {
        var self2 = this;
        var compiled = this.params.map((p) => p._compile(math2, argNames));
        return function evalRelationalNode(scope, args, context) {
          var evalLhs;
          var evalRhs = compiled[0](scope, args, context);
          for (var i3 = 0; i3 < self2.conditionals.length; i3++) {
            evalLhs = evalRhs;
            evalRhs = compiled[i3 + 1](scope, args, context);
            var condFn = getSafeProperty(math2, self2.conditionals[i3]);
            if (!condFn(evalLhs, evalRhs)) {
              return false;
            }
          }
          return true;
        };
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        this.params.forEach((n, i3) => callback(n, "params[" + i3 + "]", this), this);
      }
      /**
       * Create a new RelationalNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {RelationalNode} Returns a transformed copy of the node
       */
      map(callback) {
        return new RelationalNode2(this.conditionals.slice(), this.params.map((n, i3) => this._ifNode(callback(n, "params[" + i3 + "]", this)), this));
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {RelationalNode}
       */
      clone() {
        return new RelationalNode2(this.conditionals, this.params);
      }
      /**
       * Get string representation.
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var paramStrings = this.params.map(function(p, index2) {
          var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
        });
        var ret = paramStrings[0];
        for (var i3 = 0; i3 < this.conditionals.length; i3++) {
          ret += " " + operatorMap[this.conditionals[i3]];
          ret += " " + paramStrings[i3 + 1];
        }
        return ret;
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name219,
          conditionals: this.conditionals,
          params: this.params
        };
      }
      /**
       * Instantiate a RelationalNode from its JSON representation
       * @param {Object} json
       *     An object structured like
       *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
       *     where mathjs is optional
       * @returns {RelationalNode}
       */
      static fromJSON(json) {
        return new RelationalNode2(json.conditionals, json.params);
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      toHTML(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var paramStrings = this.params.map(function(p, index2) {
          var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
        });
        var ret = paramStrings[0];
        for (var i3 = 0; i3 < this.conditionals.length; i3++) {
          ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i3]]) + "</span>" + paramStrings[i3 + 1];
        }
        return ret;
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
        var precedence = getPrecedence(this, parenthesis, options && options.implicit);
        var paramStrings = this.params.map(function(p, index2) {
          var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
          return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
        });
        var ret = paramStrings[0];
        for (var i3 = 0; i3 < this.conditionals.length; i3++) {
          ret += latexOperators[this.conditionals[i3]] + paramStrings[i3 + 1];
        }
        return ret;
      }
    }
    _defineProperty(RelationalNode2, "name", name219);
    return RelationalNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/node/SymbolNode.js
  var name220 = "SymbolNode";
  var dependencies220 = ["math", "?Unit", "Node"];
  var createSymbolNode = /* @__PURE__ */ factory(name220, dependencies220, (_ref) => {
    var {
      math: math2,
      Unit: Unit2,
      Node: Node2
    } = _ref;
    function isValuelessUnit(name310) {
      return Unit2 ? Unit2.isValuelessUnit(name310) : false;
    }
    class SymbolNode2 extends Node2 {
      /**
       * @constructor SymbolNode
       * @extends {Node}
       * A symbol node can hold and resolve a symbol
       * @param {string} name
       * @extends {Node}
       */
      constructor(name310) {
        super();
        if (typeof name310 !== "string") {
          throw new TypeError('String expected for parameter "name"');
        }
        this.name = name310;
      }
      get type() {
        return "SymbolNode";
      }
      get isSymbolNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math3, argNames) {
        var name310 = this.name;
        if (argNames[name310] === true) {
          return function(scope, args, context) {
            return getSafeProperty(args, name310);
          };
        } else if (name310 in math3) {
          return function(scope, args, context) {
            return scope.has(name310) ? scope.get(name310) : getSafeProperty(math3, name310);
          };
        } else {
          var isUnit2 = isValuelessUnit(name310);
          return function(scope, args, context) {
            return scope.has(name310) ? scope.get(name310) : isUnit2 ? new Unit2(null, name310) : SymbolNode2.onUndefinedSymbol(name310);
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
      }
      /**
       * Create a new SymbolNode with children produced by the given callback.
       * Trivial since a SymbolNode has no children
       * @param {function(child: Node, path: string, parent: Node) : Node} callback
       * @returns {SymbolNode} Returns a clone of the node
       */
      map(callback) {
        return this.clone();
      }
      /**
       * Throws an error 'Undefined symbol {name}'
       * @param {string} name
       */
      static onUndefinedSymbol(name310) {
        throw new Error("Undefined symbol " + name310);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {SymbolNode}
       */
      clone() {
        return new SymbolNode2(this.name);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toString(options) {
        return this.name;
      }
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      toHTML(options) {
        var name310 = escape(this.name);
        if (name310 === "true" || name310 === "false") {
          return '<span class="math-symbol math-boolean">' + name310 + "</span>";
        } else if (name310 === "i") {
          return '<span class="math-symbol math-imaginary-symbol">' + name310 + "</span>";
        } else if (name310 === "Infinity") {
          return '<span class="math-symbol math-infinity-symbol">' + name310 + "</span>";
        } else if (name310 === "NaN") {
          return '<span class="math-symbol math-nan-symbol">' + name310 + "</span>";
        } else if (name310 === "null") {
          return '<span class="math-symbol math-null-symbol">' + name310 + "</span>";
        } else if (name310 === "undefined") {
          return '<span class="math-symbol math-undefined-symbol">' + name310 + "</span>";
        }
        return '<span class="math-symbol">' + name310 + "</span>";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: "SymbolNode",
          name: this.name
        };
      }
      /**
       * Instantiate a SymbolNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "SymbolNode", name: "x"}`,
       *                       where mathjs is optional
       * @returns {SymbolNode}
       */
      static fromJSON(json) {
        return new SymbolNode2(json.name);
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       * @override
       */
      _toTex(options) {
        var isUnit2 = false;
        if (typeof math2[this.name] === "undefined" && isValuelessUnit(this.name)) {
          isUnit2 = true;
        }
        var symbol = toSymbol(this.name, isUnit2);
        if (symbol[0] === "\\") {
          return symbol;
        }
        return " " + symbol;
      }
    }
    return SymbolNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/utils/scope.js
  function createSubScope(parentScope) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (typeof parentScope.createSubScope === "function") {
      return assign(parentScope.createSubScope(), ...args);
    }
    return assign(createEmptyMap(), parentScope, ...args);
  }

  // node_modules/mathjs/lib/esm/expression/node/FunctionNode.js
  var name221 = "FunctionNode";
  var dependencies221 = ["math", "Node", "SymbolNode"];
  var createFunctionNode = /* @__PURE__ */ factory(name221, dependencies221, (_ref) => {
    var _class;
    var {
      math: math2,
      Node: Node2,
      SymbolNode: SymbolNode2
    } = _ref;
    var strin = (entity) => format3(entity, {
      truncate: 78
    });
    function expandTemplate(template, node, options) {
      var latex = "";
      var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
      var inputPos = 0;
      var match;
      while ((match = regex.exec(template)) !== null) {
        latex += template.substring(inputPos, match.index);
        inputPos = match.index;
        if (match[0] === "$$") {
          latex += "$";
          inputPos++;
        } else {
          inputPos += match[0].length;
          var property = node[match[1]];
          if (!property) {
            throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
          }
          if (match[2] === void 0) {
            switch (typeof property) {
              case "string":
                latex += property;
                break;
              case "object":
                if (isNode(property)) {
                  latex += property.toTex(options);
                } else if (Array.isArray(property)) {
                  latex += property.map(function(arg2, index2) {
                    if (isNode(arg2)) {
                      return arg2.toTex(options);
                    }
                    throw new TypeError("Template: " + match[1] + "[" + index2 + "] is not a Node.");
                  }).join(",");
                } else {
                  throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
                }
                break;
              default:
                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
            }
          } else {
            if (isNode(property[match[2]] && property[match[2]])) {
              latex += property[match[2]].toTex(options);
            } else {
              throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
            }
          }
        }
      }
      latex += template.slice(inputPos);
      return latex;
    }
    class FunctionNode2 extends Node2 {
      /**
       * @constructor FunctionNode
       * @extends {./Node}
       * invoke a list with arguments on a node
       * @param {./Node | string} fn
       *     Item resolving to a function on which to invoke
       *     the arguments, typically a SymboNode or AccessorNode
       * @param {./Node[]} args
       */
      constructor(fn, args) {
        super();
        if (typeof fn === "string") {
          fn = new SymbolNode2(fn);
        }
        if (!isNode(fn))
          throw new TypeError('Node expected as parameter "fn"');
        if (!Array.isArray(args) || !args.every(isNode)) {
          throw new TypeError('Array containing Nodes expected for parameter "args"');
        }
        this.fn = fn;
        this.args = args || [];
      }
      // readonly property name
      get name() {
        return this.fn.name || "";
      }
      get type() {
        return name221;
      }
      get isFunctionNode() {
        return true;
      }
      /**
       * Compile a node into a JavaScript function.
       * This basically pre-calculates as much as possible and only leaves open
       * calculations which depend on a dynamic scope with variables.
       * @param {Object} math     Math.js namespace with functions and constants.
       * @param {Object} argNames An object with argument names as key and `true`
       *                          as value. Used in the SymbolNode to optimize
       *                          for arguments from user assigned functions
       *                          (see FunctionAssignmentNode) or special symbols
       *                          like `end` (see IndexNode).
       * @return {function} Returns a function which can be called like:
       *                        evalNode(scope: Object, args: Object, context: *)
       */
      _compile(math3, argNames) {
        var evalArgs = this.args.map((arg2) => arg2._compile(math3, argNames));
        if (isSymbolNode(this.fn)) {
          var _name = this.fn.name;
          if (!argNames[_name]) {
            var fn = _name in math3 ? getSafeProperty(math3, _name) : void 0;
            var isRaw = typeof fn === "function" && fn.rawArgs === true;
            var resolveFn = (scope) => {
              var value;
              if (scope.has(_name)) {
                value = scope.get(_name);
              } else if (_name in math3) {
                value = getSafeProperty(math3, _name);
              } else {
                return FunctionNode2.onUndefinedFunction(_name);
              }
              if (typeof value === "function") {
                return value;
              }
              throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
            };
            if (isRaw) {
              var rawArgs = this.args;
              return function evalFunctionNode(scope, args, context) {
                var fn2 = resolveFn(scope);
                return fn2(rawArgs, math3, createSubScope(scope, args), scope);
              };
            } else {
              switch (evalArgs.length) {
                case 0:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    return fn2();
                  };
                case 1:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    var evalArg0 = evalArgs[0];
                    return fn2(evalArg0(scope, args, context));
                  };
                case 2:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    var evalArg0 = evalArgs[0];
                    var evalArg1 = evalArgs[1];
                    return fn2(evalArg0(scope, args, context), evalArg1(scope, args, context));
                  };
                default:
                  return function evalFunctionNode(scope, args, context) {
                    var fn2 = resolveFn(scope);
                    var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                    return fn2(...values);
                  };
              }
            }
          } else {
            var _rawArgs = this.args;
            return function evalFunctionNode(scope, args, context) {
              var fn2 = getSafeProperty(args, _name);
              if (typeof fn2 !== "function") {
                throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
              }
              if (fn2.rawArgs) {
                return fn2(_rawArgs, math3, createSubScope(scope, args), scope);
              } else {
                var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                return fn2.apply(fn2, values);
              }
            };
          }
        } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
          var evalObject = this.fn.object._compile(math3, argNames);
          var prop = this.fn.index.getObjectProperty();
          var _rawArgs2 = this.args;
          return function evalFunctionNode(scope, args, context) {
            var object = evalObject(scope, args, context);
            var fn2 = getSafeMethod(object, prop);
            if (fn2 !== null && fn2 !== void 0 && fn2.rawArgs) {
              return fn2(_rawArgs2, math3, createSubScope(scope, args), scope);
            } else {
              var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return fn2.apply(object, values);
            }
          };
        } else {
          var fnExpr = this.fn.toString();
          var evalFn = this.fn._compile(math3, argNames);
          var _rawArgs3 = this.args;
          return function evalFunctionNode(scope, args, context) {
            var fn2 = evalFn(scope, args, context);
            if (typeof fn2 !== "function") {
              throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn2)));
            }
            if (fn2.rawArgs) {
              return fn2(_rawArgs3, math3, createSubScope(scope, args), scope);
            } else {
              var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return fn2.apply(fn2, values);
            }
          };
        }
      }
      /**
       * Execute a callback for each of the child nodes of this node
       * @param {function(child: Node, path: string, parent: Node)} callback
       */
      forEach(callback) {
        callback(this.fn, "fn", this);
        for (var i3 = 0; i3 < this.args.length; i3++) {
          callback(this.args[i3], "args[" + i3 + "]", this);
        }
      }
      /**
       * Create a new FunctionNode whose children are the results of calling
       * the provided callback function for each child of the original node.
       * @param {function(child: Node, path: string, parent: Node): Node} callback
       * @returns {FunctionNode} Returns a transformed copy of the node
       */
      map(callback) {
        var fn = this._ifNode(callback(this.fn, "fn", this));
        var args = [];
        for (var i3 = 0; i3 < this.args.length; i3++) {
          args[i3] = this._ifNode(callback(this.args[i3], "args[" + i3 + "]", this));
        }
        return new FunctionNode2(fn, args);
      }
      /**
       * Create a clone of this node, a shallow copy
       * @return {FunctionNode}
       */
      clone() {
        return new FunctionNode2(this.fn, this.args.slice(0));
      }
      /**
       * Throws an error 'Undefined function {name}'
       * @param {string} name
       */
      /**
       * Get string representation. (wrapper function)
       * This overrides parts of Node's toString function.
       * If callback is an object containing callbacks, it
       * calls the correct callback for the current node,
       * otherwise it falls back to calling Node's toString
       * function.
       *
       * @param {Object} options
       * @return {string} str
       * @override
       */
      toString(options) {
        var customString;
        var name310 = this.fn.toString(options);
        if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, name310)) {
          customString = options.handler[name310](this, options);
        }
        if (typeof customString !== "undefined") {
          return customString;
        }
        return super.toString(options);
      }
      /**
       * Get string representation
       * @param {Object} options
       * @return {string} str
       */
      _toString(options) {
        var args = this.args.map(function(arg2) {
          return arg2.toString(options);
        });
        var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
        return fn + "(" + args.join(", ") + ")";
      }
      /**
       * Get a JSON representation of the node
       * @returns {Object}
       */
      toJSON() {
        return {
          mathjs: name221,
          fn: this.fn,
          args: this.args
        };
      }
      /**
       * Instantiate an AssignmentNode from its JSON representation
       * @param {Object} json  An object structured like
       *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
       *                       where mathjs is optional
       * @returns {FunctionNode}
       */
      /**
       * Get HTML representation
       * @param {Object} options
       * @return {string} str
       */
      toHTML(options) {
        var args = this.args.map(function(arg2) {
          return arg2.toHTML(options);
        });
        return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      /**
       * Get LaTeX representation. (wrapper function)
       * This overrides parts of Node's toTex function.
       * If callback is an object containing callbacks, it
       * calls the correct callback for the current node,
       * otherwise it falls back to calling Node's toTex
       * function.
       *
       * @param {Object} options
       * @return {string}
       */
      toTex(options) {
        var customTex;
        if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, this.name)) {
          customTex = options.handler[this.name](this, options);
        }
        if (typeof customTex !== "undefined") {
          return customTex;
        }
        return super.toTex(options);
      }
      /**
       * Get LaTeX representation
       * @param {Object} options
       * @return {string} str
       */
      _toTex(options) {
        var args = this.args.map(function(arg2) {
          return arg2.toTex(options);
        });
        var latexConverter;
        if (latexFunctions[this.name]) {
          latexConverter = latexFunctions[this.name];
        }
        if (math2[this.name] && (typeof math2[this.name].toTex === "function" || typeof math2[this.name].toTex === "object" || typeof math2[this.name].toTex === "string")) {
          latexConverter = math2[this.name].toTex;
        }
        var customToTex;
        switch (typeof latexConverter) {
          case "function":
            customToTex = latexConverter(this, options);
            break;
          case "string":
            customToTex = expandTemplate(latexConverter, this, options);
            break;
          case "object":
            switch (typeof latexConverter[args.length]) {
              case "function":
                customToTex = latexConverter[args.length](this, options);
                break;
              case "string":
                customToTex = expandTemplate(latexConverter[args.length], this, options);
                break;
            }
        }
        if (typeof customToTex !== "undefined") {
          return customToTex;
        }
        return expandTemplate(defaultTemplate, this, options);
      }
      /**
       * Get identifier.
       * @return {string}
       */
      getIdentifier() {
        return this.type + ":" + this.name;
      }
    }
    _class = FunctionNode2;
    _defineProperty(FunctionNode2, "name", name221);
    _defineProperty(FunctionNode2, "onUndefinedFunction", function(name310) {
      throw new Error("Undefined function " + name310);
    });
    _defineProperty(FunctionNode2, "fromJSON", function(json) {
      return new _class(json.fn, json.args);
    });
    return FunctionNode2;
  }, {
    isClass: true,
    isNode: true
  });

  // node_modules/mathjs/lib/esm/expression/parse.js
  var name222 = "parse";
  var dependencies222 = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
  var createParse = /* @__PURE__ */ factory(name222, dependencies222, (_ref) => {
    var {
      typed: typed3,
      numeric: numeric3,
      config: config4,
      AccessorNode: AccessorNode2,
      ArrayNode: ArrayNode2,
      AssignmentNode: AssignmentNode2,
      BlockNode: BlockNode2,
      ConditionalNode: ConditionalNode2,
      ConstantNode: ConstantNode2,
      FunctionAssignmentNode: FunctionAssignmentNode2,
      FunctionNode: FunctionNode2,
      IndexNode: IndexNode2,
      ObjectNode: ObjectNode2,
      OperatorNode: OperatorNode2,
      ParenthesisNode: ParenthesisNode2,
      RangeNode: RangeNode2,
      RelationalNode: RelationalNode2,
      SymbolNode: SymbolNode2
    } = _ref;
    var parse2 = typed3(name222, {
      string: function string2(expression) {
        return parseStart(expression, {});
      },
      "Array | Matrix": function ArrayMatrix(expressions) {
        return parseMultiple(expressions, {});
      },
      "string, Object": function stringObject(expression, options) {
        var extraNodes = options.nodes !== void 0 ? options.nodes : {};
        return parseStart(expression, extraNodes);
      },
      "Array | Matrix, Object": parseMultiple
    });
    function parseMultiple(expressions) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var extraNodes = options.nodes !== void 0 ? options.nodes : {};
      return deepMap(expressions, function(elem) {
        if (typeof elem !== "string")
          throw new TypeError("String expected");
        return parseStart(elem, extraNodes);
      });
    }
    var TOKENTYPE = {
      NULL: 0,
      DELIMITER: 1,
      NUMBER: 2,
      SYMBOL: 3,
      UNKNOWN: 4
    };
    var DELIMITERS = {
      ",": true,
      "(": true,
      ")": true,
      "[": true,
      "]": true,
      "{": true,
      "}": true,
      '"': true,
      "'": true,
      ";": true,
      "+": true,
      "-": true,
      "*": true,
      ".*": true,
      "/": true,
      "./": true,
      "%": true,
      "^": true,
      ".^": true,
      "~": true,
      "!": true,
      "&": true,
      "|": true,
      "^|": true,
      "=": true,
      ":": true,
      "?": true,
      "==": true,
      "!=": true,
      "<": true,
      ">": true,
      "<=": true,
      ">=": true,
      "<<": true,
      ">>": true,
      ">>>": true
    };
    var NAMED_DELIMITERS = {
      mod: true,
      to: true,
      in: true,
      and: true,
      xor: true,
      or: true,
      not: true
    };
    var CONSTANTS = {
      true: true,
      false: false,
      null: null,
      undefined: void 0
    };
    var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
    var ESCAPE_CHARACTERS = {
      '"': '"',
      "'": "'",
      "\\": "\\",
      "/": "/",
      b: "\b",
      f: "\f",
      n: "\n",
      r: "\r",
      t: "	"
      // note that \u is handled separately in parseStringToken()
    };
    function initialState() {
      return {
        extraNodes: {},
        // current extra nodes, must be careful not to mutate
        expression: "",
        // current expression
        comment: "",
        // last parsed comment
        index: 0,
        // current index in expr
        token: "",
        // current token
        tokenType: TOKENTYPE.NULL,
        // type of the token
        nestingLevel: 0,
        // level of nesting inside parameters, used to ignore newline characters
        conditionalLevel: null
        // when a conditional is being parsed, the level of the conditional is stored here
      };
    }
    function currentString(state, length) {
      return state.expression.substr(state.index, length);
    }
    function currentCharacter(state) {
      return currentString(state, 1);
    }
    function next(state) {
      state.index++;
    }
    function prevCharacter(state) {
      return state.expression.charAt(state.index - 1);
    }
    function nextCharacter(state) {
      return state.expression.charAt(state.index + 1);
    }
    function getToken(state) {
      state.tokenType = TOKENTYPE.NULL;
      state.token = "";
      state.comment = "";
      while (true) {
        if (currentCharacter(state) === "#") {
          while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
            state.comment += currentCharacter(state);
            next(state);
          }
        }
        if (parse2.isWhitespace(currentCharacter(state), state.nestingLevel)) {
          next(state);
        } else {
          break;
        }
      }
      if (currentCharacter(state) === "") {
        state.tokenType = TOKENTYPE.DELIMITER;
        return;
      }
      if (currentCharacter(state) === "\n" && !state.nestingLevel) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = currentCharacter(state);
        next(state);
        return;
      }
      var c1 = currentCharacter(state);
      var c2 = currentString(state, 2);
      var c3 = currentString(state, 3);
      if (c3.length === 3 && DELIMITERS[c3]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c3;
        next(state);
        next(state);
        next(state);
        return;
      }
      if (c2.length === 2 && DELIMITERS[c2]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c2;
        next(state);
        next(state);
        return;
      }
      if (DELIMITERS[c1]) {
        state.tokenType = TOKENTYPE.DELIMITER;
        state.token = c1;
        next(state);
        return;
      }
      if (parse2.isDigitDot(c1)) {
        state.tokenType = TOKENTYPE.NUMBER;
        var _c = currentString(state, 2);
        if (_c === "0b" || _c === "0o" || _c === "0x") {
          state.token += currentCharacter(state);
          next(state);
          state.token += currentCharacter(state);
          next(state);
          while (parse2.isHexDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (currentCharacter(state) === ".") {
            state.token += ".";
            next(state);
            while (parse2.isHexDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
          } else if (currentCharacter(state) === "i") {
            state.token += "i";
            next(state);
            while (parse2.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
          }
          return;
        }
        if (currentCharacter(state) === ".") {
          state.token += currentCharacter(state);
          next(state);
          if (!parse2.isDigit(currentCharacter(state))) {
            state.tokenType = TOKENTYPE.DELIMITER;
            return;
          }
        } else {
          while (parse2.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }
        while (parse2.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
          if (parse2.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
            state.token += currentCharacter(state);
            next(state);
            if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
              state.token += currentCharacter(state);
              next(state);
            }
            if (!parse2.isDigit(currentCharacter(state))) {
              throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
            }
            while (parse2.isDigit(currentCharacter(state))) {
              state.token += currentCharacter(state);
              next(state);
            }
            if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
              throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
            }
          } else if (nextCharacter(state) === ".") {
            next(state);
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
        }
        return;
      }
      if (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
        while (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse2.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {
          state.tokenType = TOKENTYPE.DELIMITER;
        } else {
          state.tokenType = TOKENTYPE.SYMBOL;
        }
        return;
      }
      state.tokenType = TOKENTYPE.UNKNOWN;
      while (currentCharacter(state) !== "") {
        state.token += currentCharacter(state);
        next(state);
      }
      throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
    }
    function getTokenSkipNewline(state) {
      do {
        getToken(state);
      } while (state.token === "\n");
    }
    function openParams(state) {
      state.nestingLevel++;
    }
    function closeParams(state) {
      state.nestingLevel--;
    }
    parse2.isAlpha = function isAlpha(c, cPrev, cNext) {
      return parse2.isValidLatinOrGreek(c) || parse2.isValidMathSymbol(c, cNext) || parse2.isValidMathSymbol(cPrev, c);
    };
    parse2.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
      return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
    };
    parse2.isValidMathSymbol = function isValidMathSymbol(high, low) {
      return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
    };
    parse2.isWhitespace = function isWhitespace(c, nestingLevel) {
      return c === " " || c === "	" || c === "\n" && nestingLevel > 0;
    };
    parse2.isDecimalMark = function isDecimalMark(c, cNext) {
      return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
    };
    parse2.isDigitDot = function isDigitDot(c) {
      return c >= "0" && c <= "9" || c === ".";
    };
    parse2.isDigit = function isDigit(c) {
      return c >= "0" && c <= "9";
    };
    parse2.isHexDigit = function isHexDigit(c) {
      return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
    };
    function parseStart(expression, extraNodes) {
      var state = initialState();
      _extends(state, {
        expression,
        extraNodes
      });
      getToken(state);
      var node = parseBlock(state);
      if (state.token !== "") {
        if (state.tokenType === TOKENTYPE.DELIMITER) {
          throw createError(state, "Unexpected operator " + state.token);
        } else {
          throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
        }
      }
      return node;
    }
    function parseBlock(state) {
      var node;
      var blocks = [];
      var visible;
      if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
        node = parseAssignment(state);
        if (state.comment) {
          node.comment = state.comment;
        }
      }
      while (state.token === "\n" || state.token === ";") {
        if (blocks.length === 0 && node) {
          visible = state.token !== ";";
          blocks.push({
            node,
            visible
          });
        }
        getToken(state);
        if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
          node = parseAssignment(state);
          if (state.comment) {
            node.comment = state.comment;
          }
          visible = state.token !== ";";
          blocks.push({
            node,
            visible
          });
        }
      }
      if (blocks.length > 0) {
        return new BlockNode2(blocks);
      } else {
        if (!node) {
          node = new ConstantNode2(void 0);
          if (state.comment) {
            node.comment = state.comment;
          }
        }
        return node;
      }
    }
    function parseAssignment(state) {
      var name310, args, value, valid;
      var node = parseConditional(state);
      if (state.token === "=") {
        if (isSymbolNode(node)) {
          name310 = node.name;
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode2(new SymbolNode2(name310), value);
        } else if (isAccessorNode(node)) {
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new AssignmentNode2(node.object, node.index, value);
        } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
          valid = true;
          args = [];
          name310 = node.name;
          node.args.forEach(function(arg2, index2) {
            if (isSymbolNode(arg2)) {
              args[index2] = arg2.name;
            } else {
              valid = false;
            }
          });
          if (valid) {
            getTokenSkipNewline(state);
            value = parseAssignment(state);
            return new FunctionAssignmentNode2(name310, args, value);
          }
        }
        throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
      }
      return node;
    }
    function parseConditional(state) {
      var node = parseLogicalOr(state);
      while (state.token === "?") {
        var prev = state.conditionalLevel;
        state.conditionalLevel = state.nestingLevel;
        getTokenSkipNewline(state);
        var condition = node;
        var trueExpr = parseAssignment(state);
        if (state.token !== ":")
          throw createSyntaxError(state, "False part of conditional expression expected");
        state.conditionalLevel = null;
        getTokenSkipNewline(state);
        var falseExpr = parseAssignment(state);
        node = new ConditionalNode2(condition, trueExpr, falseExpr);
        state.conditionalLevel = prev;
      }
      return node;
    }
    function parseLogicalOr(state) {
      var node = parseLogicalXor(state);
      while (state.token === "or") {
        getTokenSkipNewline(state);
        node = new OperatorNode2("or", "or", [node, parseLogicalXor(state)]);
      }
      return node;
    }
    function parseLogicalXor(state) {
      var node = parseLogicalAnd(state);
      while (state.token === "xor") {
        getTokenSkipNewline(state);
        node = new OperatorNode2("xor", "xor", [node, parseLogicalAnd(state)]);
      }
      return node;
    }
    function parseLogicalAnd(state) {
      var node = parseBitwiseOr(state);
      while (state.token === "and") {
        getTokenSkipNewline(state);
        node = new OperatorNode2("and", "and", [node, parseBitwiseOr(state)]);
      }
      return node;
    }
    function parseBitwiseOr(state) {
      var node = parseBitwiseXor(state);
      while (state.token === "|") {
        getTokenSkipNewline(state);
        node = new OperatorNode2("|", "bitOr", [node, parseBitwiseXor(state)]);
      }
      return node;
    }
    function parseBitwiseXor(state) {
      var node = parseBitwiseAnd(state);
      while (state.token === "^|") {
        getTokenSkipNewline(state);
        node = new OperatorNode2("^|", "bitXor", [node, parseBitwiseAnd(state)]);
      }
      return node;
    }
    function parseBitwiseAnd(state) {
      var node = parseRelational(state);
      while (state.token === "&") {
        getTokenSkipNewline(state);
        node = new OperatorNode2("&", "bitAnd", [node, parseRelational(state)]);
      }
      return node;
    }
    function parseRelational(state) {
      var params = [parseShift(state)];
      var conditionals = [];
      var operators = {
        "==": "equal",
        "!=": "unequal",
        "<": "smaller",
        ">": "larger",
        "<=": "smallerEq",
        ">=": "largerEq"
      };
      while (hasOwnProperty(operators, state.token)) {
        var cond = {
          name: state.token,
          fn: operators[state.token]
        };
        conditionals.push(cond);
        getTokenSkipNewline(state);
        params.push(parseShift(state));
      }
      if (params.length === 1) {
        return params[0];
      } else if (params.length === 2) {
        return new OperatorNode2(conditionals[0].name, conditionals[0].fn, params);
      } else {
        return new RelationalNode2(conditionals.map((c) => c.fn), params);
      }
    }
    function parseShift(state) {
      var node, name310, fn, params;
      node = parseConversion(state);
      var operators = {
        "<<": "leftShift",
        ">>": "rightArithShift",
        ">>>": "rightLogShift"
      };
      while (hasOwnProperty(operators, state.token)) {
        name310 = state.token;
        fn = operators[name310];
        getTokenSkipNewline(state);
        params = [node, parseConversion(state)];
        node = new OperatorNode2(name310, fn, params);
      }
      return node;
    }
    function parseConversion(state) {
      var node, name310, fn, params;
      node = parseRange(state);
      var operators = {
        to: "to",
        in: "to"
        // alias of 'to'
      };
      while (hasOwnProperty(operators, state.token)) {
        name310 = state.token;
        fn = operators[name310];
        getTokenSkipNewline(state);
        if (name310 === "in" && state.token === "") {
          node = new OperatorNode2("*", "multiply", [node, new SymbolNode2("in")], true);
        } else {
          params = [node, parseRange(state)];
          node = new OperatorNode2(name310, fn, params);
        }
      }
      return node;
    }
    function parseRange(state) {
      var node;
      var params = [];
      if (state.token === ":") {
        node = new ConstantNode2(1);
      } else {
        node = parseAddSubtract(state);
      }
      if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
        params.push(node);
        while (state.token === ":" && params.length < 3) {
          getTokenSkipNewline(state);
          if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
            params.push(new SymbolNode2("end"));
          } else {
            params.push(parseAddSubtract(state));
          }
        }
        if (params.length === 3) {
          node = new RangeNode2(params[0], params[2], params[1]);
        } else {
          node = new RangeNode2(params[0], params[1]);
        }
      }
      return node;
    }
    function parseAddSubtract(state) {
      var node, name310, fn, params;
      node = parseMultiplyDivide(state);
      var operators = {
        "+": "add",
        "-": "subtract"
      };
      while (hasOwnProperty(operators, state.token)) {
        name310 = state.token;
        fn = operators[name310];
        getTokenSkipNewline(state);
        var rightNode = parseMultiplyDivide(state);
        if (rightNode.isPercentage) {
          params = [node, new OperatorNode2("*", "multiply", [node, rightNode])];
        } else {
          params = [node, rightNode];
        }
        node = new OperatorNode2(name310, fn, params);
      }
      return node;
    }
    function parseMultiplyDivide(state) {
      var node, last, name310, fn;
      node = parseImplicitMultiplication(state);
      last = node;
      var operators = {
        "*": "multiply",
        ".*": "dotMultiply",
        "/": "divide",
        "./": "dotDivide"
      };
      while (true) {
        if (hasOwnProperty(operators, state.token)) {
          name310 = state.token;
          fn = operators[name310];
          getTokenSkipNewline(state);
          last = parseImplicitMultiplication(state);
          node = new OperatorNode2(name310, fn, [node, last]);
        } else {
          break;
        }
      }
      return node;
    }
    function parseImplicitMultiplication(state) {
      var node, last;
      node = parseRule2(state);
      last = node;
      while (true) {
        if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
          last = parseRule2(state);
          node = new OperatorNode2(
            "*",
            "multiply",
            [node, last],
            true
            /* implicit */
          );
        } else {
          break;
        }
      }
      return node;
    }
    function parseRule2(state) {
      var node = parsePercentage(state);
      var last = node;
      var tokenStates = [];
      while (true) {
        if (state.token === "/" && rule2Node(last)) {
          tokenStates.push(_extends({}, state));
          getTokenSkipNewline(state);
          if (state.tokenType === TOKENTYPE.NUMBER) {
            tokenStates.push(_extends({}, state));
            getTokenSkipNewline(state);
            if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
              _extends(state, tokenStates.pop());
              tokenStates.pop();
              last = parsePercentage(state);
              node = new OperatorNode2("/", "divide", [node, last]);
            } else {
              tokenStates.pop();
              _extends(state, tokenStates.pop());
              break;
            }
          } else {
            _extends(state, tokenStates.pop());
            break;
          }
        } else {
          break;
        }
      }
      return node;
    }
    function parsePercentage(state) {
      var node, name310, fn, params;
      node = parseUnary(state);
      var operators = {
        "%": "mod",
        mod: "mod"
      };
      while (hasOwnProperty(operators, state.token)) {
        name310 = state.token;
        fn = operators[name310];
        getTokenSkipNewline(state);
        if (name310 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
          node = new OperatorNode2("/", "divide", [node, new ConstantNode2(100)], false, true);
        } else {
          params = [node, parseUnary(state)];
          node = new OperatorNode2(name310, fn, params);
        }
      }
      return node;
    }
    function parseUnary(state) {
      var name310, params, fn;
      var operators = {
        "-": "unaryMinus",
        "+": "unaryPlus",
        "~": "bitNot",
        not: "not"
      };
      if (hasOwnProperty(operators, state.token)) {
        fn = operators[state.token];
        name310 = state.token;
        getTokenSkipNewline(state);
        params = [parseUnary(state)];
        return new OperatorNode2(name310, fn, params);
      }
      return parsePow(state);
    }
    function parsePow(state) {
      var node, name310, fn, params;
      node = parseLeftHandOperators(state);
      if (state.token === "^" || state.token === ".^") {
        name310 = state.token;
        fn = name310 === "^" ? "pow" : "dotPow";
        getTokenSkipNewline(state);
        params = [node, parseUnary(state)];
        node = new OperatorNode2(name310, fn, params);
      }
      return node;
    }
    function parseLeftHandOperators(state) {
      var node, name310, fn, params;
      node = parseCustomNodes(state);
      var operators = {
        "!": "factorial",
        "'": "ctranspose"
      };
      while (hasOwnProperty(operators, state.token)) {
        name310 = state.token;
        fn = operators[name310];
        getToken(state);
        params = [node];
        node = new OperatorNode2(name310, fn, params);
        node = parseAccessors(state, node);
      }
      return node;
    }
    function parseCustomNodes(state) {
      var params = [];
      if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {
        var CustomNode = state.extraNodes[state.token];
        getToken(state);
        if (state.token === "(") {
          params = [];
          openParams(state);
          getToken(state);
          if (state.token !== ")") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
        }
        return new CustomNode(params);
      }
      return parseSymbol(state);
    }
    function parseSymbol(state) {
      var node, name310;
      if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
        name310 = state.token;
        getToken(state);
        if (hasOwnProperty(CONSTANTS, name310)) {
          node = new ConstantNode2(CONSTANTS[name310]);
        } else if (NUMERIC_CONSTANTS.indexOf(name310) !== -1) {
          node = new ConstantNode2(numeric3(name310, "number"));
        } else {
          node = new SymbolNode2(name310);
        }
        node = parseAccessors(state, node);
        return node;
      }
      return parseString(state);
    }
    function parseAccessors(state, node, types) {
      var params;
      while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.indexOf(state.token) !== -1)) {
        params = [];
        if (state.token === "(") {
          if (isSymbolNode(node) || isAccessorNode(node)) {
            openParams(state);
            getToken(state);
            if (state.token !== ")") {
              params.push(parseAssignment(state));
              while (state.token === ",") {
                getToken(state);
                params.push(parseAssignment(state));
              }
            }
            if (state.token !== ")") {
              throw createSyntaxError(state, "Parenthesis ) expected");
            }
            closeParams(state);
            getToken(state);
            node = new FunctionNode2(node, params);
          } else {
            return node;
          }
        } else if (state.token === "[") {
          openParams(state);
          getToken(state);
          if (state.token !== "]") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== "]") {
            throw createSyntaxError(state, "Parenthesis ] expected");
          }
          closeParams(state);
          getToken(state);
          node = new AccessorNode2(node, new IndexNode2(params));
        } else {
          getToken(state);
          var isPropertyName = state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS;
          if (!isPropertyName) {
            throw createSyntaxError(state, "Property name expected after dot");
          }
          params.push(new ConstantNode2(state.token));
          getToken(state);
          var dotNotation = true;
          node = new AccessorNode2(node, new IndexNode2(params, dotNotation));
        }
      }
      return node;
    }
    function parseString(state) {
      var node, str;
      if (state.token === '"' || state.token === "'") {
        str = parseStringToken(state, state.token);
        node = new ConstantNode2(str);
        node = parseAccessors(state, node);
        return node;
      }
      return parseMatrix(state);
    }
    function parseStringToken(state, quote) {
      var str = "";
      while (currentCharacter(state) !== "" && currentCharacter(state) !== quote) {
        if (currentCharacter(state) === "\\") {
          next(state);
          var char = currentCharacter(state);
          var escapeChar = ESCAPE_CHARACTERS[char];
          if (escapeChar !== void 0) {
            str += escapeChar;
            state.index += 1;
          } else if (char === "u") {
            var unicode = state.expression.slice(state.index + 1, state.index + 5);
            if (/^[0-9A-Fa-f]{4}$/.test(unicode)) {
              str += String.fromCharCode(parseInt(unicode, 16));
              state.index += 5;
            } else {
              throw createSyntaxError(state, "Invalid unicode character \\u".concat(unicode));
            }
          } else {
            throw createSyntaxError(state, "Bad escape character \\".concat(char));
          }
        } else {
          str += currentCharacter(state);
          next(state);
        }
      }
      getToken(state);
      if (state.token !== quote) {
        throw createSyntaxError(state, "End of string ".concat(quote, " expected"));
      }
      getToken(state);
      return str;
    }
    function parseMatrix(state) {
      var array, params, rows, cols;
      if (state.token === "[") {
        openParams(state);
        getToken(state);
        if (state.token !== "]") {
          var row2 = parseRow(state);
          if (state.token === ";") {
            rows = 1;
            params = [row2];
            while (state.token === ";") {
              getToken(state);
              params[rows] = parseRow(state);
              rows++;
            }
            if (state.token !== "]") {
              throw createSyntaxError(state, "End of matrix ] expected");
            }
            closeParams(state);
            getToken(state);
            cols = params[0].items.length;
            for (var r = 1; r < rows; r++) {
              if (params[r].items.length !== cols) {
                throw createError(state, "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")");
              }
            }
            array = new ArrayNode2(params);
          } else {
            if (state.token !== "]") {
              throw createSyntaxError(state, "End of matrix ] expected");
            }
            closeParams(state);
            getToken(state);
            array = row2;
          }
        } else {
          closeParams(state);
          getToken(state);
          array = new ArrayNode2([]);
        }
        return parseAccessors(state, array);
      }
      return parseObject(state);
    }
    function parseRow(state) {
      var params = [parseAssignment(state)];
      var len = 1;
      while (state.token === ",") {
        getToken(state);
        params[len] = parseAssignment(state);
        len++;
      }
      return new ArrayNode2(params);
    }
    function parseObject(state) {
      if (state.token === "{") {
        openParams(state);
        var key;
        var properties2 = {};
        do {
          getToken(state);
          if (state.token !== "}") {
            if (state.token === '"' || state.token === "'") {
              key = parseStringToken(state, state.token);
            } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
              key = state.token;
              getToken(state);
            } else {
              throw createSyntaxError(state, "Symbol or string expected as object key");
            }
            if (state.token !== ":") {
              throw createSyntaxError(state, "Colon : expected after object key");
            }
            getToken(state);
            properties2[key] = parseAssignment(state);
          }
        } while (state.token === ",");
        if (state.token !== "}") {
          throw createSyntaxError(state, "Comma , or bracket } expected after object value");
        }
        closeParams(state);
        getToken(state);
        var node = new ObjectNode2(properties2);
        node = parseAccessors(state, node);
        return node;
      }
      return parseNumber(state);
    }
    function parseNumber(state) {
      var numberStr;
      if (state.tokenType === TOKENTYPE.NUMBER) {
        numberStr = state.token;
        getToken(state);
        return new ConstantNode2(numeric3(numberStr, config4.number));
      }
      return parseParentheses(state);
    }
    function parseParentheses(state) {
      var node;
      if (state.token === "(") {
        openParams(state);
        getToken(state);
        node = parseAssignment(state);
        if (state.token !== ")") {
          throw createSyntaxError(state, "Parenthesis ) expected");
        }
        closeParams(state);
        getToken(state);
        node = new ParenthesisNode2(node);
        node = parseAccessors(state, node);
        return node;
      }
      return parseEnd(state);
    }
    function parseEnd(state) {
      if (state.token === "") {
        throw createSyntaxError(state, "Unexpected end of expression");
      } else {
        throw createSyntaxError(state, "Value expected");
      }
    }
    function col(state) {
      return state.index - state.token.length + 1;
    }
    function createSyntaxError(state, message) {
      var c = col(state);
      var error = new SyntaxError(message + " (char " + c + ")");
      error.char = c;
      return error;
    }
    function createError(state, message) {
      var c = col(state);
      var error = new SyntaxError(message + " (char " + c + ")");
      error.char = c;
      return error;
    }
    typed3.addConversion({
      from: "string",
      to: "Node",
      convert: parse2
    });
    return parse2;
  });

  // node_modules/mathjs/lib/esm/expression/function/compile.js
  var name223 = "compile";
  var dependencies223 = ["typed", "parse"];
  var createCompile = /* @__PURE__ */ factory(name223, dependencies223, (_ref) => {
    var {
      typed: typed3,
      parse: parse2
    } = _ref;
    return typed3(name223, {
      string: function string2(expr) {
        return parse2(expr).compile();
      },
      "Array | Matrix": function ArrayMatrix(expr) {
        return deepMap(expr, function(entry) {
          return parse2(entry).compile();
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/function/evaluate.js
  var name224 = "evaluate";
  var dependencies224 = ["typed", "parse"];
  var createEvaluate = /* @__PURE__ */ factory(name224, dependencies224, (_ref) => {
    var {
      typed: typed3,
      parse: parse2
    } = _ref;
    return typed3(name224, {
      string: function string2(expr) {
        var scope = createEmptyMap();
        return parse2(expr).compile().evaluate(scope);
      },
      "string, Map | Object": function stringMapObject(expr, scope) {
        return parse2(expr).compile().evaluate(scope);
      },
      "Array | Matrix": function ArrayMatrix(expr) {
        var scope = createEmptyMap();
        return deepMap(expr, function(entry) {
          return parse2(entry).compile().evaluate(scope);
        });
      },
      "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope) {
        return deepMap(expr, function(entry) {
          return parse2(entry).compile().evaluate(scope);
        });
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/Parser.js
  var name225 = "Parser";
  var dependencies225 = ["evaluate"];
  var createParserClass = /* @__PURE__ */ factory(name225, dependencies225, (_ref) => {
    var {
      evaluate: evaluate2
    } = _ref;
    function Parser2() {
      if (!(this instanceof Parser2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      Object.defineProperty(this, "scope", {
        value: createEmptyMap(),
        writable: false
      });
    }
    Parser2.prototype.type = "Parser";
    Parser2.prototype.isParser = true;
    Parser2.prototype.evaluate = function(expr) {
      return evaluate2(expr, this.scope);
    };
    Parser2.prototype.get = function(name310) {
      if (this.scope.has(name310)) {
        return this.scope.get(name310);
      }
    };
    Parser2.prototype.getAll = function() {
      return toObject(this.scope);
    };
    Parser2.prototype.getAllAsMap = function() {
      return this.scope;
    };
    Parser2.prototype.set = function(name310, value) {
      this.scope.set(name310, value);
      return value;
    };
    Parser2.prototype.remove = function(name310) {
      this.scope.delete(name310);
    };
    Parser2.prototype.clear = function() {
      this.scope.clear();
    };
    return Parser2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/expression/function/parser.js
  var name226 = "parser";
  var dependencies226 = ["typed", "Parser"];
  var createParser = /* @__PURE__ */ factory(name226, dependencies226, (_ref) => {
    var {
      typed: typed3,
      Parser: Parser2
    } = _ref;
    return typed3(name226, {
      "": function _() {
        return new Parser2();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/lup.js
  var name227 = "lup";
  var dependencies227 = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
  var createLup = /* @__PURE__ */ factory(name227, dependencies227, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      abs: abs3,
      addScalar: addScalar2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      subtractScalar: subtractScalar2,
      larger: larger2,
      equalScalar: equalScalar2,
      unaryMinus: unaryMinus2,
      DenseMatrix: DenseMatrix2,
      SparseMatrix: SparseMatrix2,
      Spa: Spa2
    } = _ref;
    return typed3(name227, {
      DenseMatrix: function DenseMatrix3(m) {
        return _denseLUP(m);
      },
      SparseMatrix: function SparseMatrix3(m) {
        return _sparseLUP(m);
      },
      Array: function Array2(a) {
        var m = matrix2(a);
        var r = _denseLUP(m);
        return {
          L: r.L.valueOf(),
          U: r.U.valueOf(),
          p: r.p
        };
      }
    });
    function _denseLUP(m) {
      var rows = m._size[0];
      var columns = m._size[1];
      var n = Math.min(rows, columns);
      var data = clone(m._data);
      var ldata = [];
      var lsize = [rows, n];
      var udata = [];
      var usize = [n, columns];
      var i3, j, k;
      var p = [];
      for (i3 = 0; i3 < rows; i3++) {
        p[i3] = i3;
      }
      for (j = 0; j < columns; j++) {
        if (j > 0) {
          for (i3 = 0; i3 < rows; i3++) {
            var min3 = Math.min(i3, j);
            var s = 0;
            for (k = 0; k < min3; k++) {
              s = addScalar2(s, multiplyScalar2(data[i3][k], data[k][j]));
            }
            data[i3][j] = subtractScalar2(data[i3][j], s);
          }
        }
        var pi3 = j;
        var pabsv = 0;
        var vjj = 0;
        for (i3 = j; i3 < rows; i3++) {
          var v = data[i3][j];
          var absv = abs3(v);
          if (larger2(absv, pabsv)) {
            pi3 = i3;
            pabsv = absv;
            vjj = v;
          }
        }
        if (j !== pi3) {
          p[j] = [p[pi3], p[pi3] = p[j]][0];
          DenseMatrix2._swapRows(j, pi3, data);
        }
        if (j < rows) {
          for (i3 = j + 1; i3 < rows; i3++) {
            var vij = data[i3][j];
            if (!equalScalar2(vij, 0)) {
              data[i3][j] = divideScalar2(data[i3][j], vjj);
            }
          }
        }
      }
      for (j = 0; j < columns; j++) {
        for (i3 = 0; i3 < rows; i3++) {
          if (j === 0) {
            if (i3 < columns) {
              udata[i3] = [];
            }
            ldata[i3] = [];
          }
          if (i3 < j) {
            if (i3 < columns) {
              udata[i3][j] = data[i3][j];
            }
            if (j < rows) {
              ldata[i3][j] = 0;
            }
            continue;
          }
          if (i3 === j) {
            if (i3 < columns) {
              udata[i3][j] = data[i3][j];
            }
            if (j < rows) {
              ldata[i3][j] = 1;
            }
            continue;
          }
          if (i3 < columns) {
            udata[i3][j] = 0;
          }
          if (j < rows) {
            ldata[i3][j] = data[i3][j];
          }
        }
      }
      var l = new DenseMatrix2({
        data: ldata,
        size: lsize
      });
      var u = new DenseMatrix2({
        data: udata,
        size: usize
      });
      var pv = [];
      for (i3 = 0, n = p.length; i3 < n; i3++) {
        pv[p[i3]] = i3;
      }
      return {
        L: l,
        U: u,
        p: pv,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
        }
      };
    }
    function _sparseLUP(m) {
      var rows = m._size[0];
      var columns = m._size[1];
      var n = Math.min(rows, columns);
      var values = m._values;
      var index2 = m._index;
      var ptr = m._ptr;
      var lvalues = [];
      var lindex = [];
      var lptr = [];
      var lsize = [rows, n];
      var uvalues = [];
      var uindex = [];
      var uptr = [];
      var usize = [n, columns];
      var i3, j, k;
      var pvCo = [];
      var pvOc = [];
      for (i3 = 0; i3 < rows; i3++) {
        pvCo[i3] = i3;
        pvOc[i3] = i3;
      }
      var swapIndeces = function swapIndeces2(x, y2) {
        var kx = pvOc[x];
        var ky = pvOc[y2];
        pvCo[kx] = y2;
        pvCo[ky] = x;
        pvOc[x] = ky;
        pvOc[y2] = kx;
      };
      var _loop = function _loop2() {
        var spa = new Spa2();
        if (j < rows) {
          lptr.push(lvalues.length);
          lvalues.push(1);
          lindex.push(j);
        }
        uptr.push(uvalues.length);
        var k0 = ptr[j];
        var k1 = ptr[j + 1];
        for (k = k0; k < k1; k++) {
          i3 = index2[k];
          spa.set(pvCo[i3], values[k]);
        }
        if (j > 0) {
          spa.forEach(0, j - 1, function(k2, vkj) {
            SparseMatrix2._forEachRow(k2, lvalues, lindex, lptr, function(i4, vik) {
              if (i4 > k2) {
                spa.accumulate(i4, unaryMinus2(multiplyScalar2(vik, vkj)));
              }
            });
          });
        }
        var pi3 = j;
        var vjj = spa.get(j);
        var pabsv = abs3(vjj);
        spa.forEach(j + 1, rows - 1, function(x, v) {
          var absv = abs3(v);
          if (larger2(absv, pabsv)) {
            pi3 = x;
            pabsv = absv;
            vjj = v;
          }
        });
        if (j !== pi3) {
          SparseMatrix2._swapRows(j, pi3, lsize[1], lvalues, lindex, lptr);
          SparseMatrix2._swapRows(j, pi3, usize[1], uvalues, uindex, uptr);
          spa.swap(j, pi3);
          swapIndeces(j, pi3);
        }
        spa.forEach(0, rows - 1, function(x, v) {
          if (x <= j) {
            uvalues.push(v);
            uindex.push(x);
          } else {
            v = divideScalar2(v, vjj);
            if (!equalScalar2(v, 0)) {
              lvalues.push(v);
              lindex.push(x);
            }
          }
        });
      };
      for (j = 0; j < columns; j++) {
        _loop();
      }
      uptr.push(uvalues.length);
      lptr.push(lvalues.length);
      return {
        L: new SparseMatrix2({
          values: lvalues,
          index: lindex,
          ptr: lptr,
          size: lsize
        }),
        U: new SparseMatrix2({
          values: uvalues,
          index: uindex,
          ptr: uptr,
          size: usize
        }),
        p: pvCo,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
        }
      };
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/qr.js
  var name228 = "qr";
  var dependencies228 = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "complex"];
  var createQr = /* @__PURE__ */ factory(name228, dependencies228, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      zeros: zeros3,
      identity: identity2,
      isZero: isZero2,
      equal: equal2,
      sign: sign4,
      sqrt: sqrt3,
      conj: conj2,
      unaryMinus: unaryMinus2,
      addScalar: addScalar2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      subtractScalar: subtractScalar2,
      complex: complex2
    } = _ref;
    return _extends(typed3(name228, {
      DenseMatrix: function DenseMatrix2(m) {
        return _denseQR(m);
      },
      SparseMatrix: function SparseMatrix2(m) {
        return _sparseQR(m);
      },
      Array: function Array2(a) {
        var m = matrix2(a);
        var r = _denseQR(m);
        return {
          Q: r.Q.valueOf(),
          R: r.R.valueOf()
        };
      }
    }), {
      _denseQRimpl
    });
    function _denseQRimpl(m) {
      var rows = m._size[0];
      var cols = m._size[1];
      var Q3 = identity2([rows], "dense");
      var Qdata = Q3._data;
      var R = m.clone();
      var Rdata = R._data;
      var i3, j, k;
      var w2 = zeros3([rows], "");
      for (k = 0; k < Math.min(cols, rows); ++k) {
        var pivot = Rdata[k][k];
        var sgn = unaryMinus2(equal2(pivot, 0) ? 1 : sign4(pivot));
        var conjSgn = conj2(sgn);
        var alphaSquared = 0;
        for (i3 = k; i3 < rows; i3++) {
          alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i3][k], conj2(Rdata[i3][k])));
        }
        var alpha = multiplyScalar2(sgn, sqrt3(alphaSquared));
        if (!isZero2(alpha)) {
          var u1 = subtractScalar2(pivot, alpha);
          w2[k] = 1;
          for (i3 = k + 1; i3 < rows; i3++) {
            w2[i3] = divideScalar2(Rdata[i3][k], u1);
          }
          var tau3 = unaryMinus2(conj2(divideScalar2(u1, alpha)));
          var s = void 0;
          for (j = k; j < cols; j++) {
            s = 0;
            for (i3 = k; i3 < rows; i3++) {
              s = addScalar2(s, multiplyScalar2(conj2(w2[i3]), Rdata[i3][j]));
            }
            s = multiplyScalar2(s, tau3);
            for (i3 = k; i3 < rows; i3++) {
              Rdata[i3][j] = multiplyScalar2(subtractScalar2(Rdata[i3][j], multiplyScalar2(w2[i3], s)), conjSgn);
            }
          }
          for (i3 = 0; i3 < rows; i3++) {
            s = 0;
            for (j = k; j < rows; j++) {
              s = addScalar2(s, multiplyScalar2(Qdata[i3][j], w2[j]));
            }
            s = multiplyScalar2(s, tau3);
            for (j = k; j < rows; ++j) {
              Qdata[i3][j] = divideScalar2(subtractScalar2(Qdata[i3][j], multiplyScalar2(s, conj2(w2[j]))), conjSgn);
            }
          }
        }
      }
      return {
        Q: Q3,
        R,
        toString: function toString() {
          return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
        }
      };
    }
    function _denseQR(m) {
      var ret = _denseQRimpl(m);
      var Rdata = ret.R._data;
      if (m._data.length > 0) {
        var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
        for (var i3 = 0; i3 < Rdata.length; ++i3) {
          for (var j = 0; j < i3 && j < (Rdata[0] || []).length; ++j) {
            Rdata[i3][j] = zero;
          }
        }
      }
      return ret;
    }
    function _sparseQR(m) {
      throw new Error("qr not implemented for sparse matrices yet");
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csPermute.js
  function csPermute(a, pinv2, q, values) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype;
    var m = asize[0];
    var n = asize[1];
    var cvalues = values && a._values ? [] : null;
    var cindex = [];
    var cptr = [];
    var nz = 0;
    for (var k = 0; k < n; k++) {
      cptr[k] = nz;
      var j = q ? q[k] : k;
      for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
        var r = pinv2 ? pinv2[aindex[t]] : aindex[t];
        cindex[nz] = r;
        if (cvalues) {
          cvalues[nz] = avalues[t];
        }
        nz++;
      }
    }
    cptr[n] = nz;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [m, n],
      datatype: adt
    });
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csTdfs.js
  function csTdfs(j, k, w2, head, next, post, stack) {
    var top = 0;
    w2[stack] = j;
    while (top >= 0) {
      var p = w2[stack + top];
      var i3 = w2[head + p];
      if (i3 === -1) {
        top--;
        post[k++] = p;
      } else {
        w2[head + p] = w2[next + i3];
        ++top;
        w2[stack + top] = i3;
      }
    }
    return k;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csPost.js
  function csPost(parent, n) {
    if (!parent) {
      return null;
    }
    var k = 0;
    var j;
    var post = [];
    var w2 = [];
    var head = 0;
    var next = n;
    var stack = 2 * n;
    for (j = 0; j < n; j++) {
      w2[head + j] = -1;
    }
    for (j = n - 1; j >= 0; j--) {
      if (parent[j] === -1) {
        continue;
      }
      w2[next + j] = w2[head + parent[j]];
      w2[head + parent[j]] = j;
    }
    for (j = 0; j < n; j++) {
      if (parent[j] !== -1) {
        continue;
      }
      k = csTdfs(j, k, w2, head, next, post, stack);
    }
    return post;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csEtree.js
  function csEtree(a, ata) {
    if (!a) {
      return null;
    }
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var parent = [];
    var w2 = [];
    var ancestor = 0;
    var prev = n;
    var i3, inext;
    if (ata) {
      for (i3 = 0; i3 < m; i3++) {
        w2[prev + i3] = -1;
      }
    }
    for (var k = 0; k < n; k++) {
      parent[k] = -1;
      w2[ancestor + k] = -1;
      for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        var r = aindex[p];
        i3 = ata ? w2[prev + r] : r;
        for (; i3 !== -1 && i3 < k; i3 = inext) {
          inext = w2[ancestor + i3];
          w2[ancestor + i3] = k;
          if (inext === -1) {
            parent[i3] = k;
          }
        }
        if (ata) {
          w2[prev + r] = k;
        }
      }
    }
    return parent;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csFkeep.js
  function csFkeep(a, callback, other) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var nz = 0;
    for (var j = 0; j < n; j++) {
      var p = aptr[j];
      aptr[j] = nz;
      for (; p < aptr[j + 1]; p++) {
        if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
          aindex[nz] = aindex[p];
          if (avalues) {
            avalues[nz] = avalues[p];
          }
          nz++;
        }
      }
    }
    aptr[n] = nz;
    aindex.splice(nz, aindex.length - nz);
    if (avalues) {
      avalues.splice(nz, avalues.length - nz);
    }
    return nz;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csFlip.js
  function csFlip(i3) {
    return -i3 - 2;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csAmd.js
  var name229 = "csAmd";
  var dependencies229 = ["add", "multiply", "transpose"];
  var createCsAmd = /* @__PURE__ */ factory(name229, dependencies229, (_ref) => {
    var {
      add: add3,
      multiply: multiply2,
      transpose: transpose2
    } = _ref;
    return function csAmd(order, a) {
      if (!a || order <= 0 || order > 3) {
        return null;
      }
      var asize = a._size;
      var m = asize[0];
      var n = asize[1];
      var lemax = 0;
      var dense = Math.max(16, 10 * Math.sqrt(n));
      dense = Math.min(n - 2, dense);
      var cm = _createTargetMatrix(order, a, m, n, dense);
      csFkeep(cm, _diag, null);
      var cindex = cm._index;
      var cptr = cm._ptr;
      var cnz = cptr[n];
      var P3 = [];
      var W = [];
      var len = 0;
      var nv = n + 1;
      var next = 2 * (n + 1);
      var head = 3 * (n + 1);
      var elen = 4 * (n + 1);
      var degree = 5 * (n + 1);
      var w2 = 6 * (n + 1);
      var hhead = 7 * (n + 1);
      var last = P3;
      var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w2, elen, degree);
      var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w2, dense, nv, head, last, next);
      var mindeg = 0;
      var i3, j, k, k1, k2, e3, pj, ln2, nvi, pk, eln, p1, p2, pn, h, d;
      while (nel < n) {
        for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++)
          ;
        if (W[next + k] !== -1) {
          last[W[next + k]] = -1;
        }
        W[head + mindeg] = W[next + k];
        var elenk = W[elen + k];
        var nvk = W[nv + k];
        nel += nvk;
        var dk = 0;
        W[nv + k] = -nvk;
        var p = cptr[k];
        var pk1 = elenk === 0 ? p : cnz;
        var pk2 = pk1;
        for (k1 = 1; k1 <= elenk + 1; k1++) {
          if (k1 > elenk) {
            e3 = k;
            pj = p;
            ln2 = W[len + k] - elenk;
          } else {
            e3 = cindex[p++];
            pj = cptr[e3];
            ln2 = W[len + e3];
          }
          for (k2 = 1; k2 <= ln2; k2++) {
            i3 = cindex[pj++];
            if ((nvi = W[nv + i3]) <= 0) {
              continue;
            }
            dk += nvi;
            W[nv + i3] = -nvi;
            cindex[pk2++] = i3;
            if (W[next + i3] !== -1) {
              last[W[next + i3]] = last[i3];
            }
            if (last[i3] !== -1) {
              W[next + last[i3]] = W[next + i3];
            } else {
              W[head + W[degree + i3]] = W[next + i3];
            }
          }
          if (e3 !== k) {
            cptr[e3] = csFlip(k);
            W[w2 + e3] = 0;
          }
        }
        if (elenk !== 0) {
          cnz = pk2;
        }
        W[degree + k] = dk;
        cptr[k] = pk1;
        W[len + k] = pk2 - pk1;
        W[elen + k] = -2;
        mark = _wclear(mark, lemax, W, w2, n);
        for (pk = pk1; pk < pk2; pk++) {
          i3 = cindex[pk];
          if ((eln = W[elen + i3]) <= 0) {
            continue;
          }
          nvi = -W[nv + i3];
          var wnvi = mark - nvi;
          for (p = cptr[i3], p1 = cptr[i3] + eln - 1; p <= p1; p++) {
            e3 = cindex[p];
            if (W[w2 + e3] >= mark) {
              W[w2 + e3] -= nvi;
            } else if (W[w2 + e3] !== 0) {
              W[w2 + e3] = W[degree + e3] + wnvi;
            }
          }
        }
        for (pk = pk1; pk < pk2; pk++) {
          i3 = cindex[pk];
          p1 = cptr[i3];
          p2 = p1 + W[elen + i3] - 1;
          pn = p1;
          for (h = 0, d = 0, p = p1; p <= p2; p++) {
            e3 = cindex[p];
            if (W[w2 + e3] !== 0) {
              var dext = W[w2 + e3] - mark;
              if (dext > 0) {
                d += dext;
                cindex[pn++] = e3;
                h += e3;
              } else {
                cptr[e3] = csFlip(k);
                W[w2 + e3] = 0;
              }
            }
          }
          W[elen + i3] = pn - p1 + 1;
          var p3 = pn;
          var p4 = p1 + W[len + i3];
          for (p = p2 + 1; p < p4; p++) {
            j = cindex[p];
            var nvj = W[nv + j];
            if (nvj <= 0) {
              continue;
            }
            d += nvj;
            cindex[pn++] = j;
            h += j;
          }
          if (d === 0) {
            cptr[i3] = csFlip(k);
            nvi = -W[nv + i3];
            dk -= nvi;
            nvk += nvi;
            nel += nvi;
            W[nv + i3] = 0;
            W[elen + i3] = -1;
          } else {
            W[degree + i3] = Math.min(W[degree + i3], d);
            cindex[pn] = cindex[p3];
            cindex[p3] = cindex[p1];
            cindex[p1] = k;
            W[len + i3] = pn - p1 + 1;
            h = (h < 0 ? -h : h) % n;
            W[next + i3] = W[hhead + h];
            W[hhead + h] = i3;
            last[i3] = h;
          }
        }
        W[degree + k] = dk;
        lemax = Math.max(lemax, dk);
        mark = _wclear(mark + lemax, lemax, W, w2, n);
        for (pk = pk1; pk < pk2; pk++) {
          i3 = cindex[pk];
          if (W[nv + i3] >= 0) {
            continue;
          }
          h = last[i3];
          i3 = W[hhead + h];
          W[hhead + h] = -1;
          for (; i3 !== -1 && W[next + i3] !== -1; i3 = W[next + i3], mark++) {
            ln2 = W[len + i3];
            eln = W[elen + i3];
            for (p = cptr[i3] + 1; p <= cptr[i3] + ln2 - 1; p++) {
              W[w2 + cindex[p]] = mark;
            }
            var jlast = i3;
            for (j = W[next + i3]; j !== -1; ) {
              var ok = W[len + j] === ln2 && W[elen + j] === eln;
              for (p = cptr[j] + 1; ok && p <= cptr[j] + ln2 - 1; p++) {
                if (W[w2 + cindex[p]] !== mark) {
                  ok = 0;
                }
              }
              if (ok) {
                cptr[j] = csFlip(i3);
                W[nv + i3] += W[nv + j];
                W[nv + j] = 0;
                W[elen + j] = -1;
                j = W[next + j];
                W[next + jlast] = j;
              } else {
                jlast = j;
                j = W[next + j];
              }
            }
          }
        }
        for (p = pk1, pk = pk1; pk < pk2; pk++) {
          i3 = cindex[pk];
          if ((nvi = -W[nv + i3]) <= 0) {
            continue;
          }
          W[nv + i3] = nvi;
          d = W[degree + i3] + dk - nvi;
          d = Math.min(d, n - nel - nvi);
          if (W[head + d] !== -1) {
            last[W[head + d]] = i3;
          }
          W[next + i3] = W[head + d];
          last[i3] = -1;
          W[head + d] = i3;
          mindeg = Math.min(mindeg, d);
          W[degree + i3] = d;
          cindex[p++] = i3;
        }
        W[nv + k] = nvk;
        if ((W[len + k] = p - pk1) === 0) {
          cptr[k] = -1;
          W[w2 + k] = 0;
        }
        if (elenk !== 0) {
          cnz = p;
        }
      }
      for (i3 = 0; i3 < n; i3++) {
        cptr[i3] = csFlip(cptr[i3]);
      }
      for (j = 0; j <= n; j++) {
        W[head + j] = -1;
      }
      for (j = n; j >= 0; j--) {
        if (W[nv + j] > 0) {
          continue;
        }
        W[next + j] = W[head + cptr[j]];
        W[head + cptr[j]] = j;
      }
      for (e3 = n; e3 >= 0; e3--) {
        if (W[nv + e3] <= 0) {
          continue;
        }
        if (cptr[e3] !== -1) {
          W[next + e3] = W[head + cptr[e3]];
          W[head + cptr[e3]] = e3;
        }
      }
      for (k = 0, i3 = 0; i3 <= n; i3++) {
        if (cptr[i3] === -1) {
          k = csTdfs(i3, k, W, head, next, P3, w2);
        }
      }
      P3.splice(P3.length - 1, 1);
      return P3;
    };
    function _createTargetMatrix(order, a, m, n, dense) {
      var at = transpose2(a);
      if (order === 1 && n === m) {
        return add3(a, at);
      }
      if (order === 2) {
        var tindex = at._index;
        var tptr = at._ptr;
        var p2 = 0;
        for (var j = 0; j < m; j++) {
          var p = tptr[j];
          tptr[j] = p2;
          if (tptr[j + 1] - p > dense) {
            continue;
          }
          for (var p1 = tptr[j + 1]; p < p1; p++) {
            tindex[p2++] = tindex[p];
          }
        }
        tptr[m] = p2;
        a = transpose2(at);
        return multiply2(at, a);
      }
      return multiply2(at, a);
    }
    function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w2, elen, degree) {
      for (var k = 0; k < n; k++) {
        W[len + k] = cptr[k + 1] - cptr[k];
      }
      W[len + n] = 0;
      for (var i3 = 0; i3 <= n; i3++) {
        W[head + i3] = -1;
        last[i3] = -1;
        W[next + i3] = -1;
        W[hhead + i3] = -1;
        W[nv + i3] = 1;
        W[w2 + i3] = 1;
        W[elen + i3] = 0;
        W[degree + i3] = W[len + i3];
      }
      var mark = _wclear(0, 0, W, w2, n);
      W[elen + n] = -2;
      cptr[n] = -1;
      W[w2 + n] = 0;
      return mark;
    }
    function _initializeDegreeLists(n, cptr, W, degree, elen, w2, dense, nv, head, last, next) {
      var nel = 0;
      for (var i3 = 0; i3 < n; i3++) {
        var d = W[degree + i3];
        if (d === 0) {
          W[elen + i3] = -2;
          nel++;
          cptr[i3] = -1;
          W[w2 + i3] = 0;
        } else if (d > dense) {
          W[nv + i3] = 0;
          W[elen + i3] = -1;
          nel++;
          cptr[i3] = csFlip(n);
          W[nv + n]++;
        } else {
          var h = W[head + d];
          if (h !== -1) {
            last[h] = i3;
          }
          W[next + i3] = W[head + d];
          W[head + d] = i3;
        }
      }
      return nel;
    }
    function _wclear(mark, lemax, W, w2, n) {
      if (mark < 2 || mark + lemax < 0) {
        for (var k = 0; k < n; k++) {
          if (W[w2 + k] !== 0) {
            W[w2 + k] = 1;
          }
        }
        mark = 2;
      }
      return mark;
    }
    function _diag(i3, j) {
      return i3 !== j;
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csLeaf.js
  function csLeaf(i3, j, w2, first, maxfirst, prevleaf, ancestor) {
    var s, sparent;
    var jleaf = 0;
    var q;
    if (i3 <= j || w2[first + j] <= w2[maxfirst + i3]) {
      return -1;
    }
    w2[maxfirst + i3] = w2[first + j];
    var jprev = w2[prevleaf + i3];
    w2[prevleaf + i3] = j;
    if (jprev === -1) {
      jleaf = 1;
      q = i3;
    } else {
      jleaf = 2;
      for (q = jprev; q !== w2[ancestor + q]; q = w2[ancestor + q])
        ;
      for (s = jprev; s !== q; s = sparent) {
        sparent = w2[ancestor + s];
        w2[ancestor + s] = q;
      }
    }
    return {
      jleaf,
      q
    };
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csCounts.js
  var name230 = "csCounts";
  var dependencies230 = ["transpose"];
  var createCsCounts = /* @__PURE__ */ factory(name230, dependencies230, (_ref) => {
    var {
      transpose: transpose2
    } = _ref;
    return function(a, parent, post, ata) {
      if (!a || !parent || !post) {
        return null;
      }
      var asize = a._size;
      var m = asize[0];
      var n = asize[1];
      var i3, j, k, J, p, p0, p1;
      var s = 4 * n + (ata ? n + m + 1 : 0);
      var w2 = [];
      var ancestor = 0;
      var maxfirst = n;
      var prevleaf = 2 * n;
      var first = 3 * n;
      var head = 4 * n;
      var next = 5 * n + 1;
      for (k = 0; k < s; k++) {
        w2[k] = -1;
      }
      var colcount = [];
      var at = transpose2(a);
      var tindex = at._index;
      var tptr = at._ptr;
      for (k = 0; k < n; k++) {
        j = post[k];
        colcount[j] = w2[first + j] === -1 ? 1 : 0;
        for (; j !== -1 && w2[first + j] === -1; j = parent[j]) {
          w2[first + j] = k;
        }
      }
      if (ata) {
        for (k = 0; k < n; k++) {
          w2[post[k]] = k;
        }
        for (i3 = 0; i3 < m; i3++) {
          for (k = n, p0 = tptr[i3], p1 = tptr[i3 + 1], p = p0; p < p1; p++) {
            k = Math.min(k, w2[tindex[p]]);
          }
          w2[next + i3] = w2[head + k];
          w2[head + k] = i3;
        }
      }
      for (i3 = 0; i3 < n; i3++) {
        w2[ancestor + i3] = i3;
      }
      for (k = 0; k < n; k++) {
        j = post[k];
        if (parent[j] !== -1) {
          colcount[parent[j]]--;
        }
        for (J = ata ? w2[head + k] : j; J !== -1; J = ata ? w2[next + J] : -1) {
          for (p = tptr[J]; p < tptr[J + 1]; p++) {
            i3 = tindex[p];
            var r = csLeaf(i3, j, w2, first, maxfirst, prevleaf, ancestor);
            if (r.jleaf >= 1) {
              colcount[j]++;
            }
            if (r.jleaf === 2) {
              colcount[r.q]--;
            }
          }
        }
        if (parent[j] !== -1) {
          w2[ancestor + j] = parent[j];
        }
      }
      for (j = 0; j < n; j++) {
        if (parent[j] !== -1) {
          colcount[parent[j]] += colcount[j];
        }
      }
      return colcount;
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csSqr.js
  var name231 = "csSqr";
  var dependencies231 = ["add", "multiply", "transpose"];
  var createCsSqr = /* @__PURE__ */ factory(name231, dependencies231, (_ref) => {
    var {
      add: add3,
      multiply: multiply2,
      transpose: transpose2
    } = _ref;
    var csAmd = createCsAmd({
      add: add3,
      multiply: multiply2,
      transpose: transpose2
    });
    var csCounts = createCsCounts({
      transpose: transpose2
    });
    return function csSqr(order, a, qr2) {
      var aptr = a._ptr;
      var asize = a._size;
      var n = asize[1];
      var k;
      var s = {};
      s.q = csAmd(order, a);
      if (order && !s.q) {
        return null;
      }
      if (qr2) {
        var c = order ? csPermute(a, null, s.q, 0) : a;
        s.parent = csEtree(c, 1);
        var post = csPost(s.parent, n);
        s.cp = csCounts(c, s.parent, post, 1);
        if (c && s.parent && s.cp && _vcount(c, s)) {
          for (s.unz = 0, k = 0; k < n; k++) {
            s.unz += s.cp[k];
          }
        }
      } else {
        s.unz = 4 * aptr[n] + n;
        s.lnz = s.unz;
      }
      return s;
    };
    function _vcount(a, s) {
      var aptr = a._ptr;
      var aindex = a._index;
      var asize = a._size;
      var m = asize[0];
      var n = asize[1];
      s.pinv = [];
      s.leftmost = [];
      var parent = s.parent;
      var pinv2 = s.pinv;
      var leftmost = s.leftmost;
      var w2 = [];
      var next = 0;
      var head = m;
      var tail = m + n;
      var nque = m + 2 * n;
      var i3, k, p, p0, p1;
      for (k = 0; k < n; k++) {
        w2[head + k] = -1;
        w2[tail + k] = -1;
        w2[nque + k] = 0;
      }
      for (i3 = 0; i3 < m; i3++) {
        leftmost[i3] = -1;
      }
      for (k = n - 1; k >= 0; k--) {
        for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
          leftmost[aindex[p]] = k;
        }
      }
      for (i3 = m - 1; i3 >= 0; i3--) {
        pinv2[i3] = -1;
        k = leftmost[i3];
        if (k === -1) {
          continue;
        }
        if (w2[nque + k]++ === 0) {
          w2[tail + k] = i3;
        }
        w2[next + i3] = w2[head + k];
        w2[head + k] = i3;
      }
      s.lnz = 0;
      s.m2 = m;
      for (k = 0; k < n; k++) {
        i3 = w2[head + k];
        s.lnz++;
        if (i3 < 0) {
          i3 = s.m2++;
        }
        pinv2[i3] = k;
        if (--nque[k] <= 0) {
          continue;
        }
        s.lnz += w2[nque + k];
        var pa = parent[k];
        if (pa !== -1) {
          if (w2[nque + pa] === 0) {
            w2[tail + pa] = w2[tail + k];
          }
          w2[next + w2[tail + k]] = w2[head + pa];
          w2[head + pa] = w2[next + i3];
          w2[nque + pa] += w2[nque + k];
        }
      }
      for (i3 = 0; i3 < m; i3++) {
        if (pinv2[i3] < 0) {
          pinv2[i3] = k++;
        }
      }
      return true;
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csMarked.js
  function csMarked(w2, j) {
    return w2[j] < 0;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csMark.js
  function csMark(w2, j) {
    w2[j] = csFlip(w2[j]);
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csUnflip.js
  function csUnflip(i3) {
    return i3 < 0 ? csFlip(i3) : i3;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csDfs.js
  function csDfs(j, g2, top, xi, pinv2) {
    var index2 = g2._index;
    var ptr = g2._ptr;
    var size2 = g2._size;
    var n = size2[1];
    var i3, p, p2;
    var head = 0;
    xi[0] = j;
    while (head >= 0) {
      j = xi[head];
      var jnew = pinv2 ? pinv2[j] : j;
      if (!csMarked(ptr, j)) {
        csMark(ptr, j);
        xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
      }
      var done = 1;
      for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
        i3 = index2[p];
        if (csMarked(ptr, i3)) {
          continue;
        }
        xi[n + head] = p;
        xi[++head] = i3;
        done = 0;
        break;
      }
      if (done) {
        head--;
        xi[--top] = j;
      }
    }
    return top;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csReach.js
  function csReach(g2, b, k, xi, pinv2) {
    var gptr = g2._ptr;
    var gsize = g2._size;
    var bindex = b._index;
    var bptr = b._ptr;
    var n = gsize[1];
    var p, p0, p1;
    var top = n;
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
      var i3 = bindex[p];
      if (!csMarked(gptr, i3)) {
        top = csDfs(i3, g2, top, xi, pinv2);
      }
    }
    for (p = top; p < n; p++) {
      csMark(gptr, xi[p]);
    }
    return top;
  }

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csSpsolve.js
  var name232 = "csSpsolve";
  var dependencies232 = ["divideScalar", "multiply", "subtract"];
  var createCsSpsolve = /* @__PURE__ */ factory(name232, dependencies232, (_ref) => {
    var {
      divideScalar: divideScalar2,
      multiply: multiply2,
      subtract: subtract2
    } = _ref;
    return function csSpsolve(g2, b, k, xi, x, pinv2, lo) {
      var gvalues = g2._values;
      var gindex = g2._index;
      var gptr = g2._ptr;
      var gsize = g2._size;
      var n = gsize[1];
      var bvalues = b._values;
      var bindex = b._index;
      var bptr = b._ptr;
      var p, p0, p1, q;
      var top = csReach(g2, b, k, xi, pinv2);
      for (p = top; p < n; p++) {
        x[xi[p]] = 0;
      }
      for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
        x[bindex[p]] = bvalues[p];
      }
      for (var px = top; px < n; px++) {
        var j = xi[px];
        var J = pinv2 ? pinv2[j] : j;
        if (J < 0) {
          continue;
        }
        p0 = gptr[J];
        p1 = gptr[J + 1];
        x[j] = divideScalar2(x[j], gvalues[lo ? p0 : p1 - 1]);
        p = lo ? p0 + 1 : p0;
        q = lo ? p1 : p1 - 1;
        for (; p < q; p++) {
          var i3 = gindex[p];
          x[i3] = subtract2(x[i3], multiply2(gvalues[p], x[j]));
        }
      }
      return top;
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csLu.js
  var name233 = "csLu";
  var dependencies233 = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
  var createCsLu = /* @__PURE__ */ factory(name233, dependencies233, (_ref) => {
    var {
      abs: abs3,
      divideScalar: divideScalar2,
      multiply: multiply2,
      subtract: subtract2,
      larger: larger2,
      largerEq: largerEq2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    var csSpsolve = createCsSpsolve({
      divideScalar: divideScalar2,
      multiply: multiply2,
      subtract: subtract2
    });
    return function csLu(m, s, tol) {
      if (!m) {
        return null;
      }
      var size2 = m._size;
      var n = size2[1];
      var q;
      var lnz = 100;
      var unz = 100;
      if (s) {
        q = s.q;
        lnz = s.lnz || lnz;
        unz = s.unz || unz;
      }
      var lvalues = [];
      var lindex = [];
      var lptr = [];
      var L = new SparseMatrix2({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: [n, n]
      });
      var uvalues = [];
      var uindex = [];
      var uptr = [];
      var U = new SparseMatrix2({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: [n, n]
      });
      var pinv2 = [];
      var i3, p;
      var x = [];
      var xi = [];
      for (i3 = 0; i3 < n; i3++) {
        x[i3] = 0;
        pinv2[i3] = -1;
        lptr[i3 + 1] = 0;
      }
      lnz = 0;
      unz = 0;
      for (var k = 0; k < n; k++) {
        lptr[k] = lnz;
        uptr[k] = unz;
        var col = q ? q[k] : k;
        var top = csSpsolve(L, m, col, xi, x, pinv2, 1);
        var ipiv = -1;
        var a = -1;
        for (p = top; p < n; p++) {
          i3 = xi[p];
          if (pinv2[i3] < 0) {
            var xabs = abs3(x[i3]);
            if (larger2(xabs, a)) {
              a = xabs;
              ipiv = i3;
            }
          } else {
            uindex[unz] = pinv2[i3];
            uvalues[unz++] = x[i3];
          }
        }
        if (ipiv === -1 || a <= 0) {
          return null;
        }
        if (pinv2[col] < 0 && largerEq2(abs3(x[col]), multiply2(a, tol))) {
          ipiv = col;
        }
        var pivot = x[ipiv];
        uindex[unz] = k;
        uvalues[unz++] = pivot;
        pinv2[ipiv] = k;
        lindex[lnz] = ipiv;
        lvalues[lnz++] = 1;
        for (p = top; p < n; p++) {
          i3 = xi[p];
          if (pinv2[i3] < 0) {
            lindex[lnz] = i3;
            lvalues[lnz++] = divideScalar2(x[i3], pivot);
          }
          x[i3] = 0;
        }
      }
      lptr[n] = lnz;
      uptr[n] = unz;
      for (p = 0; p < lnz; p++) {
        lindex[p] = pinv2[lindex[p]];
      }
      lvalues.splice(lnz, lvalues.length - lnz);
      lindex.splice(lnz, lindex.length - lnz);
      uvalues.splice(unz, uvalues.length - unz);
      uindex.splice(unz, uindex.length - unz);
      return {
        L,
        U,
        pinv: pinv2
      };
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/slu.js
  var name234 = "slu";
  var dependencies234 = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
  var createSlu = /* @__PURE__ */ factory(name234, dependencies234, (_ref) => {
    var {
      typed: typed3,
      abs: abs3,
      add: add3,
      multiply: multiply2,
      transpose: transpose2,
      divideScalar: divideScalar2,
      subtract: subtract2,
      larger: larger2,
      largerEq: largerEq2,
      SparseMatrix: SparseMatrix2
    } = _ref;
    var csSqr = createCsSqr({
      add: add3,
      multiply: multiply2,
      transpose: transpose2
    });
    var csLu = createCsLu({
      abs: abs3,
      divideScalar: divideScalar2,
      multiply: multiply2,
      subtract: subtract2,
      larger: larger2,
      largerEq: largerEq2,
      SparseMatrix: SparseMatrix2
    });
    return typed3(name234, {
      "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
        if (!isInteger(order) || order < 0 || order > 3) {
          throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
        }
        if (threshold < 0 || threshold > 1) {
          throw new Error("Partial pivoting threshold must be a number from 0 to 1");
        }
        var s = csSqr(order, a, false);
        var f = csLu(a, s, threshold);
        return {
          L: f.L,
          U: f.U,
          p: f.pinv,
          q: s.q,
          toString: function toString() {
            return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
          }
        };
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/sparse/csIpvec.js
  function csIpvec(p, b) {
    var k;
    var n = b.length;
    var x = [];
    if (p) {
      for (k = 0; k < n; k++) {
        x[p[k]] = b[k];
      }
    } else {
      for (k = 0; k < n; k++) {
        x[k] = b[k];
      }
    }
    return x;
  }

  // node_modules/mathjs/lib/esm/function/algebra/solver/lusolve.js
  var name235 = "lusolve";
  var dependencies235 = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
  var createLusolve = /* @__PURE__ */ factory(name235, dependencies235, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      lup: lup2,
      slu: slu2,
      usolve: usolve2,
      lsolve: lsolve2,
      DenseMatrix: DenseMatrix2
    } = _ref;
    var solveValidation = createSolveValidation({
      DenseMatrix: DenseMatrix2
    });
    return typed3(name235, {
      "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
        a = matrix2(a);
        var d = lup2(a);
        var x = _lusolve(d.L, d.U, d.p, null, b);
        return x.valueOf();
      },
      "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
        var d = lup2(a);
        return _lusolve(d.L, d.U, d.p, null, b);
      },
      "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
        var d = lup2(a);
        return _lusolve(d.L, d.U, d.p, null, b);
      },
      "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
        var d = slu2(a, order, threshold);
        return _lusolve(d.L, d.U, d.p, d.q, b);
      },
      "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
        return _lusolve(d.L, d.U, d.p, d.q, b);
      }
    });
    function _toMatrix(a) {
      if (isMatrix(a)) {
        return a;
      }
      if (isArray(a)) {
        return matrix2(a);
      }
      throw new TypeError("Invalid Matrix LU decomposition");
    }
    function _lusolve(l, u, p, q, b) {
      l = _toMatrix(l);
      u = _toMatrix(u);
      if (p) {
        b = solveValidation(l, b, true);
        b._data = csIpvec(p, b._data);
      }
      var y2 = lsolve2(l, b);
      var x = usolve2(u, y2);
      if (q) {
        x._data = csIpvec(q, x._data);
      }
      return x;
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/polynomialRoot.js
  var name236 = "polynomialRoot";
  var dependencies236 = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
  var createPolynomialRoot = /* @__PURE__ */ factory(name236, dependencies236, (_ref) => {
    var {
      typed: typed3,
      isZero: isZero2,
      equalScalar: equalScalar2,
      add: add3,
      subtract: subtract2,
      multiply: multiply2,
      divide: divide3,
      sqrt: sqrt3,
      unaryMinus: unaryMinus2,
      cbrt: cbrt5,
      typeOf: typeOf3,
      im: im2,
      re: re2
    } = _ref;
    return typed3(name236, {
      "number|Complex, ...number|Complex": (constant, restCoeffs) => {
        var coeffs = [constant, ...restCoeffs];
        while (coeffs.length > 0 && isZero2(coeffs[coeffs.length - 1])) {
          coeffs.pop();
        }
        if (coeffs.length < 2) {
          throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
        }
        switch (coeffs.length) {
          case 2:
            return [unaryMinus2(divide3(coeffs[0], coeffs[1]))];
          case 3: {
            var [c, b, a] = coeffs;
            var denom = multiply2(2, a);
            var d1 = multiply2(b, b);
            var d2 = multiply2(4, a, c);
            if (equalScalar2(d1, d2))
              return [divide3(unaryMinus2(b), denom)];
            var discriminant = sqrt3(subtract2(d1, d2));
            return [divide3(subtract2(discriminant, b), denom), divide3(subtract2(unaryMinus2(discriminant), b), denom)];
          }
          case 4: {
            var [d, _c, _b, _a] = coeffs;
            var _denom = unaryMinus2(multiply2(3, _a));
            var D0_1 = multiply2(_b, _b);
            var D0_2 = multiply2(3, _a, _c);
            var D1_1 = add3(multiply2(2, _b, _b, _b), multiply2(27, _a, _a, d));
            var D1_2 = multiply2(9, _a, _b, _c);
            if (equalScalar2(D0_1, D0_2) && equalScalar2(D1_1, D1_2)) {
              return [divide3(_b, _denom)];
            }
            var Delta0 = subtract2(D0_1, D0_2);
            var Delta1 = subtract2(D1_1, D1_2);
            var discriminant1 = add3(multiply2(18, _a, _b, _c, d), multiply2(_b, _b, _c, _c));
            var discriminant2 = add3(multiply2(4, _b, _b, _b, d), multiply2(4, _a, _c, _c, _c), multiply2(27, _a, _a, d, d));
            if (equalScalar2(discriminant1, discriminant2)) {
              return [
                divide3(subtract2(multiply2(4, _a, _b, _c), add3(multiply2(9, _a, _a, d), multiply2(_b, _b, _b))), multiply2(_a, Delta0)),
                // simple root
                divide3(subtract2(multiply2(9, _a, d), multiply2(_b, _c)), multiply2(2, Delta0))
                // double root
              ];
            }
            var Ccubed;
            if (equalScalar2(D0_1, D0_2)) {
              Ccubed = Delta1;
            } else {
              Ccubed = divide3(add3(Delta1, sqrt3(subtract2(multiply2(Delta1, Delta1), multiply2(4, Delta0, Delta0, Delta0)))), 2);
            }
            var allRoots = true;
            var rawRoots = cbrt5(Ccubed, allRoots).toArray().map((C2) => divide3(add3(_b, C2, divide3(Delta0, C2)), _denom));
            return rawRoots.map((r) => {
              if (typeOf3(r) === "Complex" && equalScalar2(re2(r), re2(r) + im2(r))) {
                return re2(r);
              }
              return r;
            });
          }
          default:
            throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
        }
      }
    });
  });

  // node_modules/mathjs/lib/esm/expression/Help.js
  var name237 = "Help";
  var dependencies237 = ["parse"];
  var createHelpClass = /* @__PURE__ */ factory(name237, dependencies237, (_ref) => {
    var {
      parse: parse2
    } = _ref;
    function Help2(doc) {
      if (!(this instanceof Help2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (!doc)
        throw new Error('Argument "doc" missing');
      this.doc = doc;
    }
    Help2.prototype.type = "Help";
    Help2.prototype.isHelp = true;
    Help2.prototype.toString = function() {
      var doc = this.doc || {};
      var desc = "\n";
      if (doc.name) {
        desc += "Name: " + doc.name + "\n\n";
      }
      if (doc.category) {
        desc += "Category: " + doc.category + "\n\n";
      }
      if (doc.description) {
        desc += "Description:\n    " + doc.description + "\n\n";
      }
      if (doc.syntax) {
        desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
      }
      if (doc.examples) {
        desc += "Examples:\n";
        var scope = {};
        for (var i3 = 0; i3 < doc.examples.length; i3++) {
          var expr = doc.examples[i3];
          desc += "    " + expr + "\n";
          var res = void 0;
          try {
            res = parse2(expr).compile().evaluate(scope);
          } catch (e3) {
            res = e3;
          }
          if (res !== void 0 && !isHelp(res)) {
            desc += "        " + format3(res, {
              precision: 14
            }) + "\n";
          }
        }
        desc += "\n";
      }
      if (doc.mayThrow && doc.mayThrow.length) {
        desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
      }
      if (doc.seealso && doc.seealso.length) {
        desc += "See also: " + doc.seealso.join(", ") + "\n";
      }
      return desc;
    };
    Help2.prototype.toJSON = function() {
      var obj = clone(this.doc);
      obj.mathjs = "Help";
      return obj;
    };
    Help2.fromJSON = function(json) {
      var doc = {};
      Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
        doc[prop] = json[prop];
      });
      return new Help2(doc);
    };
    Help2.prototype.valueOf = Help2.prototype.toString;
    return Help2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/type/chain/Chain.js
  var name238 = "Chain";
  var dependencies238 = ["?on", "math", "typed"];
  var createChainClass = /* @__PURE__ */ factory(name238, dependencies238, (_ref) => {
    var {
      on,
      math: math2,
      typed: typed3
    } = _ref;
    function Chain2(value) {
      if (!(this instanceof Chain2)) {
        throw new SyntaxError("Constructor must be called with the new operator");
      }
      if (isChain(value)) {
        this.value = value.value;
      } else {
        this.value = value;
      }
    }
    Chain2.prototype.type = "Chain";
    Chain2.prototype.isChain = true;
    Chain2.prototype.done = function() {
      return this.value;
    };
    Chain2.prototype.valueOf = function() {
      return this.value;
    };
    Chain2.prototype.toString = function() {
      return format3(this.value);
    };
    Chain2.prototype.toJSON = function() {
      return {
        mathjs: "Chain",
        value: this.value
      };
    };
    Chain2.fromJSON = function(json) {
      return new Chain2(json.value);
    };
    function createProxy(name310, fn) {
      if (typeof fn === "function") {
        Chain2.prototype[name310] = chainify(fn);
      }
    }
    function createLazyProxy(name310, resolver) {
      lazy(Chain2.prototype, name310, function outerResolver() {
        var fn = resolver();
        if (typeof fn === "function") {
          return chainify(fn);
        }
        return void 0;
      });
    }
    function chainify(fn) {
      return function() {
        if (arguments.length === 0) {
          return new Chain2(fn(this.value));
        }
        var args = [this.value];
        for (var i3 = 0; i3 < arguments.length; i3++) {
          args[i3 + 1] = arguments[i3];
        }
        if (typed3.isTypedFunction(fn)) {
          var sigObject = typed3.resolve(fn, args);
          if (sigObject.params.length === 1) {
            throw new Error("chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments.");
          }
          return new Chain2(sigObject.implementation.apply(fn, args));
        }
        return new Chain2(fn.apply(fn, args));
      };
    }
    Chain2.createProxy = function(arg0, arg1) {
      if (typeof arg0 === "string") {
        createProxy(arg0, arg1);
      } else {
        var _loop = function _loop2(_name2) {
          if (hasOwnProperty(arg0, _name2) && excludedNames[_name2] === void 0) {
            createLazyProxy(_name2, () => arg0[_name2]);
          }
        };
        for (var _name in arg0) {
          _loop(_name);
        }
      }
    };
    var excludedNames = {
      expression: true,
      docs: true,
      type: true,
      classes: true,
      json: true,
      error: true,
      isChain: true
      // conflicts with the property isChain of a Chain instance
    };
    Chain2.createProxy(math2);
    if (on) {
      on("import", function(name310, resolver, path) {
        if (!path) {
          createLazyProxy(name310, resolver);
        }
      });
    }
    return Chain2;
  }, {
    isClass: true
  });

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/e.js
  var eDocs = {
    name: "e",
    category: "Constants",
    syntax: ["e"],
    description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
    examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
    seealso: ["exp"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/false.js
  var falseDocs = {
    name: "false",
    category: "Constants",
    syntax: ["false"],
    description: "Boolean value false",
    examples: ["false"],
    seealso: ["true"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/i.js
  var iDocs = {
    name: "i",
    category: "Constants",
    syntax: ["i"],
    description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
    examples: ["i", "i * i", "sqrt(-1)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/Infinity.js
  var InfinityDocs = {
    name: "Infinity",
    category: "Constants",
    syntax: ["Infinity"],
    description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
    examples: ["Infinity", "1 / 0"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN10.js
  var LN10Docs = {
    name: "LN10",
    category: "Constants",
    syntax: ["LN10"],
    description: "Returns the natural logarithm of 10, approximately equal to 2.302",
    examples: ["LN10", "log(10)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LN2.js
  var LN2Docs = {
    name: "LN2",
    category: "Constants",
    syntax: ["LN2"],
    description: "Returns the natural logarithm of 2, approximately equal to 0.693",
    examples: ["LN2", "log(2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG10E.js
  var LOG10EDocs = {
    name: "LOG10E",
    category: "Constants",
    syntax: ["LOG10E"],
    description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
    examples: ["LOG10E", "log(e, 10)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/LOG2E.js
  var LOG2EDocs = {
    name: "LOG2E",
    category: "Constants",
    syntax: ["LOG2E"],
    description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
    examples: ["LOG2E", "log(e, 2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/NaN.js
  var NaNDocs = {
    name: "NaN",
    category: "Constants",
    syntax: ["NaN"],
    description: "Not a number",
    examples: ["NaN", "0 / 0"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/null.js
  var nullDocs = {
    name: "null",
    category: "Constants",
    syntax: ["null"],
    description: "Value null",
    examples: ["null"],
    seealso: ["true", "false"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/phi.js
  var phiDocs = {
    name: "phi",
    category: "Constants",
    syntax: ["phi"],
    description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
    examples: ["phi"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/pi.js
  var piDocs = {
    name: "pi",
    category: "Constants",
    syntax: ["pi"],
    description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
    examples: ["pi", "sin(pi/2)"],
    seealso: ["tau"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT1_2.js
  var SQRT12Docs = {
    name: "SQRT1_2",
    category: "Constants",
    syntax: ["SQRT1_2"],
    description: "Returns the square root of 1/2, approximately equal to 0.707",
    examples: ["SQRT1_2", "sqrt(1/2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/SQRT2.js
  var SQRT2Docs = {
    name: "SQRT2",
    category: "Constants",
    syntax: ["SQRT2"],
    description: "Returns the square root of 2, approximately equal to 1.414",
    examples: ["SQRT2", "sqrt(2)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/tau.js
  var tauDocs = {
    name: "tau",
    category: "Constants",
    syntax: ["tau"],
    description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
    examples: ["tau", "2 * pi"],
    seealso: ["pi"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/true.js
  var trueDocs = {
    name: "true",
    category: "Constants",
    syntax: ["true"],
    description: "Boolean value true",
    examples: ["true"],
    seealso: ["false"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/constants/version.js
  var versionDocs = {
    name: "version",
    category: "Constants",
    syntax: ["version"],
    description: "A string with the version number of math.js",
    examples: ["version"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/bignumber.js
  var bignumberDocs = {
    name: "bignumber",
    category: "Construction",
    syntax: ["bignumber(x)"],
    description: "Create a big number from a number or string.",
    examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
    seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/boolean.js
  var booleanDocs = {
    name: "boolean",
    category: "Construction",
    syntax: ["x", "boolean(x)"],
    description: "Convert a string or number into a boolean.",
    examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
    seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/complex.js
  var complexDocs = {
    name: "complex",
    category: "Construction",
    syntax: ["complex()", "complex(re, im)", "complex(string)"],
    description: "Create a complex number.",
    examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
    seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/createUnit.js
  var createUnitDocs = {
    name: "createUnit",
    category: "Construction",
    syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
    description: "Create a user-defined unit and register it with the Unit type.",
    examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
    seealso: ["unit", "splitUnit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/fraction.js
  var fractionDocs = {
    name: "fraction",
    category: "Construction",
    syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
    description: "Create a fraction from a number or from integer numerator and denominator.",
    examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
    seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/index.js
  var indexDocs = {
    name: "index",
    category: "Construction",
    syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
    description: "Create an index to get or replace a subset of a matrix",
    examples: ["A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = 1", "B = [1, 2, 3]", "B[B>1 and B<3]"],
    seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/matrix.js
  var matrixDocs = {
    name: "matrix",
    category: "Construction",
    syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
    description: "Create a matrix.",
    examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
    seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/number.js
  var numberDocs = {
    name: "number",
    category: "Construction",
    syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
    description: "Create a number or convert a string or boolean into a number.",
    examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
    seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/sparse.js
  var sparseDocs = {
    name: "sparse",
    category: "Construction",
    syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
    description: "Create a sparse matrix.",
    examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
    seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/splitUnit.js
  var splitUnitDocs = {
    name: "splitUnit",
    category: "Construction",
    syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
    description: "Split a unit in an array of units whose sum is equal to the original unit.",
    examples: ['splitUnit(1 m, ["feet", "inch"])'],
    seealso: ["unit", "createUnit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/string.js
  var stringDocs = {
    name: "string",
    category: "Construction",
    syntax: ['"text"', "string(x)"],
    description: "Create a string or convert a value to a string",
    examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
    seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/construction/unit.js
  var unitDocs = {
    name: "unit",
    category: "Construction",
    syntax: ["value unit", "unit(value, unit)", "unit(string)"],
    description: "Create a unit.",
    examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
    seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/config.js
  var configDocs = {
    name: "config",
    category: "Core",
    syntax: ["config()", "config(options)"],
    description: "Get configuration or change configuration.",
    examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/import.js
  var importDocs = {
    name: "import",
    category: "Core",
    syntax: ["import(functions)", "import(functions, options)"],
    description: "Import functions or constants from an object.",
    examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/core/typed.js
  var typedDocs = {
    name: "typed",
    category: "Core",
    syntax: ["typed(signatures)", "typed(name, signatures)"],
    description: "Create a typed function.",
    examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', "double(2)", 'double("hello")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/derivative.js
  var derivativeDocs = {
    name: "derivative",
    category: "Algebra",
    syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
    description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
    examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
    seealso: ["simplify", "parse", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/leafCount.js
  var leafCountDocs = {
    name: "leafCount",
    category: "Algebra",
    syntax: ["leafCount(expr)"],
    description: "Computes the number of leaves in the parse tree of the given expression",
    examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
    seealso: ["simplify"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolve.js
  var lsolveDocs = {
    name: "lsolve",
    category: "Algebra",
    syntax: ["x=lsolve(L, b)"],
    description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lsolveAll.js
  var lsolveAllDocs = {
    name: "lsolveAll",
    category: "Algebra",
    syntax: ["x=lsolveAll(L, b)"],
    description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
    seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lup.js
  var lupDocs = {
    name: "lup",
    category: "Algebra",
    syntax: ["lup(m)"],
    description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
    examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lusolve.js
  var lusolveDocs = {
    name: "lusolve",
    category: "Algebra",
    syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
    description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
    examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
    seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/polynomialRoot.js
  var polynomialRootDocs = {
    name: "polynomialRoot",
    category: "Algebra",
    syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
    description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
    examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
    seealso: ["cbrt", "sqrt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/qr.js
  var qrDocs = {
    name: "qr",
    category: "Algebra",
    syntax: ["qr(A)"],
    description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
    examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
    seealso: ["lup", "slu", "matrix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/rationalize.js
  var rationalizeDocs = {
    name: "rationalize",
    category: "Algebra",
    syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
    description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
    examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
    seealso: ["simplify"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/resolve.js
  var resolveDocs = {
    name: "resolve",
    category: "Algebra",
    syntax: ["resolve(node, scope)"],
    description: "Recursively substitute variables in an expression tree.",
    examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
    seealso: ["simplify", "evaluate"],
    mayThrow: ["ReferenceError"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplify.js
  var simplifyDocs = {
    name: "simplify",
    category: "Algebra",
    syntax: ["simplify(expr)", "simplify(expr, rules)"],
    description: "Simplify an expression tree.",
    examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
    seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyConstant.js
  var simplifyConstantDocs = {
    name: "simplifyConstant",
    category: "Algebra",
    syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
    description: "Replace constant subexpressions of node with their values.",
    examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
    seealso: ["simplify", "simplifyCore", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/simplifyCore.js
  var simplifyCoreDocs = {
    name: "simplifyCore",
    category: "Algebra",
    syntax: ["simplifyCore(node)"],
    description: "Perform simple one-pass simplifications on an expression tree.",
    examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
    seealso: ["simplify", "simplifyConstant", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/slu.js
  var sluDocs = {
    name: "slu",
    category: "Algebra",
    syntax: ["slu(A, order, threshold)"],
    description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
    examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
    seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/symbolicEqual.js
  var symbolicEqualDocs = {
    name: "symbolicEqual",
    category: "Algebra",
    syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
    description: "Returns true if the difference of the expressions simplifies to 0",
    examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
    seealso: ["simplify", "evaluate"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolve.js
  var usolveDocs = {
    name: "usolve",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
    seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/usolveAll.js
  var usolveAllDocs = {
    name: "usolveAll",
    category: "Algebra",
    syntax: ["x=usolve(U, b)"],
    description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
    examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
    seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/abs.js
  var absDocs = {
    name: "abs",
    category: "Arithmetic",
    syntax: ["abs(x)"],
    description: "Compute the absolute value.",
    examples: ["abs(3.5)", "abs(-4.2)"],
    seealso: ["sign"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/add.js
  var addDocs = {
    name: "add",
    category: "Operators",
    syntax: ["x + y", "add(x, y)"],
    description: "Add two values.",
    examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
    seealso: ["subtract"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cbrt.js
  var cbrtDocs = {
    name: "cbrt",
    category: "Arithmetic",
    syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
    description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
    examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
    seealso: ["square", "sqrt", "cube", "multiply"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/ceil.js
  var ceilDocs = {
    name: "ceil",
    category: "Arithmetic",
    syntax: ["ceil(x)"],
    description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
    examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
    seealso: ["floor", "fix", "round"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/cube.js
  var cubeDocs = {
    name: "cube",
    category: "Arithmetic",
    syntax: ["cube(x)"],
    description: "Compute the cube of a value. The cube of x is x * x * x.",
    examples: ["cube(2)", "2^3", "2 * 2 * 2"],
    seealso: ["multiply", "square", "pow"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/divide.js
  var divideDocs = {
    name: "divide",
    category: "Operators",
    syntax: ["x / y", "divide(x, y)"],
    description: "Divide two values.",
    examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
    seealso: ["multiply"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotDivide.js
  var dotDivideDocs = {
    name: "dotDivide",
    category: "Operators",
    syntax: ["x ./ y", "dotDivide(x, y)"],
    description: "Divide two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
    seealso: ["multiply", "dotMultiply", "divide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotMultiply.js
  var dotMultiplyDocs = {
    name: "dotMultiply",
    category: "Operators",
    syntax: ["x .* y", "dotMultiply(x, y)"],
    description: "Multiply two values element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
    seealso: ["multiply", "divide", "dotDivide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/dotPow.js
  var dotPowDocs = {
    name: "dotPow",
    category: "Operators",
    syntax: ["x .^ y", "dotPow(x, y)"],
    description: "Calculates the power of x to y element wise.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
    seealso: ["pow"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/exp.js
  var expDocs = {
    name: "exp",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description: "Calculate the exponent of a value.",
    examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
    seealso: ["expm", "expm1", "pow", "log"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm.js
  var expmDocs = {
    name: "expm",
    category: "Arithmetic",
    syntax: ["exp(x)"],
    description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
    examples: ["expm([[0,2],[0,0]])"],
    seealso: ["exp"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/expm1.js
  var expm1Docs = {
    name: "expm1",
    category: "Arithmetic",
    syntax: ["expm1(x)"],
    description: "Calculate the value of subtracting 1 from the exponential value.",
    examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
    seealso: ["exp", "pow", "log"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/fix.js
  var fixDocs = {
    name: "fix",
    category: "Arithmetic",
    syntax: ["fix(x)"],
    description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
    examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
    seealso: ["ceil", "floor", "round"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/floor.js
  var floorDocs = {
    name: "floor",
    category: "Arithmetic",
    syntax: ["floor(x)"],
    description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
    examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
    seealso: ["ceil", "fix", "round"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/gcd.js
  var gcdDocs = {
    name: "gcd",
    category: "Arithmetic",
    syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
    description: "Compute the greatest common divisor.",
    examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
    seealso: ["lcm", "xgcd"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/hypot.js
  var hypotDocs = {
    name: "hypot",
    category: "Arithmetic",
    syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
    description: "Calculate the hypotenusa of a list with values. ",
    examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
    seealso: ["abs", "norm"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/invmod.js
  var invmodDocs = {
    name: "invmod",
    category: "Arithmetic",
    syntax: ["invmod(a, b)"],
    description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax \u2263 1 (mod b)",
    examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
    seealso: ["gcd", "xgcd"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/lcm.js
  var lcmDocs = {
    name: "lcm",
    category: "Arithmetic",
    syntax: ["lcm(x, y)"],
    description: "Compute the least common multiple.",
    examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
    seealso: ["gcd"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log.js
  var logDocs = {
    name: "log",
    category: "Arithmetic",
    syntax: ["log(x)", "log(x, base)"],
    description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
    examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
    seealso: ["exp", "log1p", "log2", "log10"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log10.js
  var log10Docs = {
    name: "log10",
    category: "Arithmetic",
    syntax: ["log10(x)"],
    description: "Compute the 10-base logarithm of a value.",
    examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
    seealso: ["exp", "log"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log1p.js
  var log1pDocs = {
    name: "log1p",
    category: "Arithmetic",
    syntax: ["log1p(x)", "log1p(x, base)"],
    description: "Calculate the logarithm of a `value+1`",
    examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
    seealso: ["exp", "log", "log2", "log10"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/log2.js
  var log2Docs = {
    name: "log2",
    category: "Arithmetic",
    syntax: ["log2(x)"],
    description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
    examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
    seealso: ["exp", "log1p", "log", "log10"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/mod.js
  var modDocs = {
    name: "mod",
    category: "Operators",
    syntax: ["x % y", "x mod y", "mod(x, y)"],
    description: "Calculates the modulus, the remainder of an integer division.",
    examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
    seealso: ["divide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/multiply.js
  var multiplyDocs = {
    name: "multiply",
    category: "Operators",
    syntax: ["x * y", "multiply(x, y)"],
    description: "multiply two values.",
    examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
    seealso: ["divide"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/norm.js
  var normDocs = {
    name: "norm",
    category: "Arithmetic",
    syntax: ["norm(x)", "norm(x, p)"],
    description: "Calculate the norm of a number, vector or matrix.",
    examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoot.js
  var nthRootDocs = {
    name: "nthRoot",
    category: "Arithmetic",
    syntax: ["nthRoot(a)", "nthRoot(a, root)"],
    description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
    examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
    seealso: ["nthRoots", "pow", "sqrt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/nthRoots.js
  var nthRootsDocs = {
    name: "nthRoots",
    category: "Arithmetic",
    syntax: ["nthRoots(A)", "nthRoots(A, root)"],
    description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
    examples: ["nthRoots(1)", "nthRoots(1, 3)"],
    seealso: ["sqrt", "pow", "nthRoot"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/pow.js
  var powDocs = {
    name: "pow",
    category: "Operators",
    syntax: ["x ^ y", "pow(x, y)"],
    description: "Calculates the power of x to y, x^y.",
    examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
    seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/round.js
  var roundDocs = {
    name: "round",
    category: "Arithmetic",
    syntax: ["round(x)", "round(x, n)", "round(unit, valuelessUnit)", "round(unit, n, valuelessUnit)"],
    description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
    examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)", "round(3.241cm, 2, cm)", "round([3.2, 3.8, -4.7])"],
    seealso: ["ceil", "floor", "fix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sign.js
  var signDocs = {
    name: "sign",
    category: "Arithmetic",
    syntax: ["sign(x)"],
    description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
    examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
    seealso: ["abs"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrt.js
  var sqrtDocs = {
    name: "sqrt",
    category: "Arithmetic",
    syntax: ["sqrt(x)"],
    description: "Compute the square root value. If x = y * y, then y is the square root of x.",
    examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
    seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/sqrtm.js
  var sqrtmDocs = {
    name: "sqrtm",
    category: "Arithmetic",
    syntax: ["sqrtm(x)"],
    description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
    examples: ["sqrtm([[33, 24], [48, 57]])"],
    seealso: ["sqrt", "abs", "square", "multiply"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/sylvester.js
  var sylvesterDocs = {
    name: "sylvester",
    category: "Algebra",
    syntax: ["sylvester(A,B,C)"],
    description: "Solves the real-valued Sylvester equation AX+XB=C for X",
    examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]", "sylvester(A, B, C)"],
    seealso: ["schur", "lyap"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/schur.js
  var schurDocs = {
    name: "schur",
    category: "Algebra",
    syntax: ["schur(A)"],
    description: "Performs a real Schur decomposition of the real matrix A = UTU'",
    examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
    seealso: ["lyap", "sylvester"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/algebra/lyap.js
  var lyapDocs = {
    name: "lyap",
    category: "Algebra",
    syntax: ["lyap(A,Q)"],
    description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
    examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "A = [[-2, 0], [1, -4]]", "Q = [[3, 1], [1, 3]]", "lyap(A,Q)"],
    seealso: ["schur", "sylvester"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/square.js
  var squareDocs = {
    name: "square",
    category: "Arithmetic",
    syntax: ["square(x)"],
    description: "Compute the square of a value. The square of x is x * x.",
    examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
    seealso: ["multiply", "pow", "sqrt", "cube"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/subtract.js
  var subtractDocs = {
    name: "subtract",
    category: "Operators",
    syntax: ["x - y", "subtract(x, y)"],
    description: "subtract two values.",
    examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
    seealso: ["add"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryMinus.js
  var unaryMinusDocs = {
    name: "unaryMinus",
    category: "Operators",
    syntax: ["-x", "unaryMinus(x)"],
    description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
    examples: ["-4.5", "-(-5.6)", '-"22"'],
    seealso: ["add", "subtract", "unaryPlus"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/unaryPlus.js
  var unaryPlusDocs = {
    name: "unaryPlus",
    category: "Operators",
    syntax: ["+x", "unaryPlus(x)"],
    description: "Converts booleans and strings to numbers.",
    examples: ["+true", '+"2"'],
    seealso: ["add", "subtract", "unaryMinus"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/arithmetic/xgcd.js
  var xgcdDocs = {
    name: "xgcd",
    category: "Arithmetic",
    syntax: ["xgcd(a, b)"],
    description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
    examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
    seealso: ["gcd", "lcm"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitAnd.js
  var bitAndDocs = {
    name: "bitAnd",
    category: "Bitwise",
    syntax: ["x & y", "bitAnd(x, y)"],
    description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
    examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
    seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitNot.js
  var bitNotDocs = {
    name: "bitNot",
    category: "Bitwise",
    syntax: ["~x", "bitNot(x)"],
    description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
    examples: ["~1", "~2", "bitNot([2, -3, 4])"],
    seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitOr.js
  var bitOrDocs = {
    name: "bitOr",
    category: "Bitwise",
    syntax: ["x | y", "bitOr(x, y)"],
    description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
    examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
    seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/bitXor.js
  var bitXorDocs = {
    name: "bitXor",
    category: "Bitwise",
    syntax: ["bitXor(x, y)"],
    description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
    examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
    seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/leftShift.js
  var leftShiftDocs = {
    name: "leftShift",
    category: "Bitwise",
    syntax: ["x << y", "leftShift(x, y)"],
    description: "Bitwise left logical shift of a value x by y number of bits.",
    examples: ["4 << 1", "8 >> 1"],
    seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightArithShift.js
  var rightArithShiftDocs = {
    name: "rightArithShift",
    category: "Bitwise",
    syntax: ["x >> y", "rightArithShift(x, y)"],
    description: "Bitwise right arithmetic shift of a value x by y number of bits.",
    examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
    seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/bitwise/rightLogShift.js
  var rightLogShiftDocs = {
    name: "rightLogShift",
    category: "Bitwise",
    syntax: ["x >>> y", "rightLogShift(x, y)"],
    description: "Bitwise right logical shift of a value x by y number of bits.",
    examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
    seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/bellNumbers.js
  var bellNumbersDocs = {
    name: "bellNumbers",
    category: "Combinatorics",
    syntax: ["bellNumbers(n)"],
    description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["bellNumbers(3)", "bellNumbers(8)"],
    seealso: ["stirlingS2"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/catalan.js
  var catalanDocs = {
    name: "catalan",
    category: "Combinatorics",
    syntax: ["catalan(n)"],
    description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
    examples: ["catalan(3)", "catalan(8)"],
    seealso: ["bellNumbers"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/composition.js
  var compositionDocs = {
    name: "composition",
    category: "Combinatorics",
    syntax: ["composition(n, k)"],
    description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
    examples: ["composition(5, 3)"],
    seealso: ["combinations"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/combinatorics/stirlingS2.js
  var stirlingS2Docs = {
    name: "stirlingS2",
    category: "Combinatorics",
    syntax: ["stirlingS2(n, k)"],
    description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
    examples: ["stirlingS2(5, 3)"],
    seealso: ["bellNumbers"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/arg.js
  var argDocs = {
    name: "arg",
    category: "Complex",
    syntax: ["arg(x)"],
    description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
    examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
    seealso: ["re", "im", "conj", "abs"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/conj.js
  var conjDocs = {
    name: "conj",
    category: "Complex",
    syntax: ["conj(x)"],
    description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
    examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
    seealso: ["re", "im", "abs", "arg"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/im.js
  var imDocs = {
    name: "im",
    category: "Complex",
    syntax: ["im(x)"],
    description: "Get the imaginary part of a complex number.",
    examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
    seealso: ["re", "conj", "abs", "arg"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/complex/re.js
  var reDocs = {
    name: "re",
    category: "Complex",
    syntax: ["re(x)"],
    description: "Get the real part of a complex number.",
    examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
    seealso: ["im", "conj", "abs", "arg"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/evaluate.js
  var evaluateDocs = {
    name: "evaluate",
    category: "Expression",
    syntax: ["evaluate(expression)", "evaluate(expression, scope)", "evaluate([expr1, expr2, expr3, ...])", "evaluate([expr1, expr2, expr3, ...], scope)"],
    description: "Evaluate an expression or an array with expressions.",
    examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/expression/help.js
  var helpDocs = {
    name: "help",
    category: "Expression",
    syntax: ["help(object)", "help(string)"],
    description: "Display documentation on a function or data type.",
    examples: ["help(sqrt)", 'help("complex")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/distance.js
  var distanceDocs = {
    name: "distance",
    category: "Geometry",
    syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
    description: "Calculates the Euclidean distance between two points.",
    examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/geometry/intersect.js
  var intersectDocs = {
    name: "intersect",
    category: "Geometry",
    syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
    description: "Computes the intersection point of lines and/or planes.",
    examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/and.js
  var andDocs = {
    name: "and",
    category: "Logical",
    syntax: ["x and y", "and(x, y)"],
    description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
    examples: ["true and false", "true and true", "2 and 4"],
    seealso: ["not", "or", "xor"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/not.js
  var notDocs = {
    name: "not",
    category: "Logical",
    syntax: ["not x", "not(x)"],
    description: "Logical not. Flips the boolean value of given argument.",
    examples: ["not true", "not false", "not 2", "not 0"],
    seealso: ["and", "or", "xor"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/or.js
  var orDocs = {
    name: "or",
    category: "Logical",
    syntax: ["x or y", "or(x, y)"],
    description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
    examples: ["true or false", "false or false", "0 or 4"],
    seealso: ["not", "and", "xor"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/logical/xor.js
  var xorDocs = {
    name: "xor",
    category: "Logical",
    syntax: ["x xor y", "xor(x, y)"],
    description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
    examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
    seealso: ["not", "and", "or"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/column.js
  var columnDocs = {
    name: "column",
    category: "Matrix",
    syntax: ["column(x, index)"],
    description: "Return a column from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
    seealso: ["row", "matrixFromColumns"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/concat.js
  var concatDocs = {
    name: "concat",
    category: "Matrix",
    syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
    description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
    examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
    seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/count.js
  var countDocs = {
    name: "count",
    category: "Matrix",
    syntax: ["count(x)"],
    description: "Count the number of elements of a matrix, array or string.",
    examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
    seealso: ["size"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/cross.js
  var crossDocs = {
    name: "cross",
    category: "Matrix",
    syntax: ["cross(A, B)"],
    description: "Calculate the cross product for two vectors in three dimensional space.",
    examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
    seealso: ["multiply", "dot"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ctranspose.js
  var ctransposeDocs = {
    name: "ctranspose",
    category: "Matrix",
    syntax: ["x'", "ctranspose(x)"],
    description: "Complex Conjugate and Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/det.js
  var detDocs = {
    name: "det",
    category: "Matrix",
    syntax: ["det(x)"],
    description: "Calculate the determinant of a matrix",
    examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
    seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diag.js
  var diagDocs = {
    name: "diag",
    category: "Matrix",
    syntax: ["diag(x)", "diag(x, k)"],
    description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
    examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
    seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/diff.js
  var diffDocs = {
    name: "diff",
    category: "Matrix",
    syntax: ["diff(arr)", "diff(arr, dim)"],
    description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
    examples: ["A = [1, 2, 4, 7, 0]", "diff(A)", "diff(A, 1)", "B = [[1, 2], [3, 4]]", "diff(B)", "diff(B, 1)", "diff(B, 2)", "diff(B, bignumber(2))", "diff([[1, 2], matrix([3, 4])], 2)"],
    seealso: ["subtract", "partitionSelect"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/dot.js
  var dotDocs = {
    name: "dot",
    category: "Matrix",
    syntax: ["dot(A, B)", "A * B"],
    description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
    examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
    seealso: ["multiply", "cross"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/eigs.js
  var eigsDocs = {
    name: "eigs",
    category: "Matrix",
    syntax: ["eigs(x)"],
    description: "Calculate the eigenvalues and optionally eigenvectors of a square matrix",
    examples: ["eigs([[5, 2.3], [2.3, 1]])", "eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false }"],
    seealso: ["inv"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/filter.js
  var filterDocs = {
    name: "filter",
    category: "Matrix",
    syntax: ["filter(x, test)"],
    description: "Filter items in a matrix.",
    examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
    seealso: ["sort", "map", "forEach"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/flatten.js
  var flattenDocs = {
    name: "flatten",
    category: "Matrix",
    syntax: ["flatten(x)"],
    description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
    seealso: ["concat", "resize", "size", "squeeze"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/forEach.js
  var forEachDocs = {
    name: "forEach",
    category: "Matrix",
    syntax: ["forEach(x, callback)"],
    description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
    examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
    seealso: ["map", "sort", "filter"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/getMatrixDataType.js
  var getMatrixDataTypeDocs = {
    name: "getMatrixDataType",
    category: "Matrix",
    syntax: ["getMatrixDataType(x)"],
    description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
    examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
    seealso: ["matrix", "sparse", "typeOf"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/identity.js
  var identityDocs = {
    name: "identity",
    category: "Matrix",
    syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
    description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
    examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
    seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/inv.js
  var invDocs = {
    name: "inv",
    category: "Matrix",
    syntax: ["inv(x)"],
    description: "Calculate the inverse of a matrix",
    examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
    seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/pinv.js
  var pinvDocs = {
    name: "pinv",
    category: "Matrix",
    syntax: ["pinv(x)"],
    description: "Calculate the Moore\u2013Penrose inverse of a matrix",
    examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
    seealso: ["inv"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/kron.js
  var kronDocs = {
    name: "kron",
    category: "Matrix",
    syntax: ["kron(x, y)"],
    description: "Calculates the kronecker product of 2 matrices or vectors.",
    examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
    seealso: ["multiply", "dot", "cross"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/map.js
  var mapDocs = {
    name: "map",
    category: "Matrix",
    syntax: ["map(x, callback)"],
    description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
    examples: ["map([1, 2, 3], square)"],
    seealso: ["filter", "forEach"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromColumns.js
  var matrixFromColumnsDocs = {
    name: "matrixFromColumns",
    category: "Matrix",
    syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
    description: "Create a dense matrix from vectors as individual columns.",
    examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
    seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromFunction.js
  var matrixFromFunctionDocs = {
    name: "matrixFromFunction",
    category: "Matrix",
    syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
    description: "Create a matrix by evaluating a generating function at each index.",
    examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
    seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/matrixFromRows.js
  var matrixFromRowsDocs = {
    name: "matrixFromRows",
    category: "Matrix",
    syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
    description: "Create a dense matrix from vectors as individual rows.",
    examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
    seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ones.js
  var onesDocs = {
    name: "ones",
    category: "Matrix",
    syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
    description: "Create a matrix containing ones.",
    examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
    seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/partitionSelect.js
  var partitionSelectDocs = {
    name: "partitionSelect",
    category: "Matrix",
    syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
    description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
    examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]", "arr"],
    seealso: ["sort"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/range.js
  var rangeDocs = {
    name: "range",
    category: "Type",
    syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
    description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
    examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "range(1m, 1m, 3m)", "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/reshape.js
  var reshapeDocs = {
    name: "reshape",
    category: "Matrix",
    syntax: ["reshape(x, sizes)"],
    description: "Reshape a multi dimensional array to fit the specified dimensions.",
    examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
    seealso: ["size", "squeeze", "resize"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/resize.js
  var resizeDocs = {
    name: "resize",
    category: "Matrix",
    syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
    description: "Resize a matrix.",
    examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
    seealso: ["size", "subset", "squeeze", "reshape"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotate.js
  var rotateDocs = {
    name: "rotate",
    category: "Matrix",
    syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
    description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
    seealso: ["matrix", "rotationMatrix"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/rotationMatrix.js
  var rotationMatrixDocs = {
    name: "rotationMatrix",
    category: "Matrix",
    syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
    description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
    examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
    seealso: ["cos", "sin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/row.js
  var rowDocs = {
    name: "row",
    category: "Matrix",
    syntax: ["row(x, index)"],
    description: "Return a row from a matrix or array.",
    examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
    seealso: ["column", "matrixFromRows"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/size.js
  var sizeDocs = {
    name: "size",
    category: "Matrix",
    syntax: ["size(x)"],
    description: "Calculate the size of a matrix.",
    examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
    seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/sort.js
  var sortDocs = {
    name: "sort",
    category: "Matrix",
    syntax: ["sort(x)", "sort(x, compare)"],
    description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
    examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
    seealso: ["map", "filter", "forEach"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/squeeze.js
  var squeezeDocs = {
    name: "squeeze",
    category: "Matrix",
    syntax: ["squeeze(x)"],
    description: "Remove inner and outer singleton dimensions from a matrix.",
    examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/subset.js
  var subsetDocs = {
    name: "subset",
    category: "Matrix",
    syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
    description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
    examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/trace.js
  var traceDocs = {
    name: "trace",
    category: "Matrix",
    syntax: ["trace(A)"],
    description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
    examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/transpose.js
  var transposeDocs = {
    name: "transpose",
    category: "Matrix",
    syntax: ["x'", "transpose(x)"],
    description: "Transpose a matrix",
    examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/zeros.js
  var zerosDocs = {
    name: "zeros",
    category: "Matrix",
    syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
    description: "Create a matrix containing zeros.",
    examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
    seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/fft.js
  var fftDocs = {
    name: "fft",
    category: "Matrix",
    syntax: ["fft(x)"],
    description: "Calculate N-dimensional fourier transform",
    examples: ["fft([[1, 0], [1, 0]])"],
    seealso: ["ifft"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/matrix/ifft.js
  var ifftDocs = {
    name: "ifft",
    category: "Matrix",
    syntax: ["ifft(x)"],
    description: "Calculate N-dimensional inverse fourier transform",
    examples: ["ifft([[2, 2], [0, 0]])"],
    seealso: ["fft"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinations.js
  var combinationsDocs = {
    name: "combinations",
    category: "Probability",
    syntax: ["combinations(n, k)"],
    description: "Compute the number of combinations of n items taken k at a time",
    examples: ["combinations(7, 5)"],
    seealso: ["combinationsWithRep", "permutations", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/combinationsWithRep.js
  var combinationsWithRepDocs = {
    name: "combinationsWithRep",
    category: "Probability",
    syntax: ["combinationsWithRep(n, k)"],
    description: "Compute the number of combinations of n items taken k at a time with replacements.",
    examples: ["combinationsWithRep(7, 5)"],
    seealso: ["combinations", "permutations", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/factorial.js
  var factorialDocs = {
    name: "factorial",
    category: "Probability",
    syntax: ["n!", "factorial(n)"],
    description: "Compute the factorial of a value",
    examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
    seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/gamma.js
  var gammaDocs = {
    name: "gamma",
    category: "Probability",
    syntax: ["gamma(n)"],
    description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
    examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
    seealso: ["factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/lgamma.js
  var lgammaDocs = {
    name: "lgamma",
    category: "Probability",
    syntax: ["lgamma(n)"],
    description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
    examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
    seealso: ["gamma"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/kldivergence.js
  var kldivergenceDocs = {
    name: "kldivergence",
    category: "Probability",
    syntax: ["kldivergence(x, y)"],
    description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
    examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/multinomial.js
  var multinomialDocs = {
    name: "multinomial",
    category: "Probability",
    syntax: ["multinomial(A)"],
    description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
    examples: ["multinomial([1, 2, 1])"],
    seealso: ["combinations", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/permutations.js
  var permutationsDocs = {
    name: "permutations",
    category: "Probability",
    syntax: ["permutations(n)", "permutations(n, k)"],
    description: "Compute the number of permutations of n items taken k at a time",
    examples: ["permutations(5)", "permutations(5, 3)"],
    seealso: ["combinations", "combinationsWithRep", "factorial"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/pickRandom.js
  var pickRandomDocs = {
    name: "pickRandom",
    category: "Probability",
    syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
    description: "Pick a random entry from a given array.",
    examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
    seealso: ["random", "randomInt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/random.js
  var randomDocs = {
    name: "random",
    category: "Probability",
    syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
    description: "Return a random number.",
    examples: ["random()", "random(10, 20)", "random([2, 3])"],
    seealso: ["pickRandom", "randomInt"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/probability/randomInt.js
  var randomIntDocs = {
    name: "randomInt",
    category: "Probability",
    syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
    description: "Return a random integer number",
    examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
    seealso: ["pickRandom", "random"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compare.js
  var compareDocs = {
    name: "compare",
    category: "Relational",
    syntax: ["compare(x, y)"],
    description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
    seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareNatural.js
  var compareNaturalDocs = {
    name: "compareNatural",
    category: "Relational",
    syntax: ["compareNatural(x, y)"],
    description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
    seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/compareText.js
  var compareTextDocs = {
    name: "compareText",
    category: "Relational",
    syntax: ["compareText(x, y)"],
    description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
    examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
    seealso: ["compare", "compareNatural"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/deepEqual.js
  var deepEqualDocs = {
    name: "deepEqual",
    category: "Relational",
    syntax: ["deepEqual(x, y)"],
    description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
    examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
    seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equal.js
  var equalDocs = {
    name: "equal",
    category: "Relational",
    syntax: ["x == y", "equal(x, y)"],
    description: "Check equality of two values. Returns true if the values are equal, and false if not.",
    examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
    seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/equalText.js
  var equalTextDocs = {
    name: "equalText",
    category: "Relational",
    syntax: ["equalText(x, y)"],
    description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
    examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
    seealso: ["compare", "compareNatural", "compareText", "equal"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/larger.js
  var largerDocs = {
    name: "larger",
    category: "Relational",
    syntax: ["x > y", "larger(x, y)"],
    description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
    examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
    seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/largerEq.js
  var largerEqDocs = {
    name: "largerEq",
    category: "Relational",
    syntax: ["x >= y", "largerEq(x, y)"],
    description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
    examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
    seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smaller.js
  var smallerDocs = {
    name: "smaller",
    category: "Relational",
    syntax: ["x < y", "smaller(x, y)"],
    description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
    examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
    seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/smallerEq.js
  var smallerEqDocs = {
    name: "smallerEq",
    category: "Relational",
    syntax: ["x <= y", "smallerEq(x, y)"],
    description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
    examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
    seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/relational/unequal.js
  var unequalDocs = {
    name: "unequal",
    category: "Relational",
    syntax: ["x != y", "unequal(x, y)"],
    description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
    examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
    seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setCartesian.js
  var setCartesianDocs = {
    name: "setCartesian",
    category: "Set",
    syntax: ["setCartesian(set1, set2)"],
    description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
    examples: ["setCartesian([1, 2], [3, 4])"],
    seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDifference.js
  var setDifferenceDocs = {
    name: "setDifference",
    category: "Set",
    syntax: ["setDifference(set1, set2)"],
    description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setUnion", "setIntersect", "setSymDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setDistinct.js
  var setDistinctDocs = {
    name: "setDistinct",
    category: "Set",
    syntax: ["setDistinct(set)"],
    description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
    seealso: ["setMultiplicity"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIntersect.js
  var setIntersectDocs = {
    name: "setIntersect",
    category: "Set",
    syntax: ["setIntersect(set1, set2)"],
    description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setUnion", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setIsSubset.js
  var setIsSubsetDocs = {
    name: "setIsSubset",
    category: "Set",
    syntax: ["setIsSubset(set1, set2)"],
    description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
    seealso: ["setUnion", "setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setMultiplicity.js
  var setMultiplicityDocs = {
    name: "setMultiplicity",
    category: "Set",
    syntax: ["setMultiplicity(element, set)"],
    description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
    seealso: ["setDistinct", "setSize"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setPowerset.js
  var setPowersetDocs = {
    name: "setPowerset",
    category: "Set",
    syntax: ["setPowerset(set)"],
    description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
    examples: ["setPowerset([1, 2, 3])"],
    seealso: ["setCartesian"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSize.js
  var setSizeDocs = {
    name: "setSize",
    category: "Set",
    syntax: ["setSize(set)", "setSize(set, unique)"],
    description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
    examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
    seealso: ["setUnion", "setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setSymDifference.js
  var setSymDifferenceDocs = {
    name: "setSymDifference",
    category: "Set",
    syntax: ["setSymDifference(set1, set2)"],
    description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setUnion", "setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/set/setUnion.js
  var setUnionDocs = {
    name: "setUnion",
    category: "Set",
    syntax: ["setUnion(set1, set2)"],
    description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
    examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
    seealso: ["setIntersect", "setDifference"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/zpk2tf.js
  var zpk2tfDocs = {
    name: "zpk2tf",
    category: "Signal",
    syntax: ["zpk2tf(z, p, k)"],
    description: "Compute the transfer function of a zero-pole-gain model.",
    examples: ["zpk2tf([1, 2], [-1, -2], 1)", "zpk2tf([1, 2], [-1, -2])", "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/signal/freqz.js
  var freqzDocs = {
    name: "freqz",
    category: "Signal",
    syntax: ["freqz(b, a)", "freqz(b, a, w)"],
    description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
    examples: ["freqz([1, 2], [1, 2, 3])", "freqz([1, 2], [1, 2, 3], [0, 1])", "freqz([1, 2], [1, 2, 3], 512)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/erf.js
  var erfDocs = {
    name: "erf",
    category: "Special",
    syntax: ["erf(x)"],
    description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
    examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/special/zeta.js
  var zetaDocs = {
    name: "zeta",
    category: "Special",
    syntax: ["zeta(s)"],
    description: "Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",
    examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mad.js
  var madDocs = {
    name: "mad",
    category: "Statistics",
    syntax: ["mad(a, b, c, ...)", "mad(A)"],
    description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
    examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
    seealso: ["mean", "median", "std", "abs"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/max.js
  var maxDocs = {
    name: "max",
    category: "Statistics",
    syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
    description: "Compute the maximum value of a list of values.",
    examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
    seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mean.js
  var meanDocs = {
    name: "mean",
    category: "Statistics",
    syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
    description: "Compute the arithmetic mean of a list of values.",
    examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
    seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/median.js
  var medianDocs = {
    name: "median",
    category: "Statistics",
    syntax: ["median(a, b, c, ...)", "median(A)"],
    description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
    examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
    seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/min.js
  var minDocs = {
    name: "min",
    category: "Statistics",
    syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
    description: "Compute the minimum value of a list of values.",
    examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
    seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/mode.js
  var modeDocs = {
    name: "mode",
    category: "Statistics",
    syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
    description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
    examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
    seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/prod.js
  var prodDocs = {
    name: "prod",
    category: "Statistics",
    syntax: ["prod(a, b, c, ...)", "prod(A)"],
    description: "Compute the product of all values.",
    examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
    seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/quantileSeq.js
  var quantileSeqDocs = {
    name: "quantileSeq",
    category: "Statistics",
    syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
    description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
    examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
    seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/std.js
  var stdDocs = {
    name: "std",
    category: "Statistics",
    syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
    description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
    seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/cumsum.js
  var cumSumDocs = {
    name: "cumsum",
    category: "Statistics",
    syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
    description: "Compute the cumulative sum of all values.",
    examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
    seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/sum.js
  var sumDocs = {
    name: "sum",
    category: "Statistics",
    syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
    description: "Compute the sum of all values.",
    examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
    seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/variance.js
  var varianceDocs = {
    name: "variance",
    category: "Statistics",
    syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
    description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
    examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
    seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/statistics/corr.js
  var corrDocs = {
    name: "corr",
    category: "Statistics",
    syntax: ["corr(A,B)"],
    description: "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
    examples: ["corr([2, 4, 6, 8],[1, 2, 3, 6])", "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],
    seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acos.js
  var acosDocs = {
    name: "acos",
    category: "Trigonometry",
    syntax: ["acos(x)"],
    description: "Compute the inverse cosine of a value in radians.",
    examples: ["acos(0.5)", "acos(cos(2.3))"],
    seealso: ["cos", "atan", "asin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acosh.js
  var acoshDocs = {
    name: "acosh",
    category: "Trigonometry",
    syntax: ["acosh(x)"],
    description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
    examples: ["acosh(1.5)"],
    seealso: ["cosh", "asinh", "atanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acot.js
  var acotDocs = {
    name: "acot",
    category: "Trigonometry",
    syntax: ["acot(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
    seealso: ["cot", "atan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acoth.js
  var acothDocs = {
    name: "acoth",
    category: "Trigonometry",
    syntax: ["acoth(x)"],
    description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
    examples: ["acoth(2)", "acoth(0.5)"],
    seealso: ["acsch", "asech"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsc.js
  var acscDocs = {
    name: "acsc",
    category: "Trigonometry",
    syntax: ["acsc(x)"],
    description: "Calculate the inverse cotangent of a value.",
    examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
    seealso: ["csc", "asin", "asec"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/acsch.js
  var acschDocs = {
    name: "acsch",
    category: "Trigonometry",
    syntax: ["acsch(x)"],
    description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
    examples: ["acsch(0.5)"],
    seealso: ["asech", "acoth"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asec.js
  var asecDocs = {
    name: "asec",
    category: "Trigonometry",
    syntax: ["asec(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
    seealso: ["acos", "acot", "acsc"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asech.js
  var asechDocs = {
    name: "asech",
    category: "Trigonometry",
    syntax: ["asech(x)"],
    description: "Calculate the inverse secant of a value.",
    examples: ["asech(0.5)"],
    seealso: ["acsch", "acoth"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asin.js
  var asinDocs = {
    name: "asin",
    category: "Trigonometry",
    syntax: ["asin(x)"],
    description: "Compute the inverse sine of a value in radians.",
    examples: ["asin(0.5)", "asin(sin(0.5))"],
    seealso: ["sin", "acos", "atan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/asinh.js
  var asinhDocs = {
    name: "asinh",
    category: "Trigonometry",
    syntax: ["asinh(x)"],
    description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
    examples: ["asinh(0.5)"],
    seealso: ["acosh", "atanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan.js
  var atanDocs = {
    name: "atan",
    category: "Trigonometry",
    syntax: ["atan(x)"],
    description: "Compute the inverse tangent of a value in radians.",
    examples: ["atan(0.5)", "atan(tan(0.5))"],
    seealso: ["tan", "acos", "asin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atan2.js
  var atan2Docs = {
    name: "atan2",
    category: "Trigonometry",
    syntax: ["atan2(y, x)"],
    description: "Computes the principal value of the arc tangent of y/x in radians.",
    examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
    seealso: ["sin", "cos", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/atanh.js
  var atanhDocs = {
    name: "atanh",
    category: "Trigonometry",
    syntax: ["atanh(x)"],
    description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
    examples: ["atanh(0.5)"],
    seealso: ["acosh", "asinh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cos.js
  var cosDocs = {
    name: "cos",
    category: "Trigonometry",
    syntax: ["cos(x)"],
    description: "Compute the cosine of x in radians.",
    examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
    seealso: ["acos", "sin", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cosh.js
  var coshDocs = {
    name: "cosh",
    category: "Trigonometry",
    syntax: ["cosh(x)"],
    description: "Compute the hyperbolic cosine of x in radians.",
    examples: ["cosh(0.5)"],
    seealso: ["sinh", "tanh", "coth"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/cot.js
  var cotDocs = {
    name: "cot",
    category: "Trigonometry",
    syntax: ["cot(x)"],
    description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
    examples: ["cot(2)", "1 / tan(2)"],
    seealso: ["sec", "csc", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/coth.js
  var cothDocs = {
    name: "coth",
    category: "Trigonometry",
    syntax: ["coth(x)"],
    description: "Compute the hyperbolic cotangent of x in radians.",
    examples: ["coth(2)", "1 / tanh(2)"],
    seealso: ["sech", "csch", "tanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csc.js
  var cscDocs = {
    name: "csc",
    category: "Trigonometry",
    syntax: ["csc(x)"],
    description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
    examples: ["csc(2)", "1 / sin(2)"],
    seealso: ["sec", "cot", "sin"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/csch.js
  var cschDocs = {
    name: "csch",
    category: "Trigonometry",
    syntax: ["csch(x)"],
    description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
    examples: ["csch(2)", "1 / sinh(2)"],
    seealso: ["sech", "coth", "sinh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sec.js
  var secDocs = {
    name: "sec",
    category: "Trigonometry",
    syntax: ["sec(x)"],
    description: "Compute the secant of x in radians. Defined as 1/cos(x)",
    examples: ["sec(2)", "1 / cos(2)"],
    seealso: ["cot", "csc", "cos"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sech.js
  var sechDocs = {
    name: "sech",
    category: "Trigonometry",
    syntax: ["sech(x)"],
    description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
    examples: ["sech(2)", "1 / cosh(2)"],
    seealso: ["coth", "csch", "cosh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sin.js
  var sinDocs = {
    name: "sin",
    category: "Trigonometry",
    syntax: ["sin(x)"],
    description: "Compute the sine of x in radians.",
    examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
    seealso: ["asin", "cos", "tan"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/sinh.js
  var sinhDocs = {
    name: "sinh",
    category: "Trigonometry",
    syntax: ["sinh(x)"],
    description: "Compute the hyperbolic sine of x in radians.",
    examples: ["sinh(0.5)"],
    seealso: ["cosh", "tanh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tan.js
  var tanDocs = {
    name: "tan",
    category: "Trigonometry",
    syntax: ["tan(x)"],
    description: "Compute the tangent of x in radians.",
    examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
    seealso: ["atan", "sin", "cos"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/trigonometry/tanh.js
  var tanhDocs = {
    name: "tanh",
    category: "Trigonometry",
    syntax: ["tanh(x)"],
    description: "Compute the hyperbolic tangent of x in radians.",
    examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
    seealso: ["sinh", "cosh"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/units/to.js
  var toDocs = {
    name: "to",
    category: "Units",
    syntax: ["x to unit", "to(x, unit)"],
    description: "Change the unit of a value.",
    examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/bin.js
  var binDocs = {
    name: "bin",
    category: "Utils",
    syntax: ["bin(value)"],
    description: "Format a number as binary",
    examples: ["bin(2)"],
    seealso: ["oct", "hex"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/clone.js
  var cloneDocs = {
    name: "clone",
    category: "Utils",
    syntax: ["clone(x)"],
    description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
    examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
    seealso: []
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/format.js
  var formatDocs = {
    name: "format",
    category: "Utils",
    syntax: ["format(value)", "format(value, precision)"],
    description: "Format a value of any type as string.",
    examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
    seealso: ["print"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hasNumericValue.js
  var hasNumericValueDocs = {
    name: "hasNumericValue",
    category: "Utils",
    syntax: ["hasNumericValue(x)"],
    description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
    examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
    seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/hex.js
  var hexDocs = {
    name: "hex",
    category: "Utils",
    syntax: ["hex(value)"],
    description: "Format a number as hexadecimal",
    examples: ["hex(240)"],
    seealso: ["bin", "oct"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isInteger.js
  var isIntegerDocs = {
    name: "isInteger",
    category: "Utils",
    syntax: ["isInteger(x)"],
    description: "Test whether a value is an integer number.",
    examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNaN.js
  var isNaNDocs = {
    name: "isNaN",
    category: "Utils",
    syntax: ["isNaN(x)"],
    description: "Test whether a value is NaN (not a number)",
    examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
    seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNegative.js
  var isNegativeDocs = {
    name: "isNegative",
    category: "Utils",
    syntax: ["isNegative(x)"],
    description: "Test whether a value is negative: smaller than zero.",
    examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
    seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isNumeric.js
  var isNumericDocs = {
    name: "isNumeric",
    category: "Utils",
    syntax: ["isNumeric(x)"],
    description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
    examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
    seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPositive.js
  var isPositiveDocs = {
    name: "isPositive",
    category: "Utils",
    syntax: ["isPositive(x)"],
    description: "Test whether a value is positive: larger than zero.",
    examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isPrime.js
  var isPrimeDocs = {
    name: "isPrime",
    category: "Utils",
    syntax: ["isPrime(x)"],
    description: "Test whether a value is prime: has no divisors other than itself and one.",
    examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/isZero.js
  var isZeroDocs = {
    name: "isZero",
    category: "Utils",
    syntax: ["isZero(x)"],
    description: "Test whether a value is zero.",
    examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
    seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/numeric.js
  var numericDocs = {
    name: "numeric",
    category: "Utils",
    syntax: ["numeric(x)"],
    description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
    examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
    seealso: ["number", "fraction", "bignumber", "string", "format"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/oct.js
  var octDocs = {
    name: "oct",
    category: "Utils",
    syntax: ["oct(value)"],
    description: "Format a number as octal",
    examples: ["oct(56)"],
    seealso: ["bin", "hex"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/print.js
  var printDocs = {
    name: "print",
    category: "Utils",
    syntax: ["print(template, values)", "print(template, values, precision)"],
    description: "Interpolate values into a string template.",
    examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $1, $2, $3", [6, 9, 4])'],
    seealso: ["format"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/utils/typeOf.js
  var typeOfDocs = {
    name: "typeOf",
    category: "Utils",
    syntax: ["typeOf(x)"],
    description: "Get the type of a variable.",
    examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
    seealso: ["getMatrixDataType"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/function/numeric/solveODE.js
  var solveODEDocs = {
    name: "solveODE",
    category: "Numeric",
    syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
    description: "Numerical Integration of Ordinary Differential Equations.",
    examples: ["f(t,y) = y", "tspan = [0, 4]", "solveODE(f, tspan, 1)", "solveODE(f, tspan, [1, 2])", 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
    seealso: ["derivative", "simplifyCore"]
  };

  // node_modules/mathjs/lib/esm/expression/embeddedDocs/embeddedDocs.js
  var embeddedDocs = {
    // construction functions
    bignumber: bignumberDocs,
    boolean: booleanDocs,
    complex: complexDocs,
    createUnit: createUnitDocs,
    fraction: fractionDocs,
    index: indexDocs,
    matrix: matrixDocs,
    number: numberDocs,
    sparse: sparseDocs,
    splitUnit: splitUnitDocs,
    string: stringDocs,
    unit: unitDocs,
    // constants
    e: eDocs,
    E: eDocs,
    false: falseDocs,
    i: iDocs,
    Infinity: InfinityDocs,
    LN2: LN2Docs,
    LN10: LN10Docs,
    LOG2E: LOG2EDocs,
    LOG10E: LOG10EDocs,
    NaN: NaNDocs,
    null: nullDocs,
    pi: piDocs,
    PI: piDocs,
    phi: phiDocs,
    SQRT1_2: SQRT12Docs,
    SQRT2: SQRT2Docs,
    tau: tauDocs,
    true: trueDocs,
    version: versionDocs,
    // physical constants
    // TODO: more detailed docs for physical constants
    speedOfLight: {
      description: "Speed of light in vacuum",
      examples: ["speedOfLight"]
    },
    gravitationConstant: {
      description: "Newtonian constant of gravitation",
      examples: ["gravitationConstant"]
    },
    planckConstant: {
      description: "Planck constant",
      examples: ["planckConstant"]
    },
    reducedPlanckConstant: {
      description: "Reduced Planck constant",
      examples: ["reducedPlanckConstant"]
    },
    magneticConstant: {
      description: "Magnetic constant (vacuum permeability)",
      examples: ["magneticConstant"]
    },
    electricConstant: {
      description: "Electric constant (vacuum permeability)",
      examples: ["electricConstant"]
    },
    vacuumImpedance: {
      description: "Characteristic impedance of vacuum",
      examples: ["vacuumImpedance"]
    },
    coulomb: {
      description: "Coulomb's constant",
      examples: ["coulomb"]
    },
    elementaryCharge: {
      description: "Elementary charge",
      examples: ["elementaryCharge"]
    },
    bohrMagneton: {
      description: "Borh magneton",
      examples: ["bohrMagneton"]
    },
    conductanceQuantum: {
      description: "Conductance quantum",
      examples: ["conductanceQuantum"]
    },
    inverseConductanceQuantum: {
      description: "Inverse conductance quantum",
      examples: ["inverseConductanceQuantum"]
    },
    // josephson: {description: 'Josephson constant', examples: ['josephson']},
    magneticFluxQuantum: {
      description: "Magnetic flux quantum",
      examples: ["magneticFluxQuantum"]
    },
    nuclearMagneton: {
      description: "Nuclear magneton",
      examples: ["nuclearMagneton"]
    },
    klitzing: {
      description: "Von Klitzing constant",
      examples: ["klitzing"]
    },
    bohrRadius: {
      description: "Borh radius",
      examples: ["bohrRadius"]
    },
    classicalElectronRadius: {
      description: "Classical electron radius",
      examples: ["classicalElectronRadius"]
    },
    electronMass: {
      description: "Electron mass",
      examples: ["electronMass"]
    },
    fermiCoupling: {
      description: "Fermi coupling constant",
      examples: ["fermiCoupling"]
    },
    fineStructure: {
      description: "Fine-structure constant",
      examples: ["fineStructure"]
    },
    hartreeEnergy: {
      description: "Hartree energy",
      examples: ["hartreeEnergy"]
    },
    protonMass: {
      description: "Proton mass",
      examples: ["protonMass"]
    },
    deuteronMass: {
      description: "Deuteron Mass",
      examples: ["deuteronMass"]
    },
    neutronMass: {
      description: "Neutron mass",
      examples: ["neutronMass"]
    },
    quantumOfCirculation: {
      description: "Quantum of circulation",
      examples: ["quantumOfCirculation"]
    },
    rydberg: {
      description: "Rydberg constant",
      examples: ["rydberg"]
    },
    thomsonCrossSection: {
      description: "Thomson cross section",
      examples: ["thomsonCrossSection"]
    },
    weakMixingAngle: {
      description: "Weak mixing angle",
      examples: ["weakMixingAngle"]
    },
    efimovFactor: {
      description: "Efimov factor",
      examples: ["efimovFactor"]
    },
    atomicMass: {
      description: "Atomic mass constant",
      examples: ["atomicMass"]
    },
    avogadro: {
      description: "Avogadro's number",
      examples: ["avogadro"]
    },
    boltzmann: {
      description: "Boltzmann constant",
      examples: ["boltzmann"]
    },
    faraday: {
      description: "Faraday constant",
      examples: ["faraday"]
    },
    firstRadiation: {
      description: "First radiation constant",
      examples: ["firstRadiation"]
    },
    loschmidt: {
      description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
      examples: ["loschmidt"]
    },
    gasConstant: {
      description: "Gas constant",
      examples: ["gasConstant"]
    },
    molarPlanckConstant: {
      description: "Molar Planck constant",
      examples: ["molarPlanckConstant"]
    },
    molarVolume: {
      description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
      examples: ["molarVolume"]
    },
    sackurTetrode: {
      description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
      examples: ["sackurTetrode"]
    },
    secondRadiation: {
      description: "Second radiation constant",
      examples: ["secondRadiation"]
    },
    stefanBoltzmann: {
      description: "Stefan-Boltzmann constant",
      examples: ["stefanBoltzmann"]
    },
    wienDisplacement: {
      description: "Wien displacement law constant",
      examples: ["wienDisplacement"]
    },
    // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
    molarMass: {
      description: "Molar mass constant",
      examples: ["molarMass"]
    },
    molarMassC12: {
      description: "Molar mass constant of carbon-12",
      examples: ["molarMassC12"]
    },
    gravity: {
      description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
      examples: ["gravity"]
    },
    planckLength: {
      description: "Planck length",
      examples: ["planckLength"]
    },
    planckMass: {
      description: "Planck mass",
      examples: ["planckMass"]
    },
    planckTime: {
      description: "Planck time",
      examples: ["planckTime"]
    },
    planckCharge: {
      description: "Planck charge",
      examples: ["planckCharge"]
    },
    planckTemperature: {
      description: "Planck temperature",
      examples: ["planckTemperature"]
    },
    // functions - algebra
    derivative: derivativeDocs,
    lsolve: lsolveDocs,
    lsolveAll: lsolveAllDocs,
    lup: lupDocs,
    lusolve: lusolveDocs,
    leafCount: leafCountDocs,
    polynomialRoot: polynomialRootDocs,
    resolve: resolveDocs,
    simplify: simplifyDocs,
    simplifyConstant: simplifyConstantDocs,
    simplifyCore: simplifyCoreDocs,
    symbolicEqual: symbolicEqualDocs,
    rationalize: rationalizeDocs,
    slu: sluDocs,
    usolve: usolveDocs,
    usolveAll: usolveAllDocs,
    qr: qrDocs,
    // functions - arithmetic
    abs: absDocs,
    add: addDocs,
    cbrt: cbrtDocs,
    ceil: ceilDocs,
    cube: cubeDocs,
    divide: divideDocs,
    dotDivide: dotDivideDocs,
    dotMultiply: dotMultiplyDocs,
    dotPow: dotPowDocs,
    exp: expDocs,
    expm: expmDocs,
    expm1: expm1Docs,
    fix: fixDocs,
    floor: floorDocs,
    gcd: gcdDocs,
    hypot: hypotDocs,
    lcm: lcmDocs,
    log: logDocs,
    log2: log2Docs,
    log1p: log1pDocs,
    log10: log10Docs,
    mod: modDocs,
    multiply: multiplyDocs,
    norm: normDocs,
    nthRoot: nthRootDocs,
    nthRoots: nthRootsDocs,
    pow: powDocs,
    round: roundDocs,
    sign: signDocs,
    sqrt: sqrtDocs,
    sqrtm: sqrtmDocs,
    square: squareDocs,
    subtract: subtractDocs,
    unaryMinus: unaryMinusDocs,
    unaryPlus: unaryPlusDocs,
    xgcd: xgcdDocs,
    invmod: invmodDocs,
    // functions - bitwise
    bitAnd: bitAndDocs,
    bitNot: bitNotDocs,
    bitOr: bitOrDocs,
    bitXor: bitXorDocs,
    leftShift: leftShiftDocs,
    rightArithShift: rightArithShiftDocs,
    rightLogShift: rightLogShiftDocs,
    // functions - combinatorics
    bellNumbers: bellNumbersDocs,
    catalan: catalanDocs,
    composition: compositionDocs,
    stirlingS2: stirlingS2Docs,
    // functions - core
    config: configDocs,
    import: importDocs,
    typed: typedDocs,
    // functions - complex
    arg: argDocs,
    conj: conjDocs,
    re: reDocs,
    im: imDocs,
    // functions - expression
    evaluate: evaluateDocs,
    help: helpDocs,
    // functions - geometry
    distance: distanceDocs,
    intersect: intersectDocs,
    // functions - logical
    and: andDocs,
    not: notDocs,
    or: orDocs,
    xor: xorDocs,
    // functions - matrix
    concat: concatDocs,
    count: countDocs,
    cross: crossDocs,
    column: columnDocs,
    ctranspose: ctransposeDocs,
    det: detDocs,
    diag: diagDocs,
    diff: diffDocs,
    dot: dotDocs,
    getMatrixDataType: getMatrixDataTypeDocs,
    identity: identityDocs,
    filter: filterDocs,
    flatten: flattenDocs,
    forEach: forEachDocs,
    inv: invDocs,
    pinv: pinvDocs,
    eigs: eigsDocs,
    kron: kronDocs,
    matrixFromFunction: matrixFromFunctionDocs,
    matrixFromRows: matrixFromRowsDocs,
    matrixFromColumns: matrixFromColumnsDocs,
    map: mapDocs,
    ones: onesDocs,
    partitionSelect: partitionSelectDocs,
    range: rangeDocs,
    resize: resizeDocs,
    reshape: reshapeDocs,
    rotate: rotateDocs,
    rotationMatrix: rotationMatrixDocs,
    row: rowDocs,
    size: sizeDocs,
    sort: sortDocs,
    squeeze: squeezeDocs,
    subset: subsetDocs,
    trace: traceDocs,
    transpose: transposeDocs,
    zeros: zerosDocs,
    fft: fftDocs,
    ifft: ifftDocs,
    sylvester: sylvesterDocs,
    schur: schurDocs,
    lyap: lyapDocs,
    // functions - numeric
    solveODE: solveODEDocs,
    // functions - probability
    combinations: combinationsDocs,
    combinationsWithRep: combinationsWithRepDocs,
    // distribution: distributionDocs,
    factorial: factorialDocs,
    gamma: gammaDocs,
    kldivergence: kldivergenceDocs,
    lgamma: lgammaDocs,
    multinomial: multinomialDocs,
    permutations: permutationsDocs,
    pickRandom: pickRandomDocs,
    random: randomDocs,
    randomInt: randomIntDocs,
    // functions - relational
    compare: compareDocs,
    compareNatural: compareNaturalDocs,
    compareText: compareTextDocs,
    deepEqual: deepEqualDocs,
    equal: equalDocs,
    equalText: equalTextDocs,
    larger: largerDocs,
    largerEq: largerEqDocs,
    smaller: smallerDocs,
    smallerEq: smallerEqDocs,
    unequal: unequalDocs,
    // functions - set
    setCartesian: setCartesianDocs,
    setDifference: setDifferenceDocs,
    setDistinct: setDistinctDocs,
    setIntersect: setIntersectDocs,
    setIsSubset: setIsSubsetDocs,
    setMultiplicity: setMultiplicityDocs,
    setPowerset: setPowersetDocs,
    setSize: setSizeDocs,
    setSymDifference: setSymDifferenceDocs,
    setUnion: setUnionDocs,
    // functions - signal
    zpk2tf: zpk2tfDocs,
    freqz: freqzDocs,
    // functions - special
    erf: erfDocs,
    zeta: zetaDocs,
    // functions - statistics
    cumsum: cumSumDocs,
    mad: madDocs,
    max: maxDocs,
    mean: meanDocs,
    median: medianDocs,
    min: minDocs,
    mode: modeDocs,
    prod: prodDocs,
    quantileSeq: quantileSeqDocs,
    std: stdDocs,
    sum: sumDocs,
    variance: varianceDocs,
    corr: corrDocs,
    // functions - trigonometry
    acos: acosDocs,
    acosh: acoshDocs,
    acot: acotDocs,
    acoth: acothDocs,
    acsc: acscDocs,
    acsch: acschDocs,
    asec: asecDocs,
    asech: asechDocs,
    asin: asinDocs,
    asinh: asinhDocs,
    atan: atanDocs,
    atanh: atanhDocs,
    atan2: atan2Docs,
    cos: cosDocs,
    cosh: coshDocs,
    cot: cotDocs,
    coth: cothDocs,
    csc: cscDocs,
    csch: cschDocs,
    sec: secDocs,
    sech: sechDocs,
    sin: sinDocs,
    sinh: sinhDocs,
    tan: tanDocs,
    tanh: tanhDocs,
    // functions - units
    to: toDocs,
    // functions - utils
    clone: cloneDocs,
    format: formatDocs,
    bin: binDocs,
    oct: octDocs,
    hex: hexDocs,
    isNaN: isNaNDocs,
    isInteger: isIntegerDocs,
    isNegative: isNegativeDocs,
    isNumeric: isNumericDocs,
    hasNumericValue: hasNumericValueDocs,
    isPositive: isPositiveDocs,
    isPrime: isPrimeDocs,
    isZero: isZeroDocs,
    print: printDocs,
    typeOf: typeOfDocs,
    numeric: numericDocs
  };

  // node_modules/mathjs/lib/esm/expression/function/help.js
  var name239 = "help";
  var dependencies239 = ["typed", "mathWithTransform", "Help"];
  var createHelp = /* @__PURE__ */ factory(name239, dependencies239, (_ref) => {
    var {
      typed: typed3,
      mathWithTransform: mathWithTransform2,
      Help: Help2
    } = _ref;
    return typed3(name239, {
      any: function any(search) {
        var prop;
        var searchName = search;
        if (typeof search !== "string") {
          for (prop in mathWithTransform2) {
            if (hasOwnProperty(mathWithTransform2, prop) && search === mathWithTransform2[prop]) {
              searchName = prop;
              break;
            }
          }
        }
        var doc = getSafeProperty(embeddedDocs, searchName);
        if (!doc) {
          var searchText = typeof searchName === "function" ? searchName.name : searchName;
          throw new Error('No documentation found on "' + searchText + '"');
        }
        return new Help2(doc);
      }
    });
  });

  // node_modules/mathjs/lib/esm/type/chain/function/chain.js
  var name240 = "chain";
  var dependencies240 = ["typed", "Chain"];
  var createChain = /* @__PURE__ */ factory(name240, dependencies240, (_ref) => {
    var {
      typed: typed3,
      Chain: Chain2
    } = _ref;
    return typed3(name240, {
      "": function _() {
        return new Chain2();
      },
      any: function any(value) {
        return new Chain2(value);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/matrix/det.js
  var name241 = "det";
  var dependencies241 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"];
  var createDet = /* @__PURE__ */ factory(name241, dependencies241, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      subtractScalar: subtractScalar2,
      multiply: multiply2,
      divideScalar: divideScalar2,
      isZero: isZero2,
      unaryMinus: unaryMinus2
    } = _ref;
    return typed3(name241, {
      any: function any(x) {
        return clone(x);
      },
      "Array | Matrix": function det2(x) {
        var size2;
        if (isMatrix(x)) {
          size2 = x.size();
        } else if (Array.isArray(x)) {
          x = matrix2(x);
          size2 = x.size();
        } else {
          size2 = [];
        }
        switch (size2.length) {
          case 0:
            return clone(x);
          case 1:
            if (size2[0] === 1) {
              return clone(x.valueOf()[0]);
            }
            if (size2[0] === 0) {
              return 1;
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          case 2: {
            var rows = size2[0];
            var cols = size2[1];
            if (rows === cols) {
              return _det(x.clone().valueOf(), rows, cols);
            }
            if (cols === 0) {
              return 1;
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
        }
      }
    });
    function _det(matrix3, rows, cols) {
      if (rows === 1) {
        return clone(matrix3[0][0]);
      } else if (rows === 2) {
        return subtractScalar2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
      } else {
        var negated = false;
        var rowIndices = new Array(rows).fill(0).map((_, i4) => i4);
        for (var k = 0; k < rows; k++) {
          var k_ = rowIndices[k];
          if (isZero2(matrix3[k_][k])) {
            var _k = void 0;
            for (_k = k + 1; _k < rows; _k++) {
              if (!isZero2(matrix3[rowIndices[_k]][k])) {
                k_ = rowIndices[_k];
                rowIndices[_k] = rowIndices[k];
                rowIndices[k] = k_;
                negated = !negated;
                break;
              }
            }
            if (_k === rows)
              return matrix3[k_][k];
          }
          var piv = matrix3[k_][k];
          var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
          for (var i3 = k + 1; i3 < rows; i3++) {
            var i_ = rowIndices[i3];
            for (var j = k + 1; j < rows; j++) {
              matrix3[i_][j] = divideScalar2(subtractScalar2(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
            }
          }
        }
        var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
        return negated ? unaryMinus2(det2) : det2;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/inv.js
  var name242 = "inv";
  var dependencies242 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
  var createInv = /* @__PURE__ */ factory(name242, dependencies242, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      divideScalar: divideScalar2,
      addScalar: addScalar2,
      multiply: multiply2,
      unaryMinus: unaryMinus2,
      det: det2,
      identity: identity2,
      abs: abs3
    } = _ref;
    return typed3(name242, {
      "Array | Matrix": function ArrayMatrix(x) {
        var size2 = isMatrix(x) ? x.size() : arraySize(x);
        switch (size2.length) {
          case 1:
            if (size2[0] === 1) {
              if (isMatrix(x)) {
                return matrix2([divideScalar2(1, x.valueOf()[0])]);
              } else {
                return [divideScalar2(1, x[0])];
              }
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          case 2: {
            var rows = size2[0];
            var cols = size2[1];
            if (rows === cols) {
              if (isMatrix(x)) {
                return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
              } else {
                return _inv(x, rows, cols);
              }
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
        }
      },
      any: function any(x) {
        return divideScalar2(1, x);
      }
    });
    function _inv(mat, rows, cols) {
      var r, s, f, value, temp;
      if (rows === 1) {
        value = mat[0][0];
        if (value === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [[divideScalar2(1, value)]];
      } else if (rows === 2) {
        var d = det2(mat);
        if (d === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        return [[divideScalar2(mat[1][1], d), divideScalar2(unaryMinus2(mat[0][1]), d)], [divideScalar2(unaryMinus2(mat[1][0]), d), divideScalar2(mat[0][0], d)]];
      } else {
        var A2 = mat.concat();
        for (r = 0; r < rows; r++) {
          A2[r] = A2[r].concat();
        }
        var B2 = identity2(rows).valueOf();
        for (var c = 0; c < cols; c++) {
          var ABig = abs3(A2[c][c]);
          var rBig = c;
          r = c + 1;
          while (r < rows) {
            if (abs3(A2[r][c]) > ABig) {
              ABig = abs3(A2[r][c]);
              rBig = r;
            }
            r++;
          }
          if (ABig === 0) {
            throw Error("Cannot calculate inverse, determinant is zero");
          }
          r = rBig;
          if (r !== c) {
            temp = A2[c];
            A2[c] = A2[r];
            A2[r] = temp;
            temp = B2[c];
            B2[c] = B2[r];
            B2[r] = temp;
          }
          var Ac = A2[c];
          var Bc = B2[c];
          for (r = 0; r < rows; r++) {
            var Ar = A2[r];
            var Br = B2[r];
            if (r !== c) {
              if (Ar[c] !== 0) {
                f = divideScalar2(unaryMinus2(Ar[c]), Ac[c]);
                for (s = c; s < cols; s++) {
                  Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
                }
                for (s = 0; s < cols; s++) {
                  Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
                }
              }
            } else {
              f = Ac[c];
              for (s = c; s < cols; s++) {
                Ar[s] = divideScalar2(Ar[s], f);
              }
              for (s = 0; s < cols; s++) {
                Br[s] = divideScalar2(Br[s], f);
              }
            }
          }
        }
        return B2;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/pinv.js
  var name243 = "pinv";
  var dependencies243 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
  var createPinv = /* @__PURE__ */ factory(name243, dependencies243, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      inv: inv2,
      deepEqual: deepEqual2,
      equal: equal2,
      dotDivide: dotDivide2,
      dot: dot2,
      ctranspose: ctranspose2,
      divideScalar: divideScalar2,
      multiply: multiply2,
      add: add3,
      Complex: Complex3
    } = _ref;
    return typed3(name243, {
      "Array | Matrix": function ArrayMatrix(x) {
        var size2 = isMatrix(x) ? x.size() : arraySize(x);
        switch (size2.length) {
          case 1:
            if (_isZeros(x))
              return ctranspose2(x);
            if (size2[0] === 1) {
              return inv2(x);
            } else {
              return dotDivide2(ctranspose2(x), dot2(x, x));
            }
          case 2: {
            if (_isZeros(x))
              return ctranspose2(x);
            var rows = size2[0];
            var cols = size2[1];
            if (rows === cols) {
              try {
                return inv2(x);
              } catch (err) {
                if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/)) {
                } else {
                  throw err;
                }
              }
            }
            if (isMatrix(x)) {
              return matrix2(_pinv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _pinv(x, rows, cols);
            }
          }
          default:
            throw new RangeError("Matrix must be two dimensional (size: " + format3(size2) + ")");
        }
      },
      any: function any(x) {
        if (equal2(x, 0))
          return clone(x);
        return divideScalar2(1, x);
      }
    });
    function _pinv(mat, rows, cols) {
      var {
        C: C2,
        F
      } = _rankFact(mat, rows, cols);
      var Cpinv = multiply2(inv2(multiply2(ctranspose2(C2), C2)), ctranspose2(C2));
      var Fpinv = multiply2(ctranspose2(F), inv2(multiply2(F, ctranspose2(F))));
      return multiply2(Fpinv, Cpinv);
    }
    function _rref(mat, rows, cols) {
      var M = clone(mat);
      var lead = 0;
      for (var r = 0; r < rows; r++) {
        if (cols <= lead) {
          return M;
        }
        var i3 = r;
        while (_isZero(M[i3][lead])) {
          i3++;
          if (rows === i3) {
            i3 = r;
            lead++;
            if (cols === lead) {
              return M;
            }
          }
        }
        [M[i3], M[r]] = [M[r], M[i3]];
        var val = M[r][lead];
        for (var j = 0; j < cols; j++) {
          M[r][j] = dotDivide2(M[r][j], val);
        }
        for (var _i = 0; _i < rows; _i++) {
          if (_i === r)
            continue;
          val = M[_i][lead];
          for (var _j = 0; _j < cols; _j++) {
            M[_i][_j] = add3(M[_i][_j], multiply2(-1, multiply2(val, M[r][_j])));
          }
        }
        lead++;
      }
      return M;
    }
    function _rankFact(mat, rows, cols) {
      var rref = _rref(mat, rows, cols);
      var C2 = mat.map((_, i3) => _.filter((_2, j) => j < rows && !_isZero(dot2(rref[j], rref[j]))));
      var F = rref.filter((_, i3) => !_isZero(dot2(rref[i3], rref[i3])));
      return {
        C: C2,
        F
      };
    }
    function _isZero(x) {
      return equal2(add3(x, Complex3(1, 1)), add3(0, Complex3(1, 1)));
    }
    function _isZeros(arr) {
      return deepEqual2(add3(arr, Complex3(1, 1)), add3(multiply2(arr, 0), Complex3(1, 1)));
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/eigs/complexEigs.js
  function createComplexEigs(_ref) {
    var {
      addScalar: addScalar2,
      subtract: subtract2,
      flatten: flatten3,
      multiply: multiply2,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      sqrt: sqrt3,
      abs: abs3,
      bignumber: bignumber2,
      diag: diag2,
      size: size2,
      reshape: reshape3,
      inv: inv2,
      qr: qr2,
      usolve: usolve2,
      usolveAll: usolveAll2,
      equal: equal2,
      complex: complex2,
      larger: larger2,
      smaller: smaller2,
      matrixFromColumns: matrixFromColumns2,
      dot: dot2
    } = _ref;
    function complexEigs(arr, N, prec, type) {
      var findVectors = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
      var R = balance(arr, N, prec, type, findVectors);
      reduceToHessenberg(arr, N, prec, type, findVectors, R);
      var {
        values,
        C: C2
      } = iterateUntilTriangular(arr, N, prec, type, findVectors);
      if (findVectors) {
        var eigenvectors = findEigenvectors(arr, N, C2, R, values, prec, type);
        return {
          values,
          eigenvectors
        };
      }
      return {
        values
      };
    }
    function balance(arr, N, prec, type, findVectors) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var realzero = big ? bignumber2(0) : 0;
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      var realone = big ? bignumber2(1) : 1;
      var radix = big ? bignumber2(10) : 2;
      var radixSq = multiplyScalar2(radix, radix);
      var Rdiag;
      if (findVectors) {
        Rdiag = Array(N).fill(one);
      }
      var last = false;
      while (!last) {
        last = true;
        for (var i3 = 0; i3 < N; i3++) {
          var colNorm = realzero;
          var rowNorm = realzero;
          for (var j = 0; j < N; j++) {
            if (i3 === j)
              continue;
            colNorm = addScalar2(colNorm, abs3(arr[j][i3]));
            rowNorm = addScalar2(rowNorm, abs3(arr[i3][j]));
          }
          if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
            var f = realone;
            var c = colNorm;
            var rowDivRadix = divideScalar2(rowNorm, radix);
            var rowMulRadix = multiplyScalar2(rowNorm, radix);
            while (smaller2(c, rowDivRadix)) {
              c = multiplyScalar2(c, radixSq);
              f = multiplyScalar2(f, radix);
            }
            while (larger2(c, rowMulRadix)) {
              c = divideScalar2(c, radixSq);
              f = divideScalar2(f, radix);
            }
            var condition = smaller2(divideScalar2(addScalar2(c, rowNorm), f), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
            if (condition) {
              last = false;
              var g2 = divideScalar2(1, f);
              for (var _j = 0; _j < N; _j++) {
                if (i3 === _j) {
                  continue;
                }
                arr[i3][_j] = multiplyScalar2(arr[i3][_j], g2);
                arr[_j][i3] = multiplyScalar2(arr[_j][i3], f);
              }
              if (findVectors) {
                Rdiag[i3] = multiplyScalar2(Rdiag[i3], g2);
              }
            }
          }
        }
      }
      return findVectors ? diag2(Rdiag) : null;
    }
    function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
      if (big) {
        prec = bignumber2(prec);
      }
      for (var i3 = 0; i3 < N - 2; i3++) {
        var maxIndex = 0;
        var max3 = zero;
        for (var j = i3 + 1; j < N; j++) {
          var el = arr[j][i3];
          if (smaller2(abs3(max3), abs3(el))) {
            max3 = el;
            maxIndex = j;
          }
        }
        if (smaller2(abs3(max3), prec)) {
          continue;
        }
        if (maxIndex !== i3 + 1) {
          var tmp1 = arr[maxIndex];
          arr[maxIndex] = arr[i3 + 1];
          arr[i3 + 1] = tmp1;
          for (var _j2 = 0; _j2 < N; _j2++) {
            var tmp2 = arr[_j2][maxIndex];
            arr[_j2][maxIndex] = arr[_j2][i3 + 1];
            arr[_j2][i3 + 1] = tmp2;
          }
          if (findVectors) {
            var tmp3 = R[maxIndex];
            R[maxIndex] = R[i3 + 1];
            R[i3 + 1] = tmp3;
          }
        }
        for (var _j3 = i3 + 2; _j3 < N; _j3++) {
          var n = divideScalar2(arr[_j3][i3], max3);
          if (n === 0) {
            continue;
          }
          for (var k = 0; k < N; k++) {
            arr[_j3][k] = subtract2(arr[_j3][k], multiplyScalar2(n, arr[i3 + 1][k]));
          }
          for (var _k = 0; _k < N; _k++) {
            arr[_k][i3 + 1] = addScalar2(arr[_k][i3 + 1], multiplyScalar2(n, arr[_k][_j3]));
          }
          if (findVectors) {
            for (var _k2 = 0; _k2 < N; _k2++) {
              R[_j3][_k2] = subtract2(R[_j3][_k2], multiplyScalar2(n, R[i3 + 1][_k2]));
            }
          }
        }
      }
      return R;
    }
    function iterateUntilTriangular(A2, N, prec, type, findVectors) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      if (big) {
        prec = bignumber2(prec);
      }
      var arr = clone(A2);
      var lambdas = [];
      var n = N;
      var Sdiag = [];
      var Qtotal = findVectors ? diag2(Array(N).fill(one)) : void 0;
      var Qpartial = findVectors ? diag2(Array(n).fill(one)) : void 0;
      var lastConvergenceBefore = 0;
      while (lastConvergenceBefore <= 100) {
        lastConvergenceBefore += 1;
        var k = arr[n - 1][n - 1];
        for (var i3 = 0; i3 < n; i3++) {
          arr[i3][i3] = subtract2(arr[i3][i3], k);
        }
        var {
          Q: Q3,
          R
        } = qr2(arr);
        arr = multiply2(R, Q3);
        for (var _i = 0; _i < n; _i++) {
          arr[_i][_i] = addScalar2(arr[_i][_i], k);
        }
        if (findVectors) {
          Qpartial = multiply2(Qpartial, Q3);
        }
        if (n === 1 || smaller2(abs3(arr[n - 1][n - 2]), prec)) {
          lastConvergenceBefore = 0;
          lambdas.push(arr[n - 1][n - 1]);
          if (findVectors) {
            Sdiag.unshift([[1]]);
            inflateMatrix(Qpartial, N);
            Qtotal = multiply2(Qtotal, Qpartial);
            if (n > 1) {
              Qpartial = diag2(Array(n - 1).fill(one));
            }
          }
          n -= 1;
          arr.pop();
          for (var _i2 = 0; _i2 < n; _i2++) {
            arr[_i2].pop();
          }
        } else if (n === 2 || smaller2(abs3(arr[n - 2][n - 3]), prec)) {
          lastConvergenceBefore = 0;
          var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
          lambdas.push(...ll);
          if (findVectors) {
            Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
            inflateMatrix(Qpartial, N);
            Qtotal = multiply2(Qtotal, Qpartial);
            if (n > 2) {
              Qpartial = diag2(Array(n - 2).fill(one));
            }
          }
          n -= 2;
          arr.pop();
          arr.pop();
          for (var _i3 = 0; _i3 < n; _i3++) {
            arr[_i3].pop();
            arr[_i3].pop();
          }
        }
        if (n === 0) {
          break;
        }
      }
      lambdas.sort((a, b) => +subtract2(abs3(a), abs3(b)));
      if (lastConvergenceBefore > 100) {
        var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
        err.values = lambdas;
        err.vectors = [];
        throw err;
      }
      var C2 = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : void 0;
      return {
        values: lambdas,
        C: C2
      };
    }
    function findEigenvectors(A2, N, C2, R, values, prec, type) {
      var Cinv = inv2(C2);
      var U = multiply2(Cinv, A2, C2);
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      var uniqueValues = [];
      var multiplicities = [];
      for (var lambda of values) {
        var i3 = indexOf(uniqueValues, lambda, equal2);
        if (i3 === -1) {
          uniqueValues.push(lambda);
          multiplicities.push(1);
        } else {
          multiplicities[i3] += 1;
        }
      }
      var vectors = [];
      var len = uniqueValues.length;
      var b = Array(N).fill(zero);
      var E2 = diag2(Array(N).fill(one));
      var _loop = function _loop2() {
        var lambda2 = uniqueValues[_i4];
        var S = subtract2(U, multiply2(lambda2, E2));
        var solutions = usolveAll2(S, b);
        solutions.shift();
        while (solutions.length < multiplicities[_i4]) {
          var approxVec = inverseIterate(S, N, solutions, prec, type);
          if (approxVec === null) {
            break;
          }
          solutions.push(approxVec);
        }
        var correction = multiply2(inv2(R), C2);
        solutions = solutions.map((v) => multiply2(correction, v));
        vectors.push(...solutions.map((v) => ({
          value: lambda2,
          vector: flatten3(v)
        })));
      };
      for (var _i4 = 0; _i4 < len; _i4++) {
        _loop();
      }
      return vectors;
    }
    function eigenvalues2x2(a, b, c, d) {
      var trA = addScalar2(a, d);
      var detA = subtract2(multiplyScalar2(a, d), multiplyScalar2(b, c));
      var x = multiplyScalar2(trA, 0.5);
      var y2 = multiplyScalar2(sqrt3(subtract2(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
      return [addScalar2(x, y2), subtract2(x, y2)];
    }
    function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      if (smaller2(abs3(c), prec)) {
        return [[one, zero], [zero, one]];
      }
      if (larger2(abs3(subtract2(l1, l2)), prec)) {
        return [[subtract2(l1, d), subtract2(l2, d)], [c, c]];
      }
      var na = subtract2(a, l1);
      var nd = subtract2(d, l1);
      if (smaller2(abs3(b), prec) && smaller2(abs3(nd), prec)) {
        return [[na, one], [c, zero]];
      } else {
        return [[b, zero], [nd, one]];
      }
    }
    function inflateMatrix(arr, N) {
      for (var i3 = 0; i3 < arr.length; i3++) {
        arr[i3].push(...Array(N - arr[i3].length).fill(0));
      }
      for (var _i5 = arr.length; _i5 < N; _i5++) {
        arr.push(Array(N).fill(0));
        arr[_i5][_i5] = 1;
      }
      return arr;
    }
    function blockDiag(arr, N) {
      var M = [];
      for (var i3 = 0; i3 < N; i3++) {
        M[i3] = Array(N).fill(0);
      }
      var I2 = 0;
      for (var sub2 of arr) {
        var n = sub2.length;
        for (var _i6 = 0; _i6 < n; _i6++) {
          for (var j = 0; j < n; j++) {
            M[I2 + _i6][I2 + j] = sub2[_i6][j];
          }
        }
        I2 += n;
      }
      return M;
    }
    function indexOf(arr, el, fn) {
      for (var i3 = 0; i3 < arr.length; i3++) {
        if (fn(arr[i3], el)) {
          return i3;
        }
      }
      return -1;
    }
    function inverseIterate(A2, N, orthog, prec, type) {
      var largeNum = type === "BigNumber" ? bignumber2(1e3) : 1e3;
      var b;
      var i3 = 0;
      for (; i3 < 5; ++i3) {
        b = randomOrthogonalVector(N, orthog, type);
        try {
          b = usolve2(A2, b);
        } catch (_unused) {
          continue;
        }
        if (larger2(norm2(b), largeNum)) {
          break;
        }
      }
      if (i3 >= 5) {
        return null;
      }
      i3 = 0;
      while (true) {
        var c = usolve2(A2, b);
        if (smaller2(norm2(orthogonalComplement(b, [c])), prec)) {
          break;
        }
        if (++i3 >= 10) {
          return null;
        }
        b = normalize(c);
      }
      return b;
    }
    function randomOrthogonalVector(N, orthog, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
      if (big) {
        v = v.map((n) => bignumber2(n));
      }
      if (cplx) {
        v = v.map((n) => complex2(n));
      }
      v = orthogonalComplement(v, orthog);
      return normalize(v, type);
    }
    function orthogonalComplement(v, orthog) {
      var vectorShape = size2(v);
      for (var w2 of orthog) {
        w2 = reshape3(w2, vectorShape);
        v = subtract2(v, multiply2(divideScalar2(dot2(w2, v), dot2(w2, w2)), w2));
      }
      return v;
    }
    function norm2(v) {
      return abs3(sqrt3(dot2(v, v)));
    }
    function normalize(v, type) {
      var big = type === "BigNumber";
      var cplx = type === "Complex";
      var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
      return multiply2(divideScalar2(one, norm2(v)), v);
    }
    return complexEigs;
  }

  // node_modules/mathjs/lib/esm/function/matrix/eigs/realSymmetric.js
  function createRealSymmetric(_ref) {
    var {
      config: config4,
      addScalar: addScalar2,
      subtract: subtract2,
      abs: abs3,
      atan: atan4,
      cos: cos3,
      sin: sin3,
      multiplyScalar: multiplyScalar2,
      inv: inv2,
      bignumber: bignumber2,
      multiply: multiply2,
      add: add3
    } = _ref;
    function main(arr, N) {
      var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config4.epsilon;
      var type = arguments.length > 3 ? arguments[3] : void 0;
      var computeVectors = arguments.length > 4 ? arguments[4] : void 0;
      if (type === "number") {
        return diag2(arr, prec, computeVectors);
      }
      if (type === "BigNumber") {
        return diagBig(arr, prec, computeVectors);
      }
      throw TypeError("Unsupported data type: " + type);
    }
    function diag2(x, precision, computeVectors) {
      var N = x.length;
      var e0 = Math.abs(precision / N);
      var psi;
      var Sij;
      if (computeVectors) {
        Sij = new Array(N);
        for (var i3 = 0; i3 < N; i3++) {
          Sij[i3] = Array(N).fill(0);
          Sij[i3][i3] = 1;
        }
      }
      var Vab = getAij(x);
      while (Math.abs(Vab[1]) >= Math.abs(e0)) {
        var _i = Vab[0][0];
        var j = Vab[0][1];
        psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
        x = x1(x, psi, _i, j);
        if (computeVectors)
          Sij = Sij1(Sij, psi, _i, j);
        Vab = getAij(x);
      }
      var Ei = Array(N).fill(0);
      for (var _i2 = 0; _i2 < N; _i2++) {
        Ei[_i2] = x[_i2][_i2];
      }
      return sorting(clone(Ei), Sij, computeVectors);
    }
    function diagBig(x, precision, computeVectors) {
      var N = x.length;
      var e0 = abs3(precision / N);
      var psi;
      var Sij;
      if (computeVectors) {
        Sij = new Array(N);
        for (var i3 = 0; i3 < N; i3++) {
          Sij[i3] = Array(N).fill(0);
          Sij[i3][i3] = 1;
        }
      }
      var Vab = getAijBig(x);
      while (abs3(Vab[1]) >= abs3(e0)) {
        var _i3 = Vab[0][0];
        var j = Vab[0][1];
        psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
        x = x1Big(x, psi, _i3, j);
        if (computeVectors)
          Sij = Sij1Big(Sij, psi, _i3, j);
        Vab = getAijBig(x);
      }
      var Ei = Array(N).fill(0);
      for (var _i4 = 0; _i4 < N; _i4++) {
        Ei[_i4] = x[_i4][_i4];
      }
      return sorting(clone(Ei), Sij, computeVectors);
    }
    function getTheta(aii, ajj, aij) {
      var denom = ajj - aii;
      if (Math.abs(denom) <= config4.epsilon) {
        return Math.PI / 4;
      } else {
        return 0.5 * Math.atan(2 * aij / (ajj - aii));
      }
    }
    function getThetaBig(aii, ajj, aij) {
      var denom = subtract2(ajj, aii);
      if (abs3(denom) <= config4.epsilon) {
        return bignumber2(-1).acos().div(4);
      } else {
        return multiplyScalar2(0.5, atan4(multiply2(2, aij, inv2(denom))));
      }
    }
    function Sij1(Sij, theta, i3, j) {
      var N = Sij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var Ski = Array(N).fill(0);
      var Skj = Array(N).fill(0);
      for (var k = 0; k < N; k++) {
        Ski[k] = c * Sij[k][i3] - s * Sij[k][j];
        Skj[k] = s * Sij[k][i3] + c * Sij[k][j];
      }
      for (var _k = 0; _k < N; _k++) {
        Sij[_k][i3] = Ski[_k];
        Sij[_k][j] = Skj[_k];
      }
      return Sij;
    }
    function Sij1Big(Sij, theta, i3, j) {
      var N = Sij.length;
      var c = cos3(theta);
      var s = sin3(theta);
      var Ski = Array(N).fill(bignumber2(0));
      var Skj = Array(N).fill(bignumber2(0));
      for (var k = 0; k < N; k++) {
        Ski[k] = subtract2(multiplyScalar2(c, Sij[k][i3]), multiplyScalar2(s, Sij[k][j]));
        Skj[k] = addScalar2(multiplyScalar2(s, Sij[k][i3]), multiplyScalar2(c, Sij[k][j]));
      }
      for (var _k2 = 0; _k2 < N; _k2++) {
        Sij[_k2][i3] = Ski[_k2];
        Sij[_k2][j] = Skj[_k2];
      }
      return Sij;
    }
    function x1Big(Hij, theta, i3, j) {
      var N = Hij.length;
      var c = bignumber2(cos3(theta));
      var s = bignumber2(sin3(theta));
      var c2 = multiplyScalar2(c, c);
      var s2 = multiplyScalar2(s, s);
      var Aki = Array(N).fill(bignumber2(0));
      var Akj = Array(N).fill(bignumber2(0));
      var csHij = multiply2(bignumber2(2), c, s, Hij[i3][j]);
      var Aii = addScalar2(subtract2(multiplyScalar2(c2, Hij[i3][i3]), csHij), multiplyScalar2(s2, Hij[j][j]));
      var Ajj = add3(multiplyScalar2(s2, Hij[i3][i3]), csHij, multiplyScalar2(c2, Hij[j][j]));
      for (var k = 0; k < N; k++) {
        Aki[k] = subtract2(multiplyScalar2(c, Hij[i3][k]), multiplyScalar2(s, Hij[j][k]));
        Akj[k] = addScalar2(multiplyScalar2(s, Hij[i3][k]), multiplyScalar2(c, Hij[j][k]));
      }
      Hij[i3][i3] = Aii;
      Hij[j][j] = Ajj;
      Hij[i3][j] = bignumber2(0);
      Hij[j][i3] = bignumber2(0);
      for (var _k3 = 0; _k3 < N; _k3++) {
        if (_k3 !== i3 && _k3 !== j) {
          Hij[i3][_k3] = Aki[_k3];
          Hij[_k3][i3] = Aki[_k3];
          Hij[j][_k3] = Akj[_k3];
          Hij[_k3][j] = Akj[_k3];
        }
      }
      return Hij;
    }
    function x1(Hij, theta, i3, j) {
      var N = Hij.length;
      var c = Math.cos(theta);
      var s = Math.sin(theta);
      var c2 = c * c;
      var s2 = s * s;
      var Aki = Array(N).fill(0);
      var Akj = Array(N).fill(0);
      var Aii = c2 * Hij[i3][i3] - 2 * c * s * Hij[i3][j] + s2 * Hij[j][j];
      var Ajj = s2 * Hij[i3][i3] + 2 * c * s * Hij[i3][j] + c2 * Hij[j][j];
      for (var k = 0; k < N; k++) {
        Aki[k] = c * Hij[i3][k] - s * Hij[j][k];
        Akj[k] = s * Hij[i3][k] + c * Hij[j][k];
      }
      Hij[i3][i3] = Aii;
      Hij[j][j] = Ajj;
      Hij[i3][j] = 0;
      Hij[j][i3] = 0;
      for (var _k4 = 0; _k4 < N; _k4++) {
        if (_k4 !== i3 && _k4 !== j) {
          Hij[i3][_k4] = Aki[_k4];
          Hij[_k4][i3] = Aki[_k4];
          Hij[j][_k4] = Akj[_k4];
          Hij[_k4][j] = Akj[_k4];
        }
      }
      return Hij;
    }
    function getAij(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i3 = 0; i3 < N; i3++) {
        for (var j = i3 + 1; j < N; j++) {
          if (Math.abs(maxMij) < Math.abs(Mij[i3][j])) {
            maxMij = Math.abs(Mij[i3][j]);
            maxIJ = [i3, j];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function getAijBig(Mij) {
      var N = Mij.length;
      var maxMij = 0;
      var maxIJ = [0, 1];
      for (var i3 = 0; i3 < N; i3++) {
        for (var j = i3 + 1; j < N; j++) {
          if (abs3(maxMij) < abs3(Mij[i3][j])) {
            maxMij = abs3(Mij[i3][j]);
            maxIJ = [i3, j];
          }
        }
      }
      return [maxIJ, maxMij];
    }
    function sorting(E2, S, computeVectors) {
      var N = E2.length;
      var values = Array(N);
      var vecs;
      if (computeVectors) {
        vecs = Array(N);
        for (var k = 0; k < N; k++) {
          vecs[k] = Array(N);
        }
      }
      for (var i3 = 0; i3 < N; i3++) {
        var minID = 0;
        var minE = E2[0];
        for (var j = 0; j < E2.length; j++) {
          if (abs3(E2[j]) < abs3(minE)) {
            minID = j;
            minE = E2[minID];
          }
        }
        values[i3] = E2.splice(minID, 1)[0];
        if (computeVectors) {
          for (var _k5 = 0; _k5 < N; _k5++) {
            vecs[i3][_k5] = S[_k5][minID];
            S[_k5].splice(minID, 1);
          }
        }
      }
      if (!computeVectors)
        return {
          values
        };
      var eigenvectors = vecs.map((vector, i4) => ({
        value: values[i4],
        vector
      }));
      return {
        values,
        eigenvectors
      };
    }
    return main;
  }

  // node_modules/mathjs/lib/esm/function/matrix/eigs.js
  var name244 = "eigs";
  var dependencies244 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "size", "reshape", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
  var createEigs = /* @__PURE__ */ factory(name244, dependencies244, (_ref) => {
    var {
      config: config4,
      typed: typed3,
      matrix: matrix2,
      addScalar: addScalar2,
      subtract: subtract2,
      equal: equal2,
      abs: abs3,
      atan: atan4,
      cos: cos3,
      sin: sin3,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      inv: inv2,
      bignumber: bignumber2,
      multiply: multiply2,
      add: add3,
      larger: larger2,
      column: column2,
      flatten: flatten3,
      number: number2,
      complex: complex2,
      sqrt: sqrt3,
      diag: diag2,
      size: size2,
      reshape: reshape3,
      qr: qr2,
      usolve: usolve2,
      usolveAll: usolveAll2,
      im: im2,
      re: re2,
      smaller: smaller2,
      matrixFromColumns: matrixFromColumns2,
      dot: dot2
    } = _ref;
    var doRealSymmetric = createRealSymmetric({
      config: config4,
      addScalar: addScalar2,
      subtract: subtract2,
      column: column2,
      flatten: flatten3,
      equal: equal2,
      abs: abs3,
      atan: atan4,
      cos: cos3,
      sin: sin3,
      multiplyScalar: multiplyScalar2,
      inv: inv2,
      bignumber: bignumber2,
      complex: complex2,
      multiply: multiply2,
      add: add3
    });
    var doComplexEigs = createComplexEigs({
      config: config4,
      addScalar: addScalar2,
      subtract: subtract2,
      multiply: multiply2,
      multiplyScalar: multiplyScalar2,
      flatten: flatten3,
      divideScalar: divideScalar2,
      sqrt: sqrt3,
      abs: abs3,
      bignumber: bignumber2,
      diag: diag2,
      size: size2,
      reshape: reshape3,
      qr: qr2,
      inv: inv2,
      usolve: usolve2,
      usolveAll: usolveAll2,
      equal: equal2,
      complex: complex2,
      larger: larger2,
      smaller: smaller2,
      matrixFromColumns: matrixFromColumns2,
      dot: dot2
    });
    return typed3("eigs", {
      // The conversion to matrix in the first two implementations,
      // just to convert back to an array right away in
      // computeValuesAndVectors, is unfortunate, and should perhaps be
      // streamlined. It is done because the Matrix object carries some
      // type information about its entries, and so constructing the matrix
      // is a roundabout way of doing type detection.
      Array: function Array2(x) {
        return doEigs(matrix2(x));
      },
      "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
        return doEigs(matrix2(x), {
          precision: prec
        });
      },
      "Array, Object"(x, opts) {
        return doEigs(matrix2(x), opts);
      },
      Matrix: function Matrix2(mat) {
        return doEigs(mat, {
          matricize: true
        });
      },
      "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
        return doEigs(mat, {
          precision: prec,
          matricize: true
        });
      },
      "Matrix, Object": function MatrixObject(mat, opts) {
        var useOpts = {
          matricize: true
        };
        _extends(useOpts, opts);
        return doEigs(mat, useOpts);
      }
    });
    function doEigs(mat) {
      var _opts$precision;
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var computeVectors = "eigenvectors" in opts ? opts.eigenvectors : true;
      var prec = (_opts$precision = opts.precision) !== null && _opts$precision !== void 0 ? _opts$precision : config4.epsilon;
      var result = computeValuesAndVectors(mat, prec, computeVectors);
      if (opts.matricize) {
        result.values = matrix2(result.values);
        if (computeVectors) {
          result.eigenvectors = result.eigenvectors.map((_ref2) => {
            var {
              value,
              vector
            } = _ref2;
            return {
              value,
              vector: matrix2(vector)
            };
          });
        }
      }
      if (computeVectors) {
        Object.defineProperty(result, "vectors", {
          enumerable: false,
          // to make sure that the eigenvectors can still be
          // converted to string.
          get: () => {
            throw new Error("eigs(M).vectors replaced with eigs(M).eigenvectors");
          }
        });
      }
      return result;
    }
    function computeValuesAndVectors(mat, prec, computeVectors) {
      var arr = mat.toArray();
      var asize = mat.size();
      if (asize.length !== 2 || asize[0] !== asize[1]) {
        throw new RangeError("Matrix must be square (size: ".concat(format3(asize), ")"));
      }
      var N = asize[0];
      if (isReal(arr, N, prec)) {
        coerceReal(arr, N);
        if (isSymmetric(arr, N, prec)) {
          var _type = coerceTypes(mat, arr, N);
          return doRealSymmetric(arr, N, prec, _type, computeVectors);
        }
      }
      var type = coerceTypes(mat, arr, N);
      return doComplexEigs(arr, N, prec, type, computeVectors);
    }
    function isSymmetric(arr, N, prec) {
      for (var i3 = 0; i3 < N; i3++) {
        for (var j = i3; j < N; j++) {
          if (larger2(bignumber2(abs3(subtract2(arr[i3][j], arr[j][i3]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    function isReal(arr, N, prec) {
      for (var i3 = 0; i3 < N; i3++) {
        for (var j = 0; j < N; j++) {
          if (larger2(bignumber2(abs3(im2(arr[i3][j]))), prec)) {
            return false;
          }
        }
      }
      return true;
    }
    function coerceReal(arr, N) {
      for (var i3 = 0; i3 < N; i3++) {
        for (var j = 0; j < N; j++) {
          arr[i3][j] = re2(arr[i3][j]);
        }
      }
    }
    function coerceTypes(mat, arr, N) {
      var type = mat.datatype();
      if (type === "number" || type === "BigNumber" || type === "Complex") {
        return type;
      }
      var hasNumber = false;
      var hasBig = false;
      var hasComplex = false;
      for (var i3 = 0; i3 < N; i3++) {
        for (var j = 0; j < N; j++) {
          var el = arr[i3][j];
          if (isNumber(el) || isFraction(el)) {
            hasNumber = true;
          } else if (isBigNumber(el)) {
            hasBig = true;
          } else if (isComplex(el)) {
            hasComplex = true;
          } else {
            throw TypeError("Unsupported type in Matrix: " + typeOf(el));
          }
        }
      }
      if (hasBig && hasComplex) {
        console.warn("Complex BigNumbers not supported, this operation will lose precission.");
      }
      if (hasComplex) {
        for (var _i = 0; _i < N; _i++) {
          for (var _j = 0; _j < N; _j++) {
            arr[_i][_j] = complex2(arr[_i][_j]);
          }
        }
        return "Complex";
      }
      if (hasBig) {
        for (var _i2 = 0; _i2 < N; _i2++) {
          for (var _j2 = 0; _j2 < N; _j2++) {
            arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
          }
        }
        return "BigNumber";
      }
      if (hasNumber) {
        for (var _i3 = 0; _i3 < N; _i3++) {
          for (var _j3 = 0; _j3 < N; _j3++) {
            arr[_i3][_j3] = number2(arr[_i3][_j3]);
          }
        }
        return "number";
      } else {
        throw TypeError("Matrix contains unsupported types only.");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/expm.js
  var name245 = "expm";
  var dependencies245 = ["typed", "abs", "add", "identity", "inv", "multiply"];
  var createExpm = /* @__PURE__ */ factory(name245, dependencies245, (_ref) => {
    var {
      typed: typed3,
      abs: abs3,
      add: add3,
      identity: identity2,
      inv: inv2,
      multiply: multiply2
    } = _ref;
    return typed3(name245, {
      Matrix: function Matrix2(A2) {
        var size2 = A2.size();
        if (size2.length !== 2 || size2[0] !== size2[1]) {
          throw new RangeError("Matrix must be square (size: " + format3(size2) + ")");
        }
        var n = size2[0];
        var eps = 1e-15;
        var infNorm = infinityNorm(A2);
        var params = findParams(infNorm, eps);
        var q = params.q;
        var j = params.j;
        var Apos = multiply2(A2, Math.pow(2, -j));
        var N = identity2(n);
        var D2 = identity2(n);
        var factor = 1;
        var AposToI = Apos;
        var alternate = -1;
        for (var i3 = 1; i3 <= q; i3++) {
          if (i3 > 1) {
            AposToI = multiply2(AposToI, Apos);
            alternate = -alternate;
          }
          factor = factor * (q - i3 + 1) / ((2 * q - i3 + 1) * i3);
          N = add3(N, multiply2(factor, AposToI));
          D2 = add3(D2, multiply2(factor * alternate, AposToI));
        }
        var R = multiply2(inv2(D2), N);
        for (var _i = 0; _i < j; _i++) {
          R = multiply2(R, R);
        }
        return isSparseMatrix(A2) ? A2.createSparseMatrix(R) : R;
      }
    });
    function infinityNorm(A2) {
      var n = A2.size()[0];
      var infNorm = 0;
      for (var i3 = 0; i3 < n; i3++) {
        var rowSum = 0;
        for (var j = 0; j < n; j++) {
          rowSum += abs3(A2.get([i3, j]));
        }
        infNorm = Math.max(rowSum, infNorm);
      }
      return infNorm;
    }
    function findParams(infNorm, eps) {
      var maxSearchSize = 30;
      for (var k = 0; k < maxSearchSize; k++) {
        for (var q = 0; q <= k; q++) {
          var j = k - q;
          if (errorEstimate(infNorm, q, j) < eps) {
            return {
              q,
              j
            };
          }
        }
      }
      throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
    }
    function errorEstimate(infNorm, q, j) {
      var qfac = 1;
      for (var i3 = 2; i3 <= q; i3++) {
        qfac *= i3;
      }
      var twoqfac = qfac;
      for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
        twoqfac *= _i2;
      }
      var twoqp1fac = twoqfac * (2 * q + 1);
      return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
    }
  });

  // node_modules/mathjs/lib/esm/function/matrix/sqrtm.js
  var name246 = "sqrtm";
  var dependencies246 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
  var createSqrtm = /* @__PURE__ */ factory(name246, dependencies246, (_ref) => {
    var {
      typed: typed3,
      abs: abs3,
      add: add3,
      multiply: multiply2,
      map: map3,
      sqrt: sqrt3,
      subtract: subtract2,
      inv: inv2,
      size: size2,
      max: max3,
      identity: identity2
    } = _ref;
    var _maxIterations = 1e3;
    var _tolerance = 1e-6;
    function _denmanBeavers(A2) {
      var error;
      var iterations = 0;
      var Y = A2;
      var Z = identity2(size2(A2));
      do {
        var Yk = Y;
        Y = multiply2(0.5, add3(Yk, inv2(Z)));
        Z = multiply2(0.5, add3(Z, inv2(Yk)));
        error = max3(abs3(subtract2(Y, Yk)));
        if (error > _tolerance && ++iterations > _maxIterations) {
          throw new Error("computing square root of matrix: iterative method could not converge");
        }
      } while (error > _tolerance);
      return Y;
    }
    return typed3(name246, {
      "Array | Matrix": function ArrayMatrix(A2) {
        var size3 = isMatrix(A2) ? A2.size() : arraySize(A2);
        switch (size3.length) {
          case 1:
            if (size3[0] === 1) {
              return map3(A2, sqrt3);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size3) + ")");
            }
          case 2: {
            var rows = size3[0];
            var cols = size3[1];
            if (rows === cols) {
              return _denmanBeavers(A2);
            } else {
              throw new RangeError("Matrix must be square (size: " + format3(size3) + ")");
            }
          }
          default:
            throw new RangeError("Matrix must be at most two dimensional (size: " + format3(size3) + ")");
        }
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/sylvester.js
  var name247 = "sylvester";
  var dependencies247 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
  var createSylvester = /* @__PURE__ */ factory(name247, dependencies247, (_ref) => {
    var {
      typed: typed3,
      schur: schur2,
      matrixFromColumns: matrixFromColumns2,
      matrix: matrix2,
      multiply: multiply2,
      range: range2,
      concat: concat3,
      transpose: transpose2,
      index: index2,
      subset: subset2,
      add: add3,
      subtract: subtract2,
      identity: identity2,
      lusolve: lusolve2,
      abs: abs3
    } = _ref;
    return typed3(name247, {
      "Matrix, Matrix, Matrix": _sylvester,
      "Array, Matrix, Matrix": function ArrayMatrixMatrix(A2, B2, C2) {
        return _sylvester(matrix2(A2), B2, C2);
      },
      "Array, Array, Matrix": function ArrayArrayMatrix(A2, B2, C2) {
        return _sylvester(matrix2(A2), matrix2(B2), C2);
      },
      "Array, Matrix, Array": function ArrayMatrixArray(A2, B2, C2) {
        return _sylvester(matrix2(A2), B2, matrix2(C2));
      },
      "Matrix, Array, Matrix": function MatrixArrayMatrix(A2, B2, C2) {
        return _sylvester(A2, matrix2(B2), C2);
      },
      "Matrix, Array, Array": function MatrixArrayArray(A2, B2, C2) {
        return _sylvester(A2, matrix2(B2), matrix2(C2));
      },
      "Matrix, Matrix, Array": function MatrixMatrixArray(A2, B2, C2) {
        return _sylvester(A2, B2, matrix2(C2));
      },
      "Array, Array, Array": function ArrayArrayArray(A2, B2, C2) {
        return _sylvester(matrix2(A2), matrix2(B2), matrix2(C2)).toArray();
      }
    });
    function _sylvester(A2, B2, C2) {
      var n = B2.size()[0];
      var m = A2.size()[0];
      var sA = schur2(A2);
      var F = sA.T;
      var U = sA.U;
      var sB = schur2(multiply2(-1, B2));
      var G2 = sB.T;
      var V = sB.U;
      var D2 = multiply2(multiply2(transpose2(U), C2), V);
      var all = range2(0, m);
      var y2 = [];
      var hc = (a, b) => concat3(a, b, 1);
      var vc = (a, b) => concat3(a, b, 0);
      for (var k = 0; k < n; k++) {
        if (k < n - 1 && abs3(subset2(G2, index2(k + 1, k))) > 1e-5) {
          var RHS = vc(subset2(D2, index2(all, k)), subset2(D2, index2(all, k + 1)));
          for (var j = 0; j < k; j++) {
            RHS = add3(RHS, vc(multiply2(y2[j], subset2(G2, index2(j, k))), multiply2(y2[j], subset2(G2, index2(j, k + 1)))));
          }
          var gkk = multiply2(identity2(m), multiply2(-1, subset2(G2, index2(k, k))));
          var gmk = multiply2(identity2(m), multiply2(-1, subset2(G2, index2(k + 1, k))));
          var gkm = multiply2(identity2(m), multiply2(-1, subset2(G2, index2(k, k + 1))));
          var gmm = multiply2(identity2(m), multiply2(-1, subset2(G2, index2(k + 1, k + 1))));
          var LHS = vc(hc(add3(F, gkk), gmk), hc(gkm, add3(F, gmm)));
          var yAux = lusolve2(LHS, RHS);
          y2[k] = yAux.subset(index2(range2(0, m), 0));
          y2[k + 1] = yAux.subset(index2(range2(m, 2 * m), 0));
          k++;
        } else {
          var _RHS = subset2(D2, index2(all, k));
          for (var _j = 0; _j < k; _j++) {
            _RHS = add3(_RHS, multiply2(y2[_j], subset2(G2, index2(_j, k))));
          }
          var _gkk = subset2(G2, index2(k, k));
          var _LHS = subtract2(F, multiply2(_gkk, identity2(m)));
          y2[k] = lusolve2(_LHS, _RHS);
        }
      }
      var Y = matrix2(matrixFromColumns2(...y2));
      var X = multiply2(U, multiply2(Y, transpose2(V)));
      return X;
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/decomposition/schur.js
  var name248 = "schur";
  var dependencies248 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
  var createSchur = /* @__PURE__ */ factory(name248, dependencies248, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      identity: identity2,
      multiply: multiply2,
      qr: qr2,
      norm: norm2,
      subtract: subtract2
    } = _ref;
    return typed3(name248, {
      Array: function Array2(X) {
        var r = _schur(matrix2(X));
        return {
          U: r.U.valueOf(),
          T: r.T.valueOf()
        };
      },
      Matrix: function Matrix2(X) {
        return _schur(X);
      }
    });
    function _schur(X) {
      var n = X.size()[0];
      var A2 = X;
      var U = identity2(n);
      var k = 0;
      var A0;
      do {
        A0 = A2;
        var QR = qr2(A2);
        var Q3 = QR.Q;
        var R = QR.R;
        A2 = multiply2(R, Q3);
        U = multiply2(U, Q3);
        if (k++ > 100) {
          break;
        }
      } while (norm2(subtract2(A2, A0)) > 1e-4);
      return {
        U,
        T: A2
      };
    }
  });

  // node_modules/mathjs/lib/esm/function/algebra/lyap.js
  var name249 = "lyap";
  var dependencies249 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
  var createLyap = /* @__PURE__ */ factory(name249, dependencies249, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      sylvester: sylvester2,
      multiply: multiply2,
      transpose: transpose2
    } = _ref;
    return typed3(name249, {
      "Matrix, Matrix": function MatrixMatrix(A2, Q3) {
        return sylvester2(A2, transpose2(A2), multiply2(-1, Q3));
      },
      "Array, Matrix": function ArrayMatrix(A2, Q3) {
        return sylvester2(matrix2(A2), transpose2(matrix2(A2)), multiply2(-1, Q3));
      },
      "Matrix, Array": function MatrixArray(A2, Q3) {
        return sylvester2(A2, transpose2(matrix2(A2)), matrix2(multiply2(-1, Q3)));
      },
      "Array, Array": function ArrayArray(A2, Q3) {
        return sylvester2(matrix2(A2), transpose2(matrix2(A2)), matrix2(multiply2(-1, Q3))).toArray();
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/arithmetic/divide.js
  var name250 = "divide";
  var dependencies250 = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
  var createDivide = /* @__PURE__ */ factory(name250, dependencies250, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      multiply: multiply2,
      equalScalar: equalScalar2,
      divideScalar: divideScalar2,
      inv: inv2
    } = _ref;
    var matAlgo11xS0s = createMatAlgo11xS0s({
      typed: typed3,
      equalScalar: equalScalar2
    });
    var matAlgo14xDs = createMatAlgo14xDs({
      typed: typed3
    });
    return typed3("divide", extend({
      // we extend the signatures of divideScalar with signatures dealing with matrices
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y2) {
        return multiply2(x, inv2(y2));
      },
      "DenseMatrix, any": function DenseMatrixAny(x, y2) {
        return matAlgo14xDs(x, y2, divideScalar2, false);
      },
      "SparseMatrix, any": function SparseMatrixAny(x, y2) {
        return matAlgo11xS0s(x, y2, divideScalar2, false);
      },
      "Array, any": function ArrayAny(x, y2) {
        return matAlgo14xDs(matrix2(x), y2, divideScalar2, false).valueOf();
      },
      "any, Array | Matrix": function anyArrayMatrix(x, y2) {
        return multiply2(x, inv2(y2));
      }
    }, divideScalar2.signatures));
  });

  // node_modules/mathjs/lib/esm/function/geometry/distance.js
  var name251 = "distance";
  var dependencies251 = ["typed", "addScalar", "subtractScalar", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"];
  var createDistance = /* @__PURE__ */ factory(name251, dependencies251, (_ref) => {
    var {
      typed: typed3,
      addScalar: addScalar2,
      subtractScalar: subtractScalar2,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      deepEqual: deepEqual2,
      sqrt: sqrt3,
      abs: abs3
    } = _ref;
    return typed3(name251, {
      "Array, Array, Array": function ArrayArrayArray(x, y2, z) {
        if (x.length === 2 && y2.length === 2 && z.length === 2) {
          if (!_2d(x)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
          }
          if (!_2d(y2)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
          }
          if (!_2d(z)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
          }
          if (deepEqual2(y2, z)) {
            throw new TypeError("LinePoint1 should not be same with LinePoint2");
          }
          var xCoeff = subtractScalar2(z[1], y2[1]);
          var yCoeff = subtractScalar2(y2[0], z[0]);
          var constant = subtractScalar2(multiplyScalar2(z[0], y2[1]), multiplyScalar2(y2[0], z[1]));
          return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Object, Object, Object": function ObjectObjectObject(x, y2, z) {
        if (Object.keys(x).length === 2 && Object.keys(y2).length === 2 && Object.keys(z).length === 2) {
          if (!_2d(x)) {
            throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
          }
          if (!_2d(y2)) {
            throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
          }
          if (!_2d(z)) {
            throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
          }
          if (deepEqual2(_objectToArray(y2), _objectToArray(z))) {
            throw new TypeError("LinePoint1 should not be same with LinePoint2");
          }
          if ("pointX" in x && "pointY" in x && "lineOnePtX" in y2 && "lineOnePtY" in y2 && "lineTwoPtX" in z && "lineTwoPtY" in z) {
            var xCoeff = subtractScalar2(z.lineTwoPtY, y2.lineOnePtY);
            var yCoeff = subtractScalar2(y2.lineOnePtX, z.lineTwoPtX);
            var constant = subtractScalar2(multiplyScalar2(z.lineTwoPtX, y2.lineOnePtY), multiplyScalar2(y2.lineOnePtX, z.lineTwoPtY));
            return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Array, Array": function ArrayArray(x, y2) {
        if (x.length === 2 && y2.length === 3) {
          if (!_2d(x)) {
            throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
          }
          if (!_3d(y2)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
          }
          return _distancePointLine2D(x[0], x[1], y2[0], y2[1], y2[2]);
        } else if (x.length === 3 && y2.length === 6) {
          if (!_3d(x)) {
            throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
          }
          if (!_parametricLine(y2)) {
            throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
          }
          return _distancePointLine3D(x[0], x[1], x[2], y2[0], y2[1], y2[2], y2[3], y2[4], y2[5]);
        } else if (x.length === y2.length && x.length > 0) {
          if (!_containsOnlyNumbers(x)) {
            throw new TypeError("All values of an array should be numbers or BigNumbers");
          }
          if (!_containsOnlyNumbers(y2)) {
            throw new TypeError("All values of an array should be numbers or BigNumbers");
          }
          return _euclideanDistance(x, y2);
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      "Object, Object": function ObjectObject(x, y2) {
        if (Object.keys(x).length === 2 && Object.keys(y2).length === 3) {
          if (!_2d(x)) {
            throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
          }
          if (!_3d(y2)) {
            throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
          }
          if ("pointX" in x && "pointY" in x && "xCoeffLine" in y2 && "yCoeffLine" in y2 && "constant" in y2) {
            return _distancePointLine2D(x.pointX, x.pointY, y2.xCoeffLine, y2.yCoeffLine, y2.constant);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y2).length === 6) {
          if (!_3d(x)) {
            throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
          }
          if (!_parametricLine(y2)) {
            throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
          }
          if ("pointX" in x && "pointY" in x && "x0" in y2 && "y0" in y2 && "z0" in y2 && "a" in y2 && "b" in y2 && "c" in y2) {
            return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y2.x0, y2.y0, y2.z0, y2.a, y2.b, y2.c);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 2 && Object.keys(y2).length === 2) {
          if (!_2d(x)) {
            throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
          }
          if (!_2d(y2)) {
            throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
          }
          if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y2 && "pointTwoY" in y2) {
            return _euclideanDistance([x.pointOneX, x.pointOneY], [y2.pointTwoX, y2.pointTwoY]);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else if (Object.keys(x).length === 3 && Object.keys(y2).length === 3) {
          if (!_3d(x)) {
            throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
          }
          if (!_3d(y2)) {
            throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
          }
          if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y2 && "pointTwoY" in y2 && "pointTwoZ" in y2) {
            return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y2.pointTwoX, y2.pointTwoY, y2.pointTwoZ]);
          } else {
            throw new TypeError("Key names do not match");
          }
        } else {
          throw new TypeError("Invalid Arguments: Try again");
        }
      },
      Array: function Array2(arr) {
        if (!_pairwise(arr)) {
          throw new TypeError("Incorrect array format entered for pairwise distance calculation");
        }
        return _distancePairwise(arr);
      }
    });
    function _isNumber(a) {
      return typeof a === "number" || isBigNumber(a);
    }
    function _2d(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }
      return _isNumber(a[0]) && _isNumber(a[1]);
    }
    function _3d(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }
      return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
    }
    function _containsOnlyNumbers(a) {
      if (!Array.isArray(a)) {
        a = _objectToArray(a);
      }
      return a.every(_isNumber);
    }
    function _parametricLine(a) {
      if (a.constructor !== Array) {
        a = _objectToArray(a);
      }
      return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
    }
    function _objectToArray(o2) {
      var keys = Object.keys(o2);
      var a = [];
      for (var i3 = 0; i3 < keys.length; i3++) {
        a.push(o2[keys[i3]]);
      }
      return a;
    }
    function _pairwise(a) {
      if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
        if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
          return false;
        }
      } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
        if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
          return false;
        }
      } else {
        return false;
      }
      return true;
    }
    function _distancePointLine2D(x, y2, a, b, c) {
      var num = abs3(addScalar2(addScalar2(multiplyScalar2(a, x), multiplyScalar2(b, y2)), c));
      var den = sqrt3(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)));
      return divideScalar2(num, den);
    }
    function _distancePointLine3D(x, y2, z, x0, y0, z0, a, b, c) {
      var num = [subtractScalar2(multiplyScalar2(subtractScalar2(y0, y2), c), multiplyScalar2(subtractScalar2(z0, z), b)), subtractScalar2(multiplyScalar2(subtractScalar2(z0, z), a), multiplyScalar2(subtractScalar2(x0, x), c)), subtractScalar2(multiplyScalar2(subtractScalar2(x0, x), b), multiplyScalar2(subtractScalar2(y0, y2), a))];
      num = sqrt3(addScalar2(addScalar2(multiplyScalar2(num[0], num[0]), multiplyScalar2(num[1], num[1])), multiplyScalar2(num[2], num[2])));
      var den = sqrt3(addScalar2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)), multiplyScalar2(c, c)));
      return divideScalar2(num, den);
    }
    function _euclideanDistance(x, y2) {
      var vectorSize = x.length;
      var result = 0;
      var diff2 = 0;
      for (var i3 = 0; i3 < vectorSize; i3++) {
        diff2 = subtractScalar2(x[i3], y2[i3]);
        result = addScalar2(multiplyScalar2(diff2, diff2), result);
      }
      return sqrt3(result);
    }
    function _distancePairwise(a) {
      var result = [];
      var pointA = [];
      var pointB = [];
      for (var i3 = 0; i3 < a.length - 1; i3++) {
        for (var j = i3 + 1; j < a.length; j++) {
          if (a[0].length === 2) {
            pointA = [a[i3][0], a[i3][1]];
            pointB = [a[j][0], a[j][1]];
          } else if (a[0].length === 3) {
            pointA = [a[i3][0], a[i3][1], a[i3][2]];
            pointB = [a[j][0], a[j][1], a[j][2]];
          }
          result.push(_euclideanDistance(pointA, pointB));
        }
      }
      return result;
    }
  });

  // node_modules/mathjs/lib/esm/function/geometry/intersect.js
  var name252 = "intersect";
  var dependencies252 = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
  var createIntersect = /* @__PURE__ */ factory(name252, dependencies252, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      abs: abs3,
      add: add3,
      addScalar: addScalar2,
      matrix: matrix2,
      multiply: multiply2,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      subtract: subtract2,
      smaller: smaller2,
      equalScalar: equalScalar2,
      flatten: flatten3,
      isZero: isZero2,
      isNumeric: isNumeric2
    } = _ref;
    return typed3("intersect", {
      "Array, Array, Array": _AAA,
      "Array, Array, Array, Array": _AAAA,
      "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y2, plane) {
        var arr = _AAA(x.valueOf(), y2.valueOf(), plane.valueOf());
        return arr === null ? null : matrix2(arr);
      },
      "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w2, x, y2, z) {
        var arr = _AAAA(w2.valueOf(), x.valueOf(), y2.valueOf(), z.valueOf());
        return arr === null ? null : matrix2(arr);
      }
    });
    function _AAA(x, y2, plane) {
      x = _coerceArr(x);
      y2 = _coerceArr(y2);
      plane = _coerceArr(plane);
      if (!_3d(x)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(y2)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_4d(plane)) {
        throw new TypeError("Array with 4 numbers expected as third argument");
      }
      return _intersectLinePlane(x[0], x[1], x[2], y2[0], y2[1], y2[2], plane[0], plane[1], plane[2], plane[3]);
    }
    function _AAAA(w2, x, y2, z) {
      w2 = _coerceArr(w2);
      x = _coerceArr(x);
      y2 = _coerceArr(y2);
      z = _coerceArr(z);
      if (w2.length === 2) {
        if (!_2d(w2)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(y2)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        if (!_2d(z)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
        }
        return _intersect2d(w2, x, y2, z);
      } else if (w2.length === 3) {
        if (!_3d(w2)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        if (!_3d(y2)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
        }
        if (!_3d(z)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
        }
        return _intersect3d(w2[0], w2[1], w2[2], x[0], x[1], x[2], y2[0], y2[1], y2[2], z[0], z[1], z[2]);
      } else {
        throw new TypeError("Arrays with two or thee dimensional points expected");
      }
    }
    function _coerceArr(arr) {
      if (arr.length === 1)
        return arr[0];
      if (arr.length > 1 && Array.isArray(arr[0])) {
        if (arr.every((el) => Array.isArray(el) && el.length === 1))
          return flatten3(arr);
      }
      return arr;
    }
    function _2d(x) {
      return x.length === 2 && isNumeric2(x[0]) && isNumeric2(x[1]);
    }
    function _3d(x) {
      return x.length === 3 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]);
    }
    function _4d(x) {
      return x.length === 4 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]) && isNumeric2(x[3]);
    }
    function _intersect2d(p1a, p1b, p2a, p2b) {
      var o1 = p1a;
      var o2 = p2a;
      var d1 = subtract2(o1, p1b);
      var d2 = subtract2(o2, p2b);
      var det2 = subtract2(multiplyScalar2(d1[0], d2[1]), multiplyScalar2(d2[0], d1[1]));
      if (isZero2(det2))
        return null;
      if (smaller2(abs3(det2), config4.epsilon)) {
        return null;
      }
      var d20o11 = multiplyScalar2(d2[0], o1[1]);
      var d21o10 = multiplyScalar2(d2[1], o1[0]);
      var d20o21 = multiplyScalar2(d2[0], o2[1]);
      var d21o20 = multiplyScalar2(d2[1], o2[0]);
      var t = divideScalar2(addScalar2(subtract2(subtract2(d20o11, d21o10), d20o21), d21o20), det2);
      return add3(multiply2(d1, t), o1);
    }
    function _intersect3dHelper(a, b, c, d, e3, f, g2, h, i3, j, k, l) {
      var add1 = multiplyScalar2(subtract2(a, b), subtract2(c, d));
      var add22 = multiplyScalar2(subtract2(e3, f), subtract2(g2, h));
      var add32 = multiplyScalar2(subtract2(i3, j), subtract2(k, l));
      return addScalar2(addScalar2(add1, add22), add32);
    }
    function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
      var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
      var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
      var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
      var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
      var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
      var numerator = subtract2(multiplyScalar2(d1343, d4321), multiplyScalar2(d1321, d4343));
      var denominator = subtract2(multiplyScalar2(d2121, d4343), multiplyScalar2(d4321, d4321));
      if (isZero2(denominator))
        return null;
      var ta = divideScalar2(numerator, denominator);
      var tb = divideScalar2(addScalar2(d1343, multiplyScalar2(ta, d4321)), d4343);
      var pax = addScalar2(x1, multiplyScalar2(ta, subtract2(x2, x1)));
      var pay = addScalar2(y1, multiplyScalar2(ta, subtract2(y2, y1)));
      var paz = addScalar2(z1, multiplyScalar2(ta, subtract2(z2, z1)));
      var pbx = addScalar2(x3, multiplyScalar2(tb, subtract2(x4, x3)));
      var pby = addScalar2(y3, multiplyScalar2(tb, subtract2(y4, y3)));
      var pbz = addScalar2(z3, multiplyScalar2(tb, subtract2(z4, z3)));
      if (equalScalar2(pax, pbx) && equalScalar2(pay, pby) && equalScalar2(paz, pbz)) {
        return [pax, pay, paz];
      } else {
        return null;
      }
    }
    function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y3, z, c) {
      var x1x = multiplyScalar2(x1, x);
      var x2x = multiplyScalar2(x2, x);
      var y1y = multiplyScalar2(y1, y3);
      var y2y = multiplyScalar2(y2, y3);
      var z1z = multiplyScalar2(z1, z);
      var z2z = multiplyScalar2(z2, z);
      var numerator = subtract2(subtract2(subtract2(c, x1x), y1y), z1z);
      var denominator = subtract2(subtract2(subtract2(addScalar2(addScalar2(x2x, y2y), z2z), x1x), y1y), z1z);
      var t = divideScalar2(numerator, denominator);
      var px = addScalar2(x1, multiplyScalar2(t, subtract2(x2, x1)));
      var py = addScalar2(y1, multiplyScalar2(t, subtract2(y2, y1)));
      var pz = addScalar2(z1, multiplyScalar2(t, subtract2(z2, z1)));
      return [px, py, pz];
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/sum.js
  var name253 = "sum";
  var dependencies253 = ["typed", "config", "add", "numeric"];
  var createSum = /* @__PURE__ */ factory(name253, dependencies253, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      add: add3,
      numeric: numeric3
    } = _ref;
    return typed3(name253, {
      // sum([a, b, c, d, ...])
      "Array | Matrix": _sum,
      // sum([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": _nsumDim,
      // sum(a, b, c, d, ...)
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function sum");
        }
        return _sum(args);
      }
    });
    function _sum(array) {
      var sum3;
      deepForEach(array, function(value) {
        try {
          sum3 = sum3 === void 0 ? value : add3(sum3, value);
        } catch (err) {
          throw improveErrorMessage(err, "sum", value);
        }
      });
      if (sum3 === void 0) {
        sum3 = numeric3(0, config4.number);
      }
      if (typeof sum3 === "string") {
        sum3 = numeric3(sum3, config4.number);
      }
      return sum3;
    }
    function _nsumDim(array, dim) {
      try {
        var sum3 = reduce(array, dim, add3);
        return sum3;
      } catch (err) {
        throw improveErrorMessage(err, "sum");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/cumsum.js
  var name254 = "cumsum";
  var dependencies254 = ["typed", "add", "unaryPlus"];
  var createCumSum = /* @__PURE__ */ factory(name254, dependencies254, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      unaryPlus: unaryPlus2
    } = _ref;
    return typed3(name254, {
      // sum([a, b, c, d, ...])
      Array: _cumsum,
      Matrix: function Matrix2(matrix2) {
        return matrix2.create(_cumsum(matrix2.valueOf()));
      },
      // sum([a, b, c, d, ...], dim)
      "Array, number | BigNumber": _ncumSumDim,
      "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix2, dim) {
        return matrix2.create(_ncumSumDim(matrix2.valueOf(), dim));
      },
      // cumsum(a, b, c, d, ...)
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("All values expected to be scalar in function cumsum");
        }
        return _cumsum(args);
      }
    });
    function _cumsum(array) {
      try {
        return _cumsummap(array);
      } catch (err) {
        throw improveErrorMessage(err, name254);
      }
    }
    function _cumsummap(array) {
      if (array.length === 0) {
        return [];
      }
      var sums = [unaryPlus2(array[0])];
      for (var i3 = 1; i3 < array.length; ++i3) {
        sums.push(add3(sums[i3 - 1], array[i3]));
      }
      return sums;
    }
    function _ncumSumDim(array, dim) {
      var size2 = arraySize(array);
      if (dim < 0 || dim >= size2.length) {
        throw new IndexError(dim, size2.length);
      }
      try {
        return _cumsumDimensional(array, dim);
      } catch (err) {
        throw improveErrorMessage(err, name254);
      }
    }
    function _cumsumDimensional(mat, dim) {
      var i3, ret, tran;
      if (dim <= 0) {
        var initialValue = mat[0][0];
        if (!Array.isArray(initialValue)) {
          return _cumsummap(mat);
        } else {
          tran = _switch(mat);
          ret = [];
          for (i3 = 0; i3 < tran.length; i3++) {
            ret[i3] = _cumsumDimensional(tran[i3], dim - 1);
          }
          return ret;
        }
      } else {
        ret = [];
        for (i3 = 0; i3 < mat.length; i3++) {
          ret[i3] = _cumsumDimensional(mat[i3], dim - 1);
        }
        return ret;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/mean.js
  var name255 = "mean";
  var dependencies255 = ["typed", "add", "divide"];
  var createMean = /* @__PURE__ */ factory(name255, dependencies255, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      divide: divide3
    } = _ref;
    return typed3(name255, {
      // mean([a, b, c, d, ...])
      "Array | Matrix": _mean,
      // mean([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": _nmeanDim,
      // mean(a, b, c, d, ...)
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function mean");
        }
        return _mean(args);
      }
    });
    function _nmeanDim(array, dim) {
      try {
        var sum3 = reduce(array, dim, add3);
        var s = Array.isArray(array) ? arraySize(array) : array.size();
        return divide3(sum3, s[dim]);
      } catch (err) {
        throw improveErrorMessage(err, "mean");
      }
    }
    function _mean(array) {
      var sum3;
      var num = 0;
      deepForEach(array, function(value) {
        try {
          sum3 = sum3 === void 0 ? value : add3(sum3, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, "mean", value);
        }
      });
      if (num === 0) {
        throw new Error("Cannot calculate the mean of an empty array");
      }
      return divide3(sum3, num);
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/median.js
  var name256 = "median";
  var dependencies256 = ["typed", "add", "divide", "compare", "partitionSelect"];
  var createMedian = /* @__PURE__ */ factory(name256, dependencies256, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      divide: divide3,
      compare: compare2,
      partitionSelect: partitionSelect2
    } = _ref;
    function _median(array) {
      try {
        array = flatten(array.valueOf());
        var num = array.length;
        if (num === 0) {
          throw new Error("Cannot calculate median of an empty array");
        }
        if (num % 2 === 0) {
          var mid = num / 2 - 1;
          var right = partitionSelect2(array, mid + 1);
          var left = array[mid];
          for (var i3 = 0; i3 < mid; ++i3) {
            if (compare2(array[i3], left) > 0) {
              left = array[i3];
            }
          }
          return middle2(left, right);
        } else {
          var m = partitionSelect2(array, (num - 1) / 2);
          return middle(m);
        }
      } catch (err) {
        throw improveErrorMessage(err, "median");
      }
    }
    var middle = typed3({
      "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
        return value;
      }
    });
    var middle2 = typed3({
      "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
        return divide3(add3(left, right), 2);
      }
    });
    return typed3(name256, {
      // median([a, b, c, d, ...])
      "Array | Matrix": _median,
      // median([a, b, c, d, ...], dim)
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        throw new Error("median(A, dim) is not yet supported");
      },
      // median(a, b, c, d, ...)
      "...": function _(args) {
        if (containsCollections(args)) {
          throw new TypeError("Scalar values expected in function median");
        }
        return _median(args);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/statistics/mad.js
  var name257 = "mad";
  var dependencies257 = ["typed", "abs", "map", "median", "subtract"];
  var createMad = /* @__PURE__ */ factory(name257, dependencies257, (_ref) => {
    var {
      typed: typed3,
      abs: abs3,
      map: map3,
      median: median2,
      subtract: subtract2
    } = _ref;
    return typed3(name257, {
      // mad([a, b, c, d, ...])
      "Array | Matrix": _mad,
      // mad(a, b, c, d, ...)
      "...": function _(args) {
        return _mad(args);
      }
    });
    function _mad(array) {
      array = flatten(array.valueOf());
      if (array.length === 0) {
        throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
      }
      try {
        var med = median2(array);
        return median2(map3(array, function(value) {
          return abs3(subtract2(value, med));
        }));
      } catch (err) {
        if (err instanceof TypeError && err.message.indexOf("median") !== -1) {
          throw new TypeError(err.message.replace("median", "mad"));
        } else {
          throw improveErrorMessage(err, "mad");
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/variance.js
  var DEFAULT_NORMALIZATION = "unbiased";
  var name258 = "variance";
  var dependencies258 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
  var createVariance = /* @__PURE__ */ factory(name258, dependencies258, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      subtract: subtract2,
      multiply: multiply2,
      divide: divide3,
      apply: apply2,
      isNaN: isNaN3
    } = _ref;
    return typed3(name258, {
      // variance([a, b, c, d, ...])
      "Array | Matrix": function ArrayMatrix(array) {
        return _var(array, DEFAULT_NORMALIZATION);
      },
      // variance([a, b, c, d, ...], normalization)
      "Array | Matrix, string": _var,
      // variance([a, b, c, c, ...], dim)
      "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
        return _varDim(array, dim, DEFAULT_NORMALIZATION);
      },
      // variance([a, b, c, c, ...], dim, normalization)
      "Array | Matrix, number | BigNumber, string": _varDim,
      // variance(a, b, c, d, ...)
      "...": function _(args) {
        return _var(args, DEFAULT_NORMALIZATION);
      }
    });
    function _var(array, normalization) {
      var sum3;
      var num = 0;
      if (array.length === 0) {
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      }
      deepForEach(array, function(value) {
        try {
          sum3 = sum3 === void 0 ? value : add3(sum3, value);
          num++;
        } catch (err) {
          throw improveErrorMessage(err, "variance", value);
        }
      });
      if (num === 0)
        throw new Error("Cannot calculate variance of an empty array");
      var mean2 = divide3(sum3, num);
      sum3 = void 0;
      deepForEach(array, function(value) {
        var diff2 = subtract2(value, mean2);
        sum3 = sum3 === void 0 ? multiply2(diff2, diff2) : add3(sum3, multiply2(diff2, diff2));
      });
      if (isNaN3(sum3)) {
        return sum3;
      }
      switch (normalization) {
        case "uncorrected":
          return divide3(sum3, num);
        case "biased":
          return divide3(sum3, num + 1);
        case "unbiased": {
          var zero = isBigNumber(sum3) ? sum3.mul(0) : 0;
          return num === 1 ? zero : divide3(sum3, num - 1);
        }
        default:
          throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
      }
    }
    function _varDim(array, dim, normalization) {
      try {
        if (array.length === 0) {
          throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
        }
        return apply2(array, dim, (x) => _var(x, normalization));
      } catch (err) {
        throw improveErrorMessage(err, "variance");
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/quantileSeq.js
  var name259 = "quantileSeq";
  var dependencies259 = ["typed", "?bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
  var createQuantileSeq = /* @__PURE__ */ factory(name259, dependencies259, (_ref) => {
    var {
      typed: typed3,
      bignumber: bignumber2,
      add: add3,
      subtract: subtract2,
      divide: divide3,
      multiply: multiply2,
      partitionSelect: partitionSelect2,
      compare: compare2,
      isInteger: isInteger3,
      smaller: smaller2,
      smallerEq: smallerEq2,
      larger: larger2
    } = _ref;
    var apply2 = createApply({
      typed: typed3,
      isInteger: isInteger3
    });
    return typed3(name259, {
      "Array | Matrix, number | BigNumber": (data, p) => _quantileSeqProbNumber(data, p, false),
      "Array | Matrix, number | BigNumber, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber),
      "Array | Matrix, number | BigNumber, boolean": _quantileSeqProbNumber,
      "Array | Matrix, number | BigNumber, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber),
      "Array | Matrix, Array | Matrix": (data, p) => _quantileSeqProbCollection(data, p, false),
      "Array | Matrix, Array | Matrix, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection),
      "Array | Matrix, Array | Matrix, boolean": _quantileSeqProbCollection,
      "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection)
    });
    function _quantileSeqDim(data, prob, sorted, dim, fn) {
      return apply2(data, dim, (x) => fn(x, prob, sorted));
    }
    function _quantileSeqProbNumber(data, probOrN, sorted) {
      var probArr;
      var dataArr = data.valueOf();
      if (smaller2(probOrN, 0)) {
        throw new Error("N/prob must be non-negative");
      }
      if (smallerEq2(probOrN, 1)) {
        return isNumber(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber2(_quantileSeq(dataArr, probOrN, sorted));
      }
      if (larger2(probOrN, 1)) {
        if (!isInteger3(probOrN)) {
          throw new Error("N must be a positive integer");
        }
        if (larger2(probOrN, 4294967295)) {
          throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
        }
        var nPlusOne = add3(probOrN, 1);
        probArr = [];
        for (var i3 = 0; smaller2(i3, probOrN); i3++) {
          var prob = divide3(i3 + 1, nPlusOne);
          probArr.push(_quantileSeq(dataArr, prob, sorted));
        }
        return isNumber(probOrN) ? probArr : bignumber2(probArr);
      }
    }
    function _quantileSeqProbCollection(data, probOrN, sorted) {
      var dataArr = data.valueOf();
      var probOrNArr = probOrN.valueOf();
      var probArr = [];
      for (var i3 = 0; i3 < probOrNArr.length; ++i3) {
        probArr.push(_quantileSeq(dataArr, probOrNArr[i3], sorted));
      }
      return probArr;
    }
    function _quantileSeq(array, prob, sorted) {
      var flat = flatten(array);
      var len = flat.length;
      if (len === 0) {
        throw new Error("Cannot calculate quantile of an empty sequence");
      }
      var index2 = isNumber(prob) ? prob * (len - 1) : prob.times(len - 1);
      var integerPart = isNumber(prob) ? Math.floor(index2) : index2.floor().toNumber();
      var fracPart = isNumber(prob) ? index2 % 1 : index2.minus(integerPart);
      if (isInteger3(index2)) {
        return sorted ? flat[index2] : partitionSelect2(flat, isNumber(prob) ? index2 : index2.valueOf());
      }
      var left;
      var right;
      if (sorted) {
        left = flat[integerPart];
        right = flat[integerPart + 1];
      } else {
        right = partitionSelect2(flat, integerPart + 1);
        left = flat[integerPart];
        for (var i3 = 0; i3 < integerPart; ++i3) {
          if (compare2(flat[i3], left) > 0) {
            left = flat[i3];
          }
        }
      }
      return add3(multiply2(left, subtract2(1, fracPart)), multiply2(right, fracPart));
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/std.js
  var name260 = "std";
  var dependencies260 = ["typed", "map", "sqrt", "variance"];
  var createStd = /* @__PURE__ */ factory(name260, dependencies260, (_ref) => {
    var {
      typed: typed3,
      map: map3,
      sqrt: sqrt3,
      variance: variance2
    } = _ref;
    return typed3(name260, {
      // std([a, b, c, d, ...])
      "Array | Matrix": _std,
      // std([a, b, c, d, ...], normalization)
      "Array | Matrix, string": _std,
      // std([a, b, c, c, ...], dim)
      "Array | Matrix, number | BigNumber": _std,
      // std([a, b, c, c, ...], dim, normalization)
      "Array | Matrix, number | BigNumber, string": _std,
      // std(a, b, c, d, ...)
      "...": function _(args) {
        return _std(args);
      }
    });
    function _std(array, normalization) {
      if (array.length === 0) {
        throw new SyntaxError("Function std requires one or more parameters (0 provided)");
      }
      try {
        var v = variance2.apply(null, arguments);
        if (isCollection(v)) {
          return map3(v, sqrt3);
        } else {
          return sqrt3(v);
        }
      } catch (err) {
        if (err instanceof TypeError && err.message.indexOf(" variance") !== -1) {
          throw new TypeError(err.message.replace(" variance", " std"));
        } else {
          throw err;
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/statistics/corr.js
  var name261 = "corr";
  var dependencies261 = ["typed", "matrix", "mean", "sqrt", "sum", "add", "subtract", "multiply", "pow", "divide"];
  var createCorr = /* @__PURE__ */ factory(name261, dependencies261, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      sqrt: sqrt3,
      sum: sum3,
      add: add3,
      subtract: subtract2,
      multiply: multiply2,
      pow: pow3,
      divide: divide3
    } = _ref;
    return typed3(name261, {
      "Array, Array": function ArrayArray(A2, B2) {
        return _corr(A2, B2);
      },
      "Matrix, Matrix": function MatrixMatrix(A2, B2) {
        var res = _corr(A2.toArray(), B2.toArray());
        return Array.isArray(res) ? matrix2(res) : res;
      }
    });
    function _corr(A2, B2) {
      var correlations = [];
      if (Array.isArray(A2[0]) && Array.isArray(B2[0])) {
        if (A2.length !== B2.length) {
          throw new SyntaxError("Dimension mismatch. Array A and B must have the same length.");
        }
        for (var i3 = 0; i3 < A2.length; i3++) {
          if (A2[i3].length !== B2[i3].length) {
            throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
          }
          correlations.push(correlation(A2[i3], B2[i3]));
        }
        return correlations;
      } else {
        if (A2.length !== B2.length) {
          throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
        }
        return correlation(A2, B2);
      }
    }
    function correlation(A2, B2) {
      var n = A2.length;
      var sumX = sum3(A2);
      var sumY = sum3(B2);
      var sumXY = A2.reduce((acc, x, index2) => add3(acc, multiply2(x, B2[index2])), 0);
      var sumXSquare = sum3(A2.map((x) => pow3(x, 2)));
      var sumYSquare = sum3(B2.map((y2) => pow3(y2, 2)));
      var numerator = subtract2(multiply2(n, sumXY), multiply2(sumX, sumY));
      var denominator = sqrt3(multiply2(subtract2(multiply2(n, sumXSquare), pow3(sumX, 2)), subtract2(multiply2(n, sumYSquare), pow3(sumY, 2))));
      return divide3(numerator, denominator);
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/combinations.js
  var name262 = "combinations";
  var dependencies262 = ["typed"];
  var createCombinations = /* @__PURE__ */ factory(name262, dependencies262, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name262, {
      "number, number": combinationsNumber,
      "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
        var BigNumber2 = n.constructor;
        var result, i3;
        var nMinusk = n.minus(k);
        var one = new BigNumber2(1);
        if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
          throw new TypeError("Positive integer value expected in function combinations");
        }
        if (k.gt(n)) {
          throw new TypeError("k must be less than n in function combinations");
        }
        result = one;
        if (k.lt(nMinusk)) {
          for (i3 = one; i3.lte(nMinusk); i3 = i3.plus(one)) {
            result = result.times(k.plus(i3)).dividedBy(i3);
          }
        } else {
          for (i3 = one; i3.lte(k); i3 = i3.plus(one)) {
            result = result.times(nMinusk.plus(i3)).dividedBy(i3);
          }
        }
        return result;
      }
      // TODO: implement support for collection in combinations
    });
  });
  function isPositiveInteger(n) {
    return n.isInteger() && n.gte(0);
  }

  // node_modules/mathjs/lib/esm/function/probability/combinationsWithRep.js
  var name263 = "combinationsWithRep";
  var dependencies263 = ["typed"];
  var createCombinationsWithRep = /* @__PURE__ */ factory(name263, dependencies263, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    return typed3(name263, {
      "number, number": function numberNumber(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError("Positive integer value expected in function combinationsWithRep");
        }
        if (!isInteger(k) || k < 0) {
          throw new TypeError("Positive integer value expected in function combinationsWithRep");
        }
        if (n < 1) {
          throw new TypeError("k must be less than or equal to n + k - 1");
        }
        if (k < n - 1) {
          var _prodrange = product2(n, n + k - 1);
          return _prodrange / product2(1, k);
        }
        var prodrange = product2(k + 1, n + k - 1);
        return prodrange / product2(1, n - 1);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
        var BigNumber2 = n.constructor;
        var result, i3;
        var one = new BigNumber2(1);
        var nMinusOne = n.minus(one);
        if (!isPositiveInteger2(n) || !isPositiveInteger2(k)) {
          throw new TypeError("Positive integer value expected in function combinationsWithRep");
        }
        if (n.lt(one)) {
          throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
        }
        result = one;
        if (k.lt(nMinusOne)) {
          for (i3 = one; i3.lte(nMinusOne); i3 = i3.plus(one)) {
            result = result.times(k.plus(i3)).dividedBy(i3);
          }
        } else {
          for (i3 = one; i3.lte(k); i3 = i3.plus(one)) {
            result = result.times(nMinusOne.plus(i3)).dividedBy(i3);
          }
        }
        return result;
      }
    });
  });
  function isPositiveInteger2(n) {
    return n.isInteger() && n.gte(0);
  }

  // node_modules/mathjs/lib/esm/function/probability/gamma.js
  var name264 = "gamma";
  var dependencies264 = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
  var createGamma = /* @__PURE__ */ factory(name264, dependencies264, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      multiplyScalar: multiplyScalar2,
      pow: pow3,
      BigNumber: _BigNumber,
      Complex: Complex3
    } = _ref;
    function gammaComplex(n) {
      if (n.im === 0) {
        return gammaNumber(n.re);
      }
      if (n.re < 0.5) {
        var _t = new Complex3(1 - n.re, -n.im);
        var r = new Complex3(Math.PI * n.re, Math.PI * n.im);
        return new Complex3(Math.PI).div(r.sin()).div(gammaComplex(_t));
      }
      n = new Complex3(n.re - 1, n.im);
      var x = new Complex3(gammaP[0], 0);
      for (var i3 = 1; i3 < gammaP.length; ++i3) {
        var gammaPval = new Complex3(gammaP[i3], 0);
        x = x.add(gammaPval.div(n.add(i3)));
      }
      var t = new Complex3(n.re + gammaG + 0.5, n.im);
      var twoPiSqrt = Math.sqrt(2 * Math.PI);
      var tpow = t.pow(n.add(0.5));
      var expt = t.neg().exp();
      return x.mul(twoPiSqrt).mul(tpow).mul(expt);
    }
    return typed3(name264, {
      number: gammaNumber,
      Complex: gammaComplex,
      BigNumber: function BigNumber2(n) {
        if (n.isInteger()) {
          return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
        }
        if (!n.isFinite()) {
          return new _BigNumber(n.isNegative() ? NaN : Infinity);
        }
        throw new Error("Integer BigNumber expected");
      }
    });
    function bigFactorial(n) {
      if (n < 8) {
        return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
      }
      var precision = config4.precision + (Math.log(n.toNumber()) | 0);
      var Big = _BigNumber.clone({
        precision
      });
      if (n % 2 === 1) {
        return n.times(bigFactorial(new _BigNumber(n - 1)));
      }
      var p = n;
      var prod2 = new Big(n);
      var sum3 = n.toNumber();
      while (p > 2) {
        p -= 2;
        sum3 += p;
        prod2 = prod2.times(sum3);
      }
      return new _BigNumber(prod2.toPrecision(_BigNumber.precision));
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/lgamma.js
  var name265 = "lgamma";
  var dependencies265 = ["Complex", "typed"];
  var createLgamma = /* @__PURE__ */ factory(name265, dependencies265, (_ref) => {
    var {
      Complex: Complex3,
      typed: typed3
    } = _ref;
    var SMALL_RE = 7;
    var SMALL_IM = 7;
    var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
    return typed3(name265, {
      number: lgammaNumber,
      Complex: lgammaComplex,
      BigNumber: function BigNumber2() {
        throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
      }
    });
    function lgammaComplex(n) {
      var TWOPI = 6.283185307179586;
      var LOGPI = 1.1447298858494002;
      var REFLECTION = 0.1;
      if (n.isNaN()) {
        return new Complex3(NaN, NaN);
      } else if (n.im === 0) {
        return new Complex3(lgammaNumber(n.re), 0);
      } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
        return lgammaStirling(n);
      } else if (n.re <= REFLECTION) {
        var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
        var a = n.mul(Math.PI).sin().log();
        var b = lgammaComplex(new Complex3(1 - n.re, -n.im));
        return new Complex3(LOGPI, tmp).sub(a).sub(b);
      } else if (n.im >= 0) {
        return lgammaRecurrence(n);
      } else {
        return lgammaRecurrence(n.conjugate()).conjugate();
      }
    }
    function lgammaStirling(z) {
      var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
      var rz = new Complex3(1, 0).div(z);
      var rzz = rz.div(z);
      var a = coeffs[0];
      var b = coeffs[1];
      var r = 2 * rzz.re;
      var s = rzz.re * rzz.re + rzz.im * rzz.im;
      for (var i3 = 2; i3 < 8; i3++) {
        var tmp = b;
        b = -s * a + coeffs[i3];
        a = r * a + tmp;
      }
      var rightPart = rz.mul(rzz.mul(a).add(b));
      return leftPart.add(rightPart);
    }
    function lgammaRecurrence(z) {
      var signflips = 0;
      var sb = 0;
      var shiftprod = z;
      z = z.add(1);
      while (z.re <= SMALL_RE) {
        shiftprod = shiftprod.mul(z);
        var nsb = shiftprod.im < 0 ? 1 : 0;
        if (nsb !== 0 && sb === 0)
          signflips++;
        sb = nsb;
        z = z.add(1);
      }
      return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex3(0, signflips * 2 * Math.PI * 1));
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/factorial.js
  var name266 = "factorial";
  var dependencies266 = ["typed", "gamma"];
  var createFactorial = /* @__PURE__ */ factory(name266, dependencies266, (_ref) => {
    var {
      typed: typed3,
      gamma: gamma2
    } = _ref;
    return typed3(name266, {
      number: function number2(n) {
        if (n < 0) {
          throw new Error("Value must be non-negative");
        }
        return gamma2(n + 1);
      },
      BigNumber: function BigNumber2(n) {
        if (n.isNegative()) {
          throw new Error("Value must be non-negative");
        }
        return gamma2(n.plus(1));
      },
      "Array | Matrix": typed3.referToSelf((self2) => (n) => deepMap(n, self2))
    });
  });

  // node_modules/mathjs/lib/esm/function/probability/kldivergence.js
  var name267 = "kldivergence";
  var dependencies267 = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
  var createKldivergence = /* @__PURE__ */ factory(name267, dependencies267, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      divide: divide3,
      sum: sum3,
      multiply: multiply2,
      map: map3,
      dotDivide: dotDivide2,
      log: log4,
      isNumeric: isNumeric2
    } = _ref;
    return typed3(name267, {
      "Array, Array": function ArrayArray(q, p) {
        return _kldiv(matrix2(q), matrix2(p));
      },
      "Matrix, Array": function MatrixArray(q, p) {
        return _kldiv(q, matrix2(p));
      },
      "Array, Matrix": function ArrayMatrix(q, p) {
        return _kldiv(matrix2(q), p);
      },
      "Matrix, Matrix": function MatrixMatrix(q, p) {
        return _kldiv(q, p);
      }
    });
    function _kldiv(q, p) {
      var plength = p.size().length;
      var qlength = q.size().length;
      if (plength > 1) {
        throw new Error("first object must be one dimensional");
      }
      if (qlength > 1) {
        throw new Error("second object must be one dimensional");
      }
      if (plength !== qlength) {
        throw new Error("Length of two vectors must be equal");
      }
      var sumq = sum3(q);
      if (sumq === 0) {
        throw new Error("Sum of elements in first object must be non zero");
      }
      var sump = sum3(p);
      if (sump === 0) {
        throw new Error("Sum of elements in second object must be non zero");
      }
      var qnorm = divide3(q, sum3(q));
      var pnorm = divide3(p, sum3(p));
      var result = sum3(multiply2(qnorm, map3(dotDivide2(qnorm, pnorm), (x) => log4(x))));
      if (isNumeric2(result)) {
        return result;
      } else {
        return Number.NaN;
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/multinomial.js
  var name268 = "multinomial";
  var dependencies268 = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
  var createMultinomial = /* @__PURE__ */ factory(name268, dependencies268, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      divide: divide3,
      multiply: multiply2,
      factorial: factorial2,
      isInteger: isInteger3,
      isPositive: isPositive2
    } = _ref;
    return typed3(name268, {
      "Array | Matrix": function ArrayMatrix(a) {
        var sum3 = 0;
        var denom = 1;
        deepForEach(a, function(ai) {
          if (!isInteger3(ai) || !isPositive2(ai)) {
            throw new TypeError("Positive integer value expected in function multinomial");
          }
          sum3 = add3(sum3, ai);
          denom = multiply2(denom, factorial2(ai));
        });
        return divide3(factorial2(sum3), denom);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/probability/permutations.js
  var name269 = "permutations";
  var dependencies269 = ["typed", "factorial"];
  var createPermutations = /* @__PURE__ */ factory(name269, dependencies269, (_ref) => {
    var {
      typed: typed3,
      factorial: factorial2
    } = _ref;
    return typed3(name269, {
      "number | BigNumber": factorial2,
      "number, number": function numberNumber(n, k) {
        if (!isInteger(n) || n < 0) {
          throw new TypeError("Positive integer value expected in function permutations");
        }
        if (!isInteger(k) || k < 0) {
          throw new TypeError("Positive integer value expected in function permutations");
        }
        if (k > n) {
          throw new TypeError("second argument k must be less than or equal to first argument n");
        }
        return product2(n - k + 1, n);
      },
      "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
        var result, i3;
        if (!isPositiveInteger3(n) || !isPositiveInteger3(k)) {
          throw new TypeError("Positive integer value expected in function permutations");
        }
        if (k.gt(n)) {
          throw new TypeError("second argument k must be less than or equal to first argument n");
        }
        var one = n.mul(0).add(1);
        result = one;
        for (i3 = n.minus(k).plus(1); i3.lte(n); i3 = i3.plus(1)) {
          result = result.times(i3);
        }
        return result;
      }
      // TODO: implement support for collection in permutations
    });
  });
  function isPositiveInteger3(n) {
    return n.isInteger() && n.gte(0);
  }

  // node_modules/mathjs/lib/esm/function/probability/util/seededRNG.js
  var import_seedrandom = __toESM(require_seedrandom2(), 1);
  var singletonRandom = /* @__PURE__ */ (0, import_seedrandom.default)(Date.now());
  function createRng(randomSeed) {
    var random3;
    function setSeed(seed) {
      random3 = seed === null ? singletonRandom : (0, import_seedrandom.default)(String(seed));
    }
    setSeed(randomSeed);
    function rng() {
      return random3();
    }
    return rng;
  }

  // node_modules/mathjs/lib/esm/function/probability/pickRandom.js
  var name270 = "pickRandom";
  var dependencies270 = ["typed", "config", "?on"];
  var createPickRandom = /* @__PURE__ */ factory(name270, dependencies270, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      on
    } = _ref;
    var rng = createRng(config4.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed3(name270, {
      "Array | Matrix": function ArrayMatrix(possibles) {
        return _pickRandom(possibles, {});
      },
      "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
        return _pickRandom(possibles, options);
      },
      "Array | Matrix, number": function ArrayMatrixNumber(possibles, number2) {
        return _pickRandom(possibles, {
          number: number2
        });
      },
      "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
        return _pickRandom(possibles, {
          weights
        });
      },
      "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number2) {
        return _pickRandom(possibles, {
          number: number2,
          weights
        });
      },
      "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number2, weights) {
        return _pickRandom(possibles, {
          number: number2,
          weights
        });
      }
    });
    function _pickRandom(possibles, _ref2) {
      var {
        number: number2,
        weights,
        elementWise = true
      } = _ref2;
      var single = typeof number2 === "undefined";
      if (single) {
        number2 = 1;
      }
      var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
      possibles = possibles.valueOf();
      if (weights) {
        weights = weights.valueOf();
      }
      if (elementWise === true) {
        possibles = flatten(possibles);
        weights = flatten(weights);
      }
      var totalWeights = 0;
      if (typeof weights !== "undefined") {
        if (weights.length !== possibles.length) {
          throw new Error("Weights must have the same length as possibles");
        }
        for (var i3 = 0, len = weights.length; i3 < len; i3++) {
          if (!isNumber(weights[i3]) || weights[i3] < 0) {
            throw new Error("Weights must be an array of positive numbers");
          }
          totalWeights += weights[i3];
        }
      }
      var length = possibles.length;
      var result = [];
      var pick;
      while (result.length < number2) {
        if (typeof weights === "undefined") {
          pick = possibles[Math.floor(rng() * length)];
        } else {
          var randKey = rng() * totalWeights;
          for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
            randKey -= weights[_i];
            if (randKey < 0) {
              pick = possibles[_i];
              break;
            }
          }
        }
        result.push(pick);
      }
      return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/util/randomMatrix.js
  function randomMatrix(size2, random3) {
    var data = [];
    size2 = size2.slice(0);
    if (size2.length > 1) {
      for (var i3 = 0, length = size2.shift(); i3 < length; i3++) {
        data.push(randomMatrix(size2, random3));
      }
    } else {
      for (var _i = 0, _length = size2.shift(); _i < _length; _i++) {
        data.push(random3());
      }
    }
    return data;
  }

  // node_modules/mathjs/lib/esm/function/probability/random.js
  var name271 = "random";
  var dependencies271 = ["typed", "config", "?on"];
  var createRandom = /* @__PURE__ */ factory(name271, dependencies271, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      on
    } = _ref;
    var rng = createRng(config4.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed3(name271, {
      "": () => _random(0, 1),
      number: (max3) => _random(0, max3),
      "number, number": (min3, max3) => _random(min3, max3),
      "Array | Matrix": (size2) => _randomMatrix(size2, 0, 1),
      "Array | Matrix, number": (size2, max3) => _randomMatrix(size2, 0, max3),
      "Array | Matrix, number, number": (size2, min3, max3) => _randomMatrix(size2, min3, max3)
    });
    function _randomMatrix(size2, min3, max3) {
      var res = randomMatrix(size2.valueOf(), () => _random(min3, max3));
      return isMatrix(size2) ? size2.create(res) : res;
    }
    function _random(min3, max3) {
      return min3 + rng() * (max3 - min3);
    }
  });

  // node_modules/mathjs/lib/esm/function/probability/randomInt.js
  var name272 = "randomInt";
  var dependencies272 = ["typed", "config", "?on"];
  var createRandomInt = /* @__PURE__ */ factory(name272, dependencies272, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      on
    } = _ref;
    var rng = createRng(config4.randomSeed);
    if (on) {
      on("config", function(curr, prev) {
        if (curr.randomSeed !== prev.randomSeed) {
          rng = createRng(curr.randomSeed);
        }
      });
    }
    return typed3(name272, {
      "": () => _randomInt(0, 1),
      number: (max3) => _randomInt(0, max3),
      "number, number": (min3, max3) => _randomInt(min3, max3),
      "Array | Matrix": (size2) => _randomIntMatrix(size2, 0, 1),
      "Array | Matrix, number": (size2, max3) => _randomIntMatrix(size2, 0, max3),
      "Array | Matrix, number, number": (size2, min3, max3) => _randomIntMatrix(size2, min3, max3)
    });
    function _randomIntMatrix(size2, min3, max3) {
      var res = randomMatrix(size2.valueOf(), () => _randomInt(min3, max3));
      return isMatrix(size2) ? size2.create(res) : res;
    }
    function _randomInt(min3, max3) {
      return Math.floor(min3 + rng() * (max3 - min3));
    }
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/stirlingS2.js
  var name273 = "stirlingS2";
  var dependencies273 = ["typed", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
  var createStirlingS2 = /* @__PURE__ */ factory(name273, dependencies273, (_ref) => {
    var {
      typed: typed3,
      addScalar: addScalar2,
      subtractScalar: subtractScalar2,
      multiplyScalar: multiplyScalar2,
      divideScalar: divideScalar2,
      pow: pow3,
      factorial: factorial2,
      combinations: combinations2,
      isNegative: isNegative2,
      isInteger: isInteger3,
      number: number2,
      bignumber: bignumber2,
      larger: larger2
    } = _ref;
    var smallCache = [];
    var bigCache = [];
    return typed3(name273, {
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
        if (!isInteger3(n) || isNegative2(n) || !isInteger3(k) || isNegative2(k)) {
          throw new TypeError("Non-negative integer value expected in function stirlingS2");
        } else if (larger2(k, n)) {
          throw new TypeError("k must be less than or equal to n in function stirlingS2");
        }
        var big = !(isNumber(n) && isNumber(k));
        var cache = big ? bigCache : smallCache;
        var make = big ? bignumber2 : number2;
        var nn = number2(n);
        var nk = number2(k);
        if (cache[nn] && cache[nn].length > nk) {
          return cache[nn][nk];
        }
        for (var m = 0; m <= nn; ++m) {
          if (!cache[m]) {
            cache[m] = [m === 0 ? make(1) : make(0)];
          }
          if (m === 0)
            continue;
          var row2 = cache[m];
          var prev = cache[m - 1];
          for (var i3 = row2.length; i3 <= m && i3 <= nk; ++i3) {
            if (i3 === m) {
              row2[i3] = 1;
            } else {
              row2[i3] = addScalar2(multiplyScalar2(make(i3), prev[i3]), prev[i3 - 1]);
            }
          }
        }
        return cache[nn][nk];
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/bellNumbers.js
  var name274 = "bellNumbers";
  var dependencies274 = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
  var createBellNumbers = /* @__PURE__ */ factory(name274, dependencies274, (_ref) => {
    var {
      typed: typed3,
      addScalar: addScalar2,
      isNegative: isNegative2,
      isInteger: isInteger3,
      stirlingS2: stirlingS22
    } = _ref;
    return typed3(name274, {
      "number | BigNumber": function numberBigNumber(n) {
        if (!isInteger3(n) || isNegative2(n)) {
          throw new TypeError("Non-negative integer value expected in function bellNumbers");
        }
        var result = 0;
        for (var i3 = 0; i3 <= n; i3++) {
          result = addScalar2(result, stirlingS22(n, i3));
        }
        return result;
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/catalan.js
  var name275 = "catalan";
  var dependencies275 = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
  var createCatalan = /* @__PURE__ */ factory(name275, dependencies275, (_ref) => {
    var {
      typed: typed3,
      addScalar: addScalar2,
      divideScalar: divideScalar2,
      multiplyScalar: multiplyScalar2,
      combinations: combinations2,
      isNegative: isNegative2,
      isInteger: isInteger3
    } = _ref;
    return typed3(name275, {
      "number | BigNumber": function numberBigNumber(n) {
        if (!isInteger3(n) || isNegative2(n)) {
          throw new TypeError("Non-negative integer value expected in function catalan");
        }
        return divideScalar2(combinations2(multiplyScalar2(n, 2), n), addScalar2(n, 1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/combinatorics/composition.js
  var name276 = "composition";
  var dependencies276 = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
  var createComposition = /* @__PURE__ */ factory(name276, dependencies276, (_ref) => {
    var {
      typed: typed3,
      addScalar: addScalar2,
      combinations: combinations2,
      isPositive: isPositive2,
      isNegative: isNegative2,
      isInteger: isInteger3,
      larger: larger2
    } = _ref;
    return typed3(name276, {
      "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
        if (!isInteger3(n) || !isPositive2(n) || !isInteger3(k) || !isPositive2(k)) {
          throw new TypeError("Positive integer value expected in function composition");
        } else if (larger2(k, n)) {
          throw new TypeError("k must be less than or equal to n in function composition");
        }
        return combinations2(addScalar2(n, -1), addScalar2(k, -1));
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/leafCount.js
  var name277 = "leafCount";
  var dependencies277 = ["parse", "typed"];
  var createLeafCount = /* @__PURE__ */ factory(name277, dependencies277, (_ref) => {
    var {
      parse: parse2,
      typed: typed3
    } = _ref;
    function countLeaves(node) {
      var count2 = 0;
      node.forEach((n) => {
        count2 += countLeaves(n);
      });
      return count2 || 1;
    }
    return typed3(name277, {
      Node: function Node2(expr) {
        return countLeaves(expr);
      }
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify/wildcards.js
  function isNumericNode(x) {
    return isConstantNode(x) || isOperatorNode(x) && x.isUnary() && isConstantNode(x.args[0]);
  }
  function isConstantExpression(x) {
    if (isConstantNode(x)) {
      return true;
    }
    if ((isFunctionNode(x) || isOperatorNode(x)) && x.args.every(isConstantExpression)) {
      return true;
    }
    if (isParenthesisNode(x) && isConstantExpression(x.content)) {
      return true;
    }
    return false;
  }

  // node_modules/mathjs/lib/esm/function/algebra/simplify/util.js
  function ownKeys3(e3, r) {
    var t = Object.keys(e3);
    if (Object.getOwnPropertySymbols) {
      var o2 = Object.getOwnPropertySymbols(e3);
      r && (o2 = o2.filter(function(r2) {
        return Object.getOwnPropertyDescriptor(e3, r2).enumerable;
      })), t.push.apply(t, o2);
    }
    return t;
  }
  function _objectSpread3(e3) {
    for (var r = 1; r < arguments.length; r++) {
      var t = null != arguments[r] ? arguments[r] : {};
      r % 2 ? ownKeys3(Object(t), true).forEach(function(r2) {
        _defineProperty(e3, r2, t[r2]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e3, Object.getOwnPropertyDescriptors(t)) : ownKeys3(Object(t)).forEach(function(r2) {
        Object.defineProperty(e3, r2, Object.getOwnPropertyDescriptor(t, r2));
      });
    }
    return e3;
  }
  var name278 = "simplifyUtil";
  var dependencies278 = ["FunctionNode", "OperatorNode", "SymbolNode"];
  var createUtil = /* @__PURE__ */ factory(name278, dependencies278, (_ref) => {
    var {
      FunctionNode: FunctionNode2,
      OperatorNode: OperatorNode2,
      SymbolNode: SymbolNode2
    } = _ref;
    var T = true;
    var F = false;
    var defaultName = "defaultF";
    var defaultContext = {
      /*      */
      add: {
        trivial: T,
        total: T,
        commutative: T,
        associative: T
      },
      /**/
      unaryPlus: {
        trivial: T,
        total: T,
        commutative: T,
        associative: T
      },
      /* */
      subtract: {
        trivial: F,
        total: T,
        commutative: F,
        associative: F
      },
      /* */
      multiply: {
        trivial: T,
        total: T,
        commutative: T,
        associative: T
      },
      /*   */
      divide: {
        trivial: F,
        total: T,
        commutative: F,
        associative: F
      },
      /*    */
      paren: {
        trivial: T,
        total: T,
        commutative: T,
        associative: F
      },
      /* */
      defaultF: {
        trivial: F,
        total: T,
        commutative: F,
        associative: F
      }
    };
    var realContext = {
      divide: {
        total: F
      },
      log: {
        total: F
      }
    };
    var positiveContext = {
      subtract: {
        total: F
      },
      abs: {
        trivial: T
      },
      log: {
        total: T
      }
    };
    function hasProperty(nodeOrName, property) {
      var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultContext;
      var name310 = defaultName;
      if (typeof nodeOrName === "string") {
        name310 = nodeOrName;
      } else if (isOperatorNode(nodeOrName)) {
        name310 = nodeOrName.fn.toString();
      } else if (isFunctionNode(nodeOrName)) {
        name310 = nodeOrName.name;
      } else if (isParenthesisNode(nodeOrName)) {
        name310 = "paren";
      }
      if (hasOwnProperty(context, name310)) {
        var properties2 = context[name310];
        if (hasOwnProperty(properties2, property)) {
          return properties2[property];
        }
        if (hasOwnProperty(defaultContext, name310)) {
          return defaultContext[name310][property];
        }
      }
      if (hasOwnProperty(context, defaultName)) {
        var _properties = context[defaultName];
        if (hasOwnProperty(_properties, property)) {
          return _properties[property];
        }
        return defaultContext[defaultName][property];
      }
      if (hasOwnProperty(defaultContext, name310)) {
        var _properties2 = defaultContext[name310];
        if (hasOwnProperty(_properties2, property)) {
          return _properties2[property];
        }
      }
      return defaultContext[defaultName][property];
    }
    function isCommutative(node) {
      var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
      return hasProperty(node, "commutative", context);
    }
    function isAssociative(node) {
      var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
      return hasProperty(node, "associative", context);
    }
    function mergeContext(primary, secondary) {
      var merged = _objectSpread3({}, primary);
      for (var prop in secondary) {
        if (hasOwnProperty(primary, prop)) {
          merged[prop] = _objectSpread3(_objectSpread3({}, secondary[prop]), primary[prop]);
        } else {
          merged[prop] = secondary[prop];
        }
      }
      return merged;
    }
    function flatten3(node, context) {
      if (!node.args || node.args.length === 0) {
        return node;
      }
      node.args = allChildren(node, context);
      for (var i3 = 0; i3 < node.args.length; i3++) {
        flatten3(node.args[i3], context);
      }
    }
    function allChildren(node, context) {
      var op;
      var children = [];
      var findChildren = function findChildren2(node2) {
        for (var i3 = 0; i3 < node2.args.length; i3++) {
          var child = node2.args[i3];
          if (isOperatorNode(child) && op === child.op) {
            findChildren2(child);
          } else {
            children.push(child);
          }
        }
      };
      if (isAssociative(node, context)) {
        op = node.op;
        findChildren(node);
        return children;
      } else {
        return node.args;
      }
    }
    function unflattenr(node, context) {
      if (!node.args || node.args.length === 0) {
        return;
      }
      var makeNode = createMakeNodeFunction(node);
      var l = node.args.length;
      for (var i3 = 0; i3 < l; i3++) {
        unflattenr(node.args[i3], context);
      }
      if (l > 2 && isAssociative(node, context)) {
        var curnode = node.args.pop();
        while (node.args.length > 0) {
          curnode = makeNode([node.args.pop(), curnode]);
        }
        node.args = curnode.args;
      }
    }
    function unflattenl(node, context) {
      if (!node.args || node.args.length === 0) {
        return;
      }
      var makeNode = createMakeNodeFunction(node);
      var l = node.args.length;
      for (var i3 = 0; i3 < l; i3++) {
        unflattenl(node.args[i3], context);
      }
      if (l > 2 && isAssociative(node, context)) {
        var curnode = node.args.shift();
        while (node.args.length > 0) {
          curnode = makeNode([curnode, node.args.shift()]);
        }
        node.args = curnode.args;
      }
    }
    function createMakeNodeFunction(node) {
      if (isOperatorNode(node)) {
        return function(args) {
          try {
            return new OperatorNode2(node.op, node.fn, args, node.implicit);
          } catch (err) {
            console.error(err);
            return [];
          }
        };
      } else {
        return function(args) {
          return new FunctionNode2(new SymbolNode2(node.name), args);
        };
      }
    }
    return {
      createMakeNodeFunction,
      hasProperty,
      isCommutative,
      isAssociative,
      mergeContext,
      flatten: flatten3,
      allChildren,
      unflattenr,
      unflattenl,
      defaultContext,
      realContext,
      positiveContext
    };
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplify.js
  var name279 = "simplify";
  var dependencies279 = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
  var createSimplify = /* @__PURE__ */ factory(name279, dependencies279, (_ref) => {
    var {
      config: config4,
      typed: typed3,
      parse: parse2,
      add: add3,
      subtract: subtract2,
      multiply: multiply2,
      divide: divide3,
      pow: pow3,
      isZero: isZero2,
      equal: equal2,
      resolve: resolve2,
      simplifyConstant: simplifyConstant2,
      simplifyCore: simplifyCore2,
      fraction: fraction2,
      bignumber: bignumber2,
      mathWithTransform: mathWithTransform2,
      matrix: matrix2,
      AccessorNode: AccessorNode2,
      ArrayNode: ArrayNode2,
      ConstantNode: ConstantNode2,
      FunctionNode: FunctionNode2,
      IndexNode: IndexNode2,
      ObjectNode: ObjectNode2,
      OperatorNode: OperatorNode2,
      ParenthesisNode: ParenthesisNode2,
      SymbolNode: SymbolNode2
    } = _ref;
    var {
      hasProperty,
      isCommutative,
      isAssociative,
      mergeContext,
      flatten: flatten3,
      unflattenr,
      unflattenl,
      createMakeNodeFunction,
      defaultContext,
      realContext,
      positiveContext
    } = createUtil({
      FunctionNode: FunctionNode2,
      OperatorNode: OperatorNode2,
      SymbolNode: SymbolNode2
    });
    typed3.addConversion({
      from: "Object",
      to: "Map",
      convert: createMap
    });
    var simplify2 = typed3("simplify", {
      Node: _simplify,
      "Node, Map": (expr, scope) => _simplify(expr, false, scope),
      "Node, Map, Object": (expr, scope, options) => _simplify(expr, false, scope, options),
      "Node, Array": _simplify,
      "Node, Array, Map": _simplify,
      "Node, Array, Map, Object": _simplify
    });
    typed3.removeConversion({
      from: "Object",
      to: "Map",
      convert: createMap
    });
    simplify2.defaultContext = defaultContext;
    simplify2.realContext = realContext;
    simplify2.positiveContext = positiveContext;
    function removeParens(node) {
      return node.transform(function(node2, path, parent) {
        return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
      });
    }
    var SUPPORTED_CONSTANTS = {
      true: true,
      false: true,
      e: true,
      i: true,
      Infinity: true,
      LN2: true,
      LN10: true,
      LOG2E: true,
      LOG10E: true,
      NaN: true,
      phi: true,
      pi: true,
      SQRT1_2: true,
      SQRT2: true,
      tau: true
      // null: false,
      // undefined: false,
      // version: false,
    };
    simplify2.rules = [
      simplifyCore2,
      // { l: 'n+0', r: 'n' },     // simplifyCore
      // { l: 'n^0', r: '1' },     // simplifyCore
      // { l: '0*n', r: '0' },     // simplifyCore
      // { l: 'n/n', r: '1'},      // simplifyCore
      // { l: 'n^1', r: 'n' },     // simplifyCore
      // { l: '+n1', r:'n1' },     // simplifyCore
      // { l: 'n--n1', r:'n+n1' }, // simplifyCore
      {
        l: "log(e)",
        r: "1"
      },
      // temporary rules
      // Note initially we tend constants to the right because like-term
      // collection prefers the left, and we would rather collect nonconstants
      {
        s: "n-n1 -> n+-n1",
        // temporarily replace 'subtract' so we can further flatten the 'add' operator
        assuming: {
          subtract: {
            total: true
          }
        }
      },
      {
        s: "n-n -> 0",
        // partial alternative when we can't always subtract
        assuming: {
          subtract: {
            total: false
          }
        }
      },
      {
        s: "-(cl*v) -> v * (-cl)",
        // make non-constant terms positive
        assuming: {
          multiply: {
            commutative: true
          },
          subtract: {
            total: true
          }
        }
      },
      {
        s: "-(cl*v) -> (-cl) * v",
        // non-commutative version, part 1
        assuming: {
          multiply: {
            commutative: false
          },
          subtract: {
            total: true
          }
        }
      },
      {
        s: "-(v*cl) -> v * (-cl)",
        // non-commutative version, part 2
        assuming: {
          multiply: {
            commutative: false
          },
          subtract: {
            total: true
          }
        }
      },
      {
        l: "-(n1/n2)",
        r: "-n1/n2"
      },
      {
        l: "-v",
        r: "v * (-1)"
      },
      // finish making non-constant terms positive
      {
        l: "(n1 + n2)*(-1)",
        r: "n1*(-1) + n2*(-1)",
        repeat: true
      },
      // expand negations to achieve as much sign cancellation as possible
      {
        l: "n/n1^n2",
        r: "n*n1^-n2"
      },
      // temporarily replace 'divide' so we can further flatten the 'multiply' operator
      {
        l: "n/n1",
        r: "n*n1^-1"
      },
      {
        s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
        assuming: {
          multiply: {
            commutative: true
          }
        }
      },
      {
        s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      // expand nested exponentiation
      {
        s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
        assuming: {
          divide: {
            total: true
          }
        }
        // 1/(1/n) = n needs 1/n to exist
      },
      // collect like factors; into a sum, only do this for nonconstants
      {
        l: " vd   * ( vd   * n1 + n2)",
        r: "vd^2       * n1 +  vd   * n2"
      },
      {
        s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
        assuming: {
          divide: {
            total: true
          }
        }
        // v*1/v = v^(1+-1) needs 1/v
      },
      {
        s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
        assuming: {
          divide: {
            total: true
          }
        }
      },
      {
        s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
        assuming: {
          divide: {
            total: true
          }
        }
      },
      {
        l: "n*n",
        r: "n^2"
      },
      {
        s: "n * n^n1 -> n^(n1+1)",
        assuming: {
          divide: {
            total: true
          }
        }
        // n*1/n = n^(-1+1) needs 1/n
      },
      {
        s: "n^n1 * n^n2 -> n^(n1+n2)",
        assuming: {
          divide: {
            total: true
          }
        }
        // ditto for n^2*1/n^2
      },
      // Unfortunately, to deal with more complicated cancellations, it
      // becomes necessary to simplify constants twice per pass. It's not
      // terribly expensive compared to matching rules, so this should not
      // pose a performance problem.
      simplifyConstant2,
      // First: before collecting like terms
      // collect like terms
      {
        s: "n+n -> 2*n",
        assuming: {
          add: {
            total: true
          }
        }
        // 2 = 1 + 1 needs to exist
      },
      {
        l: "n+-n",
        r: "0"
      },
      {
        l: "vd*n + vd",
        r: "vd*(n+1)"
      },
      // NOTE: leftmost position is special:
      {
        l: "n3*n1 + n3*n2",
        r: "n3*(n1+n2)"
      },
      // All sub-monomials tried there.
      {
        l: "n3^(-n4)*n1 +   n3  * n2",
        r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
      },
      {
        l: "n3^(-n4)*n1 + n3^n5 * n2",
        r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
      },
      // noncommutative additional cases (term collection & factoring)
      {
        s: "n*vd + vd -> (n+1)*vd",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "vd + n*vd -> (1+n)*vd",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "n^n1 * n -> n^(n1+1)",
        assuming: {
          divide: {
            total: true
          },
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        l: "n*cd + cd",
        r: "(n+1)*cd"
      },
      {
        s: "cd*n + cd -> cd*(n+1)",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      {
        s: "cd + cd*n -> cd*(1+n)",
        assuming: {
          multiply: {
            commutative: false
          }
        }
      },
      simplifyConstant2,
      // Second: before returning expressions to "standard form"
      // make factors positive (and undo 'make non-constant terms positive')
      {
        s: "(-n)*n1 -> -(n*n1)",
        assuming: {
          subtract: {
            total: true
          }
        }
      },
      {
        s: "n1*(-n) -> -(n1*n)",
        // in case * non-commutative
        assuming: {
          subtract: {
            total: true
          },
          multiply: {
            commutative: false
          }
        }
      },
      // final ordering of constants
      {
        s: "ce+ve -> ve+ce",
        assuming: {
          add: {
            commutative: true
          }
        },
        imposeContext: {
          add: {
            commutative: false
          }
        }
      },
      {
        s: "vd*cd -> cd*vd",
        assuming: {
          multiply: {
            commutative: true
          }
        },
        imposeContext: {
          multiply: {
            commutative: false
          }
        }
      },
      // undo temporary rules
      // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
      {
        l: "n+-n1",
        r: "n-n1"
      },
      // undo replace 'subtract'
      {
        l: "n+-(n1)",
        r: "n-(n1)"
      },
      {
        s: "n*(n1^-1) -> n/n1",
        // undo replace 'divide'; for * commutative
        assuming: {
          multiply: {
            commutative: true
          }
        }
        // o.w. / not conventional
      },
      {
        s: "n*n1^-n2 -> n/n1^n2",
        assuming: {
          multiply: {
            commutative: true
          }
        }
        // o.w. / not conventional
      },
      {
        s: "n^-1 -> 1/n",
        assuming: {
          multiply: {
            commutative: true
          }
        }
        // o.w. / not conventional
      },
      {
        l: "n^1",
        r: "n"
      },
      // can be produced by power cancellation
      {
        s: "n*(n1/n2) -> (n*n1)/n2",
        // '*' before '/'
        assuming: {
          multiply: {
            associative: true
          }
        }
      },
      {
        s: "n-(n1+n2) -> n-n1-n2",
        // '-' before '+'
        assuming: {
          addition: {
            associative: true,
            commutative: true
          }
        }
      },
      // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
      // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
      // simplifyConstant can leave an extra factor of 1, which can always
      // be eliminated, since the identity always commutes
      {
        l: "1*n",
        r: "n",
        imposeContext: {
          multiply: {
            commutative: true
          }
        }
      },
      {
        s: "n1/(n2/n3) -> (n1*n3)/n2",
        assuming: {
          multiply: {
            associative: true
          }
        }
      },
      {
        l: "n1/(-n2)",
        r: "-n1/n2"
      }
    ];
    function _canonicalizeRule(ruleObject, context) {
      var newRule = {};
      if (ruleObject.s) {
        var lr = ruleObject.s.split("->");
        if (lr.length === 2) {
          newRule.l = lr[0];
          newRule.r = lr[1];
        } else {
          throw SyntaxError("Could not parse rule: " + ruleObject.s);
        }
      } else {
        newRule.l = ruleObject.l;
        newRule.r = ruleObject.r;
      }
      newRule.l = removeParens(parse2(newRule.l));
      newRule.r = removeParens(parse2(newRule.r));
      for (var prop of ["imposeContext", "repeat", "assuming"]) {
        if (prop in ruleObject) {
          newRule[prop] = ruleObject[prop];
        }
      }
      if (ruleObject.evaluate) {
        newRule.evaluate = parse2(ruleObject.evaluate);
      }
      if (isAssociative(newRule.l, context)) {
        var nonCommutative = !isCommutative(newRule.l, context);
        var leftExpandsym;
        if (nonCommutative)
          leftExpandsym = _getExpandPlaceholderSymbol();
        var makeNode = createMakeNodeFunction(newRule.l);
        var expandsym = _getExpandPlaceholderSymbol();
        newRule.expanded = {};
        newRule.expanded.l = makeNode([newRule.l, expandsym]);
        flatten3(newRule.expanded.l, context);
        unflattenr(newRule.expanded.l, context);
        newRule.expanded.r = makeNode([newRule.r, expandsym]);
        if (nonCommutative) {
          newRule.expandedNC1 = {};
          newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);
          newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);
          newRule.expandedNC2 = {};
          newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);
          newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);
        }
      }
      return newRule;
    }
    function _buildRules(rules, context) {
      var ruleSet = [];
      for (var i3 = 0; i3 < rules.length; i3++) {
        var rule = rules[i3];
        var newRule = void 0;
        var ruleType = typeof rule;
        switch (ruleType) {
          case "string":
            rule = {
              s: rule
            };
          case "object":
            newRule = _canonicalizeRule(rule, context);
            break;
          case "function":
            newRule = rule;
            break;
          default:
            throw TypeError("Unsupported type of rule: " + ruleType);
        }
        ruleSet.push(newRule);
      }
      return ruleSet;
    }
    var _lastsym = 0;
    function _getExpandPlaceholderSymbol() {
      return new SymbolNode2("_p" + _lastsym++);
    }
    function _simplify(expr, rules) {
      var scope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createEmptyMap();
      var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
      var debug = options.consoleDebug;
      rules = _buildRules(rules || simplify2.rules, options.context);
      var res = resolve2(expr, scope);
      res = removeParens(res);
      var visited = {};
      var str = res.toString({
        parenthesis: "all"
      });
      while (!visited[str]) {
        visited[str] = true;
        _lastsym = 0;
        var laststr = str;
        if (debug)
          console.log("Working on: ", str);
        for (var i3 = 0; i3 < rules.length; i3++) {
          var rulestr = "";
          if (typeof rules[i3] === "function") {
            res = rules[i3](res, options);
            if (debug)
              rulestr = rules[i3].name;
          } else {
            flatten3(res, options.context);
            res = applyRule(res, rules[i3], options.context);
            if (debug) {
              rulestr = "".concat(rules[i3].l.toString(), " -> ").concat(rules[i3].r.toString());
            }
          }
          if (debug) {
            var newstr = res.toString({
              parenthesis: "all"
            });
            if (newstr !== laststr) {
              console.log("Applying", rulestr, "produced", newstr);
              laststr = newstr;
            }
          }
          unflattenl(res, options.context);
        }
        str = res.toString({
          parenthesis: "all"
        });
      }
      return res;
    }
    function mapRule(nodes, rule, context) {
      var resNodes = nodes;
      if (nodes) {
        for (var i3 = 0; i3 < nodes.length; ++i3) {
          var newNode = applyRule(nodes[i3], rule, context);
          if (newNode !== nodes[i3]) {
            if (resNodes === nodes) {
              resNodes = nodes.slice();
            }
            resNodes[i3] = newNode;
          }
        }
      }
      return resNodes;
    }
    function applyRule(node, rule, context) {
      if (rule.assuming) {
        for (var symbol in rule.assuming) {
          for (var property in rule.assuming[symbol]) {
            if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
              return node;
            }
          }
        }
      }
      var mergedContext = mergeContext(rule.imposeContext, context);
      var res = node;
      if (res instanceof OperatorNode2 || res instanceof FunctionNode2) {
        var newArgs = mapRule(res.args, rule, context);
        if (newArgs !== res.args) {
          res = res.clone();
          res.args = newArgs;
        }
      } else if (res instanceof ParenthesisNode2) {
        if (res.content) {
          var newContent = applyRule(res.content, rule, context);
          if (newContent !== res.content) {
            res = new ParenthesisNode2(newContent);
          }
        }
      } else if (res instanceof ArrayNode2) {
        var newItems = mapRule(res.items, rule, context);
        if (newItems !== res.items) {
          res = new ArrayNode2(newItems);
        }
      } else if (res instanceof AccessorNode2) {
        var newObj = res.object;
        if (res.object) {
          newObj = applyRule(res.object, rule, context);
        }
        var newIndex = res.index;
        if (res.index) {
          newIndex = applyRule(res.index, rule, context);
        }
        if (newObj !== res.object || newIndex !== res.index) {
          res = new AccessorNode2(newObj, newIndex);
        }
      } else if (res instanceof IndexNode2) {
        var newDims = mapRule(res.dimensions, rule, context);
        if (newDims !== res.dimensions) {
          res = new IndexNode2(newDims);
        }
      } else if (res instanceof ObjectNode2) {
        var changed = false;
        var newProps = {};
        for (var prop in res.properties) {
          newProps[prop] = applyRule(res.properties[prop], rule, context);
          if (newProps[prop] !== res.properties[prop]) {
            changed = true;
          }
        }
        if (changed) {
          res = new ObjectNode2(newProps);
        }
      }
      var repl = rule.r;
      var matches = _ruleMatch(rule.l, res, mergedContext)[0];
      if (!matches && rule.expanded) {
        repl = rule.expanded.r;
        matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
      }
      if (!matches && rule.expandedNC1) {
        repl = rule.expandedNC1.r;
        matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
        if (!matches) {
          repl = rule.expandedNC2.r;
          matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
        }
      }
      if (matches) {
        var implicit = res.implicit;
        res = repl.clone();
        if (implicit && "implicit" in repl) {
          res.implicit = true;
        }
        res = res.transform(function(node2) {
          if (node2.isSymbolNode && hasOwnProperty(matches.placeholders, node2.name)) {
            return matches.placeholders[node2.name].clone();
          } else {
            return node2;
          }
        });
      }
      if (rule.repeat && res !== node) {
        res = applyRule(res, rule, context);
      }
      return res;
    }
    function getSplits(node, context) {
      var res = [];
      var right, rightArgs;
      var makeNode = createMakeNodeFunction(node);
      if (isCommutative(node, context)) {
        for (var i3 = 0; i3 < node.args.length; i3++) {
          rightArgs = node.args.slice(0);
          rightArgs.splice(i3, 1);
          right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
          res.push(makeNode([node.args[i3], right]));
        }
      } else {
        for (var _i = 1; _i < node.args.length; _i++) {
          var left = node.args[0];
          if (_i > 1) {
            left = makeNode(node.args.slice(0, _i));
          }
          rightArgs = node.args.slice(_i);
          right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
          res.push(makeNode([left, right]));
        }
      }
      return res;
    }
    function mergeMatch(match1, match2) {
      var res = {
        placeholders: {}
      };
      if (!match1.placeholders && !match2.placeholders) {
        return res;
      } else if (!match1.placeholders) {
        return match2;
      } else if (!match2.placeholders) {
        return match1;
      }
      for (var key in match1.placeholders) {
        if (hasOwnProperty(match1.placeholders, key)) {
          res.placeholders[key] = match1.placeholders[key];
          if (hasOwnProperty(match2.placeholders, key)) {
            if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
              return null;
            }
          }
        }
      }
      for (var _key in match2.placeholders) {
        if (hasOwnProperty(match2.placeholders, _key)) {
          res.placeholders[_key] = match2.placeholders[_key];
        }
      }
      return res;
    }
    function combineChildMatches(list1, list2) {
      var res = [];
      if (list1.length === 0 || list2.length === 0) {
        return res;
      }
      var merged;
      for (var i1 = 0; i1 < list1.length; i1++) {
        for (var i22 = 0; i22 < list2.length; i22++) {
          merged = mergeMatch(list1[i1], list2[i22]);
          if (merged) {
            res.push(merged);
          }
        }
      }
      return res;
    }
    function mergeChildMatches(childMatches) {
      if (childMatches.length === 0) {
        return childMatches;
      }
      var sets = childMatches.reduce(combineChildMatches);
      var uniqueSets = [];
      var unique = {};
      for (var i3 = 0; i3 < sets.length; i3++) {
        var s = JSON.stringify(sets[i3]);
        if (!unique[s]) {
          unique[s] = true;
          uniqueSets.push(sets[i3]);
        }
      }
      return uniqueSets;
    }
    function _ruleMatch(rule, node, context, isSplit) {
      var res = [{
        placeholders: {}
      }];
      if (rule instanceof OperatorNode2 && node instanceof OperatorNode2 || rule instanceof FunctionNode2 && node instanceof FunctionNode2) {
        if (rule instanceof OperatorNode2) {
          if (rule.op !== node.op || rule.fn !== node.fn) {
            return [];
          }
        } else if (rule instanceof FunctionNode2) {
          if (rule.name !== node.name) {
            return [];
          }
        }
        if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
          var childMatches = [];
          for (var i3 = 0; i3 < rule.args.length; i3++) {
            var childMatch = _ruleMatch(rule.args[i3], node.args[i3], context);
            if (childMatch.length === 0) {
              break;
            }
            childMatches.push(childMatch);
          }
          if (childMatches.length !== rule.args.length) {
            if (!isCommutative(node, context) || // exact match in order needed
            rule.args.length === 1) {
              return [];
            }
            if (rule.args.length > 2) {
              throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
            }
            var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
            if (leftMatch.length === 0) {
              return [];
            }
            var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
            if (rightMatch.length === 0) {
              return [];
            }
            childMatches = [leftMatch, rightMatch];
          }
          res = mergeChildMatches(childMatches);
        } else if (node.args.length >= 2 && rule.args.length === 2) {
          var splits = getSplits(node, context);
          var splitMatches = [];
          for (var _i2 = 0; _i2 < splits.length; _i2++) {
            var matchSet = _ruleMatch(rule, splits[_i2], context, true);
            splitMatches = splitMatches.concat(matchSet);
          }
          return splitMatches;
        } else if (rule.args.length > 2) {
          throw Error("Unexpected non-binary associative function: " + rule.toString());
        } else {
          return [];
        }
      } else if (rule instanceof SymbolNode2) {
        if (rule.name.length === 0) {
          throw new Error("Symbol in rule has 0 length...!?");
        }
        if (SUPPORTED_CONSTANTS[rule.name]) {
          if (rule.name !== node.name) {
            return [];
          }
        } else {
          switch (rule.name[1] >= "a" && rule.name[1] <= "z" ? rule.name.substring(0, 2) : rule.name[0]) {
            case "n":
            case "_p":
              res[0].placeholders[rule.name] = node;
              break;
            case "c":
            case "cl":
              if (isConstantNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "v":
              if (!isConstantNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "vl":
              if (isSymbolNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "cd":
              if (isNumericNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "vd":
              if (!isNumericNode(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "ce":
              if (isConstantExpression(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            case "ve":
              if (!isConstantExpression(node)) {
                res[0].placeholders[rule.name] = node;
              } else {
                return [];
              }
              break;
            default:
              throw new Error("Invalid symbol in rule: " + rule.name);
          }
        }
      } else if (rule instanceof ConstantNode2) {
        if (!equal2(rule.value, node.value)) {
          return [];
        }
      } else {
        return [];
      }
      return res;
    }
    function _exactMatch(p, q) {
      if (p instanceof ConstantNode2 && q instanceof ConstantNode2) {
        if (!equal2(p.value, q.value)) {
          return false;
        }
      } else if (p instanceof SymbolNode2 && q instanceof SymbolNode2) {
        if (p.name !== q.name) {
          return false;
        }
      } else if (p instanceof OperatorNode2 && q instanceof OperatorNode2 || p instanceof FunctionNode2 && q instanceof FunctionNode2) {
        if (p instanceof OperatorNode2) {
          if (p.op !== q.op || p.fn !== q.fn) {
            return false;
          }
        } else if (p instanceof FunctionNode2) {
          if (p.name !== q.name) {
            return false;
          }
        }
        if (p.args.length !== q.args.length) {
          return false;
        }
        for (var i3 = 0; i3 < p.args.length; i3++) {
          if (!_exactMatch(p.args[i3], q.args[i3])) {
            return false;
          }
        }
      } else {
        return false;
      }
      return true;
    }
    return simplify2;
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplifyConstant.js
  var name280 = "simplifyConstant";
  var dependencies280 = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
  var createSimplifyConstant = /* @__PURE__ */ factory(name280, dependencies280, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      mathWithTransform: mathWithTransform2,
      matrix: matrix2,
      fraction: fraction2,
      bignumber: bignumber2,
      AccessorNode: AccessorNode2,
      ArrayNode: ArrayNode2,
      ConstantNode: ConstantNode2,
      FunctionNode: FunctionNode2,
      IndexNode: IndexNode2,
      ObjectNode: ObjectNode2,
      OperatorNode: OperatorNode2,
      SymbolNode: SymbolNode2
    } = _ref;
    var {
      isCommutative,
      isAssociative,
      allChildren,
      createMakeNodeFunction
    } = createUtil({
      FunctionNode: FunctionNode2,
      OperatorNode: OperatorNode2,
      SymbolNode: SymbolNode2
    });
    var simplifyConstant2 = typed3("simplifyConstant", {
      Node: (node) => _ensureNode(foldFraction(node, {})),
      "Node, Object": function NodeObject(expr, options) {
        return _ensureNode(foldFraction(expr, options));
      }
    });
    function _removeFractions(thing) {
      if (isFraction(thing)) {
        return thing.valueOf();
      }
      if (thing instanceof Array) {
        return thing.map(_removeFractions);
      }
      if (isMatrix(thing)) {
        return matrix2(_removeFractions(thing.valueOf()));
      }
      return thing;
    }
    function _eval(fnname, args, options) {
      try {
        return mathWithTransform2[fnname].apply(null, args);
      } catch (ignore) {
        args = args.map(_removeFractions);
        return _toNumber(mathWithTransform2[fnname].apply(null, args), options);
      }
    }
    var _toNode = typed3({
      Fraction: _fractionToNode,
      number: function number2(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode2(-n));
        }
        return new ConstantNode2(n);
      },
      BigNumber: function BigNumber2(n) {
        if (n < 0) {
          return unaryMinusNode(new ConstantNode2(-n));
        }
        return new ConstantNode2(n);
      },
      Complex: function Complex3(s) {
        throw new Error("Cannot convert Complex number to Node");
      },
      string: function string2(s) {
        return new ConstantNode2(s);
      },
      Matrix: function Matrix2(m) {
        return new ArrayNode2(m.valueOf().map((e3) => _toNode(e3)));
      }
    });
    function _ensureNode(thing) {
      if (isNode(thing)) {
        return thing;
      }
      return _toNode(thing);
    }
    function _exactFraction(n, options) {
      var exactFractions = options && options.exactFractions !== false;
      if (exactFractions && isFinite(n) && fraction2) {
        var f = fraction2(n);
        var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
        if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
          return f;
        }
      }
      return n;
    }
    var _toNumber = typed3({
      "string, Object": function stringObject(s, options) {
        if (config4.number === "BigNumber") {
          if (bignumber2 === void 0) {
            noBignumber();
          }
          return bignumber2(s);
        } else if (config4.number === "Fraction") {
          if (fraction2 === void 0) {
            noFraction();
          }
          return fraction2(s);
        } else {
          var n = parseFloat(s);
          return _exactFraction(n, options);
        }
      },
      "Fraction, Object": function FractionObject(s, options) {
        return s;
      },
      // we don't need options here
      "BigNumber, Object": function BigNumberObject(s, options) {
        return s;
      },
      // we don't need options here
      "number, Object": function numberObject(s, options) {
        return _exactFraction(s, options);
      },
      "Complex, Object": function ComplexObject(s, options) {
        if (s.im !== 0) {
          return s;
        }
        return _exactFraction(s.re, options);
      },
      "Matrix, Object": function MatrixObject(s, options) {
        return matrix2(_exactFraction(s.valueOf()));
      },
      "Array, Object": function ArrayObject(s, options) {
        return s.map(_exactFraction);
      }
    });
    function unaryMinusNode(n) {
      return new OperatorNode2("-", "unaryMinus", [n]);
    }
    function _fractionToNode(f) {
      var n;
      var vn = f.s * f.n;
      if (vn < 0) {
        n = new OperatorNode2("-", "unaryMinus", [new ConstantNode2(-vn)]);
      } else {
        n = new ConstantNode2(vn);
      }
      if (f.d === 1) {
        return n;
      }
      return new OperatorNode2("/", "divide", [n, new ConstantNode2(f.d)]);
    }
    function _foldAccessor(obj, index2, options) {
      if (!isIndexNode(index2)) {
        return new AccessorNode2(_ensureNode(obj), _ensureNode(index2));
      }
      if (isArrayNode(obj) || isMatrix(obj)) {
        var remainingDims = Array.from(index2.dimensions);
        while (remainingDims.length > 0) {
          if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
            var first = _toNumber(remainingDims.shift().value, options);
            if (isArrayNode(obj)) {
              obj = obj.items[first - 1];
            } else {
              obj = obj.valueOf()[first - 1];
              if (obj instanceof Array) {
                obj = matrix2(obj);
              }
            }
          } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
            var second = _toNumber(remainingDims[1].value, options);
            var tryItems = [];
            var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
            for (var item of fromItems) {
              if (isArrayNode(item)) {
                tryItems.push(item.items[second - 1]);
              } else if (isMatrix(obj)) {
                tryItems.push(item[second - 1]);
              } else {
                break;
              }
            }
            if (tryItems.length === fromItems.length) {
              if (isArrayNode(obj)) {
                obj = new ArrayNode2(tryItems);
              } else {
                obj = matrix2(tryItems);
              }
              remainingDims.splice(1, 1);
            } else {
              break;
            }
          } else {
            break;
          }
        }
        if (remainingDims.length === index2.dimensions.length) {
          return new AccessorNode2(_ensureNode(obj), index2);
        }
        if (remainingDims.length > 0) {
          index2 = new IndexNode2(remainingDims);
          return new AccessorNode2(_ensureNode(obj), index2);
        }
        return obj;
      }
      if (isObjectNode(obj) && index2.dimensions.length === 1 && isConstantNode(index2.dimensions[0])) {
        var key = index2.dimensions[0].value;
        if (key in obj.properties) {
          return obj.properties[key];
        }
        return new ConstantNode2();
      }
      return new AccessorNode2(_ensureNode(obj), index2);
    }
    function foldOp(fn, args, makeNode, options) {
      var first = args.shift();
      var reduction = args.reduce((sofar, next) => {
        if (!isNode(next)) {
          var last = sofar.pop();
          if (isNode(last)) {
            return [last, next];
          }
          try {
            sofar.push(_eval(fn, [last, next], options));
            return sofar;
          } catch (ignoreandcontinue) {
            sofar.push(last);
          }
        }
        sofar.push(_ensureNode(sofar.pop()));
        var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
        return [makeNode([newtree, _ensureNode(next)])];
      }, [first]);
      if (reduction.length === 1) {
        return reduction[0];
      }
      return makeNode([reduction[0], _toNode(reduction[1])]);
    }
    function foldFraction(node, options) {
      switch (node.type) {
        case "SymbolNode":
          return node;
        case "ConstantNode":
          switch (typeof node.value) {
            case "number":
              return _toNumber(node.value, options);
            case "string":
              return node.value;
            default:
              if (!isNaN(node.value))
                return _toNumber(node.value, options);
          }
          return node;
        case "FunctionNode":
          if (mathWithTransform2[node.name] && mathWithTransform2[node.name].rawArgs) {
            return node;
          }
          {
            var operatorFunctions = ["add", "multiply"];
            if (operatorFunctions.indexOf(node.name) === -1) {
              var args = node.args.map((arg2) => foldFraction(arg2, options));
              if (!args.some(isNode)) {
                try {
                  return _eval(node.name, args, options);
                } catch (ignoreandcontinue) {
                }
              }
              if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
                var sz = [];
                var section = args[0];
                while (isArrayNode(section)) {
                  sz.push(section.items.length);
                  section = section.items[0];
                }
                return matrix2(sz);
              }
              return new FunctionNode2(node.name, args.map(_ensureNode));
            } else {
            }
          }
        case "OperatorNode": {
          var fn = node.fn.toString();
          var _args;
          var res;
          var makeNode = createMakeNodeFunction(node);
          if (isOperatorNode(node) && node.isUnary()) {
            _args = [foldFraction(node.args[0], options)];
            if (!isNode(_args[0])) {
              res = _eval(fn, _args, options);
            } else {
              res = makeNode(_args);
            }
          } else if (isAssociative(node, options.context)) {
            _args = allChildren(node, options.context);
            _args = _args.map((arg2) => foldFraction(arg2, options));
            if (isCommutative(fn, options.context)) {
              var consts = [];
              var vars = [];
              for (var i3 = 0; i3 < _args.length; i3++) {
                if (!isNode(_args[i3])) {
                  consts.push(_args[i3]);
                } else {
                  vars.push(_args[i3]);
                }
              }
              if (consts.length > 1) {
                res = foldOp(fn, consts, makeNode, options);
                vars.unshift(res);
                res = foldOp(fn, vars, makeNode, options);
              } else {
                res = foldOp(fn, _args, makeNode, options);
              }
            } else {
              res = foldOp(fn, _args, makeNode, options);
            }
          } else {
            _args = node.args.map((arg2) => foldFraction(arg2, options));
            res = foldOp(fn, _args, makeNode, options);
          }
          return res;
        }
        case "ParenthesisNode":
          return foldFraction(node.content, options);
        case "AccessorNode":
          return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
        case "ArrayNode": {
          var foldItems = node.items.map((item) => foldFraction(item, options));
          if (foldItems.some(isNode)) {
            return new ArrayNode2(foldItems.map(_ensureNode));
          }
          return matrix2(foldItems);
        }
        case "IndexNode": {
          return new IndexNode2(node.dimensions.map((n) => simplifyConstant2(n, options)));
        }
        case "ObjectNode": {
          var foldProps = {};
          for (var prop in node.properties) {
            foldProps[prop] = simplifyConstant2(node.properties[prop], options);
          }
          return new ObjectNode2(foldProps);
        }
        case "AssignmentNode":
        case "BlockNode":
        case "FunctionAssignmentNode":
        case "RangeNode":
        case "ConditionalNode":
        default:
          throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
      }
    }
    return simplifyConstant2;
  });

  // node_modules/mathjs/lib/esm/function/algebra/simplifyCore.js
  var name281 = "simplifyCore";
  var dependencies281 = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
  var createSimplifyCore = /* @__PURE__ */ factory(name281, dependencies281, (_ref) => {
    var {
      typed: typed3,
      parse: parse2,
      equal: equal2,
      isZero: isZero2,
      add: add3,
      subtract: subtract2,
      multiply: multiply2,
      divide: divide3,
      pow: pow3,
      AccessorNode: AccessorNode2,
      ArrayNode: ArrayNode2,
      ConstantNode: ConstantNode2,
      FunctionNode: FunctionNode2,
      IndexNode: IndexNode2,
      ObjectNode: ObjectNode2,
      OperatorNode: OperatorNode2,
      ParenthesisNode: ParenthesisNode2,
      SymbolNode: SymbolNode2
    } = _ref;
    var node0 = new ConstantNode2(0);
    var node1 = new ConstantNode2(1);
    var nodeT = new ConstantNode2(true);
    var nodeF = new ConstantNode2(false);
    function isAlwaysBoolean(node) {
      return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
    }
    var {
      hasProperty,
      isCommutative
    } = createUtil({
      FunctionNode: FunctionNode2,
      OperatorNode: OperatorNode2,
      SymbolNode: SymbolNode2
    });
    function _simplifyCore(nodeToSimplify) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var context = options ? options.context : void 0;
      if (hasProperty(nodeToSimplify, "trivial", context)) {
        if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
          return _simplifyCore(nodeToSimplify.args[0], options);
        }
        var simpChild = false;
        var childCount = 0;
        nodeToSimplify.forEach((c) => {
          ++childCount;
          if (childCount === 1) {
            simpChild = _simplifyCore(c, options);
          }
        });
        if (childCount === 1) {
          return simpChild;
        }
      }
      var node = nodeToSimplify;
      if (isFunctionNode(node)) {
        var op = getOperator(node.name);
        if (op) {
          if (node.args.length > 2 && hasProperty(node, "associative", context)) {
            while (node.args.length > 2) {
              var last = node.args.pop();
              var seclast = node.args.pop();
              node.args.push(new OperatorNode2(op, node.name, [last, seclast]));
            }
          }
          node = new OperatorNode2(op, node.name, node.args);
        } else {
          return new FunctionNode2(_simplifyCore(node.fn), node.args.map((n) => _simplifyCore(n, options)));
        }
      }
      if (isOperatorNode(node) && node.isUnary()) {
        var a0 = _simplifyCore(node.args[0], options);
        if (node.op === "~") {
          if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
            return a0.args[0];
          }
        }
        if (node.op === "not") {
          if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
            if (isAlwaysBoolean(a0.args[0])) {
              return a0.args[0];
            }
          }
        }
        var finish = true;
        if (node.op === "-") {
          if (isOperatorNode(a0)) {
            if (a0.isBinary() && a0.fn === "subtract") {
              node = new OperatorNode2("-", "subtract", [a0.args[1], a0.args[0]]);
              finish = false;
            }
            if (a0.isUnary() && a0.op === "-") {
              return a0.args[0];
            }
          }
        }
        if (finish)
          return new OperatorNode2(node.op, node.fn, [a0]);
      }
      if (isOperatorNode(node) && node.isBinary()) {
        var _a = _simplifyCore(node.args[0], options);
        var a1 = _simplifyCore(node.args[1], options);
        if (node.op === "+") {
          if (isConstantNode(_a) && isZero2(_a.value)) {
            return a1;
          }
          if (isConstantNode(a1) && isZero2(a1.value)) {
            return _a;
          }
          if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
            a1 = a1.args[0];
            node = new OperatorNode2("-", "subtract", [_a, a1]);
          }
        }
        if (node.op === "-") {
          if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
            return _simplifyCore(new OperatorNode2("+", "add", [_a, a1.args[0]]), options);
          }
          if (isConstantNode(_a) && isZero2(_a.value)) {
            return _simplifyCore(new OperatorNode2("-", "unaryMinus", [a1]));
          }
          if (isConstantNode(a1) && isZero2(a1.value)) {
            return _a;
          }
          return new OperatorNode2(node.op, node.fn, [_a, a1]);
        }
        if (node.op === "*") {
          if (isConstantNode(_a)) {
            if (isZero2(_a.value)) {
              return node0;
            } else if (equal2(_a.value, 1)) {
              return a1;
            }
          }
          if (isConstantNode(a1)) {
            if (isZero2(a1.value)) {
              return node0;
            } else if (equal2(a1.value, 1)) {
              return _a;
            }
            if (isCommutative(node, context)) {
              return new OperatorNode2(node.op, node.fn, [a1, _a], node.implicit);
            }
          }
          return new OperatorNode2(node.op, node.fn, [_a, a1], node.implicit);
        }
        if (node.op === "/") {
          if (isConstantNode(_a) && isZero2(_a.value)) {
            return node0;
          }
          if (isConstantNode(a1) && equal2(a1.value, 1)) {
            return _a;
          }
          return new OperatorNode2(node.op, node.fn, [_a, a1]);
        }
        if (node.op === "^") {
          if (isConstantNode(a1)) {
            if (isZero2(a1.value)) {
              return node1;
            } else if (equal2(a1.value, 1)) {
              return _a;
            }
          }
        }
        if (node.op === "and") {
          if (isConstantNode(_a)) {
            if (_a.value) {
              if (isAlwaysBoolean(a1))
                return a1;
            } else {
              return nodeF;
            }
          }
          if (isConstantNode(a1)) {
            if (a1.value) {
              if (isAlwaysBoolean(_a))
                return _a;
            } else {
              return nodeF;
            }
          }
        }
        if (node.op === "or") {
          if (isConstantNode(_a)) {
            if (_a.value) {
              return nodeT;
            } else {
              if (isAlwaysBoolean(a1))
                return a1;
            }
          }
          if (isConstantNode(a1)) {
            if (a1.value) {
              return nodeT;
            } else {
              if (isAlwaysBoolean(_a))
                return _a;
            }
          }
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1]);
      }
      if (isOperatorNode(node)) {
        return new OperatorNode2(node.op, node.fn, node.args.map((a) => _simplifyCore(a, options)));
      }
      if (isArrayNode(node)) {
        return new ArrayNode2(node.items.map((n) => _simplifyCore(n, options)));
      }
      if (isAccessorNode(node)) {
        return new AccessorNode2(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
      }
      if (isIndexNode(node)) {
        return new IndexNode2(node.dimensions.map((n) => _simplifyCore(n, options)));
      }
      if (isObjectNode(node)) {
        var newProps = {};
        for (var prop in node.properties) {
          newProps[prop] = _simplifyCore(node.properties[prop], options);
        }
        return new ObjectNode2(newProps);
      }
      return node;
    }
    return typed3(name281, {
      Node: _simplifyCore,
      "Node,Object": _simplifyCore
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/resolve.js
  var name282 = "resolve";
  var dependencies282 = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
  var createResolve = /* @__PURE__ */ factory(name282, dependencies282, (_ref) => {
    var {
      typed: typed3,
      parse: parse2,
      ConstantNode: ConstantNode2,
      FunctionNode: FunctionNode2,
      OperatorNode: OperatorNode2,
      ParenthesisNode: ParenthesisNode2
    } = _ref;
    function _resolve(node, scope) {
      var within = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
      if (!scope) {
        return node;
      }
      if (isSymbolNode(node)) {
        if (within.has(node.name)) {
          var variables = Array.from(within).join(", ");
          throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
        }
        var value = scope.get(node.name);
        if (isNode(value)) {
          var nextWithin = new Set(within);
          nextWithin.add(node.name);
          return _resolve(value, scope, nextWithin);
        } else if (typeof value === "number") {
          return parse2(String(value));
        } else if (value !== void 0) {
          return new ConstantNode2(value);
        } else {
          return node;
        }
      } else if (isOperatorNode(node)) {
        var args = node.args.map(function(arg2) {
          return _resolve(arg2, scope, within);
        });
        return new OperatorNode2(node.op, node.fn, args, node.implicit);
      } else if (isParenthesisNode(node)) {
        return new ParenthesisNode2(_resolve(node.content, scope, within));
      } else if (isFunctionNode(node)) {
        var _args = node.args.map(function(arg2) {
          return _resolve(arg2, scope, within);
        });
        return new FunctionNode2(node.name, _args);
      }
      return node.map((child) => _resolve(child, scope, within));
    }
    return typed3("resolve", {
      Node: _resolve,
      "Node, Map | null | undefined": _resolve,
      "Node, Object": (n, scope) => _resolve(n, createMap(scope)),
      // For arrays and matrices, we map `self` rather than `_resolve`
      // because resolve is fairly expensive anyway, and this way
      // we get nice error messages if one entry in the array has wrong type.
      "Array | Matrix": typed3.referToSelf((self2) => (A2) => A2.map((n) => self2(n))),
      "Array | Matrix, null | undefined": typed3.referToSelf((self2) => (A2) => A2.map((n) => self2(n))),
      "Array, Object": typed3.referTo("Array,Map", (selfAM) => (A2, scope) => selfAM(A2, createMap(scope))),
      "Matrix, Object": typed3.referTo("Matrix,Map", (selfMM) => (A2, scope) => selfMM(A2, createMap(scope))),
      "Array | Matrix, Map": typed3.referToSelf((self2) => (A2, scope) => A2.map((n) => self2(n, scope)))
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/symbolicEqual.js
  var name283 = "symbolicEqual";
  var dependencies283 = ["parse", "simplify", "typed", "OperatorNode"];
  var createSymbolicEqual = /* @__PURE__ */ factory(name283, dependencies283, (_ref) => {
    var {
      parse: parse2,
      simplify: simplify2,
      typed: typed3,
      OperatorNode: OperatorNode2
    } = _ref;
    function _symbolicEqual(e1, e22) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var diff2 = new OperatorNode2("-", "subtract", [e1, e22]);
      var simplified = simplify2(diff2, {}, options);
      return isConstantNode(simplified) && !simplified.value;
    }
    return typed3(name283, {
      "Node, Node": _symbolicEqual,
      "Node, Node, Object": _symbolicEqual
    });
  });

  // node_modules/mathjs/lib/esm/function/algebra/derivative.js
  var name284 = "derivative";
  var dependencies284 = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
  var createDerivative = /* @__PURE__ */ factory(name284, dependencies284, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      parse: parse2,
      simplify: simplify2,
      equal: equal2,
      isZero: isZero2,
      numeric: numeric3,
      ConstantNode: ConstantNode2,
      FunctionNode: FunctionNode2,
      OperatorNode: OperatorNode2,
      ParenthesisNode: ParenthesisNode2,
      SymbolNode: SymbolNode2
    } = _ref;
    function plainDerivative(expr, variable) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
        simplify: true
      };
      var constNodes = {};
      constTag(constNodes, expr, variable.name);
      var res = _derivative(expr, constNodes);
      return options.simplify ? simplify2(res) : res;
    }
    typed3.addConversion({
      from: "identifier",
      to: "SymbolNode",
      convert: parse2
    });
    var derivative2 = typed3(name284, {
      "Node, SymbolNode": plainDerivative,
      "Node, SymbolNode, Object": plainDerivative
      /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
      'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
        let res = expr
        for (let i = 0; i < order; i++) {
          let constNodes = {}
          constTag(constNodes, expr, variable.name)
          res = _derivative(res, constNodes)
        }
        return res
      }
      */
    });
    typed3.removeConversion({
      from: "identifier",
      to: "SymbolNode",
      convert: parse2
    });
    derivative2._simplify = true;
    derivative2.toTex = function(deriv) {
      return _derivTex.apply(null, deriv.args);
    };
    var _derivTex = typed3("_derivTex", {
      "Node, SymbolNode": function NodeSymbolNode(expr, x) {
        if (isConstantNode(expr) && typeOf(expr.value) === "string") {
          return _derivTex(parse2(expr.value).toString(), x.toString(), 1);
        } else {
          return _derivTex(expr.toTex(), x.toString(), 1);
        }
      },
      "Node, ConstantNode": function NodeConstantNode(expr, x) {
        if (typeOf(x.value) === "string") {
          return _derivTex(expr, parse2(x.value));
        } else {
          throw new Error("The second parameter to 'derivative' is a non-string constant");
        }
      },
      "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x, order) {
        return _derivTex(expr.toString(), x.name, order.value);
      },
      "string, string, number": function stringStringNumber(expr, x, order) {
        var d;
        if (order === 1) {
          d = "{d\\over d" + x + "}";
        } else {
          d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
        }
        return d + "\\left[".concat(expr, "\\right]");
      }
    });
    var constTag = typed3("constTag", {
      "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
        constNodes[node] = true;
        return true;
      },
      "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
        if (node.name !== varName) {
          constNodes[node] = true;
          return true;
        }
        return false;
      },
      "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
        return constTag(constNodes, node.content, varName);
      },
      "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
        if (node.params.indexOf(varName) === -1) {
          constNodes[node] = true;
          return true;
        }
        return constTag(constNodes, node.expr, varName);
      },
      "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
        if (node.args.length > 0) {
          var isConst = constTag(constNodes, node.args[0], varName);
          for (var i3 = 1; i3 < node.args.length; ++i3) {
            isConst = constTag(constNodes, node.args[i3], varName) && isConst;
          }
          if (isConst) {
            constNodes[node] = true;
            return true;
          }
        }
        return false;
      }
    });
    var _derivative = typed3("_derivative", {
      "ConstantNode, Object": function ConstantNodeObject(node) {
        return createConstantNode2(0);
      },
      "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        return createConstantNode2(1);
      },
      "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
        return new ParenthesisNode2(_derivative(node.content, constNodes));
      },
      "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        return _derivative(node.expr, constNodes);
      },
      "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        var arg0 = node.args[0];
        var arg1;
        var div2 = false;
        var negative = false;
        var funcDerivative;
        switch (node.name) {
          case "cbrt":
            div2 = true;
            funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(3), new OperatorNode2("^", "pow", [arg0, new OperatorNode2("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
            break;
          case "sqrt":
          case "nthRoot":
            if (node.args.length === 1) {
              div2 = true;
              funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(2), new FunctionNode2("sqrt", [arg0])]);
            } else if (node.args.length === 2) {
              arg1 = new OperatorNode2("/", "divide", [createConstantNode2(1), node.args[1]]);
              constNodes[arg1] = constNodes[node.args[1]];
              return _derivative(new OperatorNode2("^", "pow", [arg0, arg1]), constNodes);
            }
            break;
          case "log10":
            arg1 = createConstantNode2(10);
          case "log":
            if (!arg1 && node.args.length === 1) {
              funcDerivative = arg0.clone();
              div2 = true;
            } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
              funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("log", [arg1 || node.args[1]])]);
              div2 = true;
            } else if (node.args.length === 2) {
              return _derivative(new OperatorNode2("/", "divide", [new FunctionNode2("log", [arg0]), new FunctionNode2("log", [node.args[1]])]), constNodes);
            }
            break;
          case "pow":
            if (node.args.length === 2) {
              constNodes[arg1] = constNodes[node.args[1]];
              return _derivative(new OperatorNode2("^", "pow", [arg0, node.args[1]]), constNodes);
            }
            break;
          case "exp":
            funcDerivative = new FunctionNode2("exp", [arg0.clone()]);
            break;
          case "sin":
            funcDerivative = new FunctionNode2("cos", [arg0.clone()]);
            break;
          case "cos":
            funcDerivative = new OperatorNode2("-", "unaryMinus", [new FunctionNode2("sin", [arg0.clone()])]);
            break;
          case "tan":
            funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sec", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "sec":
            funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tan", [arg0.clone()])]);
            break;
          case "csc":
            negative = true;
            funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("cot", [arg0.clone()])]);
            break;
          case "cot":
            negative = true;
            funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csc", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "asin":
            div2 = true;
            funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
            break;
          case "acos":
            div2 = true;
            negative = true;
            funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
            break;
          case "atan":
            div2 = true;
            funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
            break;
          case "asec":
            div2 = true;
            funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
            break;
          case "acsc":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
            break;
          case "acot":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
            break;
          case "sinh":
            funcDerivative = new FunctionNode2("cosh", [arg0.clone()]);
            break;
          case "cosh":
            funcDerivative = new FunctionNode2("sinh", [arg0.clone()]);
            break;
          case "tanh":
            funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sech", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "sech":
            negative = true;
            funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tanh", [arg0.clone()])]);
            break;
          case "csch":
            negative = true;
            funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("coth", [arg0.clone()])]);
            break;
          case "coth":
            negative = true;
            funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csch", [arg0.clone()]), createConstantNode2(2)]);
            break;
          case "asinh":
            div2 = true;
            funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
            break;
          case "acosh":
            div2 = true;
            funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
            break;
          case "atanh":
            div2 = true;
            funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
            break;
          case "asech":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
            break;
          case "acsch":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
            break;
          case "acoth":
            div2 = true;
            negative = true;
            funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
            break;
          case "abs":
            funcDerivative = new OperatorNode2("/", "divide", [new FunctionNode2(new SymbolNode2("abs"), [arg0.clone()]), arg0.clone()]);
            break;
          case "gamma":
          default:
            throw new Error('Cannot process function "' + node.name + '" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported');
        }
        var op, func;
        if (div2) {
          op = "/";
          func = "divide";
        } else {
          op = "*";
          func = "multiply";
        }
        var chainDerivative = _derivative(arg0, constNodes);
        if (negative) {
          chainDerivative = new OperatorNode2("-", "unaryMinus", [chainDerivative]);
        }
        return new OperatorNode2(op, func, [chainDerivative, funcDerivative]);
      },
      "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
        if (constNodes[node] !== void 0) {
          return createConstantNode2(0);
        }
        if (node.op === "+") {
          return new OperatorNode2(node.op, node.fn, node.args.map(function(arg2) {
            return _derivative(arg2, constNodes);
          }));
        }
        if (node.op === "-") {
          if (node.isUnary()) {
            return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
          }
          if (node.isBinary()) {
            return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
          }
        }
        if (node.op === "*") {
          var constantTerms = node.args.filter(function(arg2) {
            return constNodes[arg2] !== void 0;
          });
          if (constantTerms.length > 0) {
            var nonConstantTerms = node.args.filter(function(arg2) {
              return constNodes[arg2] === void 0;
            });
            var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode2("*", "multiply", nonConstantTerms);
            var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
            return new OperatorNode2("*", "multiply", newArgs);
          }
          return new OperatorNode2("+", "add", node.args.map(function(argOuter) {
            return new OperatorNode2("*", "multiply", node.args.map(function(argInner) {
              return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
            }));
          }));
        }
        if (node.op === "/" && node.isBinary()) {
          var arg0 = node.args[0];
          var arg1 = node.args[1];
          if (constNodes[arg1] !== void 0) {
            return new OperatorNode2("/", "divide", [_derivative(arg0, constNodes), arg1]);
          }
          if (constNodes[arg0] !== void 0) {
            return new OperatorNode2("*", "multiply", [new OperatorNode2("-", "unaryMinus", [arg0]), new OperatorNode2("/", "divide", [_derivative(arg1, constNodes), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
          }
          return new OperatorNode2("/", "divide", [new OperatorNode2("-", "subtract", [new OperatorNode2("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode2("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
        }
        if (node.op === "^" && node.isBinary()) {
          var _arg = node.args[0];
          var _arg2 = node.args[1];
          if (constNodes[_arg] !== void 0) {
            if (isConstantNode(_arg) && (isZero2(_arg.value) || equal2(_arg.value, 1))) {
              return createConstantNode2(0);
            }
            return new OperatorNode2("*", "multiply", [node, new OperatorNode2("*", "multiply", [new FunctionNode2("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
          }
          if (constNodes[_arg2] !== void 0) {
            if (isConstantNode(_arg2)) {
              if (isZero2(_arg2.value)) {
                return createConstantNode2(0);
              }
              if (equal2(_arg2.value, 1)) {
                return _derivative(_arg, constNodes);
              }
            }
            var powMinusOne = new OperatorNode2("^", "pow", [_arg.clone(), new OperatorNode2("-", "subtract", [_arg2, createConstantNode2(1)])]);
            return new OperatorNode2("*", "multiply", [_arg2.clone(), new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
          }
          return new OperatorNode2("*", "multiply", [new OperatorNode2("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode2("+", "add", [new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode2("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode2("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode2("log", [_arg.clone()])])])]);
        }
        throw new Error('Cannot process operator "' + node.op + '" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported');
      }
    });
    function createConstantNode2(value, valueType) {
      return new ConstantNode2(numeric3(value, valueType || config4.number));
    }
    return derivative2;
  });

  // node_modules/mathjs/lib/esm/function/algebra/rationalize.js
  var name285 = "rationalize";
  var dependencies285 = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
  var createRationalize = /* @__PURE__ */ factory(name285, dependencies285, (_ref) => {
    var {
      config: config4,
      typed: typed3,
      equal: equal2,
      isZero: isZero2,
      add: add3,
      subtract: subtract2,
      multiply: multiply2,
      divide: divide3,
      pow: pow3,
      parse: parse2,
      simplifyConstant: simplifyConstant2,
      simplifyCore: simplifyCore2,
      simplify: simplify2,
      fraction: fraction2,
      bignumber: bignumber2,
      mathWithTransform: mathWithTransform2,
      matrix: matrix2,
      AccessorNode: AccessorNode2,
      ArrayNode: ArrayNode2,
      ConstantNode: ConstantNode2,
      FunctionNode: FunctionNode2,
      IndexNode: IndexNode2,
      ObjectNode: ObjectNode2,
      OperatorNode: OperatorNode2,
      SymbolNode: SymbolNode2,
      ParenthesisNode: ParenthesisNode2
    } = _ref;
    function _rationalize(expr) {
      var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var detailed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var setRules = rulesRationalize();
      var polyRet = polynomial(expr, scope, true, setRules.firstRules);
      var nVars = polyRet.variables.length;
      var noExactFractions = {
        exactFractions: false
      };
      var withExactFractions = {
        exactFractions: true
      };
      expr = polyRet.expression;
      if (nVars >= 1) {
        expr = expandPower(expr);
        var sBefore;
        var rules;
        var eDistrDiv = true;
        var redoInic = false;
        expr = simplify2(expr, setRules.firstRules, {}, noExactFractions);
        var s;
        while (true) {
          rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
          expr = simplify2(expr, rules, {}, withExactFractions);
          eDistrDiv = !eDistrDiv;
          s = expr.toString();
          if (s === sBefore) {
            break;
          }
          redoInic = true;
          sBefore = s;
        }
        if (redoInic) {
          expr = simplify2(expr, setRules.firstRulesAgain, {}, noExactFractions);
        }
        expr = simplify2(expr, setRules.finalRules, {}, noExactFractions);
      }
      var coefficients = [];
      var retRationalize = {};
      if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
        if (nVars === 1) {
          expr.args[0] = polyToCanonical(expr.args[0], coefficients);
          expr.args[1] = polyToCanonical(expr.args[1]);
        }
        if (detailed) {
          retRationalize.numerator = expr.args[0];
          retRationalize.denominator = expr.args[1];
        }
      } else {
        if (nVars === 1) {
          expr = polyToCanonical(expr, coefficients);
        }
        if (detailed) {
          retRationalize.numerator = expr;
          retRationalize.denominator = null;
        }
      }
      if (!detailed)
        return expr;
      retRationalize.coefficients = coefficients;
      retRationalize.variables = polyRet.variables;
      retRationalize.expression = expr;
      return retRationalize;
    }
    return typed3(name285, {
      Node: _rationalize,
      "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
      "Node, Object": _rationalize,
      "Node, Object, boolean": _rationalize
    });
    function polynomial(expr, scope, extended, rules) {
      var variables = [];
      var node = simplify2(expr, rules, scope, {
        exactFractions: false
      });
      extended = !!extended;
      var oper = "+-*" + (extended ? "/" : "");
      recPoly(node);
      var retFunc = {};
      retFunc.expression = node;
      retFunc.variables = variables;
      return retFunc;
      function recPoly(node2) {
        var tp = node2.type;
        if (tp === "FunctionNode") {
          throw new Error("There is an unsolved function call");
        } else if (tp === "OperatorNode") {
          if (node2.op === "^") {
            if (node2.args[1].type !== "ConstantNode" || !isInteger(parseFloat(node2.args[1].value))) {
              throw new Error("There is a non-integer exponent");
            } else {
              recPoly(node2.args[0]);
            }
          } else {
            if (oper.indexOf(node2.op) === -1) {
              throw new Error("Operator " + node2.op + " invalid in polynomial expression");
            }
            for (var i3 = 0; i3 < node2.args.length; i3++) {
              recPoly(node2.args[i3]);
            }
          }
        } else if (tp === "SymbolNode") {
          var _name = node2.name;
          var pos = variables.indexOf(_name);
          if (pos === -1) {
            variables.push(_name);
          }
        } else if (tp === "ParenthesisNode") {
          recPoly(node2.content);
        } else if (tp !== "ConstantNode") {
          throw new Error("type " + tp + " is not allowed in polynomial expression");
        }
      }
    }
    function rulesRationalize() {
      var oldRules = [
        simplifyCore2,
        // sCore
        {
          l: "n+n",
          r: "2*n"
        },
        {
          l: "n+-n",
          r: "0"
        },
        simplifyConstant2,
        // sConstant
        {
          l: "n*(n1^-1)",
          r: "n/n1"
        },
        {
          l: "n*n1^-n2",
          r: "n/n1^n2"
        },
        {
          l: "n1^-1",
          r: "1/n1"
        },
        {
          l: "n*(n1/n2)",
          r: "(n*n1)/n2"
        },
        {
          l: "1*n",
          r: "n"
        }
      ];
      var rulesFirst = [
        {
          l: "(-n1)/(-n2)",
          r: "n1/n2"
        },
        // Unary division
        {
          l: "(-n1)*(-n2)",
          r: "n1*n2"
        },
        // Unary multiplication
        {
          l: "n1--n2",
          r: "n1+n2"
        },
        // '--' elimination
        {
          l: "n1-n2",
          r: "n1+(-n2)"
        },
        // Subtraction turn into add with unry minus
        {
          l: "(n1+n2)*n3",
          r: "(n1*n3 + n2*n3)"
        },
        // Distributive 1
        {
          l: "n1*(n2+n3)",
          r: "(n1*n2+n1*n3)"
        },
        // Distributive 2
        {
          l: "c1*n + c2*n",
          r: "(c1+c2)*n"
        },
        // Joining constants
        {
          l: "c1*n + n",
          r: "(c1+1)*n"
        },
        // Joining constants
        {
          l: "c1*n - c2*n",
          r: "(c1-c2)*n"
        },
        // Joining constants
        {
          l: "c1*n - n",
          r: "(c1-1)*n"
        },
        // Joining constants
        {
          l: "v/c",
          r: "(1/c)*v"
        },
        // variable/constant (new!)
        {
          l: "v/-c",
          r: "-(1/c)*v"
        },
        // variable/constant (new!)
        {
          l: "-v*-c",
          r: "c*v"
        },
        // Inversion constant and variable 1
        {
          l: "-v*c",
          r: "-c*v"
        },
        // Inversion constant and variable 2
        {
          l: "v*-c",
          r: "-c*v"
        },
        // Inversion constant and variable 3
        {
          l: "v*c",
          r: "c*v"
        },
        // Inversion constant and variable 4
        {
          l: "-(-n1*n2)",
          r: "(n1*n2)"
        },
        // Unary propagation
        {
          l: "-(n1*n2)",
          r: "(-n1*n2)"
        },
        // Unary propagation
        {
          l: "-(-n1+n2)",
          r: "(n1-n2)"
        },
        // Unary propagation
        {
          l: "-(n1+n2)",
          r: "(-n1-n2)"
        },
        // Unary propagation
        {
          l: "(n1^n2)^n3",
          r: "(n1^(n2*n3))"
        },
        // Power to Power
        {
          l: "-(-n1/n2)",
          r: "(n1/n2)"
        },
        // Division and Unary
        {
          l: "-(n1/n2)",
          r: "(-n1/n2)"
        }
      ];
      var rulesDistrDiv = [
        {
          l: "(n1/n2 + n3/n4)",
          r: "((n1*n4 + n3*n2)/(n2*n4))"
        },
        // Sum of fractions
        {
          l: "(n1/n2 + n3)",
          r: "((n1 + n3*n2)/n2)"
        },
        // Sum fraction with number 1
        {
          l: "(n1 + n2/n3)",
          r: "((n1*n3 + n2)/n3)"
        }
      ];
      var rulesSucDiv = [
        {
          l: "(n1/(n2/n3))",
          r: "((n1*n3)/n2)"
        },
        // Division simplification
        {
          l: "(n1/n2/n3)",
          r: "(n1/(n2*n3))"
        }
      ];
      var setRules = {};
      setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
      setRules.distrDivRules = rulesDistrDiv;
      setRules.sucDivRules = rulesSucDiv;
      setRules.firstRulesAgain = oldRules.concat(rulesFirst);
      setRules.finalRules = [
        simplifyCore2,
        // simplify.rules[0]
        {
          l: "n*-n",
          r: "-n^2"
        },
        // Joining multiply with power 1
        {
          l: "n*n",
          r: "n^2"
        },
        // Joining multiply with power 2
        simplifyConstant2,
        // simplify.rules[14] old 3rd index in oldRules
        {
          l: "n*-n^n1",
          r: "-n^(n1+1)"
        },
        // Joining multiply with power 3
        {
          l: "n*n^n1",
          r: "n^(n1+1)"
        },
        // Joining multiply with power 4
        {
          l: "n^n1*-n^n2",
          r: "-n^(n1+n2)"
        },
        // Joining multiply with power 5
        {
          l: "n^n1*n^n2",
          r: "n^(n1+n2)"
        },
        // Joining multiply with power 6
        {
          l: "n^n1*-n",
          r: "-n^(n1+1)"
        },
        // Joining multiply with power 7
        {
          l: "n^n1*n",
          r: "n^(n1+1)"
        },
        // Joining multiply with power 8
        {
          l: "n^n1/-n",
          r: "-n^(n1-1)"
        },
        // Joining multiply with power 8
        {
          l: "n^n1/n",
          r: "n^(n1-1)"
        },
        // Joining division with power 1
        {
          l: "n/-n^n1",
          r: "-n^(1-n1)"
        },
        // Joining division with power 2
        {
          l: "n/n^n1",
          r: "n^(1-n1)"
        },
        // Joining division with power 3
        {
          l: "n^n1/-n^n2",
          r: "n^(n1-n2)"
        },
        // Joining division with power 4
        {
          l: "n^n1/n^n2",
          r: "n^(n1-n2)"
        },
        // Joining division with power 5
        {
          l: "n1+(-n2*n3)",
          r: "n1-n2*n3"
        },
        // Solving useless parenthesis 1
        {
          l: "v*(-c)",
          r: "-c*v"
        },
        // Solving useless unary 2
        {
          l: "n1+-n2",
          r: "n1-n2"
        },
        // Solving +- together (new!)
        {
          l: "v*c",
          r: "c*v"
        },
        // inversion constant with variable
        {
          l: "(n1^n2)^n3",
          r: "(n1^(n2*n3))"
        }
        // Power to Power
      ];
      return setRules;
    }
    function expandPower(node, parent, indParent) {
      var tp = node.type;
      var internal = arguments.length > 1;
      if (tp === "OperatorNode" && node.isBinary()) {
        var does = false;
        var val;
        if (node.op === "^") {
          if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
            val = parseFloat(node.args[1].value);
            does = val >= 2 && isInteger(val);
          }
        }
        if (does) {
          if (val > 2) {
            var nEsqTopo = node.args[0];
            var nDirTopo = new OperatorNode2("^", "pow", [node.args[0].cloneDeep(), new ConstantNode2(val - 1)]);
            node = new OperatorNode2("*", "multiply", [nEsqTopo, nDirTopo]);
          } else {
            node = new OperatorNode2("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
          }
          if (internal) {
            if (indParent === "content") {
              parent.content = node;
            } else {
              parent.args[indParent] = node;
            }
          }
        }
      }
      if (tp === "ParenthesisNode") {
        expandPower(node.content, node, "content");
      } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
        for (var i3 = 0; i3 < node.args.length; i3++) {
          expandPower(node.args[i3], node, i3);
        }
      }
      if (!internal) {
        return node;
      }
    }
    function polyToCanonical(node, coefficients) {
      if (coefficients === void 0) {
        coefficients = [];
      }
      coefficients[0] = 0;
      var o2 = {};
      o2.cte = 1;
      o2.oper = "+";
      o2.fire = "";
      var maxExpo = 0;
      var varname = "";
      recurPol(node, null, o2);
      maxExpo = coefficients.length - 1;
      var first = true;
      var no;
      for (var i3 = maxExpo; i3 >= 0; i3--) {
        if (coefficients[i3] === 0)
          continue;
        var n16 = new ConstantNode2(first ? coefficients[i3] : Math.abs(coefficients[i3]));
        var op = coefficients[i3] < 0 ? "-" : "+";
        if (i3 > 0) {
          var n25 = new SymbolNode2(varname);
          if (i3 > 1) {
            var n3 = new ConstantNode2(i3);
            n25 = new OperatorNode2("^", "pow", [n25, n3]);
          }
          if (coefficients[i3] === -1 && first) {
            n16 = new OperatorNode2("-", "unaryMinus", [n25]);
          } else if (Math.abs(coefficients[i3]) === 1) {
            n16 = n25;
          } else {
            n16 = new OperatorNode2("*", "multiply", [n16, n25]);
          }
        }
        if (first) {
          no = n16;
        } else if (op === "+") {
          no = new OperatorNode2("+", "add", [no, n16]);
        } else {
          no = new OperatorNode2("-", "subtract", [no, n16]);
        }
        first = false;
      }
      if (first) {
        return new ConstantNode2(0);
      } else {
        return no;
      }
      function recurPol(node2, noPai, o3) {
        var tp = node2.type;
        if (tp === "FunctionNode") {
          throw new Error("There is an unsolved function call");
        } else if (tp === "OperatorNode") {
          if ("+-*^".indexOf(node2.op) === -1)
            throw new Error("Operator " + node2.op + " invalid");
          if (noPai !== null) {
            if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
              throw new Error("Invalid " + node2.op + " placing");
            }
            if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
              throw new Error("Invalid " + node2.op + " placing");
            }
            if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o3.noFil !== 0) {
              throw new Error("Invalid " + node2.op + " placing");
            }
          }
          if (node2.op === "^" || node2.op === "*") {
            o3.fire = node2.op;
          }
          for (var _i = 0; _i < node2.args.length; _i++) {
            if (node2.fn === "unaryMinus")
              o3.oper = "-";
            if (node2.op === "+" || node2.fn === "subtract") {
              o3.fire = "";
              o3.cte = 1;
              o3.oper = _i === 0 ? "+" : node2.op;
            }
            o3.noFil = _i;
            recurPol(node2.args[_i], node2, o3);
          }
        } else if (tp === "SymbolNode") {
          if (node2.name !== varname && varname !== "") {
            throw new Error("There is more than one variable");
          }
          varname = node2.name;
          if (noPai === null) {
            coefficients[1] = 1;
            return;
          }
          if (noPai.op === "^" && o3.noFil !== 0) {
            throw new Error("In power the variable should be the first parameter");
          }
          if (noPai.op === "*" && o3.noFil !== 1) {
            throw new Error("In multiply the variable should be the second parameter");
          }
          if (o3.fire === "" || o3.fire === "*") {
            if (maxExpo < 1)
              coefficients[1] = 0;
            coefficients[1] += o3.cte * (o3.oper === "+" ? 1 : -1);
            maxExpo = Math.max(1, maxExpo);
          }
        } else if (tp === "ConstantNode") {
          var valor = parseFloat(node2.value);
          if (noPai === null) {
            coefficients[0] = valor;
            return;
          }
          if (noPai.op === "^") {
            if (o3.noFil !== 1)
              throw new Error("Constant cannot be powered");
            if (!isInteger(valor) || valor <= 0) {
              throw new Error("Non-integer exponent is not allowed");
            }
            for (var _i2 = maxExpo + 1; _i2 < valor; _i2++)
              coefficients[_i2] = 0;
            if (valor > maxExpo)
              coefficients[valor] = 0;
            coefficients[valor] += o3.cte * (o3.oper === "+" ? 1 : -1);
            maxExpo = Math.max(valor, maxExpo);
            return;
          }
          o3.cte = valor;
          if (o3.fire === "") {
            coefficients[0] += o3.cte * (o3.oper === "+" ? 1 : -1);
          }
        } else {
          throw new Error("Type " + tp + " is not allowed");
        }
      }
    }
  });

  // node_modules/mathjs/lib/esm/function/signal/zpk2tf.js
  var name286 = "zpk2tf";
  var dependencies286 = ["typed", "add", "multiply", "Complex", "number"];
  var createZpk2tf = /* @__PURE__ */ factory(name286, dependencies286, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      multiply: multiply2,
      Complex: Complex3,
      number: number2
    } = _ref;
    return typed3(name286, {
      "Array,Array,number": function ArrayArrayNumber(z, p, k) {
        return _zpk2tf(z, p, k);
      },
      "Array,Array": function ArrayArray(z, p) {
        return _zpk2tf(z, p, 1);
      },
      "Matrix,Matrix,number": function MatrixMatrixNumber(z, p, k) {
        return _zpk2tf(z.valueOf(), p.valueOf(), k);
      },
      "Matrix,Matrix": function MatrixMatrix(z, p) {
        return _zpk2tf(z.valueOf(), p.valueOf(), 1);
      }
    });
    function _zpk2tf(z, p, k) {
      if (z.some((el) => el.type === "BigNumber")) {
        z = z.map((el) => number2(el));
      }
      if (p.some((el) => el.type === "BigNumber")) {
        p = p.map((el) => number2(el));
      }
      var num = [Complex3(1, 0)];
      var den = [Complex3(1, 0)];
      for (var i3 = 0; i3 < z.length; i3++) {
        var zero = z[i3];
        if (typeof zero === "number")
          zero = Complex3(zero, 0);
        num = _multiply(num, [Complex3(1, 0), Complex3(-zero.re, -zero.im)]);
      }
      for (var _i = 0; _i < p.length; _i++) {
        var pole = p[_i];
        if (typeof pole === "number")
          pole = Complex3(pole, 0);
        den = _multiply(den, [Complex3(1, 0), Complex3(-pole.re, -pole.im)]);
      }
      for (var _i2 = 0; _i2 < num.length; _i2++) {
        num[_i2] = multiply2(num[_i2], k);
      }
      return [num, den];
    }
    function _multiply(a, b) {
      var c = [];
      for (var i3 = 0; i3 < a.length + b.length - 1; i3++) {
        c[i3] = Complex3(0, 0);
        for (var j = 0; j < a.length; j++) {
          if (i3 - j >= 0 && i3 - j < b.length) {
            c[i3] = add3(c[i3], multiply2(a[j], b[i3 - j]));
          }
        }
      }
      return c;
    }
  });

  // node_modules/mathjs/lib/esm/function/signal/freqz.js
  var name287 = "freqz";
  var dependencies287 = ["typed", "add", "multiply", "Complex", "divide", "matrix"];
  var createFreqz = /* @__PURE__ */ factory(name287, dependencies287, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      multiply: multiply2,
      Complex: Complex3,
      divide: divide3,
      matrix: matrix2
    } = _ref;
    return typed3(name287, {
      "Array, Array": function ArrayArray(b, a) {
        var w2 = createBins(512);
        return _freqz(b, a, w2);
      },
      "Array, Array, Array": function ArrayArrayArray(b, a, w2) {
        return _freqz(b, a, w2);
      },
      "Array, Array, number": function ArrayArrayNumber(b, a, w2) {
        if (w2 < 0) {
          throw new Error("w must be a positive number");
        }
        var w22 = createBins(w2);
        return _freqz(b, a, w22);
      },
      "Matrix, Matrix": function MatrixMatrix(b, a) {
        var _w = createBins(512);
        var {
          w: w2,
          h
        } = _freqz(b.valueOf(), a.valueOf(), _w);
        return {
          w: matrix2(w2),
          h: matrix2(h)
        };
      },
      "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(b, a, w2) {
        var {
          h
        } = _freqz(b.valueOf(), a.valueOf(), w2.valueOf());
        return {
          h: matrix2(h),
          w: matrix2(w2)
        };
      },
      "Matrix, Matrix, number": function MatrixMatrixNumber(b, a, w2) {
        if (w2 < 0) {
          throw new Error("w must be a positive number");
        }
        var _w = createBins(w2);
        var {
          h
        } = _freqz(b.valueOf(), a.valueOf(), _w);
        return {
          h: matrix2(h),
          w: matrix2(_w)
        };
      }
    });
    function _freqz(b, a, w2) {
      var num = [];
      var den = [];
      for (var i3 = 0; i3 < w2.length; i3++) {
        var sumNum = Complex3(0, 0);
        var sumDen = Complex3(0, 0);
        for (var j = 0; j < b.length; j++) {
          sumNum = add3(sumNum, multiply2(b[j], Complex3(Math.cos(-j * w2[i3]), Math.sin(-j * w2[i3]))));
        }
        for (var _j = 0; _j < a.length; _j++) {
          sumDen = add3(sumDen, multiply2(a[_j], Complex3(Math.cos(-_j * w2[i3]), Math.sin(-_j * w2[i3]))));
        }
        num.push(sumNum);
        den.push(sumDen);
      }
      var h = [];
      for (var _i = 0; _i < num.length; _i++) {
        h.push(divide3(num[_i], den[_i]));
      }
      return {
        h,
        w: w2
      };
    }
    function createBins(n) {
      var bins = [];
      for (var i3 = 0; i3 < n; i3++) {
        bins.push(i3 / n * Math.PI);
      }
      return bins;
    }
  });

  // node_modules/mathjs/lib/esm/json/reviver.js
  var name288 = "reviver";
  var dependencies288 = ["classes"];
  var createReviver = /* @__PURE__ */ factory(name288, dependencies288, (_ref) => {
    var {
      classes: classes2
    } = _ref;
    return function reviver2(key, value) {
      var constructor = classes2[value && value.mathjs];
      if (constructor && typeof constructor.fromJSON === "function") {
        return constructor.fromJSON(value);
      }
      return value;
    };
  });

  // node_modules/mathjs/lib/esm/json/replacer.js
  var name289 = "replacer";
  var dependencies289 = [];
  var createReplacer = /* @__PURE__ */ factory(name289, dependencies289, () => {
    return function replacer2(key, value) {
      if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
        return {
          mathjs: "number",
          value: String(value)
        };
      }
      return value;
    };
  });

  // node_modules/mathjs/lib/esm/version.js
  var version = "12.1.0";

  // node_modules/mathjs/lib/esm/constants.js
  var createTrue = /* @__PURE__ */ factory("true", [], () => true);
  var createFalse = /* @__PURE__ */ factory("false", [], () => false);
  var createNull = /* @__PURE__ */ factory("null", [], () => null);
  var createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref;
    return config4.number === "BigNumber" ? new BigNumber2(Infinity) : Infinity;
  });
  var createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref2;
    return config4.number === "BigNumber" ? new BigNumber2(NaN) : NaN;
  });
  var createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref3;
    return config4.number === "BigNumber" ? createBigNumberPi(BigNumber2) : pi;
  });
  var createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref4;
    return config4.number === "BigNumber" ? createBigNumberTau(BigNumber2) : tau;
  });
  var createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref5;
    return config4.number === "BigNumber" ? createBigNumberE(BigNumber2) : e;
  });
  var createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref6;
    return config4.number === "BigNumber" ? createBigNumberPhi(BigNumber2) : phi;
  });
  var createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref7;
    return config4.number === "BigNumber" ? new BigNumber2(2).ln() : Math.LN2;
  });
  var createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref8;
    return config4.number === "BigNumber" ? new BigNumber2(10).ln() : Math.LN10;
  });
  var createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref9;
    return config4.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(2).ln()) : Math.LOG2E;
  });
  var createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref10;
    return config4.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(10).ln()) : Math.LOG10E;
  });
  var createSQRT1_2 = /* @__PURE__ */ recreateFactory(
    // eslint-disable-line camelcase
    "SQRT1_2",
    ["config", "?BigNumber"],
    (_ref11) => {
      var {
        config: config4,
        BigNumber: BigNumber2
      } = _ref11;
      return config4.number === "BigNumber" ? new BigNumber2("0.5").sqrt() : Math.SQRT1_2;
    }
  );
  var createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
    var {
      config: config4,
      BigNumber: BigNumber2
    } = _ref12;
    return config4.number === "BigNumber" ? new BigNumber2(2).sqrt() : Math.SQRT2;
  });
  var createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
    var {
      Complex: Complex3
    } = _ref13;
    return Complex3.I;
  });
  var createVersion = /* @__PURE__ */ factory("version", [], () => version);
  function recreateFactory(name310, dependencies310, create) {
    return factory(name310, dependencies310, create, {
      recreateOnConfigChange: true
    });
  }

  // node_modules/mathjs/lib/esm/type/unit/physicalConstants.js
  var createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
  var createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
  var createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
  var createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
  var createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
  var createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
  var createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
  var createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
  var createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
  var createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
  var createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
  var createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
  var createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
  var createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
  var createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
  var createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
  var createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
  var createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
  var createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
  var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
  var createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
  var createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
  var createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
  var createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
  var createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
  var createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
  var createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
  var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
  var createEfimovFactor = numberFactory("efimovFactor", 22.7);
  var createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
  var createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
  var createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
  var createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
  var createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
  var createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
  var createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
  var createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
  var createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
  var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
  var createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
  var createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
  var createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
  var createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
  var createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
  var createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
  var createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
  var createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
  var createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
  var createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
  var createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
  function unitFactory(name310, valueStr, unitStr) {
    var dependencies310 = ["config", "Unit", "BigNumber"];
    return factory(name310, dependencies310, (_ref) => {
      var {
        config: config4,
        Unit: Unit2,
        BigNumber: BigNumber2
      } = _ref;
      var value = config4.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
      var unit2 = new Unit2(value, unitStr);
      unit2.fixPrefix = true;
      return unit2;
    });
  }
  function numberFactory(name310, value) {
    var dependencies310 = ["config", "BigNumber"];
    return factory(name310, dependencies310, (_ref2) => {
      var {
        config: config4,
        BigNumber: BigNumber2
      } = _ref2;
      return config4.number === "BigNumber" ? new BigNumber2(value) : value;
    });
  }

  // node_modules/mathjs/lib/esm/expression/transform/apply.transform.js
  var name290 = "apply";
  var dependencies290 = ["typed", "isInteger"];
  var createApplyTransform = /* @__PURE__ */ factory(name290, dependencies290, (_ref) => {
    var {
      typed: typed3,
      isInteger: isInteger3
    } = _ref;
    var apply2 = createApply({
      typed: typed3,
      isInteger: isInteger3
    });
    return typed3("apply", {
      "...any": function any(args) {
        var dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
        try {
          return apply2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/column.transform.js
  var name291 = "column";
  var dependencies291 = ["typed", "Index", "matrix", "range"];
  var createColumnTransform = /* @__PURE__ */ factory(name291, dependencies291, (_ref) => {
    var {
      typed: typed3,
      Index: Index2,
      matrix: matrix2,
      range: range2
    } = _ref;
    var column2 = createColumn({
      typed: typed3,
      Index: Index2,
      matrix: matrix2,
      range: range2
    });
    return typed3("column", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }
        try {
          return column2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/utils/compileInlineExpression.js
  function compileInlineExpression(expression, math2, scope) {
    var symbol = expression.filter(function(node) {
      return isSymbolNode(node) && !(node.name in math2) && !scope.has(node.name);
    })[0];
    if (!symbol) {
      throw new Error('No undefined variable found in inline expression "' + expression + '"');
    }
    var name310 = symbol.name;
    var subScope = createSubScope(scope);
    var eq = expression.compile();
    return function inlineExpression(x) {
      subScope.set(name310, x);
      return eq.evaluate(subScope);
    };
  }

  // node_modules/mathjs/lib/esm/expression/transform/filter.transform.js
  var name292 = "filter";
  var dependencies292 = ["typed"];
  var createFilterTransform = /* @__PURE__ */ factory(name292, dependencies292, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    function filterTransform(args, math2, scope) {
      var x, callback;
      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }
      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          callback = args[1].compile().evaluate(scope);
        } else {
          callback = compileInlineExpression(args[1], math2, scope);
        }
      }
      return filter3(x, callback);
    }
    filterTransform.rawArgs = true;
    var filter3 = typed3("filter", {
      "Array, function": _filter,
      "Matrix, function": function MatrixFunction(x, test) {
        return x.create(_filter(x.toArray(), test));
      },
      "Array, RegExp": filterRegExp,
      "Matrix, RegExp": function MatrixRegExp(x, test) {
        return x.create(filterRegExp(x.toArray(), test));
      }
    });
    return filterTransform;
  }, {
    isTransformFunction: true
  });
  function _filter(x, callback) {
    return filter(x, function(value, index2, array) {
      return applyCallback(callback, value, [index2 + 1], array, "filter");
    });
  }

  // node_modules/mathjs/lib/esm/expression/transform/forEach.transform.js
  var name293 = "forEach";
  var dependencies293 = ["typed"];
  var createForEachTransform = /* @__PURE__ */ factory(name293, dependencies293, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    function forEachTransform(args, math2, scope) {
      var x, callback;
      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }
      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          callback = args[1].compile().evaluate(scope);
        } else {
          callback = compileInlineExpression(args[1], math2, scope);
        }
      }
      return _forEach2(x, callback);
    }
    forEachTransform.rawArgs = true;
    var _forEach2 = typed3("forEach", {
      "Array | Matrix, function": function ArrayMatrixFunction(array, callback) {
        var recurse = function recurse2(value, index2) {
          if (Array.isArray(value)) {
            forEach(value, function(child, i3) {
              recurse2(child, index2.concat(i3 + 1));
            });
          } else {
            return applyCallback(callback, value, index2, array, "forEach");
          }
        };
        recurse(array.valueOf(), []);
      }
    });
    return forEachTransform;
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/index.transform.js
  var name294 = "index";
  var dependencies294 = ["Index", "getMatrixDataType"];
  var createIndexTransform = /* @__PURE__ */ factory(name294, dependencies294, (_ref) => {
    var {
      Index: Index2,
      getMatrixDataType: getMatrixDataType2
    } = _ref;
    return function indexTransform() {
      var args = [];
      for (var i3 = 0, ii = arguments.length; i3 < ii; i3++) {
        var arg2 = arguments[i3];
        if (isRange(arg2)) {
          arg2.start--;
          arg2.end -= arg2.step > 0 ? 0 : 2;
        } else if (arg2 && arg2.isSet === true) {
          arg2 = arg2.map(function(v) {
            return v - 1;
          });
        } else if (isArray(arg2) || isMatrix(arg2)) {
          if (getMatrixDataType2(arg2) !== "boolean") {
            arg2 = arg2.map(function(v) {
              return v - 1;
            });
          }
        } else if (isNumber(arg2)) {
          arg2--;
        } else if (isBigNumber(arg2)) {
          arg2 = arg2.toNumber() - 1;
        } else if (typeof arg2 === "string") {
        } else {
          throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
        }
        args[i3] = arg2;
      }
      var res = new Index2();
      Index2.apply(res, args);
      return res;
    };
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/map.transform.js
  var name295 = "map";
  var dependencies295 = ["typed"];
  var createMapTransform = /* @__PURE__ */ factory(name295, dependencies295, (_ref) => {
    var {
      typed: typed3
    } = _ref;
    function mapTransform(args, math2, scope) {
      var x, callback;
      if (args[0]) {
        x = args[0].compile().evaluate(scope);
      }
      if (args[1]) {
        if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
          callback = args[1].compile().evaluate(scope);
        } else {
          callback = compileInlineExpression(args[1], math2, scope);
        }
      }
      return map3(x, callback);
    }
    mapTransform.rawArgs = true;
    var map3 = typed3("map", {
      "Array, function": function ArrayFunction(x, callback) {
        return _map2(x, callback, x);
      },
      "Matrix, function": function MatrixFunction(x, callback) {
        return x.create(_map2(x.valueOf(), callback, x));
      }
    });
    return mapTransform;
  }, {
    isTransformFunction: true
  });
  function _map2(array, callback, orig) {
    function recurse(value, index2) {
      if (Array.isArray(value)) {
        return map(value, function(child, i3) {
          return recurse(child, index2.concat(i3 + 1));
        });
      } else {
        return applyCallback(callback, value, index2, orig, "map");
      }
    }
    return recurse(array, []);
  }

  // node_modules/mathjs/lib/esm/expression/transform/utils/lastDimToZeroBase.js
  function lastDimToZeroBase(args) {
    if (args.length === 2 && isCollection(args[0])) {
      args = args.slice();
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
    }
    return args;
  }

  // node_modules/mathjs/lib/esm/expression/transform/max.transform.js
  var name296 = "max";
  var dependencies296 = ["typed", "config", "numeric", "larger"];
  var createMaxTransform = /* @__PURE__ */ factory(name296, dependencies296, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      numeric: numeric3,
      larger: larger2
    } = _ref;
    var max3 = createMax({
      typed: typed3,
      config: config4,
      numeric: numeric3,
      larger: larger2
    });
    return typed3("max", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return max3.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/mean.transform.js
  var name297 = "mean";
  var dependencies297 = ["typed", "add", "divide"];
  var createMeanTransform = /* @__PURE__ */ factory(name297, dependencies297, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      divide: divide3
    } = _ref;
    var mean2 = createMean({
      typed: typed3,
      add: add3,
      divide: divide3
    });
    return typed3("mean", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return mean2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/min.transform.js
  var name298 = "min";
  var dependencies298 = ["typed", "config", "numeric", "smaller"];
  var createMinTransform = /* @__PURE__ */ factory(name298, dependencies298, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      numeric: numeric3,
      smaller: smaller2
    } = _ref;
    var min3 = createMin({
      typed: typed3,
      config: config4,
      numeric: numeric3,
      smaller: smaller2
    });
    return typed3("min", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return min3.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/range.transform.js
  var name299 = "range";
  var dependencies299 = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
  var createRangeTransform = /* @__PURE__ */ factory(name299, dependencies299, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      matrix: matrix2,
      bignumber: bignumber2,
      smaller: smaller2,
      smallerEq: smallerEq2,
      larger: larger2,
      largerEq: largerEq2,
      add: add3,
      isPositive: isPositive2
    } = _ref;
    var range2 = createRange({
      typed: typed3,
      config: config4,
      matrix: matrix2,
      bignumber: bignumber2,
      smaller: smaller2,
      smallerEq: smallerEq2,
      larger: larger2,
      largerEq: largerEq2,
      add: add3,
      isPositive: isPositive2
    });
    return typed3("range", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (typeof last !== "boolean") {
          args.push(true);
        }
        return range2.apply(null, args);
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/row.transform.js
  var name300 = "row";
  var dependencies300 = ["typed", "Index", "matrix", "range"];
  var createRowTransform = /* @__PURE__ */ factory(name300, dependencies300, (_ref) => {
    var {
      typed: typed3,
      Index: Index2,
      matrix: matrix2,
      range: range2
    } = _ref;
    var row2 = createRow({
      typed: typed3,
      Index: Index2,
      matrix: matrix2,
      range: range2
    });
    return typed3("row", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        }
        try {
          return row2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/subset.transform.js
  var name301 = "subset";
  var dependencies301 = ["typed", "matrix", "zeros", "add"];
  var createSubsetTransform = /* @__PURE__ */ factory(name301, dependencies301, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      zeros: zeros3,
      add: add3
    } = _ref;
    var subset2 = createSubset({
      typed: typed3,
      matrix: matrix2,
      zeros: zeros3,
      add: add3
    });
    return typed3("subset", {
      "...any": function any(args) {
        try {
          return subset2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/concat.transform.js
  var name302 = "concat";
  var dependencies302 = ["typed", "matrix", "isInteger"];
  var createConcatTransform = /* @__PURE__ */ factory(name302, dependencies302, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      isInteger: isInteger3
    } = _ref;
    var concat3 = createConcat({
      typed: typed3,
      matrix: matrix2,
      isInteger: isInteger3
    });
    return typed3("concat", {
      "...any": function any(args) {
        var lastIndex = args.length - 1;
        var last = args[lastIndex];
        if (isNumber(last)) {
          args[lastIndex] = last - 1;
        } else if (isBigNumber(last)) {
          args[lastIndex] = last.minus(1);
        }
        try {
          return concat3.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/diff.transform.js
  var name303 = "diff";
  var dependencies303 = ["typed", "matrix", "subtract", "number", "bignumber"];
  var createDiffTransform = /* @__PURE__ */ factory(name303, dependencies303, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      subtract: subtract2,
      number: number2,
      bignumber: bignumber2
    } = _ref;
    var diff2 = createDiff({
      typed: typed3,
      matrix: matrix2,
      subtract: subtract2,
      number: number2,
      bignumber: bignumber2
    });
    return typed3(name303, {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return diff2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/std.transform.js
  var name304 = "std";
  var dependencies304 = ["typed", "map", "sqrt", "variance"];
  var createStdTransform = /* @__PURE__ */ factory(name304, dependencies304, (_ref) => {
    var {
      typed: typed3,
      map: map3,
      sqrt: sqrt3,
      variance: variance2
    } = _ref;
    var std2 = createStd({
      typed: typed3,
      map: map3,
      sqrt: sqrt3,
      variance: variance2
    });
    return typed3("std", {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return std2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/sum.transform.js
  var name305 = "sum";
  var dependencies305 = ["typed", "config", "add", "numeric"];
  var createSumTransform = /* @__PURE__ */ factory(name305, dependencies305, (_ref) => {
    var {
      typed: typed3,
      config: config4,
      add: add3,
      numeric: numeric3
    } = _ref;
    var sum3 = createSum({
      typed: typed3,
      config: config4,
      add: add3,
      numeric: numeric3
    });
    return typed3(name305, {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return sum3.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/quantileSeq.transform.js
  var name306 = "quantileSeq";
  var dependencies306 = ["typed", "bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
  var createQuantileSeqTransform = /* @__PURE__ */ factory(name306, dependencies306, (_ref) => {
    var {
      typed: typed3,
      bignumber: bignumber2,
      add: add3,
      subtract: subtract2,
      divide: divide3,
      multiply: multiply2,
      partitionSelect: partitionSelect2,
      compare: compare2,
      isInteger: isInteger3,
      smaller: smaller2,
      smallerEq: smallerEq2,
      larger: larger2
    } = _ref;
    var quantileSeq2 = createQuantileSeq({
      typed: typed3,
      bignumber: bignumber2,
      add: add3,
      subtract: subtract2,
      divide: divide3,
      multiply: multiply2,
      partitionSelect: partitionSelect2,
      compare: compare2,
      isInteger: isInteger3,
      smaller: smaller2,
      smallerEq: smallerEq2,
      larger: larger2
    });
    return typed3("quantileSeq", {
      "Array | Matrix, number | BigNumber": quantileSeq2,
      "Array | Matrix, number | BigNumber, number": (arr, prob, dim) => quantileSeq2(arr, prob, dimToZeroBase(dim)),
      "Array | Matrix, number | BigNumber, boolean": quantileSeq2,
      "Array | Matrix, number | BigNumber, boolean, number": (arr, prob, sorted, dim) => quantileSeq2(arr, prob, sorted, dimToZeroBase(dim)),
      "Array | Matrix, Array | Matrix": quantileSeq2,
      "Array | Matrix, Array | Matrix, number": (data, prob, dim) => quantileSeq2(data, prob, dimToZeroBase(dim)),
      "Array | Matrix, Array | Matrix, boolean": quantileSeq2,
      "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => quantileSeq2(data, prob, sorted, dimToZeroBase(dim))
    });
    function dimToZeroBase(dim) {
      return lastDimToZeroBase([[], dim])[1];
    }
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/cumsum.transform.js
  var name307 = "cumsum";
  var dependencies307 = ["typed", "add", "unaryPlus"];
  var createCumSumTransform = /* @__PURE__ */ factory(name307, dependencies307, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      unaryPlus: unaryPlus2
    } = _ref;
    var cumsum2 = createCumSum({
      typed: typed3,
      add: add3,
      unaryPlus: unaryPlus2
    });
    return typed3(name307, {
      "...any": function any(args) {
        if (args.length === 2 && isCollection(args[0])) {
          var dim = args[1];
          if (isNumber(dim)) {
            args[1] = dim - 1;
          } else if (isBigNumber(dim)) {
            args[1] = dim.minus(1);
          }
        }
        try {
          return cumsum2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/variance.transform.js
  var name308 = "variance";
  var dependencies308 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
  var createVarianceTransform = /* @__PURE__ */ factory(name308, dependencies308, (_ref) => {
    var {
      typed: typed3,
      add: add3,
      subtract: subtract2,
      multiply: multiply2,
      divide: divide3,
      apply: apply2,
      isNaN: isNaN3
    } = _ref;
    var variance2 = createVariance({
      typed: typed3,
      add: add3,
      subtract: subtract2,
      multiply: multiply2,
      divide: divide3,
      apply: apply2,
      isNaN: isNaN3
    });
    return typed3(name308, {
      "...any": function any(args) {
        args = lastDimToZeroBase(args);
        try {
          return variance2.apply(null, args);
        } catch (err) {
          throw errorTransform(err);
        }
      }
    });
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/expression/transform/print.transform.js
  var name309 = "print";
  var dependencies309 = ["typed", "matrix", "zeros", "add"];
  var createPrintTransform = /* @__PURE__ */ factory(name309, dependencies309, (_ref) => {
    var {
      typed: typed3,
      matrix: matrix2,
      zeros: zeros3,
      add: add3
    } = _ref;
    var print2 = createPrint({
      typed: typed3,
      matrix: matrix2,
      zeros: zeros3,
      add: add3
    });
    return typed3(name309, {
      "string, Object | Array": function stringObjectArray(template, values) {
        return print2(_convertTemplateToZeroBasedIndex(template), values);
      },
      "string, Object | Array, number | Object": function stringObjectArrayNumberObject(template, values, options) {
        return print2(_convertTemplateToZeroBasedIndex(template), values, options);
      }
    });
    function _convertTemplateToZeroBasedIndex(template) {
      return template.replace(printTemplate, (x) => {
        var parts = x.slice(1).split(".");
        var result = parts.map(function(part) {
          if (!isNaN(part) && part.length > 0) {
            return parseInt(part) - 1;
          } else {
            return part;
          }
        });
        return "$" + result.join(".");
      });
    }
  }, {
    isTransformFunction: true
  });

  // node_modules/mathjs/lib/esm/entry/pureFunctionsAny.generated.js
  var BigNumber = /* @__PURE__ */ createBigNumberClass({
    config
  });
  var Complex2 = /* @__PURE__ */ createComplexClass({});
  var e2 = /* @__PURE__ */ createE({
    BigNumber,
    config
  });
  var _false = /* @__PURE__ */ createFalse({});
  var fineStructure = /* @__PURE__ */ createFineStructure({
    BigNumber,
    config
  });
  var Fraction2 = /* @__PURE__ */ createFractionClass({});
  var i2 = /* @__PURE__ */ createI({
    Complex: Complex2
  });
  var _Infinity = /* @__PURE__ */ createInfinity({
    BigNumber,
    config
  });
  var LN102 = /* @__PURE__ */ createLN10({
    BigNumber,
    config
  });
  var LOG10E = /* @__PURE__ */ createLOG10E({
    BigNumber,
    config
  });
  var Matrix = /* @__PURE__ */ createMatrixClass({});
  var _NaN = /* @__PURE__ */ createNaN({
    BigNumber,
    config
  });
  var _null = /* @__PURE__ */ createNull({});
  var phi2 = /* @__PURE__ */ createPhi({
    BigNumber,
    config
  });
  var Range = /* @__PURE__ */ createRangeClass({});
  var ResultSet = /* @__PURE__ */ createResultSet({});
  var SQRT1_2 = /* @__PURE__ */ createSQRT1_2({
    BigNumber,
    config
  });
  var sackurTetrode = /* @__PURE__ */ createSackurTetrode({
    BigNumber,
    config
  });
  var tau2 = /* @__PURE__ */ createTau({
    BigNumber,
    config
  });
  var _true = /* @__PURE__ */ createTrue({});
  var version2 = /* @__PURE__ */ createVersion({});
  var DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
    Matrix
  });
  var efimovFactor = /* @__PURE__ */ createEfimovFactor({
    BigNumber,
    config
  });
  var LN2 = /* @__PURE__ */ createLN2({
    BigNumber,
    config
  });
  var pi2 = /* @__PURE__ */ createPi({
    BigNumber,
    config
  });
  var replacer = /* @__PURE__ */ createReplacer({});
  var SQRT2 = /* @__PURE__ */ createSQRT2({
    BigNumber,
    config
  });
  var typed2 = /* @__PURE__ */ createTyped({
    BigNumber,
    Complex: Complex2,
    DenseMatrix,
    Fraction: Fraction2
  });
  var unaryPlus = /* @__PURE__ */ createUnaryPlus({
    BigNumber,
    config,
    typed: typed2
  });
  var weakMixingAngle = /* @__PURE__ */ createWeakMixingAngle({
    BigNumber,
    config
  });
  var abs2 = /* @__PURE__ */ createAbs({
    typed: typed2
  });
  var acos2 = /* @__PURE__ */ createAcos({
    Complex: Complex2,
    config,
    typed: typed2
  });
  var acot = /* @__PURE__ */ createAcot({
    BigNumber,
    typed: typed2
  });
  var acsc = /* @__PURE__ */ createAcsc({
    BigNumber,
    Complex: Complex2,
    config,
    typed: typed2
  });
  var addScalar = /* @__PURE__ */ createAddScalar({
    typed: typed2
  });
  var arg = /* @__PURE__ */ createArg({
    typed: typed2
  });
  var asech = /* @__PURE__ */ createAsech({
    BigNumber,
    Complex: Complex2,
    config,
    typed: typed2
  });
  var asinh3 = /* @__PURE__ */ createAsinh({
    typed: typed2
  });
  var atan3 = /* @__PURE__ */ createAtan({
    typed: typed2
  });
  var atanh3 = /* @__PURE__ */ createAtanh({
    Complex: Complex2,
    config,
    typed: typed2
  });
  var bignumber = /* @__PURE__ */ createBignumber({
    BigNumber,
    typed: typed2
  });
  var bitNot = /* @__PURE__ */ createBitNot({
    typed: typed2
  });
  var boolean = /* @__PURE__ */ createBoolean({
    typed: typed2
  });
  var clone4 = /* @__PURE__ */ createClone({
    typed: typed2
  });
  var combinations = /* @__PURE__ */ createCombinations({
    typed: typed2
  });
  var complex = /* @__PURE__ */ createComplex({
    Complex: Complex2,
    typed: typed2
  });
  var conj = /* @__PURE__ */ createConj({
    typed: typed2
  });
  var cos2 = /* @__PURE__ */ createCos({
    typed: typed2
  });
  var cot = /* @__PURE__ */ createCot({
    BigNumber,
    typed: typed2
  });
  var csc = /* @__PURE__ */ createCsc({
    BigNumber,
    typed: typed2
  });
  var cube = /* @__PURE__ */ createCube({
    typed: typed2
  });
  var equalScalar = /* @__PURE__ */ createEqualScalar({
    config,
    typed: typed2
  });
  var erf = /* @__PURE__ */ createErf({
    typed: typed2
  });
  var exp2 = /* @__PURE__ */ createExp({
    typed: typed2
  });
  var expm13 = /* @__PURE__ */ createExpm1({
    Complex: Complex2,
    typed: typed2
  });
  var filter2 = /* @__PURE__ */ createFilter({
    typed: typed2
  });
  var forEach2 = /* @__PURE__ */ createForEach({
    typed: typed2
  });
  var format4 = /* @__PURE__ */ createFormat({
    typed: typed2
  });
  var getMatrixDataType = /* @__PURE__ */ createGetMatrixDataType({
    typed: typed2
  });
  var hex = /* @__PURE__ */ createHex({
    format: format4,
    typed: typed2
  });
  var im = /* @__PURE__ */ createIm({
    typed: typed2
  });
  var isInteger2 = /* @__PURE__ */ createIsInteger({
    typed: typed2
  });
  var isNegative = /* @__PURE__ */ createIsNegative({
    typed: typed2
  });
  var isPositive = /* @__PURE__ */ createIsPositive({
    typed: typed2
  });
  var isZero = /* @__PURE__ */ createIsZero({
    typed: typed2
  });
  var LOG2E = /* @__PURE__ */ createLOG2E({
    BigNumber,
    config
  });
  var lgamma = /* @__PURE__ */ createLgamma({
    Complex: Complex2,
    typed: typed2
  });
  var log104 = /* @__PURE__ */ createLog10({
    Complex: Complex2,
    config,
    typed: typed2
  });
  var log24 = /* @__PURE__ */ createLog2({
    Complex: Complex2,
    config,
    typed: typed2
  });
  var map2 = /* @__PURE__ */ createMap2({
    typed: typed2
  });
  var multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
    typed: typed2
  });
  var not = /* @__PURE__ */ createNot({
    typed: typed2
  });
  var number = /* @__PURE__ */ createNumber({
    typed: typed2
  });
  var oct = /* @__PURE__ */ createOct({
    format: format4,
    typed: typed2
  });
  var pickRandom = /* @__PURE__ */ createPickRandom({
    config,
    typed: typed2
  });
  var print = /* @__PURE__ */ createPrint({
    typed: typed2
  });
  var random2 = /* @__PURE__ */ createRandom({
    config,
    typed: typed2
  });
  var re = /* @__PURE__ */ createRe({
    typed: typed2
  });
  var sec = /* @__PURE__ */ createSec({
    BigNumber,
    typed: typed2
  });
  var sign3 = /* @__PURE__ */ createSign({
    BigNumber,
    Fraction: Fraction2,
    complex,
    typed: typed2
  });
  var sin2 = /* @__PURE__ */ createSin({
    typed: typed2
  });
  var SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
    Matrix,
    equalScalar,
    typed: typed2
  });
  var splitUnit = /* @__PURE__ */ createSplitUnit({
    typed: typed2
  });
  var square = /* @__PURE__ */ createSquare({
    typed: typed2
  });
  var string = /* @__PURE__ */ createString({
    typed: typed2
  });
  var subtractScalar = /* @__PURE__ */ createSubtractScalar({
    typed: typed2
  });
  var tan2 = /* @__PURE__ */ createTan({
    typed: typed2
  });
  var typeOf2 = /* @__PURE__ */ createTypeOf({
    typed: typed2
  });
  var acosh3 = /* @__PURE__ */ createAcosh({
    Complex: Complex2,
    config,
    typed: typed2
  });
  var acsch = /* @__PURE__ */ createAcsch({
    BigNumber,
    typed: typed2
  });
  var apply = /* @__PURE__ */ createApply({
    isInteger: isInteger2,
    typed: typed2
  });
  var asec = /* @__PURE__ */ createAsec({
    BigNumber,
    Complex: Complex2,
    config,
    typed: typed2
  });
  var bin = /* @__PURE__ */ createBin({
    format: format4,
    typed: typed2
  });
  var combinationsWithRep = /* @__PURE__ */ createCombinationsWithRep({
    typed: typed2
  });
  var cosh3 = /* @__PURE__ */ createCosh({
    typed: typed2
  });
  var csch = /* @__PURE__ */ createCsch({
    BigNumber,
    typed: typed2
  });
  var isNaN2 = /* @__PURE__ */ createIsNaN({
    typed: typed2
  });
  var isPrime = /* @__PURE__ */ createIsPrime({
    typed: typed2
  });
  var randomInt = /* @__PURE__ */ createRandomInt({
    config,
    typed: typed2
  });
  var sech = /* @__PURE__ */ createSech({
    BigNumber,
    typed: typed2
  });
  var sinh3 = /* @__PURE__ */ createSinh({
    typed: typed2
  });
  var sparse = /* @__PURE__ */ createSparse({
    SparseMatrix,
    typed: typed2
  });
  var sqrt2 = /* @__PURE__ */ createSqrt({
    Complex: Complex2,
    config,
    typed: typed2
  });
  var tanh3 = /* @__PURE__ */ createTanh({
    typed: typed2
  });
  var unaryMinus = /* @__PURE__ */ createUnaryMinus({
    typed: typed2
  });
  var acoth = /* @__PURE__ */ createAcoth({
    BigNumber,
    Complex: Complex2,
    config,
    typed: typed2
  });
  var coth = /* @__PURE__ */ createCoth({
    BigNumber,
    typed: typed2
  });
  var fraction = /* @__PURE__ */ createFraction({
    Fraction: Fraction2,
    typed: typed2
  });
  var isNumeric = /* @__PURE__ */ createIsNumeric({
    typed: typed2
  });
  var matrix = /* @__PURE__ */ createMatrix({
    DenseMatrix,
    Matrix,
    SparseMatrix,
    typed: typed2
  });
  var matrixFromFunction = /* @__PURE__ */ createMatrixFromFunction({
    isZero,
    matrix,
    typed: typed2
  });
  var mode = /* @__PURE__ */ createMode({
    isNaN: isNaN2,
    isNumeric,
    typed: typed2
  });
  var numeric2 = /* @__PURE__ */ createNumeric({
    bignumber,
    fraction,
    number
  });
  var prod = /* @__PURE__ */ createProd({
    config,
    multiplyScalar,
    numeric: numeric2,
    typed: typed2
  });
  var reshape2 = /* @__PURE__ */ createReshape({
    isInteger: isInteger2,
    matrix,
    typed: typed2
  });
  var size = /* @__PURE__ */ createSize({
    matrix,
    config,
    typed: typed2
  });
  var squeeze2 = /* @__PURE__ */ createSqueeze({
    matrix,
    typed: typed2
  });
  var transpose = /* @__PURE__ */ createTranspose({
    matrix,
    typed: typed2
  });
  var xgcd = /* @__PURE__ */ createXgcd({
    BigNumber,
    config,
    matrix,
    typed: typed2
  });
  var zeros2 = /* @__PURE__ */ createZeros({
    BigNumber,
    config,
    matrix,
    typed: typed2
  });
  var asin2 = /* @__PURE__ */ createAsin({
    Complex: Complex2,
    config,
    typed: typed2
  });
  var cbrt4 = /* @__PURE__ */ createCbrt({
    BigNumber,
    Complex: Complex2,
    Fraction: Fraction2,
    config,
    isNegative,
    matrix,
    typed: typed2,
    unaryMinus
  });
  var concat2 = /* @__PURE__ */ createConcat({
    isInteger: isInteger2,
    matrix,
    typed: typed2
  });
  var count = /* @__PURE__ */ createCount({
    prod,
    size,
    typed: typed2
  });
  var ctranspose = /* @__PURE__ */ createCtranspose({
    conj,
    transpose,
    typed: typed2
  });
  var diag = /* @__PURE__ */ createDiag({
    DenseMatrix,
    SparseMatrix,
    matrix,
    typed: typed2
  });
  var divideScalar = /* @__PURE__ */ createDivideScalar({
    numeric: numeric2,
    typed: typed2
  });
  var dotDivide = /* @__PURE__ */ createDotDivide({
    DenseMatrix,
    concat: concat2,
    divideScalar,
    equalScalar,
    matrix,
    typed: typed2
  });
  var equal = /* @__PURE__ */ createEqual({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  });
  var flatten2 = /* @__PURE__ */ createFlatten({
    matrix,
    typed: typed2
  });
  var hasNumericValue = /* @__PURE__ */ createHasNumericValue({
    isNumeric,
    typed: typed2
  });
  var identity = /* @__PURE__ */ createIdentity({
    BigNumber,
    DenseMatrix,
    SparseMatrix,
    config,
    matrix,
    typed: typed2
  });
  var kron = /* @__PURE__ */ createKron({
    matrix,
    multiplyScalar,
    typed: typed2
  });
  var largerEq = /* @__PURE__ */ createLargerEq({
    DenseMatrix,
    concat: concat2,
    config,
    matrix,
    typed: typed2
  });
  var leftShift = /* @__PURE__ */ createLeftShift({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2,
    zeros: zeros2
  });
  var lsolve = /* @__PURE__ */ createLsolve({
    DenseMatrix,
    divideScalar,
    equalScalar,
    matrix,
    multiplyScalar,
    subtractScalar,
    typed: typed2
  });
  var matrixFromColumns = /* @__PURE__ */ createMatrixFromColumns({
    flatten: flatten2,
    matrix,
    size,
    typed: typed2
  });
  var nthRoot = /* @__PURE__ */ createNthRoot({
    BigNumber,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  });
  var ones = /* @__PURE__ */ createOnes({
    BigNumber,
    config,
    matrix,
    typed: typed2
  });
  var qr = /* @__PURE__ */ createQr({
    addScalar,
    complex,
    conj,
    divideScalar,
    equal,
    identity,
    isZero,
    matrix,
    multiplyScalar,
    sign: sign3,
    sqrt: sqrt2,
    subtractScalar,
    typed: typed2,
    unaryMinus,
    zeros: zeros2
  });
  var resize2 = /* @__PURE__ */ createResize({
    config,
    matrix
  });
  var rightArithShift = /* @__PURE__ */ createRightArithShift({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2,
    zeros: zeros2
  });
  var round2 = /* @__PURE__ */ createRound({
    BigNumber,
    DenseMatrix,
    equalScalar,
    matrix,
    typed: typed2,
    zeros: zeros2
  });
  var smaller = /* @__PURE__ */ createSmaller({
    DenseMatrix,
    concat: concat2,
    config,
    matrix,
    typed: typed2
  });
  var subtract = /* @__PURE__ */ createSubtract({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    subtractScalar,
    typed: typed2,
    unaryMinus
  });
  var to = /* @__PURE__ */ createTo({
    concat: concat2,
    matrix,
    typed: typed2
  });
  var unequal = /* @__PURE__ */ createUnequal({
    DenseMatrix,
    concat: concat2,
    config,
    equalScalar,
    matrix,
    typed: typed2
  });
  var usolve = /* @__PURE__ */ createUsolve({
    DenseMatrix,
    divideScalar,
    equalScalar,
    matrix,
    multiplyScalar,
    subtractScalar,
    typed: typed2
  });
  var xor = /* @__PURE__ */ createXor({
    DenseMatrix,
    concat: concat2,
    matrix,
    typed: typed2
  });
  var add2 = /* @__PURE__ */ createAdd({
    DenseMatrix,
    SparseMatrix,
    addScalar,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  });
  var atan22 = /* @__PURE__ */ createAtan2({
    BigNumber,
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  });
  var bitAnd = /* @__PURE__ */ createBitAnd({
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  });
  var bitXor2 = /* @__PURE__ */ createBitXor({
    DenseMatrix,
    concat: concat2,
    matrix,
    typed: typed2
  });
  var catalan = /* @__PURE__ */ createCatalan({
    addScalar,
    combinations,
    divideScalar,
    isInteger: isInteger2,
    isNegative,
    multiplyScalar,
    typed: typed2
  });
  var compare = /* @__PURE__ */ createCompare({
    BigNumber,
    DenseMatrix,
    Fraction: Fraction2,
    concat: concat2,
    config,
    equalScalar,
    matrix,
    typed: typed2
  });
  var compareText2 = /* @__PURE__ */ createCompareText({
    concat: concat2,
    matrix,
    typed: typed2
  });
  var cumsum = /* @__PURE__ */ createCumSum({
    add: add2,
    typed: typed2,
    unaryPlus
  });
  var deepEqual = /* @__PURE__ */ createDeepEqual({
    equal,
    typed: typed2
  });
  var diff = /* @__PURE__ */ createDiff({
    matrix,
    number,
    subtract,
    typed: typed2
  });
  var distance = /* @__PURE__ */ createDistance({
    abs: abs2,
    addScalar,
    deepEqual,
    divideScalar,
    multiplyScalar,
    sqrt: sqrt2,
    subtractScalar,
    typed: typed2
  });
  var dot = /* @__PURE__ */ createDot({
    addScalar,
    conj,
    multiplyScalar,
    size,
    typed: typed2
  });
  var equalText = /* @__PURE__ */ createEqualText({
    compareText: compareText2,
    isZero,
    typed: typed2
  });
  var floor2 = /* @__PURE__ */ createFloor({
    DenseMatrix,
    config,
    equalScalar,
    matrix,
    round: round2,
    typed: typed2,
    zeros: zeros2
  });
  var gcd = /* @__PURE__ */ createGcd({
    BigNumber,
    DenseMatrix,
    concat: concat2,
    config,
    equalScalar,
    matrix,
    round: round2,
    typed: typed2,
    zeros: zeros2
  });
  var hypot2 = /* @__PURE__ */ createHypot({
    abs: abs2,
    addScalar,
    divideScalar,
    isPositive,
    multiplyScalar,
    smaller,
    sqrt: sqrt2,
    typed: typed2
  });
  var ImmutableDenseMatrix = /* @__PURE__ */ createImmutableDenseMatrixClass({
    DenseMatrix,
    smaller
  });
  var Index = /* @__PURE__ */ createIndexClass({
    ImmutableDenseMatrix,
    getMatrixDataType
  });
  var larger = /* @__PURE__ */ createLarger({
    DenseMatrix,
    concat: concat2,
    config,
    matrix,
    typed: typed2
  });
  var log3 = /* @__PURE__ */ createLog({
    Complex: Complex2,
    config,
    divideScalar,
    typed: typed2
  });
  var lsolveAll = /* @__PURE__ */ createLsolveAll({
    DenseMatrix,
    divideScalar,
    equalScalar,
    matrix,
    multiplyScalar,
    subtractScalar,
    typed: typed2
  });
  var matrixFromRows = /* @__PURE__ */ createMatrixFromRows({
    flatten: flatten2,
    matrix,
    size,
    typed: typed2
  });
  var min2 = /* @__PURE__ */ createMin({
    config,
    numeric: numeric2,
    smaller,
    typed: typed2
  });
  var mod2 = /* @__PURE__ */ createMod({
    DenseMatrix,
    concat: concat2,
    config,
    equalScalar,
    matrix,
    round: round2,
    typed: typed2,
    zeros: zeros2
  });
  var multiply = /* @__PURE__ */ createMultiply({
    addScalar,
    dot,
    equalScalar,
    matrix,
    multiplyScalar,
    typed: typed2
  });
  var nthRoots = /* @__PURE__ */ createNthRoots({
    Complex: Complex2,
    config,
    divideScalar,
    typed: typed2
  });
  var or = /* @__PURE__ */ createOr({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  });
  var partitionSelect = /* @__PURE__ */ createPartitionSelect({
    compare,
    isNaN: isNaN2,
    isNumeric,
    typed: typed2
  });
  var rightLogShift = /* @__PURE__ */ createRightLogShift({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2,
    zeros: zeros2
  });
  var slu = /* @__PURE__ */ createSlu({
    SparseMatrix,
    abs: abs2,
    add: add2,
    divideScalar,
    larger,
    largerEq,
    multiply,
    subtract,
    transpose,
    typed: typed2
  });
  var subset = /* @__PURE__ */ createSubset({
    add: add2,
    matrix,
    typed: typed2,
    zeros: zeros2
  });
  var sum2 = /* @__PURE__ */ createSum({
    add: add2,
    config,
    numeric: numeric2,
    typed: typed2
  });
  var trace = /* @__PURE__ */ createTrace({
    add: add2,
    matrix,
    typed: typed2
  });
  var usolveAll = /* @__PURE__ */ createUsolveAll({
    DenseMatrix,
    divideScalar,
    equalScalar,
    matrix,
    multiplyScalar,
    subtractScalar,
    typed: typed2
  });
  var zpk2tf = /* @__PURE__ */ createZpk2tf({
    Complex: Complex2,
    add: add2,
    multiply,
    number,
    typed: typed2
  });
  var bitOr = /* @__PURE__ */ createBitOr({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  });
  var ceil2 = /* @__PURE__ */ createCeil({
    DenseMatrix,
    config,
    equalScalar,
    matrix,
    round: round2,
    typed: typed2,
    zeros: zeros2
  });
  var compareNatural = /* @__PURE__ */ createCompareNatural({
    compare,
    typed: typed2
  });
  var composition = /* @__PURE__ */ createComposition({
    addScalar,
    combinations,
    isInteger: isInteger2,
    isNegative,
    isPositive,
    larger,
    typed: typed2
  });
  var cross = /* @__PURE__ */ createCross({
    matrix,
    multiply,
    subtract,
    typed: typed2
  });
  var det = /* @__PURE__ */ createDet({
    divideScalar,
    isZero,
    matrix,
    multiply,
    subtractScalar,
    typed: typed2,
    unaryMinus
  });
  var dotMultiply = /* @__PURE__ */ createDotMultiply({
    concat: concat2,
    equalScalar,
    matrix,
    multiplyScalar,
    typed: typed2
  });
  var FibonacciHeap = /* @__PURE__ */ createFibonacciHeapClass({
    larger,
    smaller
  });
  var fix = /* @__PURE__ */ createFix({
    Complex: Complex2,
    DenseMatrix,
    ceil: ceil2,
    equalScalar,
    floor: floor2,
    matrix,
    typed: typed2,
    zeros: zeros2
  });
  var index = /* @__PURE__ */ createIndex({
    Index,
    typed: typed2
  });
  var intersect = /* @__PURE__ */ createIntersect({
    abs: abs2,
    add: add2,
    addScalar,
    config,
    divideScalar,
    equalScalar,
    flatten: flatten2,
    isNumeric,
    isZero,
    matrix,
    multiply,
    multiplyScalar,
    smaller,
    subtract,
    typed: typed2
  });
  var invmod = /* @__PURE__ */ createInvmod({
    BigNumber,
    add: add2,
    config,
    equal,
    isInteger: isInteger2,
    mod: mod2,
    smaller,
    typed: typed2,
    xgcd
  });
  var lcm = /* @__PURE__ */ createLcm({
    concat: concat2,
    equalScalar,
    matrix,
    typed: typed2
  });
  var log1p2 = /* @__PURE__ */ createLog1p({
    Complex: Complex2,
    config,
    divideScalar,
    log: log3,
    typed: typed2
  });
  var max2 = /* @__PURE__ */ createMax({
    config,
    larger,
    numeric: numeric2,
    typed: typed2
  });
  var setCartesian = /* @__PURE__ */ createSetCartesian({
    DenseMatrix,
    Index,
    compareNatural,
    size,
    subset,
    typed: typed2
  });
  var setDistinct = /* @__PURE__ */ createSetDistinct({
    DenseMatrix,
    Index,
    compareNatural,
    size,
    subset,
    typed: typed2
  });
  var setIsSubset = /* @__PURE__ */ createSetIsSubset({
    Index,
    compareNatural,
    size,
    subset,
    typed: typed2
  });
  var setPowerset = /* @__PURE__ */ createSetPowerset({
    Index,
    compareNatural,
    size,
    subset,
    typed: typed2
  });
  var smallerEq = /* @__PURE__ */ createSmallerEq({
    DenseMatrix,
    concat: concat2,
    config,
    matrix,
    typed: typed2
  });
  var sort = /* @__PURE__ */ createSort({
    compare,
    compareNatural,
    matrix,
    typed: typed2
  });
  var and = /* @__PURE__ */ createAnd({
    concat: concat2,
    equalScalar,
    matrix,
    not,
    typed: typed2,
    zeros: zeros2
  });
  var range = /* @__PURE__ */ createRange({
    bignumber,
    matrix,
    add: add2,
    config,
    isPositive,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed: typed2
  });
  var row = /* @__PURE__ */ createRow({
    Index,
    matrix,
    range,
    typed: typed2
  });
  var setDifference = /* @__PURE__ */ createSetDifference({
    DenseMatrix,
    Index,
    compareNatural,
    size,
    subset,
    typed: typed2
  });
  var setMultiplicity = /* @__PURE__ */ createSetMultiplicity({
    Index,
    compareNatural,
    size,
    subset,
    typed: typed2
  });
  var setSymDifference = /* @__PURE__ */ createSetSymDifference({
    Index,
    concat: concat2,
    setDifference,
    size,
    subset,
    typed: typed2
  });
  var Spa = /* @__PURE__ */ createSpaClass({
    FibonacciHeap,
    addScalar,
    equalScalar
  });
  var column = /* @__PURE__ */ createColumn({
    Index,
    matrix,
    range,
    typed: typed2
  });
  var inv = /* @__PURE__ */ createInv({
    abs: abs2,
    addScalar,
    det,
    divideScalar,
    identity,
    matrix,
    multiply,
    typed: typed2,
    unaryMinus
  });
  var lup = /* @__PURE__ */ createLup({
    DenseMatrix,
    Spa,
    SparseMatrix,
    abs: abs2,
    addScalar,
    divideScalar,
    equalScalar,
    larger,
    matrix,
    multiplyScalar,
    subtractScalar,
    typed: typed2,
    unaryMinus
  });
  var pinv = /* @__PURE__ */ createPinv({
    Complex: Complex2,
    add: add2,
    ctranspose,
    deepEqual,
    divideScalar,
    dot,
    dotDivide,
    equal,
    inv,
    matrix,
    multiply,
    typed: typed2
  });
  var pow2 = /* @__PURE__ */ createPow({
    Complex: Complex2,
    config,
    fraction,
    identity,
    inv,
    matrix,
    multiply,
    number,
    typed: typed2
  });
  var setIntersect = /* @__PURE__ */ createSetIntersect({
    DenseMatrix,
    Index,
    compareNatural,
    size,
    subset,
    typed: typed2
  });
  var setUnion = /* @__PURE__ */ createSetUnion({
    Index,
    concat: concat2,
    setIntersect,
    setSymDifference,
    size,
    subset,
    typed: typed2
  });
  var sqrtm = /* @__PURE__ */ createSqrtm({
    abs: abs2,
    add: add2,
    identity,
    inv,
    map: map2,
    max: max2,
    multiply,
    size,
    sqrt: sqrt2,
    subtract,
    typed: typed2
  });
  var Unit = /* @__PURE__ */ createUnitClass({
    BigNumber,
    Complex: Complex2,
    Fraction: Fraction2,
    abs: abs2,
    addScalar,
    config,
    divideScalar,
    equal,
    fix,
    format: format4,
    isNumeric,
    multiplyScalar,
    number,
    pow: pow2,
    round: round2,
    subtractScalar
  });
  var vacuumImpedance = /* @__PURE__ */ createVacuumImpedance({
    BigNumber,
    Unit,
    config
  });
  var wienDisplacement = /* @__PURE__ */ createWienDisplacement({
    BigNumber,
    Unit,
    config
  });
  var atomicMass = /* @__PURE__ */ createAtomicMass({
    BigNumber,
    Unit,
    config
  });
  var bohrMagneton = /* @__PURE__ */ createBohrMagneton({
    BigNumber,
    Unit,
    config
  });
  var boltzmann = /* @__PURE__ */ createBoltzmann({
    BigNumber,
    Unit,
    config
  });
  var conductanceQuantum = /* @__PURE__ */ createConductanceQuantum({
    BigNumber,
    Unit,
    config
  });
  var coulomb = /* @__PURE__ */ createCoulomb({
    BigNumber,
    Unit,
    config
  });
  var deuteronMass = /* @__PURE__ */ createDeuteronMass({
    BigNumber,
    Unit,
    config
  });
  var dotPow = /* @__PURE__ */ createDotPow({
    DenseMatrix,
    concat: concat2,
    equalScalar,
    matrix,
    pow: pow2,
    typed: typed2
  });
  var electricConstant = /* @__PURE__ */ createElectricConstant({
    BigNumber,
    Unit,
    config
  });
  var elementaryCharge = /* @__PURE__ */ createElementaryCharge({
    BigNumber,
    Unit,
    config
  });
  var expm = /* @__PURE__ */ createExpm({
    abs: abs2,
    add: add2,
    identity,
    inv,
    multiply,
    typed: typed2
  });
  var faraday = /* @__PURE__ */ createFaraday({
    BigNumber,
    Unit,
    config
  });
  var fft = /* @__PURE__ */ createFft({
    addScalar,
    ceil: ceil2,
    conj,
    divideScalar,
    dotDivide,
    exp: exp2,
    i: i2,
    log2: log24,
    matrix,
    multiplyScalar,
    pow: pow2,
    tau: tau2,
    typed: typed2
  });
  var gamma = /* @__PURE__ */ createGamma({
    BigNumber,
    Complex: Complex2,
    config,
    multiplyScalar,
    pow: pow2,
    typed: typed2
  });
  var gravitationConstant = /* @__PURE__ */ createGravitationConstant({
    BigNumber,
    Unit,
    config
  });
  var hartreeEnergy = /* @__PURE__ */ createHartreeEnergy({
    BigNumber,
    Unit,
    config
  });
  var ifft = /* @__PURE__ */ createIfft({
    conj,
    dotDivide,
    fft,
    typed: typed2
  });
  var klitzing = /* @__PURE__ */ createKlitzing({
    BigNumber,
    Unit,
    config
  });
  var loschmidt = /* @__PURE__ */ createLoschmidt({
    BigNumber,
    Unit,
    config
  });
  var magneticConstant = /* @__PURE__ */ createMagneticConstant({
    BigNumber,
    Unit,
    config
  });
  var molarMass = /* @__PURE__ */ createMolarMass({
    BigNumber,
    Unit,
    config
  });
  var molarPlanckConstant = /* @__PURE__ */ createMolarPlanckConstant({
    BigNumber,
    Unit,
    config
  });
  var neutronMass = /* @__PURE__ */ createNeutronMass({
    BigNumber,
    Unit,
    config
  });
  var nuclearMagneton = /* @__PURE__ */ createNuclearMagneton({
    BigNumber,
    Unit,
    config
  });
  var planckCharge = /* @__PURE__ */ createPlanckCharge({
    BigNumber,
    Unit,
    config
  });
  var planckLength = /* @__PURE__ */ createPlanckLength({
    BigNumber,
    Unit,
    config
  });
  var planckTemperature = /* @__PURE__ */ createPlanckTemperature({
    BigNumber,
    Unit,
    config
  });
  var protonMass = /* @__PURE__ */ createProtonMass({
    BigNumber,
    Unit,
    config
  });
  var quantumOfCirculation = /* @__PURE__ */ createQuantumOfCirculation({
    BigNumber,
    Unit,
    config
  });
  var reducedPlanckConstant = /* @__PURE__ */ createReducedPlanckConstant({
    BigNumber,
    Unit,
    config
  });
  var rydberg = /* @__PURE__ */ createRydberg({
    BigNumber,
    Unit,
    config
  });
  var secondRadiation = /* @__PURE__ */ createSecondRadiation({
    BigNumber,
    Unit,
    config
  });
  var speedOfLight = /* @__PURE__ */ createSpeedOfLight({
    BigNumber,
    Unit,
    config
  });
  var stefanBoltzmann = /* @__PURE__ */ createStefanBoltzmann({
    BigNumber,
    Unit,
    config
  });
  var thomsonCrossSection = /* @__PURE__ */ createThomsonCrossSection({
    BigNumber,
    Unit,
    config
  });
  var avogadro = /* @__PURE__ */ createAvogadro({
    BigNumber,
    Unit,
    config
  });
  var bohrRadius = /* @__PURE__ */ createBohrRadius({
    BigNumber,
    Unit,
    config
  });
  var createUnit = /* @__PURE__ */ createCreateUnit({
    Unit,
    typed: typed2
  });
  var divide2 = /* @__PURE__ */ createDivide({
    divideScalar,
    equalScalar,
    inv,
    matrix,
    multiply,
    typed: typed2
  });
  var electronMass = /* @__PURE__ */ createElectronMass({
    BigNumber,
    Unit,
    config
  });
  var factorial = /* @__PURE__ */ createFactorial({
    gamma,
    typed: typed2
  });
  var firstRadiation = /* @__PURE__ */ createFirstRadiation({
    BigNumber,
    Unit,
    config
  });
  var gravity = /* @__PURE__ */ createGravity({
    BigNumber,
    Unit,
    config
  });
  var inverseConductanceQuantum = /* @__PURE__ */ createInverseConductanceQuantum({
    BigNumber,
    Unit,
    config
  });
  var lusolve = /* @__PURE__ */ createLusolve({
    DenseMatrix,
    lsolve,
    lup,
    matrix,
    slu,
    typed: typed2,
    usolve
  });
  var magneticFluxQuantum = /* @__PURE__ */ createMagneticFluxQuantum({
    BigNumber,
    Unit,
    config
  });
  var molarMassC12 = /* @__PURE__ */ createMolarMassC12({
    BigNumber,
    Unit,
    config
  });
  var multinomial = /* @__PURE__ */ createMultinomial({
    add: add2,
    divide: divide2,
    factorial,
    isInteger: isInteger2,
    isPositive,
    multiply,
    typed: typed2
  });
  var permutations = /* @__PURE__ */ createPermutations({
    factorial,
    typed: typed2
  });
  var planckMass = /* @__PURE__ */ createPlanckMass({
    BigNumber,
    Unit,
    config
  });
  var polynomialRoot = /* @__PURE__ */ createPolynomialRoot({
    add: add2,
    cbrt: cbrt4,
    divide: divide2,
    equalScalar,
    im,
    isZero,
    multiply,
    re,
    sqrt: sqrt2,
    subtract,
    typeOf: typeOf2,
    typed: typed2,
    unaryMinus
  });
  var setSize = /* @__PURE__ */ createSetSize({
    compareNatural,
    typed: typed2
  });
  var solveODE = /* @__PURE__ */ createSolveODE({
    abs: abs2,
    add: add2,
    bignumber,
    divide: divide2,
    isNegative,
    isPositive,
    larger,
    map: map2,
    matrix,
    max: max2,
    multiply,
    smaller,
    subtract,
    typed: typed2,
    unaryMinus
  });
  var stirlingS2 = /* @__PURE__ */ createStirlingS2({
    bignumber,
    addScalar,
    combinations,
    divideScalar,
    factorial,
    isInteger: isInteger2,
    isNegative,
    larger,
    multiplyScalar,
    number,
    pow: pow2,
    subtractScalar,
    typed: typed2
  });
  var unit = /* @__PURE__ */ createUnitFunction({
    Unit,
    typed: typed2
  });
  var bellNumbers = /* @__PURE__ */ createBellNumbers({
    addScalar,
    isInteger: isInteger2,
    isNegative,
    stirlingS2,
    typed: typed2
  });
  var eigs = /* @__PURE__ */ createEigs({
    abs: abs2,
    add: add2,
    addScalar,
    atan: atan3,
    bignumber,
    column,
    complex,
    config,
    cos: cos2,
    diag,
    divideScalar,
    dot,
    equal,
    flatten: flatten2,
    im,
    inv,
    larger,
    matrix,
    matrixFromColumns,
    multiply,
    multiplyScalar,
    number,
    qr,
    re,
    reshape: reshape2,
    sin: sin2,
    size,
    smaller,
    sqrt: sqrt2,
    subtract,
    typed: typed2,
    usolve,
    usolveAll
  });
  var fermiCoupling = /* @__PURE__ */ createFermiCoupling({
    BigNumber,
    Unit,
    config
  });
  var gasConstant = /* @__PURE__ */ createGasConstant({
    BigNumber,
    Unit,
    config
  });
  var mean = /* @__PURE__ */ createMean({
    add: add2,
    divide: divide2,
    typed: typed2
  });
  var molarVolume = /* @__PURE__ */ createMolarVolume({
    BigNumber,
    Unit,
    config
  });
  var planckConstant = /* @__PURE__ */ createPlanckConstant({
    BigNumber,
    Unit,
    config
  });
  var quantileSeq = /* @__PURE__ */ createQuantileSeq({
    bignumber,
    add: add2,
    compare,
    divide: divide2,
    isInteger: isInteger2,
    larger,
    multiply,
    partitionSelect,
    smaller,
    smallerEq,
    subtract,
    typed: typed2
  });
  var variance = /* @__PURE__ */ createVariance({
    add: add2,
    apply,
    divide: divide2,
    isNaN: isNaN2,
    multiply,
    subtract,
    typed: typed2
  });
  var classicalElectronRadius = /* @__PURE__ */ createClassicalElectronRadius({
    BigNumber,
    Unit,
    config
  });
  var median = /* @__PURE__ */ createMedian({
    add: add2,
    compare,
    divide: divide2,
    partitionSelect,
    typed: typed2
  });
  var corr = /* @__PURE__ */ createCorr({
    add: add2,
    divide: divide2,
    matrix,
    mean,
    multiply,
    pow: pow2,
    sqrt: sqrt2,
    subtract,
    sum: sum2,
    typed: typed2
  });
  var freqz = /* @__PURE__ */ createFreqz({
    Complex: Complex2,
    add: add2,
    divide: divide2,
    matrix,
    multiply,
    typed: typed2
  });
  var mad = /* @__PURE__ */ createMad({
    abs: abs2,
    map: map2,
    median,
    subtract,
    typed: typed2
  });
  var std = /* @__PURE__ */ createStd({
    map: map2,
    sqrt: sqrt2,
    typed: typed2,
    variance
  });
  var zeta = /* @__PURE__ */ createZeta({
    BigNumber,
    Complex: Complex2,
    add: add2,
    config,
    divide: divide2,
    equal,
    factorial,
    gamma,
    isNegative,
    multiply,
    pi: pi2,
    pow: pow2,
    sin: sin2,
    smallerEq,
    subtract,
    typed: typed2
  });
  var norm = /* @__PURE__ */ createNorm({
    abs: abs2,
    add: add2,
    conj,
    ctranspose,
    eigs,
    equalScalar,
    larger,
    matrix,
    multiply,
    pow: pow2,
    smaller,
    sqrt: sqrt2,
    typed: typed2
  });
  var rotationMatrix = /* @__PURE__ */ createRotationMatrix({
    BigNumber,
    DenseMatrix,
    SparseMatrix,
    addScalar,
    config,
    cos: cos2,
    matrix,
    multiplyScalar,
    norm,
    sin: sin2,
    typed: typed2,
    unaryMinus
  });
  var kldivergence = /* @__PURE__ */ createKldivergence({
    divide: divide2,
    dotDivide,
    isNumeric,
    log: log3,
    map: map2,
    matrix,
    multiply,
    sum: sum2,
    typed: typed2
  });
  var planckTime = /* @__PURE__ */ createPlanckTime({
    BigNumber,
    Unit,
    config
  });
  var schur = /* @__PURE__ */ createSchur({
    identity,
    matrix,
    multiply,
    norm,
    qr,
    subtract,
    typed: typed2
  });
  var rotate = /* @__PURE__ */ createRotate({
    multiply,
    rotationMatrix,
    typed: typed2
  });
  var sylvester = /* @__PURE__ */ createSylvester({
    abs: abs2,
    add: add2,
    concat: concat2,
    identity,
    index,
    lusolve,
    matrix,
    matrixFromColumns,
    multiply,
    range,
    schur,
    subset,
    subtract,
    transpose,
    typed: typed2
  });
  var lyap = /* @__PURE__ */ createLyap({
    matrix,
    multiply,
    sylvester,
    transpose,
    typed: typed2
  });

  // node_modules/mathjs/lib/esm/entry/impureFunctionsAny.generated.js
  var math = {};
  var mathWithTransform = {};
  var classes = {};
  var Node = createNode({
    mathWithTransform
  });
  var ObjectNode = createObjectNode({
    Node
  });
  var OperatorNode = createOperatorNode({
    Node
  });
  var ParenthesisNode = createParenthesisNode({
    Node
  });
  var RelationalNode = createRelationalNode({
    Node
  });
  var ArrayNode = createArrayNode({
    Node
  });
  var BlockNode = createBlockNode({
    Node,
    ResultSet
  });
  var ConditionalNode = createConditionalNode({
    Node
  });
  var ConstantNode = createConstantNode({
    Node
  });
  var RangeNode = createRangeNode({
    Node
  });
  var reviver = createReviver({
    classes
  });
  var Chain = createChainClass({
    math,
    typed: typed2
  });
  var FunctionAssignmentNode = createFunctionAssignmentNode({
    Node,
    typed: typed2
  });
  var chain = createChain({
    Chain,
    typed: typed2
  });
  var IndexNode = createIndexNode({
    Node,
    size
  });
  var AccessorNode = createAccessorNode({
    Node,
    subset
  });
  var AssignmentNode = createAssignmentNode({
    matrix,
    Node,
    subset
  });
  var SymbolNode = createSymbolNode({
    Unit,
    Node,
    math
  });
  var FunctionNode = createFunctionNode({
    Node,
    SymbolNode,
    math
  });
  var parse = createParse({
    AccessorNode,
    ArrayNode,
    AssignmentNode,
    BlockNode,
    ConditionalNode,
    ConstantNode,
    FunctionAssignmentNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    RangeNode,
    RelationalNode,
    SymbolNode,
    config,
    numeric: numeric2,
    typed: typed2
  });
  var resolve = createResolve({
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode,
    parse,
    typed: typed2
  });
  var simplifyConstant = createSimplifyConstant({
    bignumber,
    fraction,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    SymbolNode,
    config,
    mathWithTransform,
    matrix,
    typed: typed2
  });
  var compile = createCompile({
    parse,
    typed: typed2
  });
  var Help = createHelpClass({
    parse
  });
  var leafCount = createLeafCount({
    parse,
    typed: typed2
  });
  var simplifyCore = createSimplifyCore({
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode,
    add: add2,
    divide: divide2,
    equal,
    isZero,
    multiply,
    parse,
    pow: pow2,
    subtract,
    typed: typed2
  });
  var evaluate = createEvaluate({
    parse,
    typed: typed2
  });
  var help = createHelp({
    Help,
    mathWithTransform,
    typed: typed2
  });
  var Parser = createParserClass({
    evaluate
  });
  var simplify = createSimplify({
    bignumber,
    fraction,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode,
    add: add2,
    config,
    divide: divide2,
    equal,
    isZero,
    mathWithTransform,
    matrix,
    multiply,
    parse,
    pow: pow2,
    resolve,
    simplifyConstant,
    simplifyCore,
    subtract,
    typed: typed2
  });
  var symbolicEqual = createSymbolicEqual({
    OperatorNode,
    parse,
    simplify,
    typed: typed2
  });
  var parser = createParser({
    Parser,
    typed: typed2
  });
  var rationalize = createRationalize({
    bignumber,
    fraction,
    AccessorNode,
    ArrayNode,
    ConstantNode,
    FunctionNode,
    IndexNode,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode,
    add: add2,
    config,
    divide: divide2,
    equal,
    isZero,
    mathWithTransform,
    matrix,
    multiply,
    parse,
    pow: pow2,
    simplify,
    simplifyConstant,
    simplifyCore,
    subtract,
    typed: typed2
  });
  var derivative = createDerivative({
    ConstantNode,
    FunctionNode,
    OperatorNode,
    ParenthesisNode,
    SymbolNode,
    config,
    equal,
    isZero,
    numeric: numeric2,
    parse,
    simplify,
    typed: typed2
  });
  _extends(math, {
    e: e2,
    false: _false,
    fineStructure,
    i: i2,
    Infinity: _Infinity,
    LN10: LN102,
    LOG10E,
    NaN: _NaN,
    null: _null,
    phi: phi2,
    SQRT1_2,
    sackurTetrode,
    tau: tau2,
    true: _true,
    "E": e2,
    version: version2,
    efimovFactor,
    LN2,
    pi: pi2,
    replacer,
    reviver,
    SQRT2,
    typed: typed2,
    unaryPlus,
    "PI": pi2,
    weakMixingAngle,
    abs: abs2,
    acos: acos2,
    acot,
    acsc,
    addScalar,
    arg,
    asech,
    asinh: asinh3,
    atan: atan3,
    atanh: atanh3,
    bignumber,
    bitNot,
    boolean,
    clone: clone4,
    combinations,
    complex,
    conj,
    cos: cos2,
    cot,
    csc,
    cube,
    equalScalar,
    erf,
    exp: exp2,
    expm1: expm13,
    filter: filter2,
    forEach: forEach2,
    format: format4,
    getMatrixDataType,
    hex,
    im,
    isInteger: isInteger2,
    isNegative,
    isPositive,
    isZero,
    LOG2E,
    lgamma,
    log10: log104,
    log2: log24,
    map: map2,
    multiplyScalar,
    not,
    number,
    oct,
    pickRandom,
    print,
    random: random2,
    re,
    sec,
    sign: sign3,
    sin: sin2,
    splitUnit,
    square,
    string,
    subtractScalar,
    tan: tan2,
    typeOf: typeOf2,
    acosh: acosh3,
    acsch,
    apply,
    asec,
    bin,
    chain,
    combinationsWithRep,
    cosh: cosh3,
    csch,
    isNaN: isNaN2,
    isPrime,
    randomInt,
    sech,
    sinh: sinh3,
    sparse,
    sqrt: sqrt2,
    tanh: tanh3,
    unaryMinus,
    acoth,
    coth,
    fraction,
    isNumeric,
    matrix,
    matrixFromFunction,
    mode,
    numeric: numeric2,
    prod,
    reshape: reshape2,
    size,
    squeeze: squeeze2,
    transpose,
    xgcd,
    zeros: zeros2,
    asin: asin2,
    cbrt: cbrt4,
    concat: concat2,
    count,
    ctranspose,
    diag,
    divideScalar,
    dotDivide,
    equal,
    flatten: flatten2,
    hasNumericValue,
    identity,
    kron,
    largerEq,
    leftShift,
    lsolve,
    matrixFromColumns,
    nthRoot,
    ones,
    qr,
    resize: resize2,
    rightArithShift,
    round: round2,
    smaller,
    subtract,
    to,
    unequal,
    usolve,
    xor,
    add: add2,
    atan2: atan22,
    bitAnd,
    bitXor: bitXor2,
    catalan,
    compare,
    compareText: compareText2,
    cumsum,
    deepEqual,
    diff,
    distance,
    dot,
    equalText,
    floor: floor2,
    gcd,
    hypot: hypot2,
    larger,
    log: log3,
    lsolveAll,
    matrixFromRows,
    min: min2,
    mod: mod2,
    multiply,
    nthRoots,
    or,
    partitionSelect,
    rightLogShift,
    slu,
    subset,
    sum: sum2,
    trace,
    usolveAll,
    zpk2tf,
    bitOr,
    ceil: ceil2,
    compareNatural,
    composition,
    cross,
    det,
    dotMultiply,
    fix,
    index,
    intersect,
    invmod,
    lcm,
    log1p: log1p2,
    max: max2,
    setCartesian,
    setDistinct,
    setIsSubset,
    setPowerset,
    smallerEq,
    sort,
    and,
    range,
    row,
    setDifference,
    setMultiplicity,
    setSymDifference,
    column,
    inv,
    lup,
    pinv,
    pow: pow2,
    setIntersect,
    setUnion,
    sqrtm,
    vacuumImpedance,
    wienDisplacement,
    atomicMass,
    bohrMagneton,
    boltzmann,
    conductanceQuantum,
    coulomb,
    deuteronMass,
    dotPow,
    electricConstant,
    elementaryCharge,
    expm,
    faraday,
    fft,
    gamma,
    gravitationConstant,
    hartreeEnergy,
    ifft,
    klitzing,
    loschmidt,
    magneticConstant,
    molarMass,
    molarPlanckConstant,
    neutronMass,
    nuclearMagneton,
    planckCharge,
    planckLength,
    planckTemperature,
    protonMass,
    quantumOfCirculation,
    reducedPlanckConstant,
    rydberg,
    secondRadiation,
    speedOfLight,
    stefanBoltzmann,
    thomsonCrossSection,
    avogadro,
    bohrRadius,
    createUnit,
    divide: divide2,
    electronMass,
    factorial,
    firstRadiation,
    gravity,
    inverseConductanceQuantum,
    lusolve,
    magneticFluxQuantum,
    molarMassC12,
    multinomial,
    parse,
    permutations,
    planckMass,
    polynomialRoot,
    resolve,
    setSize,
    simplifyConstant,
    solveODE,
    stirlingS2,
    unit,
    bellNumbers,
    compile,
    eigs,
    fermiCoupling,
    gasConstant,
    leafCount,
    mean,
    molarVolume,
    planckConstant,
    quantileSeq,
    simplifyCore,
    variance,
    classicalElectronRadius,
    evaluate,
    help,
    median,
    simplify,
    symbolicEqual,
    corr,
    freqz,
    mad,
    parser,
    rationalize,
    std,
    zeta,
    derivative,
    norm,
    rotationMatrix,
    kldivergence,
    planckTime,
    schur,
    rotate,
    sylvester,
    lyap,
    config
  });
  _extends(mathWithTransform, math, {
    filter: createFilterTransform({
      typed: typed2
    }),
    forEach: createForEachTransform({
      typed: typed2
    }),
    map: createMapTransform({
      typed: typed2
    }),
    apply: createApplyTransform({
      isInteger: isInteger2,
      typed: typed2
    }),
    concat: createConcatTransform({
      isInteger: isInteger2,
      matrix,
      typed: typed2
    }),
    max: createMaxTransform({
      config,
      larger,
      numeric: numeric2,
      typed: typed2
    }),
    print: createPrintTransform({
      add: add2,
      matrix,
      typed: typed2,
      zeros: zeros2
    }),
    diff: createDiffTransform({
      bignumber,
      matrix,
      number,
      subtract,
      typed: typed2
    }),
    min: createMinTransform({
      config,
      numeric: numeric2,
      smaller,
      typed: typed2
    }),
    subset: createSubsetTransform({
      add: add2,
      matrix,
      typed: typed2,
      zeros: zeros2
    }),
    cumsum: createCumSumTransform({
      add: add2,
      typed: typed2,
      unaryPlus
    }),
    index: createIndexTransform({
      Index,
      getMatrixDataType
    }),
    sum: createSumTransform({
      add: add2,
      config,
      numeric: numeric2,
      typed: typed2
    }),
    range: createRangeTransform({
      bignumber,
      matrix,
      add: add2,
      config,
      isPositive,
      larger,
      largerEq,
      smaller,
      smallerEq,
      typed: typed2
    }),
    row: createRowTransform({
      Index,
      matrix,
      range,
      typed: typed2
    }),
    column: createColumnTransform({
      Index,
      matrix,
      range,
      typed: typed2
    }),
    mean: createMeanTransform({
      add: add2,
      divide: divide2,
      typed: typed2
    }),
    quantileSeq: createQuantileSeqTransform({
      add: add2,
      bignumber,
      compare,
      divide: divide2,
      isInteger: isInteger2,
      larger,
      multiply,
      partitionSelect,
      smaller,
      smallerEq,
      subtract,
      typed: typed2
    }),
    variance: createVarianceTransform({
      add: add2,
      apply,
      divide: divide2,
      isNaN: isNaN2,
      multiply,
      subtract,
      typed: typed2
    }),
    std: createStdTransform({
      map: map2,
      sqrt: sqrt2,
      typed: typed2,
      variance
    })
  });
  _extends(classes, {
    BigNumber,
    Complex: Complex2,
    Fraction: Fraction2,
    Matrix,
    Node,
    ObjectNode,
    OperatorNode,
    ParenthesisNode,
    Range,
    RelationalNode,
    ResultSet,
    ArrayNode,
    BlockNode,
    ConditionalNode,
    ConstantNode,
    DenseMatrix,
    RangeNode,
    Chain,
    FunctionAssignmentNode,
    SparseMatrix,
    IndexNode,
    ImmutableDenseMatrix,
    Index,
    AccessorNode,
    AssignmentNode,
    FibonacciHeap,
    Spa,
    Unit,
    SymbolNode,
    FunctionNode,
    Help,
    Parser
  });
  Chain.createProxy(math);

  // src/index.js
  var input = document.getElementById("input_expr");
  input.addEventListener("input", generate_tree);
  function generate_tree() {
    const nodes = [];
    const edges = [];
    let expr_str = input.value;
    let ast;
    try {
      ast = parse(expr_str);
    } catch (error) {
      return;
    }
    const indexed_ast = /* @__PURE__ */ new Map();
    create_nodes(ast);
    create_edges(ast);
    var container = document.getElementById("ast");
    y().then((viz) => {
      container.innerHTML = "";
      container.appendChild(viz.renderSVGElement(
        {
          nodeAttributes: {
            shape: "rec"
          },
          nodes,
          edges
        }
      ));
    });
    function create_nodes(root) {
      let counter = 0;
      root.traverse(function(node, _path, _parent) {
        let label = "";
        switch (node.type) {
          case "OperatorNode":
            label = node.op;
            break;
          case "ConstantNode":
            label = node.value.toString();
            break;
          case "SymbolNode":
            label = node.name;
            break;
          case "ParenthesisNode":
            label = "()";
            break;
          default:
        }
        nodes.push({ name: counter, attributes: { label: label.length > 0 ? label : "unknown" } });
        indexed_ast.set(node, counter++);
      });
    }
    function create_edges(node) {
      switch (node.type) {
        case "OperatorNode":
        case "ParenthesisNode":
          node.forEach(function(child, _path, _parent) {
            edges.push({ tail: indexed_ast.get(node), head: indexed_ast.get(child) });
            create_edges(child);
          });
          break;
        case "ConstantNode":
        case "SymbolNode":
          break;
        default:
          console.log("unknown node type");
      }
    }
  }
})();
/*! Bundled license information:

complex.js/complex.js:
  (**
   * @license Complex.js v2.1.1 12/05/2020
   *
   * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

fraction.js/fraction.js:
  (**
   * @license Fraction.js v4.3.0 20/08/2023
   * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
   *
   * Copyright (c) 2023, Robert Eisele (robert@raw.org)
   * Dual licensed under the MIT or GPL Version 2 licenses.
   **)

@viz-js/viz/lib/viz-standalone.mjs:
  (*!
  Viz.js 3.2.3
  Copyright (c) 2023 Michael Daines
  
  This distribution contains other software in object code form:
  Graphviz https://www.graphviz.org
  Expat https://libexpat.github.io
  *)

decimal.js/decimal.mjs:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
